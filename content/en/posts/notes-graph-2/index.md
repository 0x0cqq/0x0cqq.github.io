---
##-- draftstate --##
draft: false
##-- page info --##
title: "图论学习笔记2——树"
date: 2021-04-06T17:59:24+08:00
categories:
- 学习笔记
tags:
- 图论
- 树
series:
- 课程学习笔记
##-- page setting --##
# slug: ""
# type: ""
pinned: false
markup: mmark
libraries:
- mathjax 
##-- toc setting --##
hideToc: false
enableToc: true
enableTocContent: true
---

《离散数学2》图论学习笔记——树部分。

<!--more-->

## 写在前面

（我们所学的）图论应该是充满直观的一门学科，而数学的抽象只是辅助于计算和证明的工具。因此希望读者能够在阅读的时候先把握直观的图论观点，随后再运用数学方法去进行深入和严谨的探讨。

本文写作时也秉持了这一原则。

读者在阅读时，应该先把握引用块外的主线逻辑，除非常关键的情况外均可以接受未加证明的定理；在之后再去阅读和理解引用块内的具体证明。

## 基本定义和概念

>  以下定义和概念都是对于无向图而言。

+ （森）林：不含任何回路的图 $G(V,E)$。

+ 树：联通，但不含任何回路的图 $G (V,E)$ 。

  > 注意：有向图的“连通”一般指“弱联通”，即刨除方向后的联通；有向图强联通的概念不在这里介绍。

  + 树枝：树的边。
  + 树叶：树中度数 1 的节点。
  + 分支节点（内节点）：树中度数大于 1 的节点。

### 树的其他等价定义

以下六个对树的定义等价。

1. （G 联通，且无回路）

   > 6->1: 若不联通，加入存在一条边后必然没有回路。

2. G 的任意两个顶点之间存在唯一路径

   > 1->2: 若有两条路径，异或则可得到一条回路。

3. G 中无回路，且 $m = n-1$ 

   > 2->3: 若存在回路，则必然能找到不唯一路径；归纳法，利用点边和连通性证明 $m = n-1$ 。

4. G 是联通的，且 $m = n-1$ 

   > 3->4: 若不连通，不可能有 $n-1$ 这么多条边。

5. G 是联通的，且 G 中任意边都是桥 

   > 4->5: 证明若只有 $n-2$ 边，不可能联通。

6. G 中无回路，且加入任意一条边能在图中得到唯一一条含新边的回路 

   > 5->6: 无回路显然，故利用 (1) 其是树；利用 (2) 中，树有唯一路径得到唯一回路（这个证明不好）

### 支撑树

+ 支撑树：图 $G(V,E)$ 支撑子图 $T$ （即图 $T$ 边的端点集合之并为 $V$），且 $T$ 为树。
  + 树边：$G$ 的在 $T$ 中的边。

+ 余树：$G-T$，即图刨除任意支撑树的边。
  + 余树边（树的弦）：$G$ 在余树中的边。

性质：支撑树与余树一一对应。（用在后面支撑树生成，只要枚举出余树也就枚举出了支撑树）。

## 基本关联矩阵与支撑树计数

> 以下关联矩阵、基本关联矩阵都是对有向图而言。对于无向图，一般可以给每条边指定一个方向，大部分方法可以套用。
>
> 【其实支撑树计数问题应该是基于无向图的，使用指定边的方向转化为有向图求解。这和课本的逻辑有微小的差距。】

### 关联矩阵

每一列代表一条边，如果边从 $v_i$ 指向 $v_j$ ，那么该列第 $i$ 行填 $1$ ，第 $j$ 行填 $-1$ ，其余均为 $0$ 。 $n \times m$ 矩阵。

用 $B$ 来代表关联矩阵。

关联矩阵是一种表示边点关系的方式。边和点可以构成“回路”，树恰好不要“回路”，那么运用一点微小的线性代数知识，我们可以获得如下的结论，从而帮助我们以数学视角探究一些图的性质，并计算支撑树数目。

#### 性质1：关联矩阵与回路

关联矩阵的 $k$ 列线性相关 $\Leftrightarrow$ 对应的 $k$ 条边中存在回路。

> 证明：这几乎是显然的，将回路对应的边调整好方向（也就是把列乘上 $1$ 或者 $-1$），从而可以顺序连接；把这些列相加可以得到 $0$ 列。

#### 性质2：关联矩阵的秩

关联矩阵的秩的图论意义是什么？根据上面的性质，上面最多能从图中挑出多少边，使它们的导出子图上没有回路。

对于有向【联通！】图的关联矩阵 $B$ ：

1. $\text{rank}(B) < n$ 。这是说，任意 $n$ 条边的导出子图中均存在回路。

   > 证明：线性代数来说，可以把所有行（$n$ 行加到一起，每个位置都是 $0$（每列只有一个 $1$ 和一个 $-1$），因此线性相关）。

2. $\text{rank}(B) = n-1$ 。这是说，一个图一定存在 $n-1$ 条边，他们的导出子图没有回路。根据上面的等价定义，这也就是说，（联通图的）支撑树一定存在。

   > 证明：从线性代数视角，考虑若干行（注意，是行！）的线性组合。如果他们的和是 $0$，且存在一个系数非 $0$ ，那么根据连通性，所有行对应的系数都是一样的（因为每列只有一个 $1$ 和一个 $-1$，这两行的系数必然相同，又因为联通，可以走到所有的 $n$ 行）。所以所有行的系数都非 $0$ ，也就不存在 $n-1$ 行的线性组合是 $0$ 。

   >  重要的结论：关联矩阵的任意 $n-1$ 行，他们都不线性相关。这保证了下面基本关联矩阵相关性结论的正确性。

### 基本关联矩阵

在关联矩阵 $B$ 中划掉第 $i$ 行（$1 \leq i \leq n$ ，$i$ 是任选的），得到基本关联矩阵 $B_i$ 。 

注意，基本关联矩阵和关联矩阵含有相同量的信息，根据基本关联矩阵我们可以推出关联矩阵。这一点可以和 $\text{rank}(B) = n-1$ 共同理解。

理解基本关联矩阵，核心的问题是：**为什么要删掉 $1$ 行呢？** 这就需要进入数学的视角来考察“树”。

因为在数学上，图“有无回路”的特征（也就是树的特征）用的是关联矩阵的线性相关性来刻画，而这一线性相关性可以用行列式来在**数值**上刻画，而行列式只能运用于方阵。

因此我们想要判断 $n-1$ 条边是否构成树（也就是判断关联矩阵中对应 $n-1$ 列是否线性相关），为了使用行列式来刻画这 $n-1$ 列的线性相关性，我们只需要 $n-1$ 行，因此是需要删除一行的。如果行列式不是 $0$ ，那么这就是一棵树；若行列式为 $0$ ，则不是。

然而，我们可以敏感的发觉“删除一行”的操作可能会出现问题。删除掉一行之后，**这 $n-1$ 列的线性相关性是否还能保持** ？答案是确定的，详细证明如下。

> 证明：
>
> 1. 有一个方向是显然的：从线性代数视角来看，如果原来的 $n-1$ 列线性相关，那么删掉一行（也就是减少一个维度）之后这 $n-1$ 列仍然线性相关；
> 2. 另一个方向略显困难：如果原来关联矩阵的 $n-1$ 列线性无关，那么删掉一行之后，在基本关联矩阵中这 $n-1$ 列仍然线性无关吗？如果删掉某行后不是线性无关，那么存在这些列的线性组合使得到的列中该行位置的元素不是 $0$，该行之外位置的元素全都是 $0$ 。那么关联矩阵的这 $n-1$ 列的线性组合后的元素和不为 $0$ ；这与关联矩阵中每一列所有元素和都是 $0$ 矛盾。

在用行列式刻画基本关联矩阵中取出来 $n-1$ 列的线性相关性的时候，我们注意到一个很好的性质：这样的行列式只会是 $\pm1$ 或 $0$ 。直观理解的话，因为矩阵很稀疏且只有 $\pm 1$ 的非 $0$ 元，所以代数余子式展开的时候不会很大。详细证明如下。

> 证明：使用数学归纳法，对阶数进行归纳。（略，待补）

这一结论（线性无关是 $\pm 1$ ，相关是 $0$ ）在下文计数时提供了很大的便利（平方后算术加和即可得到非零的“个数”）。

### 支撑树计数

有一个近乎显然的做法：我们**枚举**基本关联矩阵抽出任意 $n-1$ 列构成的子阵（它是方的），如果它的行列式不是 $0$（那么就是 $1$ 或者 $-1$ ，它的平方一定是 $1$ ），那么代表这 $n-1$ 列对应的 $n-1$ 条边可以构成一棵支撑树。

>  证明：行列式不是 $0$ $\Rightarrow$ $n-1$ 列线性无关 $\Rightarrow$ 边导出的图没有回路 $\Rightarrow$ 是一棵树

那么我们把所有的对应的行列式的平方求和即可得到某图中支撑树的数目。

接下来所有的事情都是为了加速（至少在形式上“加速”）这一过程。

#### 比内-柯西（Binet-Cauchy）定理

首先做一些纯粹数学上的准备。

对于 $ A = (a _ {ij})_ {m \times n},  B = (b _ {ij}) _ {n \times m} (m \leq n) $ ，

我们有 $\det(AB) = \sum\limits _ {S}\det(A _ {S}B_S)$ ，其中 $S \subseteq \{1,2,\cdots, n\}, |S| = m$ ；

> 关于记号的说明：$A_S$ 表示从 $A$ 中挑选 $S$ 集合下标的 $m$ 【列】构成的 $m \times m$ 方阵；$B_S$ 同理表示从 $B$ 中挑选同样 $S$ 集合下标的 $m$ 【行】构成的 $m \times m$ 的方阵。

> 证明：（略，不打算补）

#### 利用基本关联矩阵：无限制支撑树计数

利用上面的定理，我们可以巧妙的加速以上运算（或者至少让看起来的形式简洁一点）。

我们令 $B_i$ 为点 $v_i$ 对应（把 $v_i$ 对应的行删掉）的基本关联矩阵。则：

$$
\det(B_i{B_i}^T) = \sum\limits_S \det({B_i} _ S {{B_i} _ S}^T) = \sum\limits_ {S} \det({B_i} _ S)^2
$$

注意到，这个式子可以和上文的“显然的做法”对应： $\sum\limits _ {S}$ 对应中的“枚举 $n-1$ 列”，${B_i} _ S$ 对应挑出来的 $n-1$ 列构成的方阵。

于是：$\det(B_i {B_i}^T)$ 即为图的支撑树个数。

### 带限制条件的支撑树计数

有的时候，我们会对支撑树做出一些限制，而为了计算符合条件的支撑树个数，我们需要对上面的方法进行一些微小的特异化。

#### 包含或不含特定边的支撑树计数

不含 $e$ 的支撑树：删去边 $e$ 之后，按照新图构造关联矩阵与基本关联矩阵（其实就是从原来的矩阵里面删掉一列）进行计算。

包含 $e$ 的支撑树：

1. 把 $e$ 两边的点缩成一个点，再进行计算
2. 所有支撑树 - 不含 $e$ 的支撑树 = 含 $e$ 的支撑树

#### 以特定节点为根的支撑树计数

再次申明，这一概念只适用于有向图。

严格来说，“对于一棵树，其以 $v_i$ 为根” 当且仅当 “这棵树中， $v_i$ 的负度为 $0$，剩余所有节点的负度均为 $1$ ”。

以直观的视角来看，“对于一棵树，其以 $v_i$ 为根” 当且仅当 “对于一棵树，将 $v_i$ 放在最上面，按照“重力”下垂，所有的边都由上指向下”。【“重力下垂”是个很强的条件，仅仅拥有“从上向下”的边并不能保证得到的是树，只能保证得到的是有向无环图】

我们需要想办法排除掉所有不符合根条件的支撑树。也就是对关联矩阵进行修改（具体来说，就是把所有 $1$ 置为 $0$ ），使得所有不满足根条件的支撑树所对应的 $n-1$ 阶子式的行列式变为 $0$ ；满足条件的仍是它本身。

> 后者我们通过可以**给有根树的点和边重新编号**，使 $v_1$ 为根，使所有的边 $e_j = (v_i,v_j)(j = 2,3,\cdots,n)$ 都有 $i < j$ 。注意到如此编号的话，在图关于 $v_1$ 的基本关联矩阵（也就是删去了第一行）中，这棵以 $v_1$ 为根的有根树对应的 $n-1$ 阶矩阵是上三角矩阵（因为 $i < j$），且对角线均为 $-1$ ，$1$ 只能在严格上三角的位置，因此删除所有的 $1$ 不会改变行列式的值。
>
> 边和点的重新编号，体现在矩阵/行列式的数学视角里面是什么呢？对边的重新编号是列交换，对点的重新编号是行交换。
>
> 以上三个操作都不改变行列式的值，

> 前者不太好说【书上直接“显然”了】：首先如果一棵支撑树，不是以 $v_r$ 为根的有根树，那么必然存在节点 $ v_j$ , $v_j \neq v_r$ 的负度为 $0$ （利用 $ \sum  \limits _ {i}{{d^-}(v_i)} = m = n-1 $），即 $v_j$ 对应的行全为 $0$ （因为正度的 $1$ 全被删掉了），有全 $0$ 行的矩阵的行列式必然为 $0$。【其实这也有点图论视角。】

> 从图论的视角来看这个问题更加明显一点。去除所有 $1$ 后，（基本）关联矩阵本质上只表示负度，也就是某行的 $-1$ 的个数表示该行对应的点的负度度数，每列有且仅有一个 $-1$ 。而根据有根树的定义，对于一棵树，其以 $v_i$ 为根 当且仅当  $v_i$ 的负度为 $0$ 且剩余所有节点的负度均为 $1$ 。那么转化成数学表示的话，后一个条件就是 $n-1$ 阶方阵每一行、每一列有且仅有一个 $-1$ 。我们知道，这是一个置换矩阵，行列式是  $\pm 1$ 。这样想可以使两方面的推导都更加自然。

所以结论： 且令 $\vec{B_i}$ 表示将 $v_i$ 对应的基本关联矩阵中所有的 $1$ 置成 $0$ 之后的矩阵，那么以 $v_i$  为根的数的个数就等于 $\det(\vec{B_i}{B_i}^T)$ 。

至于为什么不采用 $\det(\vec{B_i}\vec{B_i}^T)$ 作为表达式？

因为上文关于 $\vec{B_i}$ 中  $n-1$ 阶子阵行列式变化视角和图论视角下的讨论，都是基于**挑出来的列对应的边能构成一棵树**的前提下进行的。而如果缺乏这个前提，上文的讨论是不能成立的。本质上来说，就是 “$v_i$ 的负度为 $0$ 且除了 $v_i$ 的点负度均为 $1$ ”的条件（删去 $v_i$ 行，再挑出来满足这样条件的边对应的的 $n-1$ 阶子阵的行列式不是 $0$ 哦！）并不能确保这些边的导出子图为一棵树。容易想到的反例就是一棵有根树 + 一堆环。

---

以上两种形式的约束可以组合。值得提到的是，包含某条边的特定节点的支撑树计数，有一种较为简单的办法：把该边指向的节点的其余所有入度都删掉。

### 矩阵树（Matrix Tree）定理

一种较为简便求解支撑树计数问题的方法。

对于**无向图** $G(V,E)$ ，定义拉普拉斯矩阵 $L _ {n \times n}$：

$$
L _ {ij} = \left \{ \begin{aligned}-m _ {ij}&,i \neq j \\ \text{deg}(v_i)&,i = j\end{aligned}\right.
$$

其中 $m _ {ij}$ 表示 $v_i$ 与 $v_j$ 之间的边数。

则该无向图 $G$ 的支撑树个数则为 $t(G) = \det(L_i)$ ，$L_i$ 为去掉第 $i$ 行和第 $i$ 列后得到的矩阵，$i = 1, 2, \cdots, n$。

或者，用特征值表示：找出 $L$ 的 $n-1$ 个非 $0$ 特征值 $ \lambda _ 1 , \cdots, \lambda _ {n-1} $， 那么 $t(G) = \frac{1}{n} \prod\limits _ {1 \leq i \leq n-1} \lambda_i$

这一定理的本质是找到了一个对于关联矩阵与其转置乘积结果的简洁表达，因此在 $m$ 较大时能节省出很多的时间。具体证明如下：

> 引理1: $BB^T = L$
>
> 证明： $(BB^T) _ {ij} = \sum \limits _ {e_k \in E} B _ {ik} {B^T} _ {kj} = \sum\limits _ {e_k \in E} B _ {ik}B _ {jk}$ 。
>
> 1. 当 $i=j$ 时，显然只有 $e_k$ 邻接与 $i$ 的时候， $B _ {ik} = \pm1$ ，其余时候均为 0 ；故求和即为与 $i$ 邻接的边的个数，即 $deg(v_i)$ 。
> 2. 当 $i \neq j$  时，$B _ {ik} \neq 0$ 且 $B _ {jk} \neq 0$ 当且仅当 $e_k$ 连接 $v_i$ 与 $v_j$ ；而 $B _ {ik}$ 与 $B _ {jk}$ 显然一者为 $1$ ，一者为 $-1$，故乘积为 $-1$ ，求和后即为 $-m _ {ij}$ 。 
>
> 引理2：$B_i{B_i}^T = L_i$ 
>
> 证明：这几乎是显然的。

关于有根树的矩阵树定理，在这里不加证明的展示以下结论：

> 对于有向图 $G(V,E)$ ，定义出度拉普拉斯矩阵 $L^\text{out}$ ：（$n \times n$）
>
> $$
> {L^\text{out}} _ {ij} = 
> \left\{\begin{aligned}-m _ {ij}&,i \neq j \\ \text{deg}^{\text{out}}(v_i)&,i = j\end{aligned}\right.
> $$
> 
> 其中 $m _ {ij}$ 为从 $v_i$ 指向 $v_j$ 的有向边条数。
>
> 同理可以定义入度拉普拉斯矩阵 $L^{\text{in}}$ 。
>
> 定义 ${L^{\text{out}}} _ i$   为 $L^\text{out}$ 去掉 第 $i$ 行和第 $i$ 列得到的矩阵；那么以 $v_r$ 为根节点的有根树个数即为 $t^{root}(G,r) = \det({L^{out}} _ r)$ 。
>
> 同理可以定义 ${L^{\text{in}}} _ i$ ，则以 $v_r$ 为叶节点的有根树数目即为 $t^\text{leaf}(G,r) = \det({L^{\text{in}}} _ r)$。 

## 回路矩阵、割集矩阵与支撑树生成

回路矩阵、割集矩阵都可以通过某种方式与支撑树形成一一对应，从而我们可以通过枚举回路和割集来确定所有的支撑树。

### 定义与概念

## 参考

1. 戴一奇等：《图论与代数结构》，清华大学出版社。
2. https://oi-wiki.org/graph/matrix-tree/
3. https://zhuanlan.zhihu.com/p/108209378