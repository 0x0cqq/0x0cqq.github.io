{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/android-chrome-192x192.png","path":"android-chrome-192x192.png","modified":0,"renderable":0},{"_id":"source/android-chrome-512x512.png","path":"android-chrome-512x512.png","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/browserconfig.xml","path":"browserconfig.xml","modified":0,"renderable":0},{"_id":"source/favicon-16x16.png","path":"favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/favicon-32x32.png","path":"favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/mstile-150x150.png","path":"mstile-150x150.png","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/safari-pinned-tab.svg","path":"safari-pinned-tab.svg","modified":0,"renderable":0},{"_id":"themes/next/source/google10e62edab32bec8a.html","path":"google10e62edab32bec8a.html","modified":0,"renderable":1},{"_id":"source/images/friends/memset0.jpg","path":"images/friends/memset0.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"source/images/friends/hzwer.jpg","path":"images/friends/hzwer.jpg","modified":0,"renderable":0},{"_id":"source/images/friends/chenqiqian.jpg","path":"images/friends/chenqiqian.jpg","modified":0,"renderable":0},{"_id":"source/images/friends/xehoth.png","path":"images/friends/xehoth.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","path":"lib/algolia-instant-search/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","path":"lib/algolia-instant-search/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"source/board/blackboard.jpg","path":"board/blackboard.jpg","modified":0,"renderable":0},{"_id":"source/images/friends/Menci.png","path":"images/friends/Menci.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"source/images/20180623-germany.jpeg","path":"images/20180623-germany.jpeg","modified":0,"renderable":0}],"Cache":[{"_id":"source/BingSiteAuth.xml","hash":"c40d96c5ce4b303b823668be36fdf3761ee9af8e","modified":1525485509000},{"_id":"source/CNAME","hash":"bfcde5baede95c3ec0714333f13e5c4ddd69ec43","modified":1525490056000},{"_id":"source/android-chrome-192x192.png","hash":"3e0cb3d97bcb6ffbea4a98e0c36a2ce61233cec3","modified":1520820638000},{"_id":"source/.DS_Store","hash":"569ac156e7587baea3e4a6f8a977619dec9d8c2b","modified":1529831836392},{"_id":"source/android-chrome-512x512.png","hash":"13844404555b4c26c9c3ae90015ed1dfcea673ae","modified":1520820638000},{"_id":"source/apple-touch-icon.png","hash":"c5d759d3931ff552e606a7913a54c0e050e07e9b","modified":1520820638000},{"_id":"source/browserconfig.xml","hash":"077ef4916926e9fd6c222005b0d41256ec13935f","modified":1520820638000},{"_id":"source/favicon-16x16.png","hash":"ffc7ab97fd9c918195fe036de6981aa0b1fa159f","modified":1520820640000},{"_id":"source/favicon-32x32.png","hash":"7e650a1074d99bfb93b4e0e9a5fa06d2c784d191","modified":1520820640000},{"_id":"source/favicon.ico","hash":"1ee0ae293c3e83e3240b11d57d03f2318d9f99c4","modified":1520820640000},{"_id":"source/manifest.json","hash":"e29a11989e1f2c946c6a379541fe08551a7d41f6","modified":1520820640000},{"_id":"source/mstile-150x150.png","hash":"6c95cc8a1ed548b0f56ac77e340046b5363c043e","modified":1520820640000},{"_id":"source/robots.txt","hash":"11d1d70eba12d57d572d4ef4faae7787b65becf8","modified":1520082129000},{"_id":"source/safari-pinned-tab.svg","hash":"d83d65ec2029dedf91dc358ae2a5d0de90bbfcde","modified":1520820640000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1521816606000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1521816606000},{"_id":"themes/next/.DS_Store","hash":"73b7b2e745165e6fcb6a963f0526521b021f5d2d","modified":1529842155091},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1521816606000},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1521816606000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1521816606000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1521816606000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1521816606000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1521816606000},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1521816606000},{"_id":"themes/next/README.md","hash":"8ae619024365621114e7ec7ba1fae5833cbd0cb9","modified":1521816606000},{"_id":"themes/next/crowdin.yml","hash":"fe22a450cc1272b7ac5476e6b33a999f8b8a2034","modified":1521816606000},{"_id":"themes/next/bower.json","hash":"b133dd92c7a825745a3b74474c2d738d9fd8ff07","modified":1521816606000},{"_id":"themes/next/_config.yml","hash":"65a7cb48f34a1de62a91a16b10f8811bef432691","modified":1529842997576},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1521816606000},{"_id":"themes/next/package.json","hash":"77f15fd8e1bf54fe9e04513e38a70823225256cc","modified":1521816606000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1521816606000},{"_id":"source/about/index.md","hash":"2a7f65bbceee409f7ac8db2ff048585470fce019","modified":1521855476000},{"_id":"source/_posts/2018-AprWeek1.md","hash":"5516fde936c00a3a2b677671744d28a30807c1f2","modified":1522930630000},{"_id":"source/_posts/2018-AprWeek2.md","hash":"c30b22b70287f5f5dccaa696848a89f20f22ee3e","modified":1523198154000},{"_id":"source/_posts/2018-AprWeek3-4.md","hash":"b1148956a052b72784c269ace950beb4320f1e53","modified":1524290491000},{"_id":"source/_posts/.DS_Store","hash":"218bcbc8e31dd6cc6e7048db071279ba99b38f10","modified":1529293675880},{"_id":"source/_posts/2018-AprWeek5.md","hash":"fa2079829c693b6569deb398283af327c81f9072","modified":1524922051000},{"_id":"source/_posts/2018-FebWeek1.md","hash":"b47b74484f3412d3ace10a5260c12dbb14709fa8","modified":1521292788000},{"_id":"source/_posts/2018-FebWeek2.md","hash":"8d7c96b105081f52fdee033f5586d7818c94b1dc","modified":1521292781000},{"_id":"source/_posts/2018-FebWeek3.md","hash":"abe8a14f976065179dff08422935a3897e3ffa0e","modified":1521292774000},{"_id":"source/_posts/2018-FebWeek4.md","hash":"bed0a9f1dfdcaf99d1013432b855ea82a8d26a6b","modified":1521292764000},{"_id":"source/_posts/2018-JanWeek2.md","hash":"065a9c17e4ba6b5748ea79bd2d6dbd56080b3918","modified":1521292755000},{"_id":"source/_posts/2018-JanWeek3.md","hash":"0660faccf170c29d1682e6fb5bbc944eacf4a116","modified":1521292746000},{"_id":"source/_posts/2018-JanWeek4.md","hash":"ba0dad4be10e79011e66ce79f78717f45bdbd208","modified":1521292735000},{"_id":"source/_posts/2018-MarWeek1.md","hash":"1df56a9c7dff86e6dc81aa4c4556ab4e0ae9ec42","modified":1521292727000},{"_id":"source/_posts/2018-MarWeek2.md","hash":"9d62b61312d34035178a952f7d84bead78c230ff","modified":1521292717000},{"_id":"source/_posts/2018-MarWeek3.md","hash":"a9baa64916631fe9716ed28d83cfa2b87af0587c","modified":1521292694000},{"_id":"source/_posts/2018-Marweek4.md","hash":"54392fe8e1eb639f284be2d3f0ca4090e488373e","modified":1522843657000},{"_id":"source/_posts/2018-MayWeek1.md","hash":"2d1302ce8fe835d4c3b2adf207990679a1fb5b10","modified":1525532624000},{"_id":"source/_posts/2018-MayWeek2.md","hash":"fb19824cf11c07d770fa23e2091d4739ac4288ed","modified":1526169599000},{"_id":"source/_posts/2018-MayWeek3.md","hash":"1ffefc52ef1d9fe19217123f9a19aff9671088ed","modified":1527953438000},{"_id":"source/_posts/2018-MayWeek4-5.md","hash":"fb6a6a04b9712fce5dd66089c21ee41fd542bc51","modified":1527953758000},{"_id":"source/_posts/2018年6月·下.md","hash":"a568346792b27c62381cd12e561c70d22be2230b","modified":1529831838242},{"_id":"source/_posts/2018年六月·上.md","hash":"b1e99b0841f830ad36b290be5af044662eb2d208","modified":1529759774266},{"_id":"source/_posts/AC自动机学习笔记.md","hash":"c376e024f0383e5cc64d9d7b8c9336e896e8577e","modified":1522930303000},{"_id":"source/_posts/BJOI2018游记.md","hash":"d8f79de5ed98c24cfd16fff6e36404d755d91bbd","modified":1523803962000},{"_id":"source/_posts/Dinic学习笔记.md","hash":"89a761e4b80a74b8cda668ab12a5163d3e6fee32","modified":1520082128000},{"_id":"source/_posts/OI大事记.md","hash":"3ae7648a8c14d3b8c64ce45856bd5e27784b09ba","modified":1522920044000},{"_id":"source/_posts/Splay学习笔记.md","hash":"7996ab720ffb49589c5569de28f5b32e13ad3045","modified":1528383866000},{"_id":"source/_posts/Treap学习笔记.md","hash":"9b531f66538bc501ec90210f4bb4cccf3bf84a6b","modified":1520082128000},{"_id":"source/_posts/hello-world.md","hash":"911782a7ccdb10e8444980d6ac549b405f5ab645","modified":1521864949000},{"_id":"source/_posts/“长大”.md","hash":"e69669e05e6d73c38dd5dc07f465bdbc4a52d5fd","modified":1520082128000},{"_id":"source/_posts/「AHOI2008」紧急集合-LCA.md","hash":"fa98d3754bb9f60f1b05a5ae1195574b87f3fa15","modified":1521864779000},{"_id":"source/_posts/「CQOI2011」动态逆序对-CDQ分治.md","hash":"01bc349e24e514a204644a18fee2b71f1a8c0fc7","modified":1528377324000},{"_id":"source/_posts/「CQOI2012」交换棋子-费用流.md","hash":"aa450447d8df9f95322501d141b93bbfe83fd848","modified":1525531829000},{"_id":"source/_posts/「CQOI2014」排序机械臂-Splay.md","hash":"8d1a3f5b20cdc61a5bfdca3e1f732b76ee4c795c","modified":1520082128000},{"_id":"source/_posts/「CQOI2015」任务查询系统-可持久化线段树.md","hash":"1075cb5b34dad66ef7f9713076ec46456e84618e","modified":1526477811000},{"_id":"source/_posts/「CQOI2016」手机号码-数位dp.md","hash":"7d7396cb7403e03e5ccd35473661d48e46ef1950","modified":1529420624766},{"_id":"source/_posts/「HAOI2007」理想的正方形-单调队列.md","hash":"0a8ccf8b95986d062d6c0f5a3975128bae6afe28","modified":1526644404000},{"_id":"source/_posts/「HAOI2009」毛毛虫-树形dp.md","hash":"9b4557aeb03c063d772ae8c46c4bad2fd805ef15","modified":1528383752000},{"_id":"source/_posts/「HNOI2009」梦幻布丁-set-启发式合并.md","hash":"cec12d2729316f360ef18e576605905273904f92","modified":1526908229000},{"_id":"source/_posts/「HNOI2010」弹飞绵羊-动态树.md","hash":"2d5851a728aea217581fbc98fc806499f91f4dd7","modified":1526641908000},{"_id":"source/_posts/「JSOI2016」最佳团体-树上背包-0-1分数规划.md","hash":"af94cbfb20d9077e02f674ed099a9248cec08a27","modified":1529294339893},{"_id":"source/_posts/「LNOI2014」LCA-树链剖分-差分.md","hash":"c6589736b9b737dbd41180f67fdc55ad5a9bf909","modified":1527954080000},{"_id":"source/_posts/「Luogu1043」数字游戏-dp.md","hash":"de8e9f5ca6d72b03406116c81083cb661f5c2547","modified":1524711856000},{"_id":"source/_posts/「Luogu2617」Dynamic-Rankings-树状数组-可持久化线段树.md","hash":"cce01e8476389ffab8a166e4e71434bf9bf914e1","modified":1526129378000},{"_id":"source/_posts/「Luogu3765」总统选举-平衡树-线段树.md","hash":"59a01ae585e61cae01aec05384cb33759fa7c25b","modified":1525531763000},{"_id":"source/_posts/「NOI2002」银河英雄传说-并查集.md","hash":"3e23983563d13b41ef6255cdfefb6bceb7178eaa","modified":1520082128000},{"_id":"source/_posts/「NOI2004」郁闷的出纳员-Splay.md","hash":"499b5f4c60934fdf9c17eb038fed05a580cf4fb3","modified":1520082128000},{"_id":"source/_posts/「NOI2005」维护数列-非旋Treap.md","hash":"c58bfaa1c30bcab2999e0960b1531e293dd93d2b","modified":1527906761000},{"_id":"source/_posts/「NOI2009」二叉查找树-区间dp.md","hash":"ad0a3920320d5a1a60523781712d3abb0f0c45dc","modified":1525531734000},{"_id":"source/_posts/「NOI2010」能量采集-简单数学.md","hash":"7a2f4d2c7b585a3cc6622b6090e32ddca5846e26","modified":1529288136671},{"_id":"source/_posts/「NOI2012」美食节-费用流.md","hash":"c1dbf58f4111028895d67bd5eea159076add5160","modified":1525429883000},{"_id":"source/_posts/「NOI2014」动物园-KMP.md","hash":"8a5f11801260ac52bcdbc7de22a8bd1bdfad3371","modified":1522930331000},{"_id":"source/_posts/「NOI2014」魔法森林-LCT.md","hash":"afc4c6aef557d2d24e8cc7741556be5cd906c245","modified":1529294656545},{"_id":"source/_posts/「NOI2015」软件包管理器-树链剖分.md","hash":"689f2e901f0547b0889f5adac306efb2d36dde5e","modified":1523280508000},{"_id":"source/_posts/「POI2014」KUR-Couriers-主席树.md","hash":"421601228ea5e824592f80315203485616bd6234","modified":1525607266000},{"_id":"source/_posts/「SCOI2010」连续攻击游戏-二分图匹配.md","hash":"087b086c33f750c84358302f0c31cad4279abd9d","modified":1528383810000},{"_id":"source/_posts/「SCOI2013」多项式的运算-Splay.md","hash":"59793a9b4ca9177b5b3b16de812ac2b06dc77187","modified":1527953981000},{"_id":"source/_posts/「SCOI2015」小凸玩密室-树形dp.md","hash":"913be7eea176f354f0ec55de1805f6ee2a869cad","modified":1528456305000},{"_id":"source/_posts/「SDOI2008」洞穴勘测-LCT.md","hash":"09848663f28c85ac08f3568f017aabc1fb8d7481","modified":1526120065000},{"_id":"source/_posts/「SDOI2009」HH的项链-莫队or树状数组.md","hash":"8c18c22ed9a383ba850fee269a18a94837f48e90","modified":1520082128000},{"_id":"source/_posts/「SDOI2011」工作安排-费用流.md","hash":"a7a8504a02ad59be66898c0b8c80c36573a2581e","modified":1525531891000},{"_id":"source/_posts/「SDOI2011」染色-树链剖分-线段树.md","hash":"ed162030afdbd28207188d35cf59ee6f6b9f04ee","modified":1521037287000},{"_id":"source/_posts/「SDOI2011」消防-树的直径-单调队列.md","hash":"b89e226e8883f90844666c53ecee4f42db4f0a79","modified":1526908236000},{"_id":"source/_posts/「SDOI2013」森林-主席树-LCA-启发式合并.md","hash":"c53451e4f360ea5b76a29e5759c82570a846e73f","modified":1528384001000},{"_id":"source/_posts/「SDOI2013」直径-树的直径.md","hash":"640919cedc16bf7888579d80c2fc0cb9c79d6900","modified":1526129092000},{"_id":"source/_posts/「SDOI2014」旅行-树链剖分-动态开点线段树.md","hash":"f4da1653aade73f973ff7fe9d9b5f451b3eab1fe","modified":1527945746000},{"_id":"source/_posts/「TJOI2017」DNA-后缀数组.md","hash":"2a893b4558cb83e74b4622f9ac9c541ee2a063f9","modified":1529758461087},{"_id":"source/_posts/「Violet」蒲公英-分块.md","hash":"543a7e8ee8b53728f0574916f35b445b17ed0d51","modified":1522470829000},{"_id":"source/_posts/「ZJOI2007」报表统计-平衡树.md","hash":"d955842d7c46a8afbb8126eea02160b8348a47e6","modified":1521037314000},{"_id":"source/_posts/「ZJOI2007」时态同步-树形dp.md","hash":"83a681189fc7edf56a9f9c70b9594bb4afe9227b","modified":1521037342000},{"_id":"source/_posts/「ZJOI2007」最大半连通子图-强连通分量-dp.md","hash":"f4714dc2401e4fca4d197796a9803522959edd77","modified":1525531907000},{"_id":"source/_posts/「ZJOI2008」树的统计-树链剖分.md","hash":"87d9e97d1f73a4232f369817e8d96edb38da163f","modified":1521037301000},{"_id":"source/_posts/「ZJOI2009」假期的宿舍-二分图匹配.md","hash":"7dc38bbb4fcc9ce5a357bd716f34647a90931e1c","modified":1520082128000},{"_id":"source/_posts/「ZJOI2010」数字计数-数位dp.md","hash":"876a65f374984a9e3bfdf7f31dfefba7c1257013","modified":1529293643992},{"_id":"source/_posts/「ZJOI2010」网络扩容-网络流-费用流.md","hash":"3cf738c1e346e86686e3ca179fe8043cf9e6a52f","modified":1523019264000},{"_id":"source/_posts/「ZJOI2013」K大数查询-整体二分.md","hash":"c1d6a9ea046704ac9235b67ae4e1ac551202bdfe","modified":1528294504000},{"_id":"source/_posts/「国家集训队」数颜色-带修改莫队.md","hash":"754c10a2d8dbfb59b74988d064f95ba5a65ffdb2","modified":1522470801000},{"_id":"source/_posts/「国家集训队」聪聪可可-点分治.md","hash":"ca5a87b66dd047c5ff934849c0184cde0b174b75","modified":1525531856000},{"_id":"source/_posts/「摘录」青春设计师-年级范文.md","hash":"cd9d3f481b43707928f467f86db36c3b8819a915","modified":1528035888000},{"_id":"source/_posts/「梦想」.md","hash":"03ee906776b6218f4ff7b6f78f4cb7cfd4d3a152","modified":1529074085120},{"_id":"source/_posts/「模板」陌上花开-CDQ分治-树状数组.md","hash":"0702d53db9ced8ee62bfbf1d6a6dd811901750b6","modified":1528290476000},{"_id":"source/_posts/「红楼一梦」.md","hash":"c54df14470d3f08722387068503e8d6612cb4837","modified":1520082128000},{"_id":"source/_posts/冬令营旅游记.md","hash":"535543a2e289b85fb26a076697b0cba324607d9e","modified":1523803113000},{"_id":"source/_posts/可持久化线段树学习笔记.md","hash":"58f4a9d1917611e370812e6f4b048b097e973750","modified":1528383901000},{"_id":"source/_posts/新高考？不过是换一种套路的折磨.md","hash":"c179ac8216462e010012d0ab3a6adcaa2eb6bf60","modified":1527949520000},{"_id":"source/_posts/日常颓废.md","hash":"95f8a2702ee66ffa77386afd21d5d3f2959a4fd7","modified":1520082129000},{"_id":"source/_posts/测试一下.md","hash":"aea86f11b9195d2801440602c5684ac846df60b4","modified":1520082129000},{"_id":"source/_posts/点分治学习笔记.md","hash":"ade52d3d7b2f9f92372a84c7995611a3c7797f97","modified":1529292520087},{"_id":"source/_posts/考试前要看的东西.md","hash":"4b6d5d4aa178aba3c3795d152dca25a0d23f958c","modified":1524712024000},{"_id":"source/_posts/莫队算法学习笔记（一）.md","hash":"0061f75e1ce7f3b882e15d9a50257b50bf479b24","modified":1522470595000},{"_id":"source/_posts/衡水中学游记.md","hash":"ec2599263ef6eaff058464dc63074ecd81137ec6","modified":1525079481000},{"_id":"source/_posts/转载-达拉崩吧OI版.md","hash":"82414ba9d8c56308d7a85f0947b2f07c7b491780","modified":1520082129000},{"_id":"source/_posts/输入输出优化模板.md","hash":"ca8e8bc45447148f6fb1bc7d7bc2fd2c2fd920a0","modified":1522924095000},{"_id":"source/_posts/非旋Treap学习笔记.md","hash":"87abe53bea46a3a5ca1e4ee950d37af30ec0e135","modified":1521037326000},{"_id":"source/_posts/高斯消元法学习笔记.md","hash":"4e3228a65d3a7489fa579045b8a88ea050919b27","modified":1529841379042},{"_id":"source/board/index.md","hash":"76658bbade0ee4640e4e6f8820be53af6405436a","modified":1523096881000},{"_id":"source/board/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1523099388000},{"_id":"source/categories/index.md","hash":"100649f1aa291a66137c66a3e603013b6140f065","modified":1523097031000},{"_id":"source/images/.DS_Store","hash":"6a6d7234486c60f8f2842b514f7de295fa30bffb","modified":1527954783000},{"_id":"source/links/index.md","hash":"58eb2b7d145a368efcb7c0c6ed249d6fc1d6e208","modified":1527955063000},{"_id":"source/tags/index.md","hash":"f367c3a92641bd4b4bd595236689ba197e30633d","modified":1523097011000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1521816606000},{"_id":"themes/next/.git/FETCH_HEAD","hash":"109c444c7356c5dd1eea20110c170f20c00ae419","modified":1523198406000},{"_id":"themes/next/.git/ORIG_HEAD","hash":"5a1d2ef48a952efc8f18fc66fc493c23d7c2df2a","modified":1523198406000},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1521816606000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1521816595000},{"_id":"themes/next/.git/index","hash":"0453aa756c2356d91a08196e27f6442de885de27","modified":1529842575492},{"_id":"themes/next/.git/packed-refs","hash":"a302977fafe178fcbb5295c07341863ad28ae2f1","modified":1521816606000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1521816606000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1521816606000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1521816606000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"476c9bb6616818be9d86567ad4e2e539c0e0da2f","modified":1521816606000},{"_id":"themes/next/.github/stale.yml","hash":"1bbdd20d025010ec57225712be82988a26485836","modified":1521816606000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1521816606000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1521816606000},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1521816606000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1521816606000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1521816606000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"9f90a1a2df8c54edd3c8d99714ef0ce175983938","modified":1521816606000},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1521816606000},{"_id":"themes/next/docs/MATH.md","hash":"d047b8a3d9aa49b478a33e5a326195d460cb4589","modified":1521816606000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1521816606000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1521816606000},{"_id":"themes/next/languages/_en.yml","hash":"2397256c752276df666c1ff579902abb367b2380","modified":1521816606000},{"_id":"themes/next/languages/ar.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/bg.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/bn.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/cs.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/da.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/el.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/de.yml","hash":"f4dc655d4bd396b9c309da2a99b42c0456c3fe16","modified":1521816606000},{"_id":"themes/next/languages/es.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/et.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/fa.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/fi.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/fr.yml","hash":"dacb82b46d7b79656cdb75768a031fa73f178477","modified":1521816606000},{"_id":"themes/next/languages/he.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/hi.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/hr.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/hu.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/id.yml","hash":"c89ef3ed946a150f052f470f71393db6a6d3acaa","modified":1521816606000},{"_id":"themes/next/languages/it.yml","hash":"f0fb26ab84e5d0508ddc07bd67d581033520bb43","modified":1521816606000},{"_id":"themes/next/languages/ja.yml","hash":"02029ef467628369a88d1022746b861dca3fb921","modified":1521816606000},{"_id":"themes/next/languages/jv.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/ko.yml","hash":"c95a00066bda4c04ce7bf65f8bf08e82c4d8fbcf","modified":1521816606000},{"_id":"themes/next/languages/lt.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/lv.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/ms.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/nl.yml","hash":"8fc1165a138081d25ff4c171dea2980ce71fe2b0","modified":1521816606000},{"_id":"themes/next/languages/no.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/pa.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/pl.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/pt-BR.yml","hash":"268188db09c6779a570c8fc647ccc1a73322476c","modified":1521816606000},{"_id":"themes/next/languages/pt.yml","hash":"d8898007460ec50eb9969ba38d1b030613260ce7","modified":1521816606000},{"_id":"themes/next/languages/ro.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/ru.yml","hash":"26ae39b50887dcf0bf3ca3d820e5382fc11cc996","modified":1521816606000},{"_id":"themes/next/languages/sl.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/sv.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/sr.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/th.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/tr.yml","hash":"efc298288935bf892efc9707b1ae4ea92d5fb7b4","modified":1521816606000},{"_id":"themes/next/languages/uk.yml","hash":"e1abab282917fcad60368e7e754ba1a70f888f38","modified":1521816606000},{"_id":"themes/next/languages/vi.yml","hash":"7792081d90122327f913f224f31965460936df5a","modified":1521816606000},{"_id":"themes/next/languages/zh-HK.yml","hash":"f7b3304e44959f74149a01d5f140fef64bfb3fa1","modified":1521816606000},{"_id":"themes/next/languages/zh-CN.yml","hash":"25a22f493b8e4b990fff83ae713d87e9ca01adec","modified":1523093948000},{"_id":"themes/next/languages/zh-TW.yml","hash":"1f025215f1ac03dd4db9b4f87aa393ee43494bc3","modified":1521816606000},{"_id":"themes/next/layout/_layout.swig","hash":"5803acd1f338db83a3b8d99eebbf163083e02520","modified":1521816606000},{"_id":"themes/next/layout/.DS_Store","hash":"ab76bf924475a4469905845e0215b1e68092bfac","modified":1529842163009},{"_id":"themes/next/layout/archive.swig","hash":"833a2213d31be45a12b8e4e5e609073978bd251b","modified":1521816606000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1521816606000},{"_id":"themes/next/layout/index.swig","hash":"8f114a4223cd0ac26cfb175a7db181fdf2f96494","modified":1521865122000},{"_id":"themes/next/layout/page.swig","hash":"3f9b2444f12251727ebbc28159f02e9e9489742e","modified":1521816606000},{"_id":"themes/next/layout/post.swig","hash":"8e2d079b46076996cc9343213d5bf7da8178d32d","modified":1521816606000},{"_id":"themes/next/scripts/fold.js","hash":"4190bf7c6fb9aedcddf802498e2e390a85a3669d","modified":1521858118000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1521816606000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1521816606000},{"_id":"themes/next/scripts/merge-configs.js","hash":"ca9845dc76f5710b4c6fba5fe25ff0d2fcf0adaa","modified":1521816606000},{"_id":"themes/next/scripts/.DS_Store","hash":"9735cac43bce3fb382d5dfcaa15be2140d4c3cda","modified":1529841617541},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1521816606000},{"_id":"themes/next/scripts/tags.js","hash":"1856eb597206957085c7fdd1c9115ed4b9bcd50a","modified":1521858027000},{"_id":"themes/next/source/.DS_Store","hash":"1b2042f492d3d842d522857a66bf07fb96929bdb","modified":1529842053511},{"_id":"themes/next/source/google10e62edab32bec8a.html","hash":"3068353704dce53a8024b9ddf7937f465fa77249","modified":1515985532000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1521816606000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1521816606000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1521816606000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"source/_posts/2018-MayWeek2/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1526133712000},{"_id":"source/_posts/BJOI2018游记/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1525078921000},{"_id":"source/_posts/Treap学习笔记/lower_upper.gif","hash":"5b772f80578f9289aaff07b5c542a489eb7cfd1f","modified":1520082128000},{"_id":"source/_posts/Treap学习笔记/rotate.gif","hash":"c4b8c9cc66ce68fbaaba6d8ec969f44f0db9680b","modified":1520082128000},{"_id":"source/_posts/Treap学习笔记/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1520082128000},{"_id":"source/_posts/「Luogu1043」数字游戏-dp/description.png","hash":"bb045878d5f4aa1fc9f0579f93cbf94b28929690","modified":1520082128000},{"_id":"source/_posts/「梦想」/2333.jpg","hash":"81599a3023408c5e9502fc152b8bb25e43d13fdd","modified":1529072176733},{"_id":"source/_posts/可持久化线段树学习笔记/segtree.png","hash":"8806045b417a479126e435f80b1426547f5d1216","modified":1527302231000},{"_id":"source/_posts/可持久化线段树学习笔记/segtree1.png","hash":"7b934d4d04bd17778576d3af7b188afa86cc5a22","modified":1527302657000},{"_id":"source/_posts/可持久化线段树学习笔记/segtree2.png","hash":"64ac5da458018948173d6e23b9c4f1871c662060","modified":1527304268000},{"_id":"source/_posts/衡水中学游记/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1526910166000},{"_id":"source/images/friends/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1520085827000},{"_id":"source/images/friends/memset0.jpg","hash":"46fb20b1fc8d9356d590adb38d3c057c7f461e21","modified":1520085443000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1521816595000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1521816595000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1521816595000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1521816595000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1521816595000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1521816595000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1521816595000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1521816595000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1521816595000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1521816595000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1521816595000},{"_id":"themes/next/.git/logs/HEAD","hash":"52626041c1af4c5f11ca0c9af7b7b55a798c3378","modified":1521816606000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1521816606000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1521816606000},{"_id":"themes/next/docs/ru/README.md","hash":"ff13616581bab8c836505e11bd425a6cbf0ce4ff","modified":1521816606000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"98ef4dc1a7a12320211ffb36d264cd86ffcce0dd","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"cbb419ccef174ef1a3fff5fc74261c600fdeec0e","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"1c7df019737656fdfd8d124c7c045a64ac8a2a8d","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1521816606000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"24753b3ddc287519252a25ee0496e83db4720ad6","modified":1521816606000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521816606000},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1521816606000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1521816606000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1521816606000},{"_id":"themes/next/layout/_macro/post.swig","hash":"7b85cd74fe673d1c842e705a18ae2e2e04f5d391","modified":1521816606000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"464082e431ea5b06df782d5f312ee25be9e5f169","modified":1521816606000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"aa620c582143f43ba1cb1a5e59240041a911185b","modified":1521816606000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"355ddd5b8af696f7bffb183addd7e84c0a4e2123","modified":1521816606000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"fea45ab314b9ea23edab25c2b8620f909d856b1d","modified":1521816606000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"79dbffba1d42f3253bc7738cb15d21cdc457e3f8","modified":1521867264000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"24163f182854c52d01b0d03b427619463b597dfc","modified":1529842129861},{"_id":"themes/next/layout/_partials/footer.swig","hash":"dfa27196630c7997e06afb48f01b605dd9573ce1","modified":1523094437000},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1521816606000},{"_id":"themes/next/layout/_partials/header.swig","hash":"6bdae92508fb5009b023386341f3b161a4ac6c70","modified":1521816606000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1521816606000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1521816606000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1521816606000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1521816606000},{"_id":"themes/next/layout/_partials/sub-menu.swig","hash":"9783a9569fe8344ed287013156e52ca1b0a25544","modified":1521816606000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1521816606000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1521816606000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1521816606000},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"17eea6add9ba3b0a19bc31400f9f12dfb5b7f0eb","modified":1529842170618},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1521816606000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1521816606000},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1521816606000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1521816606000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1521816606000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1521816606000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1521816606000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1521816606000},{"_id":"themes/next/scripts/tags/button.js","hash":"5a61c2da25970a4981fbd65f4a57c5e85db4dcda","modified":1521816606000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"db70a841e7c1708f95ca97b44413b526b267fa9b","modified":1521816606000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"2b3a4dc15dea33972c0b6d46a1483dabbf06fb5b","modified":1521816606000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a98fc19a90924f2368e1982f8c449cbc09df8439","modified":1521816606000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1b97b1b5364945b8ab3e50813bef84273055234f","modified":1521816606000},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"b7600f6b868d8f4f7032126242d9738cd1e6ad71","modified":1521816606000},{"_id":"themes/next/scripts/tags/label.js","hash":"621004f2836040b12c4e8fef77e62cf22c561297","modified":1521816606000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"460e5e1f305847dcd4bcab9da2038a85f0a1c273","modified":1521816606000},{"_id":"themes/next/scripts/tags/note.js","hash":"4975d4433e11161b2e9a5744b7287c2d667b3c76","modified":1521816606000},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1521816606000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1521816606000},{"_id":"themes/next/source/css/.DS_Store","hash":"ff5cdb7aa40747abeced85e7a5c22e165acc34d1","modified":1529841673515},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1521816606000},{"_id":"themes/next/source/images/.DS_Store","hash":"932aae77b2f0378abf9da0ca2cc7d354514c9585","modified":1529840033499},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1521816606000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1521816606000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1521816606000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1521816606000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1521816606000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1521816606000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1521816606000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1521816606000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1521816606000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1521816606000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1521816606000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1521816606000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521816606000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1521816606000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1521816606000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1521816606000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1521816606000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1521816606000},{"_id":"themes/next/source/lib/.DS_Store","hash":"51412ad13d638768328b10e8a9b6e6e3ad8f985c","modified":1525531073000},{"_id":"themes/next/source/js/.DS_Store","hash":"93bbdccb15f84595ceee8175c0e23a978cc77c3e","modified":1529841433185},{"_id":"source/_posts/2018-MayWeek4-5/title.jpg","hash":"00c33044cfe5f0ee39838a60dee823b4fab82c54","modified":1527953070000},{"_id":"source/images/friends/hzwer.jpg","hash":"4893db27370e4c1b0962274c65b3740ad0cf6bef","modified":1527954615000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1521816606000},{"_id":"source/_posts/2018-AprWeek3-4/title.jpg","hash":"bbd7e844ed350fac769ae44abeae4c6e418447b2","modified":1524290239000},{"_id":"source/_posts/2018-FebWeek4/title.jpg","hash":"a7164dbb9e8b6aa6017b3d2c2f4248a8e4985664","modified":1520082127000},{"_id":"source/images/friends/chenqiqian.jpg","hash":"3ce3ed2a6cb97c024145abc9d7f4ba5f22f7bbb4","modified":1520085858000},{"_id":"source/images/friends/xehoth.png","hash":"6902f5e8b6f284558e315ac765ad4cc15149b205","modified":1527954352000},{"_id":"themes/next/.git/objects/0b/8a1797244de2c0eef5a4ea30aed84ef32c8b6e","hash":"88928a7ab01b1dd751e97474235785f3af76a8d0","modified":1523093090000},{"_id":"themes/next/.git/objects/0e/ba79c6fe0adbb256a42c0a6f1bfc9dc670ffc1","hash":"ecf4dda0a23017719a34c98d649bcb1be084cf65","modified":1523093090000},{"_id":"themes/next/.git/objects/14/3de53cd5c8df362382077d10f011cc356da962","hash":"b30e8fb2d17ac72fbd1a6da437e2fc063fb649b0","modified":1523093090000},{"_id":"themes/next/.git/objects/15/75683f44aa6b4780088028787c9c6a6e43a1a0","hash":"c910bdbadfb223fcae4eb79ff55ca7d3efc286c4","modified":1523093090000},{"_id":"themes/next/.git/objects/19/1ba83d6cf0056e1dd88de62df18a7fc59bbb77","hash":"4b2075e3751f9da85f97a9439e1d54244d92acb8","modified":1523093090000},{"_id":"themes/next/.git/objects/1d/b89cf312289fdd8f29c42ff3991c3a7cdfa995","hash":"3dd138afaa93549f9aee029d27d8f8f540bb2d02","modified":1523093090000},{"_id":"themes/next/.git/objects/1e/3efe69612512a3fb4619baaeaa5042d517b575","hash":"84a57d54be1a6d681fa8f2e6640d774627df85aa","modified":1523093090000},{"_id":"themes/next/.git/objects/20/97034963580d5e15d7b7ae634d8c82f2c40543","hash":"f5976ce075bbba3db156fa55dccfe0822950cc43","modified":1523093090000},{"_id":"themes/next/.git/objects/25/67ffc74ca031d7f2b1cc61f4f1042881d6c5cc","hash":"8056edc35ef2b7d5bf4f7736e7f89ed8ba175336","modified":1523093090000},{"_id":"themes/next/.git/objects/26/5af45e36baedeeb6287c0d8c4c0dbb90449b69","hash":"ce8240d822d5134db91790640ffc0ee6c56b7387","modified":1523093090000},{"_id":"themes/next/.git/objects/26/cd546233c64a6d79999e6acf87bb7236bd1ac7","hash":"7b908d8c56ef9bd1986831e717709ee00e9f8151","modified":1523093090000},{"_id":"themes/next/.git/objects/2a/54ff480c07941fadbccbd3e8cc5e49cf6a7702","hash":"23abe971fcb77e19cba8c3615f87d98647ba735b","modified":1523093090000},{"_id":"themes/next/.git/objects/2a/841a9904962cd4d1d55689c4b0a0449cb18b3a","hash":"da3cce9a1bacf14a9d9fa398e0971010867a4120","modified":1523093090000},{"_id":"themes/next/.git/objects/2d/90692cf2742dbf8c6889a4d76e900d93a3b50c","hash":"7784927c7bf9e44da6876f37d711092fcc479126","modified":1523093090000},{"_id":"themes/next/.git/objects/2f/5124516f971272e2cb3c6009d3cedb5d643e2c","hash":"57a8e83ec4549b9ef2fb91ab4342d40efbcad469","modified":1523093090000},{"_id":"themes/next/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1523093090000},{"_id":"themes/next/.git/objects/31/e2afd01e53f854de8e328e2e62553f0a22ec37","hash":"8c4651c9ec8e64f130cd154e72497c1b66713c21","modified":1523093090000},{"_id":"themes/next/.git/objects/36/4d87ba70e05b1bcd7aeaeef6e7fc3fa495a51a","hash":"99d25d75416c0d1d7ffa8a33701e8185e1578dc5","modified":1523093090000},{"_id":"themes/next/.git/objects/3d/abc1651bbfa9376815e2e561ffb9c42049a3ad","hash":"829bfbe7959b33c6a9d12055f82d78f78a4da59a","modified":1523093090000},{"_id":"themes/next/.git/objects/3e/71b0a3105f4a713d6ad01b55c164e68cfbe74c","hash":"0d2e13ced6f2b92ef2dc1fecad92ebd48f0b2592","modified":1523093090000},{"_id":"themes/next/.git/objects/3e/f592a48c4170acf672027627037c06144faff2","hash":"3123eee33358024cb298d9e3865cd7f12dd76c21","modified":1523093090000},{"_id":"themes/next/.git/objects/40/af73380c4cc66102a67ddd1cf63db32ae050ea","hash":"e7785a3dc0dfd54c06dafa617ef8d882a2d97eda","modified":1523093090000},{"_id":"themes/next/.git/objects/40/25fea8974c58db2c4b33da36af5f4e2a14cb0b","hash":"3b0ee83584d7bff6ccb062b6f77b7f0945b20c1d","modified":1523093090000},{"_id":"themes/next/.git/objects/45/1ee94ac49af7e4c78a3a4fa597d5c6841329ea","hash":"1ff24f496aa4e2d333cbeeef4760d25cce1b9111","modified":1523093090000},{"_id":"themes/next/.git/objects/46/c76f1baa8377a07444dfc76c32ecfd80ff3ad1","hash":"5f16d204a8f11f414374945c57cc4efda18b9edc","modified":1523093090000},{"_id":"themes/next/.git/objects/4d/80ec2eb5837799691f8701e40e3aee5bc3c019","hash":"fb19bbb711b46435750e5d9d9ad67750e2d2ed56","modified":1523093090000},{"_id":"themes/next/.git/objects/47/781e31d68375eb30168a6423264e7c4b32df7d","hash":"46254660d8aca19e835ab50e970ecac8feb2e451","modified":1523093090000},{"_id":"themes/next/.git/objects/50/4ea75b4e1175b37b0389ea17481191f5fbb85e","hash":"624c0c6898aa7e17d78b9e24eb3981c858c8fdf9","modified":1523093090000},{"_id":"themes/next/.git/objects/50/d85ea184105882f19ca8aa700ab45eddb762f7","hash":"fc7b5b7c3401167b36ec55ed2f0f5ccee35f4d10","modified":1523093090000},{"_id":"themes/next/.git/objects/53/3d2925546421cb3c9c9741269eed662250d32b","hash":"d1cfc37d7f44011f96a9113e656b5d7ef2f78bb3","modified":1523093090000},{"_id":"themes/next/.git/objects/53/5ba53b9d140ada457553fba4610a7aa01a64b2","hash":"dd500228cd2d8c1eae767c02e4984f8f9d7d37b9","modified":1523093090000},{"_id":"themes/next/.git/objects/5e/0eadd14cb733d978190b2e6bfa87008b4205d6","hash":"f9ed5430ab565cc3e5fe5441efdc7baa4659136c","modified":1523093090000},{"_id":"themes/next/.git/objects/60/8ff21d108fabcd7e15c6afd88198996d892e6b","hash":"cc47a0e779218c665155ebab5dc466bc9f58814d","modified":1523093090000},{"_id":"themes/next/.git/objects/5e/683d7d7a76781205c00db24f339bd9253383a1","hash":"dcd21073c0319cc436e16c2cf5226eb9c1ee7d73","modified":1523093090000},{"_id":"themes/next/.git/objects/67/fed769ed5cc085b2c83b4bf869f58dfdd06238","hash":"fb502350dd28fdb092f361ce9a261e32a71c8d8b","modified":1523093090000},{"_id":"themes/next/.git/objects/63/cd8a47adf07c81dc7b7c994dcfb97819b89cef","hash":"c2dba4f04bdf5cd5bcb33a0ded3440f4cf9ebf64","modified":1523093090000},{"_id":"themes/next/.git/objects/6b/6e927efd9cfa0814707441c40c33a1d3ad3ae9","hash":"1f35ae9f41535f48fb4973bd78dc279a3896c465","modified":1523093090000},{"_id":"themes/next/.git/objects/6b/efaf90fac980f2e76b01038fe1791737203ac2","hash":"9e1c9032e46620a8a3fc4f3447b4fb839570f231","modified":1523093090000},{"_id":"themes/next/.git/objects/6d/2443c9985a8318ef122451d876ab98d01b4341","hash":"8820ed882d8591808ae54fd752c7b42dcf566fdd","modified":1523093090000},{"_id":"themes/next/.git/objects/6f/787af30855c34a8f1c1d06124baf57c7459371","hash":"d45ad296e2cf96de638817b7c5755cd5d36bdefa","modified":1523093090000},{"_id":"themes/next/.git/objects/70/164fdf21e5d85e3e0a26c70907402759af85af","hash":"1d182881f36972731b68e3abaa32335921d38e67","modified":1523093090000},{"_id":"themes/next/.git/objects/78/45dde38d2673996552241f374192e05eee5682","hash":"5dc099cdb2508a231ec93cff598e350d92e17236","modified":1523093090000},{"_id":"themes/next/.git/objects/77/92b06279a0a4cd162e1797f8be26e8c58216b9","hash":"c942b683f0f2fc82a5cafe45ad4c9af0d500e415","modified":1523093090000},{"_id":"themes/next/.git/objects/82/822ea827b8afc8c805d49ff8eeb7c5e80a26a4","hash":"e9bb410172bb29471ee3656c2367116e1fcbbd16","modified":1523093090000},{"_id":"themes/next/.git/objects/81/e02da4206a724d897dd1a4a20141f8e18cffb1","hash":"273198630929f62fd7cc4591c5c865356ae57b46","modified":1523093090000},{"_id":"themes/next/.git/objects/7a/1184afa9a9be39c4dfd97ca74d27041129d81b","hash":"20ff42c1ba40344267ddb004f42572601b3d48fb","modified":1523093090000},{"_id":"themes/next/.git/objects/77/5ac15d461f7a5e8f9f5b59822b011de941279a","hash":"91e0b6b6bb1cf7a75c3ad24e84a02cee6bd2461f","modified":1523093090000},{"_id":"themes/next/.git/objects/84/0b1f607dca3e3a95fbe2892d2a8ee133f64349","hash":"77cfef1fc346f8d57c7ecf2f05283f4554966894","modified":1523093090000},{"_id":"themes/next/.git/objects/88/749cd3ccf9f2d819b47835322d42ade060acae","hash":"6e590ccfc0a4c5e733b207f6e6cfbecb42ccd2a7","modified":1523093090000},{"_id":"themes/next/.git/objects/89/c01dc7d5f9f2abe3d9ec198250b30370d59728","hash":"146eb402dce45dd6f62a80dc86e526d30c129de3","modified":1523093090000},{"_id":"themes/next/.git/objects/8d/0c7efd183f5f9164efa7fa5387b0c2e47ca9de","hash":"1b501169e37ae6a120cd60f5a417512714920f11","modified":1523093090000},{"_id":"themes/next/.git/objects/8d/9fe276ace94eab5b00f50520604b7134804d41","hash":"f14ac8a90013aeede736af7d50bc16bef6027e75","modified":1523093090000},{"_id":"themes/next/.git/objects/8d/b1bb5fc8b425dc0ee60e3f0c14734cabb76500","hash":"7bca146df810993ea86fb58f0f438f509adc9764","modified":1523093090000},{"_id":"themes/next/.git/objects/8e/7596f914f2abfad0b199d15255634ecd01118e","hash":"d2c94fe4a14c1a3b328cec7805905d66345e5c73","modified":1523093090000},{"_id":"themes/next/.git/objects/96/044ca47021e0c65bdf5335d4a07fc379b0ea8c","hash":"c4082d108aa1897bbd50bf296ba3c5830ec64134","modified":1523093090000},{"_id":"themes/next/.git/objects/9d/82352a2e81f172404130219efbc2bffed7847d","hash":"1c188ce0168bdd213c1c6556fe97346695e2d8f2","modified":1523093090000},{"_id":"themes/next/.git/objects/9e/15e7d0133c67a1766debcafe72aa7acb1e74ff","hash":"52cfbdfb25e3957ceb7922f4576a62fc120dfe72","modified":1523093090000},{"_id":"themes/next/.git/objects/a0/173a099d48501d81ce9313689c8cf7c93b27af","hash":"662b643ddab10f469cbd5158604ac53661de7f41","modified":1523093090000},{"_id":"themes/next/.git/objects/9e/2b69a5f6f282d6ff87eaecd6c8c7c1f2c70f9e","hash":"390f03ff013fa64c483ab6f7b7859f78feb77f4b","modified":1523093090000},{"_id":"themes/next/.git/objects/a2/c18190c66ec5fb5b6efdcfa23e75c587ca0486","hash":"d669401a5c940658ea64614bb8080bc02c539693","modified":1523093090000},{"_id":"themes/next/.git/objects/a6/78acdae6fecd9c09f50e92c0c20f316d76d684","hash":"b95a7d4c53aaf01583f7d0fa7b63b459ef458cae","modified":1523093090000},{"_id":"themes/next/.git/objects/a5/0cdc255110c7550b01fbda3dcab0b52872842b","hash":"1b53c83cf2371db804f7c4dbb9fdf8327284d39c","modified":1523093090000},{"_id":"themes/next/.git/objects/af/88b2dd71f1f980b26d79964343b727a439f0cd","hash":"74e717915410df4bda460ae987471277dcf412d9","modified":1523093090000},{"_id":"themes/next/.git/objects/ab/88d1fa3713c105f302b9d1245d812ef87c3e72","hash":"006bccd7561d3e0d0237f392a681d2f79d53135a","modified":1523093090000},{"_id":"themes/next/.git/objects/b2/d7b9ca44ee27859a45810b1111998f702f02ca","hash":"a81920342c10426055ab8a4f0935025b1b746a00","modified":1523093090000},{"_id":"themes/next/.git/objects/b3/2e5feb9609db1235cc2b123d22ac374647c6f0","hash":"bcaba7b5045a3f95355fa67c5c9442bae26345fc","modified":1523093090000},{"_id":"themes/next/.git/objects/b4/c0c011120b4a30563acf555ed56150be2babe9","hash":"8f94308246c7cc4bf11ab1e1d07725e5f777a019","modified":1523093090000},{"_id":"themes/next/.git/objects/b4/c565cca72b9b62b41b6ac3a7c2d9a873ac7481","hash":"a2696c3c3b1db514a6bcf168594642859e9d0337","modified":1523093090000},{"_id":"themes/next/.git/objects/b5/5ec3b26fdde09b336465c69a1b391f83f1724e","hash":"34c85367990e11a4f287ff8e06cf6011ab194060","modified":1523093090000},{"_id":"themes/next/.git/objects/bd/6c789c43945c318b6913300f3da666d4a9445e","hash":"b5663b49e8ffb1f3cef3c41b58bc6c357c057932","modified":1523093090000},{"_id":"themes/next/.git/objects/b9/54980ab31fc655be44a655713effa111ec9816","hash":"5b90e5a93d30b2c99d54ad63fb53247fae328433","modified":1523093090000},{"_id":"themes/next/.git/objects/be/5b41cad457b97d5c200a23f875b1f873a070b4","hash":"8becd9545801fc8986d76c7a4a6cb1ad3946b5f3","modified":1523093090000},{"_id":"themes/next/.git/objects/c4/35a8a89c740d2e183de2c6093508e96051180c","hash":"f4102c4d546ffabfb623d32e4d4ac04a40606626","modified":1523093090000},{"_id":"themes/next/.git/objects/c1/81905f8c7060e6b4a8731fcb249c4f98ae1ee7","hash":"1daff5c3c530c7d427e08c1f5d07df45567fa99f","modified":1523093090000},{"_id":"themes/next/.git/objects/c6/8519f55d3c7e02683b9c08a09f1720764d4f3f","hash":"aec378c532b87a95208202a7b40ee122ff51c275","modified":1523093090000},{"_id":"themes/next/.git/objects/c6/aaa426078a8b3c2925f2c0736914cc069ab9b7","hash":"7ad9447c3f9bf2a142fff7af302da9a9f0a8b068","modified":1523093090000},{"_id":"themes/next/.git/objects/c9/9ffefb203b2090e915061c4ed1ee5e2f2d6065","hash":"b00cf347095fbe570a9edc784fe961f64ee155e2","modified":1523093090000},{"_id":"themes/next/.git/objects/cf/68db44ea4ac323a5c57a95ae09d069aedf4c3c","hash":"983bc3e33fb50dad682381e9c599243d9e42edba","modified":1523093090000},{"_id":"themes/next/.git/objects/ca/2554bcfe766a01def2cb723c52a020d94a2060","hash":"146bac7876b1f89634eff57f552248f22d99cb46","modified":1523093090000},{"_id":"themes/next/.git/objects/d2/97cf55c16c902420f4b28798ff0f1463489f95","hash":"07bf45f12394c9d444239c9a7c4eb9ff12fbe755","modified":1523093090000},{"_id":"themes/next/.git/objects/df/073f5d7c156533cab72dd08aab62722a6e1654","hash":"8acb43c75b36865336bb486300faf548bf9a1ced","modified":1523093090000},{"_id":"themes/next/.git/objects/da/f74f74fcdd050bc37b81f1a34dd907bd1e88ff","hash":"370d9ef011ace245d9de3927dc589f81b33cd8ba","modified":1523093090000},{"_id":"themes/next/.git/objects/df/1b0e24f64f70fc4c160e5bd9d6de2c4d060cdc","hash":"ff63ffaf2952103f881c7942ef5241d4447679d1","modified":1523093090000},{"_id":"themes/next/.git/objects/df/ebfa5d31f889c414ab498341f0c05f8606edae","hash":"b0804c2b6cb4acc2ffaf1b484aeda8545e448b17","modified":1523093090000},{"_id":"themes/next/.git/objects/e0/877a1ea24dae86dfe6432e24a3d7f6ec7a8477","hash":"22e1d1d8a42fe370d1ad96a7fad56acb66c52308","modified":1523093090000},{"_id":"themes/next/.git/objects/e3/e42fb963e582a148c9665bb4d1ccbc9c1792ad","hash":"ff5fb1d60b2451034100b0f25a9eceb1184d99ca","modified":1523093090000},{"_id":"themes/next/.git/objects/e7/1de35041bd895bc7aa81f8bc057f70c61370b4","hash":"0690b7f171303e5ec5f47507260a906837a75f25","modified":1523093090000},{"_id":"themes/next/.git/objects/ea/2e1d52b4bf230c477b035b5902aa23e101a92f","hash":"922320e56900361e22640cbd486ac867569991d0","modified":1523093090000},{"_id":"themes/next/.git/objects/ff/e247ac2581116a7f5eb054ae402cd99d887e19","hash":"4cb8a938e34dfa7338843c3da613566e48cde7a7","modified":1523093090000},{"_id":"themes/next/.git/refs/heads/master","hash":"5a1d2ef48a952efc8f18fc66fc493c23d7c2df2a","modified":1521816606000},{"_id":"themes/next/.git/refs/tags/v6.1.0","hash":"81c10f37e3a9a23c145030d84bf03adc71f603f1","modified":1523093090000},{"_id":"themes/next/layout/_macro/menu/menu-badge-1.swig","hash":"7ffc5c159ab566805ceda6b8c7a4149a7e296116","modified":1521816606000},{"_id":"themes/next/layout/_macro/menu/menu-badge-2.swig","hash":"7b96a0e6079e845573338523cea4437817a4b1e1","modified":1521816606000},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"6a04cd1ef9ebac103d86b61505fa9b0f26268fdc","modified":1521816606000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1521816606000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"cd7e3331a61939c820e0437bf5d815cb0a42fefb","modified":1521816606000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"9f7aa33a620aea6ede1fb907b61fd071c018c525","modified":1521816606000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1521816606000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1521816606000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1521816606000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1521816606000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1521816606000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1521816606000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1521816606000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1521816606000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521816606000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"cee047575ae324398025423696b760db64d04e6f","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1521816606000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"2fbee33a4ccd7c8217c73e85a9a1488170e05629","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1521816606000},{"_id":"themes/next/.git/objects/0b/f2e1519dfc314251cf4cd7143577f5fb85dc74","hash":"64a23eacd3b21aedaf5d33a661da50ebc2670a9d","modified":1523093090000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"ccb287855589a4a4d3f41b67e919bb030d99d888","modified":1521867172000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1521816606000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1521816606000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1521816606000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"011ae6303afacddabc4ddf570fe3dd227569cd4f","modified":1521816606000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1521816606000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1521816606000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1521816606000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1521816606000},{"_id":"themes/next/source/css/_common/.DS_Store","hash":"89f50e89c567ed2e1b1c7cc180e964286cfab354","modified":1525531203000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1521816606000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"2dd9c678bc31ba2d6dfb09325f82db4a449dd351","modified":1521858364000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1521816606000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1521816606000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1521816606000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1521816606000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"32392d213f5d05bc26b2dc452f2fc6fea9d44f6d","modified":1521816606000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"cfb03ec629f13883509eac66e561e9dba562333f","modified":1521816606000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"075cc3e87fd1c483a62e1cdda639a8059c1300c4","modified":1521895165000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1521816606000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1521816606000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1521816606000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1521816606000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1521816606000},{"_id":"themes/next/source/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1521816606000},{"_id":"themes/next/source/js/src/post-details.js","hash":"c66095150957c2ae1e59e7c1a371fd947d138cad","modified":1521857932000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1521816606000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1521816606000},{"_id":"themes/next/source/js/src/utils.js","hash":"bb67eb5b5f301a92503c81b1f8edd2a4d1fcc879","modified":1521816606000},{"_id":"themes/next/source/images/avatar.jpg","hash":"33a1d82c83c97063d41dd80f89ffb0c3a694b7ca","modified":1525075771000},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","hash":"9fa5175cdb7d3d939fe7174b6d68608ca996c174","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/README.md","hash":"bf7819cbb879bb82ec1097513d8f799df8835e0f","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1521857059000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1521816606000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1521816606000},{"_id":"source/_posts/2018-AprWeek1/title.jpg","hash":"d822c13daba810969474e29c89c7b8399c53abb0","modified":1522843305000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1521816606000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1521816606000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"8b6e6603d0d98951fa6ae21594042891af83c115","modified":1521856012000},{"_id":"source/_posts/衡水中学游记/booklet.jpg","hash":"35588d9d85c3d0bcc05a143876eb21602c99fe1f","modified":1525088492000},{"_id":"themes/next/.git/objects/pack/pack-fad1915a840541785143fe2a0d3ce08f4602a4bb.idx","hash":"8adcbad7539073ced8db42ea932513da22aa55b6","modified":1521816606000},{"_id":"source/_posts/2018-JanWeek2/title.png","hash":"e5767fb2816ec8df149ff7cb63db7aff4ee986e1","modified":1520082127000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521816606000},{"_id":"source/_posts/2018-MarWeek1/title_1024px.jpg","hash":"dbb992f3c75d5b927784d334814d06f9e9074224","modified":1520082128000},{"_id":"source/_posts/2018-MarWeek3/title.jpg","hash":"4c8a68ce795f158eaae4bab31ad80e0e08b4ef4a","modified":1521292370000},{"_id":"source/_posts/“长大”/time.jpg","hash":"78ba6c6f7b32a68aa74f4d504fbd7996e989f9b2","modified":1520082128000},{"_id":"source/_posts/「CQOI2014」排序机械臂-Splay/explanation.png","hash":"52d5a442cfb120b063b3469e047ed9b75477e404","modified":1520082128000},{"_id":"source/board/blackboard.jpg","hash":"b67f1c6f119fcc49b3afe060571b32a0d298bd3c","modified":1523096824000},{"_id":"source/images/friends/Menci.png","hash":"3253bb6765ddc58f2b25964c6083007d66e5843b","modified":1527954629000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1521816606000},{"_id":"themes/next/.git/refs/remotes/origin/master","hash":"69cc1b1d7e20036db6a37380267b91f71487b4ca","modified":1523093090000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1521816606000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"52626041c1af4c5f11ca0c9af7b7b55a798c3378","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1521816606000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1521816606000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"a863f2c8bae1fbccdc181a5d178b808cd80c5b5e","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1521816606000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1521816606000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/config","hash":"ae057b7f33eac7ddf41bed1c7a3323eb69ec0b7c","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/index","hash":"15c78d5efaa7f88eee1ba3bd0b0b571af2a35c33","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/packed-refs","hash":"52b85a0144e04fcbf9a0911b63026875ac02273a","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/config","hash":"6aef6bbfcb8ccf9d042bf26defe7d08167b6d81e","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/index","hash":"f34f02a362825de8e034b12265c4a6d02fb33e44","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/packed-refs","hash":"6effea4548320c5523c283dd1461578daaf24713","modified":1521857059000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1521816606000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1521816606000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1521816606000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1521816606000},{"_id":"source/_posts/「红楼一梦」/lindaiyu.jpg","hash":"f7622606ff7c4b5a79a7d10d7fb7c013243861b6","modified":1520082128000},{"_id":"source/_posts/衡水中学游记/screen.jpg","hash":"77c04672fa8aa71d8366b06f02bde6092a026aad","modified":1525088734000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1521816606000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1521816606000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1521816606000},{"_id":"source/_posts/2018-JanWeek3/title.jpg","hash":"b99a9886a010c5a5df71fb9e24f25c8775ebedbb","modified":1520082127000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"52626041c1af4c5f11ca0c9af7b7b55a798c3378","modified":1521816606000},{"_id":"themes/next/.git/logs/refs/remotes/origin/master","hash":"f2a011b2abbdc5aa9b3743ac8e547f523908813a","modified":1523093090000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"0b57ca04dc3998cf70bb90d777b0db05f3928b82","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"5d15cc8bbefe44c77a9b9f96bf04a6033a4b35b8","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521816606000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1521816606000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1521854755000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/HEAD","hash":"3f261185ad8475e1fc11cf8aab3a09610a690208","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1521857054000},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/HEAD","hash":"5c1f893b35216f0c143218fbdf2b3dc885989131","modified":1521857059000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1521816606000},{"_id":"source/_posts/衡水中学游记/cannon.jpg","hash":"cda83531c48d0319f7aa75852b80f18f31f52d60","modified":1525088512000},{"_id":"source/_posts/衡水中学游记/classroom.jpg","hash":"042d787762a62c831facee22106fd5e014207bd5","modified":1525088534000},{"_id":"source/_posts/衡水中学游记/clock.jpg","hash":"650655037f3d8920906ff5a33095401a1ed32c89","modified":1525088568000},{"_id":"source/_posts/衡水中学游记/play_basketball.jpg","hash":"29af64b11b86a928f59c68ae24a7cb39dd7cb1c2","modified":1525088669000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1521816606000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1521816606000},{"_id":"source/_posts/衡水中学游记/playground.jpg","hash":"474acaaaeec1bb505b1423a502a3e0600a27adda","modified":1525088685000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/08/777d50ffb9e517f20d2cbf2ea19130862fb501","hash":"110fcf7830673d2a7715f8347834f7393597ecd0","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/0d/49463cf444a6411519b6d7b5bb65fa7e96c4dc","hash":"8baa9ed7c87fbf1a9fdeb378c656471cb98c48e5","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/54/7b348ba5c8725ea590087860a352c8ff41cb98","hash":"79281e0d03b3acdbce61914bbfef33ae0c29be6d","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/59/0f6f985f6018c397b2499bb49e599b7109ec06","hash":"650b4b24a81daa3b02646b7ffd5ccdac11ab6be8","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/6d/b4c7bd4b80f34ae7165de7d91291759569d572","hash":"f04a0f8b9dde5d5c36f470634ca8f958a3b6aa15","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/92/1eb7be3c529d19b6c92ce67e4099e8f7d6adf3","hash":"023bef5405aee54ae6b00e1e02eb6984b691ccbf","modified":1521854761000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/a4/0c9f2635389a60948f0f2235f037277f8acff6","hash":"ec4074d54b477aea533dab38384dd9a52fa58854","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/c9/af6112eed1dab47eba55651562f768bfbc861d","hash":"a3ce783cca46bdcba0a1eda2d034c77221e07e06","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/da/0b2b5f2ab8f750444499f17e4cbf6074aef7f0","hash":"b343b66897d47a95d9a4363eaab8ff61a1c8a683","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/f5/e09255981809338b668b56510e360595fc12fa","hash":"c385e27cf914367d1fde121a2c920b93832cf2ed","modified":1521854759000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/heads/master","hash":"591d58b48a711af78b2cf38fbf4e5d9e23c22ab8","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/45/9262fe92f0115707bf8d8764f1886bc5e7c9e0","hash":"36040483f8af76775b7e4b6d87cec53729625399","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/2a/f622a4d7df40a2708946e91d6d7a0df1dc468c","hash":"3da7207fb18d361b83c56f4e35f67e9e945abd82","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/5a/69ce9c2e4a1a34f6063ae9a121af1555669c69","hash":"dad25cc0f450e2827b5676975f4a70636e3fd2c8","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/39233ece53c9bdb9a1faf3271ed5768b034aad","hash":"5a770d418c1bb7b0f031f4d5416530002032fcf3","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/90/f6477118d05f5f96ce0a63c6f18b7b2baea200","hash":"385f58e92981f27fa54eb52bf60424e87c70a9d8","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/98/67d1132e0e50bbb7df754a63358d70741df6d5","hash":"3cb710a1faee73c08036f5e2df7df3a7ce29e9dd","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/aa/da83ad9aa55faa2b34ede31b1d41e16966f80b","hash":"b304541ab95b7969a63ba2ec4f60f5391bd8bb44","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/d4/95d28a8fab74d23908f6ccef9e4db2625fbacb","hash":"59e6067b0a806deee7bda6460b36c0f63e2e1db5","modified":1521857059000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/heads/master","hash":"5442226ab36d787824e89f50241336839b376133","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/86/1c9f4241fe0eb6af02ad770d5ce04c1f68972b","hash":"7005c3e36015a4af30d4b91bd5a849a7861a073e","modified":1521857059000},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/75/de2b8fa62d52690de32c351c63ab6446104ed5","hash":"52d10122d633ce4895a0690c5955e1b356f5a391","modified":1521857059000},{"_id":"source/_posts/衡水中学游记/airplane.jpg","hash":"79716e6714014dae924da3ca25944e2c319f2bb5","modified":1525088452000},{"_id":"source/_posts/衡水中学游记/gate.jpg","hash":"ee020dd9f61cc540be43a83b11f3b7f3cde08c70","modified":1525088620000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/2b/d5d590d07a161741477ace2339eb37c07cc40c","hash":"10a1f52729a36d3b9d594e93473fef26fed768e1","modified":1521854761000},{"_id":"source/_posts/2018年六月·上/title1.jpg","hash":"dace0f1057549ee507799391f8c1cae0b32f4509","modified":1528556498409},{"_id":"source/_posts/衡水中学游记/rank.jpg","hash":"be2577882181ae3639e2d1a2f95fd3edde74398a","modified":1525088716000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/heads/master","hash":"3f261185ad8475e1fc11cf8aab3a09610a690208","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/heads/master","hash":"5c1f893b35216f0c143218fbdf2b3dc885989131","modified":1521857059000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1521857059000},{"_id":"source/_posts/2018-MarWeek2/title.jpg","hash":"ee0e5d25cf291c7abd7c933865fdd9723119cc94","modified":1520692926000},{"_id":"source/_posts/衡水中学游记/tank.jpg","hash":"de65444c8c2cf356e7bd35ad7a2a845d096101b9","modified":1525088750000},{"_id":"source/_posts/2018-MayWeek1/title.jpg","hash":"532b7b0e349e19a338a445a87bd0295716b1b5ed","modified":1525490976000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/remotes/origin/HEAD","hash":"3f261185ad8475e1fc11cf8aab3a09610a690208","modified":1521854761000},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/remotes/origin/HEAD","hash":"5c1f893b35216f0c143218fbdf2b3dc885989131","modified":1521857059000},{"_id":"source/_posts/衡水中学游记/lake.jpg","hash":"cc1af2a851773390c71523339d0264d9ce966b05","modified":1525088640000},{"_id":"source/_posts/衡水中学游记/final.jpg","hash":"97b59b913cd9cdb9382629757e340044188902f0","modified":1525078254000},{"_id":"source/_posts/2018-AprWeek2/title.jpg","hash":"3b53489830b35dd21207003d3567c55dea1065c6","modified":1523198072000},{"_id":"source/_posts/2018-JanWeek4/title.jpg","hash":"6c66f0074add3f9cc4d9efd3b321ae369082f053","modified":1520082127000},{"_id":"themes/next/.git/objects/pack/pack-fad1915a840541785143fe2a0d3ce08f4602a4bb.pack","hash":"d8766e5c58a75a791ed151a2b599c95be8f322c6","modified":1521816606000},{"_id":"source/_posts/2018-MayWeek2/title.jpg","hash":"cad612d255f245a2d151a9a07ba91225bf7119cd","modified":1526131026000},{"_id":"source/_posts/2018-AprWeek5/title.png","hash":"9ca779133b4edae24a0625e3b166d837bc3e22ce","modified":1524917255000},{"_id":"source/_posts/BJOI2018游记/4.jpg","hash":"2b706b0f3cbfa7d46ff9c79b2aa7e760efaa2706","modified":1523802280000},{"_id":"source/_posts/2018-FebWeek2/title.png","hash":"d6f503fbadc2a458d481a3cbcb320aa02407af90","modified":1520082127000},{"_id":"source/_posts/2018-FebWeek3/title.jpg","hash":"64bc6ea1ea01a8b7b246625013e102818bf1aab0","modified":1520082127000},{"_id":"source/_posts/2018-Marweek4/title.jpg","hash":"c03e5611bae09343e06d7f6fb0bc0055d826173c","modified":1521987718000},{"_id":"source/_posts/Splay学习笔记/splay_cqq.pdf","hash":"29473318b9c325218d67a62d554e70094d2c5a74","modified":1527950519000},{"_id":"source/_posts/BJOI2018游记/3.jpg","hash":"3cbe163acac69dd12e2b453de194e4e7c7ffd901","modified":1523802400000},{"_id":"source/_posts/2018-FebWeek1/title.jpg","hash":"ccfcf88d7e63f40e7d48e00bd4f39d4cba791632","modified":1520082127000},{"_id":"source/images/20180623-germany.jpeg","hash":"77c864049200e1704494e5541f98bc0c954937f1","modified":1529830827320},{"_id":"source/_posts/2018年六月·上/title2.jpg","hash":"8172fee2eb2c4a5b802303e8ac0e58ac1c5637d6","modified":1529066496858},{"_id":"source/_posts/2018-MayWeek3/title.jpg","hash":"4d701780d8092d7e02e3fd829ef269d0458b3850","modified":1525078193000},{"_id":"source/_posts/BJOI2018游记/1.jpg","hash":"50178f28bf1ea3a039ae7744e2f29ec65878114b","modified":1523802422000},{"_id":"source/_posts/Splay学习笔记/splay_tarjan.pdf","hash":"bb3c073053d93d6abfef9a9c76ec2c5d7f09c313","modified":1527913129000},{"_id":"source/_posts/冬令营旅游记/1.jpg","hash":"f50dc45d72e07ee22046a48201fe77b6e4916867","modified":1520082128000},{"_id":"source/_posts/冬令营旅游记/4.jpg","hash":"ab394fd4e58a0e691e4b6158bbd81ad0a89ef6e8","modified":1520082129000},{"_id":"source/_posts/冬令营旅游记/3.jpg","hash":"d9972a433aafb6c8828561f531b1d087314cef40","modified":1520082128000},{"_id":"source/_posts/冬令营旅游记/2.jpg","hash":"e27dd6a30b801a6b1df1513121a3cf7f391e79d3","modified":1520082128000},{"_id":"source/_posts/2018-MarWeek1/title.jpg","hash":"9624f54d87fee7426a6d9a02acd4b623fc4168e0","modified":1520082127000}],"Category":[{"name":"总结","_id":"cjissu3f20005bljruhvf5jts"},{"name":"OI","_id":"cjissu3hr001dbljr7l25slds"},{"name":"随笔","_id":"cjissu3i7001ybljryvvbnzrg"},{"name":"日常","_id":"cjissu3mx006nbljr46kphta8"}],"Data":[],"Page":[{"_content":"{\n    \"name\": \"Chen's Blog\",\n    \"short_name\": \"Chen's Blog\",\n    \"icons\": [\n        {\n            \"src\": \"/android-chrome-192x192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"/android-chrome-512x512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ],\n    \"theme_color\": \"#ff0000\",\n    \"background_color\": \"#ff0000\",\n    \"display\": \"standalone\"\n}\n","source":"manifest.json","raw":"{\n    \"name\": \"Chen's Blog\",\n    \"short_name\": \"Chen's Blog\",\n    \"icons\": [\n        {\n            \"src\": \"/android-chrome-192x192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"/android-chrome-512x512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ],\n    \"theme_color\": \"#ff0000\",\n    \"background_color\": \"#ff0000\",\n    \"display\": \"standalone\"\n}\n","date":"2018-06-24T12:15:45.784Z","updated":"2018-03-12T02:10:40.000Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cjissu38e0000bljrxczevf5n","content":"{\"name\":\"Chen's Blog\",\"short_name\":\"Chen's Blog\",\"icons\":[{\"src\":\"/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"theme_color\":\"#ff0000\",\"background_color\":\"#ff0000\",\"display\":\"standalone\"}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"Chen's Blog\",\"short_name\":\"Chen's Blog\",\"icons\":[{\"src\":\"/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"theme_color\":\"#ff0000\",\"background_color\":\"#ff0000\",\"display\":\"standalone\"}"},{"title":"关于我","date":"2017-12-04T13:37:41.000Z","_content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=429460239&auto=0&height=66\"></iframe>\n\n> Stay simple. Stay naïve.\n\n恭喜你！发现了一个蒟蒻的Blog。\n\n某高中开始学OI的蒟蒻。现高一。\n\n不定期更新。\n\n\\(≧▽≦)/\n\n联系方式：\n+  qiqianchen@126.com\n+  qiqianchen@gmail.com\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-12-04 21:37:41\n---\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=429460239&auto=0&height=66\"></iframe>\n\n> Stay simple. Stay naïve.\n\n恭喜你！发现了一个蒟蒻的Blog。\n\n某高中开始学OI的蒟蒻。现高一。\n\n不定期更新。\n\n\\(≧▽≦)/\n\n联系方式：\n+  qiqianchen@126.com\n+  qiqianchen@gmail.com\n\n","updated":"2018-03-24T01:37:56.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjissu3ei0001bljr230gbej1","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=429460239&auto=0&height=66\"></iframe>\n\n<blockquote>\n<p>Stay simple. Stay naïve.</p>\n</blockquote>\n<p>恭喜你！发现了一个蒟蒻的Blog。</p>\n<p>某高中开始学OI的蒟蒻。现高一。</p>\n<p>不定期更新。</p>\n<p>(≧▽≦)/</p>\n<p>联系方式：</p>\n<ul>\n<li><a href=\"mailto:qiqianchen@126.com\" target=\"_blank\" rel=\"noopener\">qiqianchen@126.com</a></li>\n<li><a href=\"mailto:qiqianchen@gmail.com\" target=\"_blank\" rel=\"noopener\">qiqianchen@gmail.com</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=429460239&auto=0&height=66\"></iframe>\n\n<blockquote>\n<p>Stay simple. Stay naïve.</p>\n</blockquote>\n<p>恭喜你！发现了一个蒟蒻的Blog。</p>\n<p>某高中开始学OI的蒟蒻。现高一。</p>\n<p>不定期更新。</p>\n<p>(≧▽≦)/</p>\n<p>联系方式：</p>\n<ul>\n<li><a href=\"mailto:qiqianchen@126.com\" target=\"_blank\" rel=\"noopener\">qiqianchen@126.com</a></li>\n<li><a href=\"mailto:qiqianchen@gmail.com\" target=\"_blank\" rel=\"noopener\">qiqianchen@gmail.com</a></li>\n</ul>\n"},{"title":"留言板","date":"2018-04-07T09:34:51.000Z","_content":"\n所有你想对我说的东西。\n\n![](blackboard.jpg)\n","source":"board/index.md","raw":"---\ntitle: 留言板\ndate: 2018-04-07 17:34:51\n---\n\n所有你想对我说的东西。\n\n![](blackboard.jpg)\n","updated":"2018-04-07T10:28:01.000Z","path":"board/index.html","comments":1,"layout":"page","_id":"cjissu3es0003bljrwoq08ebb","content":"<p>所有你想对我说的东西。</p>\n<p><img src=\"blackboard.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>所有你想对我说的东西。</p>\n<p><img src=\"blackboard.jpg\" alt=\"\"></p>\n"},{"title":"分类","type":"categories","date":"2018-03-24T01:07:31.000Z","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\ndate: 2018-03-24 09:07:31\ncomments: false\n---\n","updated":"2018-04-07T10:30:31.000Z","path":"categories/index.html","layout":"page","_id":"cjissu3f70006bljrbcvek0gq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"友情链接","date":"2018-02-14T08:06:53.000Z","_content":"\n如果有想加的神犇欢迎留言。\n\n{% raw %}\n<style>\n.md-links {\nmin-height: calc(100% - 120px - 5pc - 6em);\ntext-align: center;\nwidth: 65%;\nmin-width: 300px;\nmax-width: 500px;\nmargin: auto;\nmargin-top: 0em;\nline-height: 5px;\n}\n\n.md-links-item {\nbackground: #fff;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\nheight: 60px;\nline-height: 15px;\nmargin: 20px 0;\npadding: 1px 2px 14px 0px;\ntransition: box-shadow 0.25s;\n}\n\n.md-links a {\ncolor: #333;\ntext-decoration: none;\n}\n\n.md-links li {\nlist-style: none;\n}\n\n.md-links-item img {\nfloat: left;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 11px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\n}\n\n.md-links-item:hover {\nbox-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);\ncursor: pointer;\n}\n\n.md-links-title {\nfont-size: 20px;\nline-height: 35px;\n}\n</style>\n{% endraw %}\n\n{% raw %}\n<div class=\"md-links\" style=\"none;\">\n<a href=\"http://blog.chenqiqian.com\" title=\"Chen's Blog\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/chenqiqian.jpg\" alt=\"Chen Qiqian\" width=\"72px\">\n<span class=\"md-links-title\">Chen's Blog</span><br>\n<span>记录时光与梦想</span>\b\n</li>\n</a>\n</div>\n{% endraw %}\n\n## OIers\n\n{% raw %}\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://memset0.cn\" title=\"memset0的博客\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/memset0.jpg\" alt=\"memset0\" width=\"72px\">\n<span class=\"md-links-title\">memset0</span><br>\n<span>一个有思想的博客</span>\n</li>\n</a>\n</div>\n{% endraw %}\n\n\n## 对我的OI有很大帮助的神犇\n\n虽然他们可能并不知道。\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://xehoth.cc\" title=\"xehoth\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/xehoth.png\" alt=\"xehoth\" width=\"72px\">\n<span class=\"md-links-title\">xehoth</span><br>\n<span>明日は明日の风が吹く</span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n- - -\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://men.ci/\" title=\"Menci\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/Menci.png\" alt=\"Menci\" width=\"72px\">\n<span class=\"md-links-title\">Menci</span><br>\n<span>眉眼如初，岁月如故</span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n- - -\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://hzwer.com/\" title=\"hzwer\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/hzwer.jpg\" alt=\"hzwer\" width=\"72px\">\n<span class=\"md-links-title\">hzwer</span><br>\n<span></span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n\n\n\n\n","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2018-02-14 16:06:53\n---\n\n如果有想加的神犇欢迎留言。\n\n{% raw %}\n<style>\n.md-links {\nmin-height: calc(100% - 120px - 5pc - 6em);\ntext-align: center;\nwidth: 65%;\nmin-width: 300px;\nmax-width: 500px;\nmargin: auto;\nmargin-top: 0em;\nline-height: 5px;\n}\n\n.md-links-item {\nbackground: #fff;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\nheight: 60px;\nline-height: 15px;\nmargin: 20px 0;\npadding: 1px 2px 14px 0px;\ntransition: box-shadow 0.25s;\n}\n\n.md-links a {\ncolor: #333;\ntext-decoration: none;\n}\n\n.md-links li {\nlist-style: none;\n}\n\n.md-links-item img {\nfloat: left;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 11px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\n}\n\n.md-links-item:hover {\nbox-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);\ncursor: pointer;\n}\n\n.md-links-title {\nfont-size: 20px;\nline-height: 35px;\n}\n</style>\n{% endraw %}\n\n{% raw %}\n<div class=\"md-links\" style=\"none;\">\n<a href=\"http://blog.chenqiqian.com\" title=\"Chen's Blog\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/chenqiqian.jpg\" alt=\"Chen Qiqian\" width=\"72px\">\n<span class=\"md-links-title\">Chen's Blog</span><br>\n<span>记录时光与梦想</span>\b\n</li>\n</a>\n</div>\n{% endraw %}\n\n## OIers\n\n{% raw %}\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://memset0.cn\" title=\"memset0的博客\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/memset0.jpg\" alt=\"memset0\" width=\"72px\">\n<span class=\"md-links-title\">memset0</span><br>\n<span>一个有思想的博客</span>\n</li>\n</a>\n</div>\n{% endraw %}\n\n\n## 对我的OI有很大帮助的神犇\n\n虽然他们可能并不知道。\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://xehoth.cc\" title=\"xehoth\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/xehoth.png\" alt=\"xehoth\" width=\"72px\">\n<span class=\"md-links-title\">xehoth</span><br>\n<span>明日は明日の风が吹く</span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n- - -\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://men.ci/\" title=\"Menci\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/Menci.png\" alt=\"Menci\" width=\"72px\">\n<span class=\"md-links-title\">Menci</span><br>\n<span>眉眼如初，岁月如故</span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n- - -\n\n{% raw %}\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://hzwer.com/\" title=\"hzwer\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/hzwer.jpg\" alt=\"hzwer\" width=\"72px\">\n<span class=\"md-links-title\">hzwer</span><br>\n<span></span>\n</li>\n</a>\n</div>\n</div>\n{% endraw %}\n\n\n\n\n\n","updated":"2018-06-02T15:57:43.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"cjissu3fd0008bljr188rlqma","content":"<p>如果有想加的神犇欢迎留言。</p>\n\n<style>\n.md-links {\nmin-height: calc(100% - 120px - 5pc - 6em);\ntext-align: center;\nwidth: 65%;\nmin-width: 300px;\nmax-width: 500px;\nmargin: auto;\nmargin-top: 0em;\nline-height: 5px;\n}\n\n.md-links-item {\nbackground: #fff;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\nheight: 60px;\nline-height: 15px;\nmargin: 20px 0;\npadding: 1px 2px 14px 0px;\ntransition: box-shadow 0.25s;\n}\n\n.md-links a {\ncolor: #333;\ntext-decoration: none;\n}\n\n.md-links li {\nlist-style: none;\n}\n\n.md-links-item img {\nfloat: left;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 11px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\n}\n\n.md-links-item:hover {\nbox-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);\ncursor: pointer;\n}\n\n.md-links-title {\nfont-size: 20px;\nline-height: 35px;\n}\n</style>\n\n\n<div class=\"md-links\" style=\"none;\">\n<a href=\"http://blog.chenqiqian.com\" title=\"Chen's Blog\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/chenqiqian.jpg\" alt=\"Chen Qiqian\" width=\"72px\">\n<span class=\"md-links-title\">Chen's Blog</span><br>\n<span>记录时光与梦想</span>\b\n</li>\n</a>\n</div>\n\n<h2 id=\"OIers\"><a href=\"#OIers\" class=\"headerlink\" title=\"OIers\"></a>OIers</h2>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://memset0.cn\" title=\"memset0的博客\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/memset0.jpg\" alt=\"memset0\" width=\"72px\">\n<span class=\"md-links-title\">memset0</span><br>\n<span>一个有思想的博客</span>\n</li>\n</a>\n</div>\n\n<h2 id=\"对我的OI有很大帮助的神犇\"><a href=\"#对我的OI有很大帮助的神犇\" class=\"headerlink\" title=\"对我的OI有很大帮助的神犇\"></a>对我的OI有很大帮助的神犇</h2><p>虽然他们可能并不知道。</p>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://xehoth.cc\" title=\"xehoth\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/xehoth.png\" alt=\"xehoth\" width=\"72px\">\n<span class=\"md-links-title\">xehoth</span><br>\n<span>明日は明日の风が吹く</span>\n</li>\n</a>\n</div>\n</div>\n\n<hr>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://men.ci/\" title=\"Menci\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/Menci.png\" alt=\"Menci\" width=\"72px\">\n<span class=\"md-links-title\">Menci</span><br>\n<span>眉眼如初，岁月如故</span>\n</li>\n</a>\n</div>\n</div>\n\n<hr>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://hzwer.com/\" title=\"hzwer\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/hzwer.jpg\" alt=\"hzwer\" width=\"72px\">\n<span class=\"md-links-title\">hzwer</span><br>\n<span></span>\n</li>\n</a>\n</div>\n</div>\n\n","site":{"data":{}},"excerpt":"","more":"<p>如果有想加的神犇欢迎留言。</p>\n\n<style>\n.md-links {\nmin-height: calc(100% - 120px - 5pc - 6em);\ntext-align: center;\nwidth: 65%;\nmin-width: 300px;\nmax-width: 500px;\nmargin: auto;\nmargin-top: 0em;\nline-height: 5px;\n}\n\n.md-links-item {\nbackground: #fff;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\nheight: 60px;\nline-height: 15px;\nmargin: 20px 0;\npadding: 1px 2px 14px 0px;\ntransition: box-shadow 0.25s;\n}\n\n.md-links a {\ncolor: #333;\ntext-decoration: none;\n}\n\n.md-links li {\nlist-style: none;\n}\n\n.md-links-item img {\nfloat: left;\nbox-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 11px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);\n}\n\n.md-links-item:hover {\nbox-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);\ncursor: pointer;\n}\n\n.md-links-title {\nfont-size: 20px;\nline-height: 35px;\n}\n</style>\n\n\n<div class=\"md-links\" style=\"none;\">\n<a href=\"http://blog.chenqiqian.com\" title=\"Chen's Blog\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/chenqiqian.jpg\" alt=\"Chen Qiqian\" width=\"72px\">\n<span class=\"md-links-title\">Chen's Blog</span><br>\n<span>记录时光与梦想</span>\b\n</li>\n</a>\n</div>\n\n<h2 id=\"OIers\"><a href=\"#OIers\" class=\"headerlink\" title=\"OIers\"></a>OIers</h2>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://memset0.cn\" title=\"memset0的博客\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/memset0.jpg\" alt=\"memset0\" width=\"72px\">\n<span class=\"md-links-title\">memset0</span><br>\n<span>一个有思想的博客</span>\n</li>\n</a>\n</div>\n\n<h2 id=\"对我的OI有很大帮助的神犇\"><a href=\"#对我的OI有很大帮助的神犇\" class=\"headerlink\" title=\"对我的OI有很大帮助的神犇\"></a>对我的OI有很大帮助的神犇</h2><p>虽然他们可能并不知道。</p>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://xehoth.cc\" title=\"xehoth\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/xehoth.png\" alt=\"xehoth\" width=\"72px\">\n<span class=\"md-links-title\">xehoth</span><br>\n<span>明日は明日の风が吹く</span>\n</li>\n</a>\n</div>\n</div>\n\n<hr>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://men.ci/\" title=\"Menci\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/Menci.png\" alt=\"Menci\" width=\"72px\">\n<span class=\"md-links-title\">Menci</span><br>\n<span>眉眼如初，岁月如故</span>\n</li>\n</a>\n</div>\n</div>\n\n<hr>\n\n<div>\n<div class=\"md-links\" style=\"none;\">\n<a href=\"https://hzwer.com/\" title=\"hzwer\" target=\"_blank\">\n<li class=\"md-links-item\">\n<img src=\"/images/friends/hzwer.jpg\" alt=\"hzwer\" width=\"72px\">\n<span class=\"md-links-title\">hzwer</span><br>\n<span></span>\n</li>\n</a>\n</div>\n</div>\n\n"},{"title":"标签","type":"tags","date":"2018-03-24T01:07:29.000Z","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: \"tags\"\ndate: 2018-03-24 09:07:29\ncomments: false\n---\n","updated":"2018-04-07T10:30:11.000Z","path":"tags/index.html","layout":"page","_id":"cjissu3fh000abljr1j5e1h0i","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018 AprWeek1","urlname":"2018-AprWeek1","date":"2018-04-04T11:37:51.000Z","visible":null,"_content":"\n**2018年四月 第一周**\n\n**2018.3.26-2018.4.1**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=110 src=\"//music.163.com/outchain/player?type=2&id=28377217&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一周以及这一周的周末一大堆烂事，所以总结也就周三才勉强写成。\n\n- - -\n\n今天下雪了。四月的雪，似乎比寒冬腊月的还更加的冷酷一些。\n\n昨天也下雪了，其实倒不如说是雨夹雪。穿着单薄的校服，淋着雨，先是从体育课回班，再是从学校回家。真的很冷，很冷。\n\n今天多穿了一层外套，回家的时候还是淋着雨。虽然不是很冷，但心呐，还是不住的寒。生物、地理的爆炸是比冰粒子打在脸上更疼，比雨溅到鞋里更凉的事情。\n\n为什么要学竞赛，学竞赛值吗？以前能毫不犹豫的回答，现在决心恐怕是越来越少了吧。\n\n预计假期会发一篇AC自动机的学习笔记。\n\n也不想说那么多期望什么的。明知道不可能，说了去骗谁呢。\n\n![](title.jpg)\n\n来源：[泡雪 | うらな [pixiv]]( https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66937929)\n\n## TodoList\n\n### 这周完成\n\n+ 网络流 && 费用流的模型 && 习题 ✔ 一点？\n+ 码课件！怼分块... ✔ 讲了课\n+ 在晚自习上认真的写作业... ✔ 感冒一周...都没怎么去晚自习\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✘这周果然咕了\n+ 学习`FFT`并过掉模版`P3803` ✘ 不存在的\n\n### 下周完成\n\n+ AC自动机模版\n+ \bSplay若干题\n+ 任务清单\n","source":"_posts/2018-AprWeek1.md","raw":"---\ntitle: 2018 AprWeek1\nurlname: 2018-AprWeek1\ndate: 2018-04-04 19:37:51\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年四月 第一周**\n\n**2018.3.26-2018.4.1**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=110 src=\"//music.163.com/outchain/player?type=2&id=28377217&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一周以及这一周的周末一大堆烂事，所以总结也就周三才勉强写成。\n\n- - -\n\n今天下雪了。四月的雪，似乎比寒冬腊月的还更加的冷酷一些。\n\n昨天也下雪了，其实倒不如说是雨夹雪。穿着单薄的校服，淋着雨，先是从体育课回班，再是从学校回家。真的很冷，很冷。\n\n今天多穿了一层外套，回家的时候还是淋着雨。虽然不是很冷，但心呐，还是不住的寒。生物、地理的爆炸是比冰粒子打在脸上更疼，比雨溅到鞋里更凉的事情。\n\n为什么要学竞赛，学竞赛值吗？以前能毫不犹豫的回答，现在决心恐怕是越来越少了吧。\n\n预计假期会发一篇AC自动机的学习笔记。\n\n也不想说那么多期望什么的。明知道不可能，说了去骗谁呢。\n\n![](title.jpg)\n\n来源：[泡雪 | うらな [pixiv]]( https://www.pixiv.net/member_illust.php?mode=medium&illust_id=66937929)\n\n## TodoList\n\n### 这周完成\n\n+ 网络流 && 费用流的模型 && 习题 ✔ 一点？\n+ 码课件！怼分块... ✔ 讲了课\n+ 在晚自习上认真的写作业... ✔ 感冒一周...都没怎么去晚自习\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✘这周果然咕了\n+ 学习`FFT`并过掉模版`P3803` ✘ 不存在的\n\n### 下周完成\n\n+ AC自动机模版\n+ \bSplay若干题\n+ 任务清单\n","slug":"2018-AprWeek1","published":1,"updated":"2018-04-05T12:17:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3em0002bljrv0ylek3s","content":"<p><strong>2018年四月 第一周</strong></p>\n<p><strong>2018.3.26-2018.4.1</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"110\" src=\"//music.163.com/outchain/player?type=2&id=28377217&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一周以及这一周的周末一大堆烂事，所以总结也就周三才勉强写成。</p>\n<hr>\n<p>今天下雪了。四月的雪，似乎比寒冬腊月的还更加的冷酷一些。</p>\n<p>昨天也下雪了，其实倒不如说是雨夹雪。穿着单薄的校服，淋着雨，先是从体育课回班，再是从学校回家。真的很冷，很冷。</p>\n<p>今天多穿了一层外套，回家的时候还是淋着雨。虽然不是很冷，但心呐，还是不住的寒。生物、地理的爆炸是比冰粒子打在脸上更疼，比雨溅到鞋里更凉的事情。</p>\n<p>为什么要学竞赛，学竞赛值吗？以前能毫不犹豫的回答，现在决心恐怕是越来越少了吧。</p>\n<p>预计假期会发一篇AC自动机的学习笔记。</p>\n<p>也不想说那么多期望什么的。明知道不可能，说了去骗谁呢。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=66937929\" target=\"_blank\" rel=\"noopener\">泡雪 | うらな [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>网络流 &amp;&amp; 费用流的模型 &amp;&amp; 习题 ✔ 一点？</li>\n<li>码课件！怼分块… ✔ 讲了课</li>\n<li>在晚自习上认真的写作业… ✔ 感冒一周…都没怎么去晚自习</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✘这周果然咕了</li>\n<li>学习<code>FFT</code>并过掉模版<code>P3803</code> ✘ 不存在的</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>AC自动机模版</li>\n<li>\bSplay若干题</li>\n<li>任务清单</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年四月 第一周</strong></p>\n<p><strong>2018.3.26-2018.4.1</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"110\" src=\"//music.163.com/outchain/player?type=2&id=28377217&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一周以及这一周的周末一大堆烂事，所以总结也就周三才勉强写成。</p>\n<hr>\n<p>今天下雪了。四月的雪，似乎比寒冬腊月的还更加的冷酷一些。</p>\n<p>昨天也下雪了，其实倒不如说是雨夹雪。穿着单薄的校服，淋着雨，先是从体育课回班，再是从学校回家。真的很冷，很冷。</p>\n<p>今天多穿了一层外套，回家的时候还是淋着雨。虽然不是很冷，但心呐，还是不住的寒。生物、地理的爆炸是比冰粒子打在脸上更疼，比雨溅到鞋里更凉的事情。</p>\n<p>为什么要学竞赛，学竞赛值吗？以前能毫不犹豫的回答，现在决心恐怕是越来越少了吧。</p>\n<p>预计假期会发一篇AC自动机的学习笔记。</p>\n<p>也不想说那么多期望什么的。明知道不可能，说了去骗谁呢。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=66937929\" target=\"_blank\" rel=\"noopener\">泡雪 | うらな [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>网络流 &amp;&amp; 费用流的模型 &amp;&amp; 习题 ✔ 一点？</li>\n<li>码课件！怼分块… ✔ 讲了课</li>\n<li>在晚自习上认真的写作业… ✔ 感冒一周…都没怎么去晚自习</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✘这周果然咕了</li>\n<li>学习<code>FFT</code>并过掉模版<code>P3803</code> ✘ 不存在的</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>AC自动机模版</li>\n<li>\bSplay若干题</li>\n<li>任务清单</li>\n</ul>"},{"title":"2018 AprWeek2","urlname":"2018-AprWeek2","date":"2018-04-08T14:09:21.000Z","visible":null,"_content":"\n**2018年四月 第二周**\n\n**2018.4.2-2018.4.8**\n<!-- more -->\n\n\n按理说明天或者后天写貌似更符合一周写一篇的周期，但明明已经周日，而且这一周也挺有意义的，所以今天就来写一写吧，也作为生活正常起来的一个标志。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=512616771&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一篇总结也就是一个假期前的事情。这个假期其实还是蛮充实的。\n\n前两天主要是在家里写作业，第三天接着去BJOI集训。从开始到现在集（hua训（shui了几次，心情还是不错的。\n\n感觉每次去某个比赛或者集训啥的，都能收获不少的正反馈。想NOIP的时候连`Dijkstra`都不会写，想冬令营的时候还完全听不懂什么是费用流，而现在也能切比较简单的费用流的省选题了。虽然这次去集训还是听不太懂什么点分治、数学乱七八糟的，但我相信我还是会学到的。\n\n仔细回想的话，离冬令营都过去两个半月了。这两个半月其实也没学什么...平衡树、图论、一点字符串...仅此而已。时间不会等人，一切都是要抓紧的。\n\n今天出去春游了。玩的还算开心，和同学一起逛逛园子，赏赏花，也算一件乐事。转眼期中就要到了。时间过的真快啊。\n\n下一周会比较忙。目前的计划是两道树链剖分，三四道平衡树，三四道费用流。估计不太能全做完，能做多少是多少吧。\n\n> 一万年太久 只争朝夕\n\n![](title.jpg)\n\n来源：[Ninsou [pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56028801)\n\n## TodoList\n\n### 上周完成\n\n+ `AC`自动机模版 ✔ 完成\n+ \b`Splay`若干题 ✘ 不存在的 倒是看了不少遍自己的代码\n+ 任务清单 ✔ 稳步完成（雾\n\n### 下周完成\n\n+ 任务清单*10\n+ 复习历史 && 政治\n+ 测试`15min`敲完`Splay`\n","source":"_posts/2018-AprWeek2.md","raw":"---\ntitle: 2018 AprWeek2\nurlname: 2018-AprWeek2\ndate: 2018-04-08 22:09:21\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年四月 第二周**\n\n**2018.4.2-2018.4.8**\n<!-- more -->\n\n\n按理说明天或者后天写貌似更符合一周写一篇的周期，但明明已经周日，而且这一周也挺有意义的，所以今天就来写一写吧，也作为生活正常起来的一个标志。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=512616771&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一篇总结也就是一个假期前的事情。这个假期其实还是蛮充实的。\n\n前两天主要是在家里写作业，第三天接着去BJOI集训。从开始到现在集（hua训（shui了几次，心情还是不错的。\n\n感觉每次去某个比赛或者集训啥的，都能收获不少的正反馈。想NOIP的时候连`Dijkstra`都不会写，想冬令营的时候还完全听不懂什么是费用流，而现在也能切比较简单的费用流的省选题了。虽然这次去集训还是听不太懂什么点分治、数学乱七八糟的，但我相信我还是会学到的。\n\n仔细回想的话，离冬令营都过去两个半月了。这两个半月其实也没学什么...平衡树、图论、一点字符串...仅此而已。时间不会等人，一切都是要抓紧的。\n\n今天出去春游了。玩的还算开心，和同学一起逛逛园子，赏赏花，也算一件乐事。转眼期中就要到了。时间过的真快啊。\n\n下一周会比较忙。目前的计划是两道树链剖分，三四道平衡树，三四道费用流。估计不太能全做完，能做多少是多少吧。\n\n> 一万年太久 只争朝夕\n\n![](title.jpg)\n\n来源：[Ninsou [pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=56028801)\n\n## TodoList\n\n### 上周完成\n\n+ `AC`自动机模版 ✔ 完成\n+ \b`Splay`若干题 ✘ 不存在的 倒是看了不少遍自己的代码\n+ 任务清单 ✔ 稳步完成（雾\n\n### 下周完成\n\n+ 任务清单*10\n+ 复习历史 && 政治\n+ 测试`15min`敲完`Splay`\n","slug":"2018-AprWeek2","published":1,"updated":"2018-04-08T14:35:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3et0004bljrzvy2l2jm","content":"<p><strong>2018年四月 第二周</strong></p>\n<p><strong>2018.4.2-2018.4.8</strong><br><a id=\"more\"></a></p>\n<p>按理说明天或者后天写貌似更符合一周写一篇的周期，但明明已经周日，而且这一周也挺有意义的，所以今天就来写一写吧，也作为生活正常起来的一个标志。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=512616771&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一篇总结也就是一个假期前的事情。这个假期其实还是蛮充实的。</p>\n<p>前两天主要是在家里写作业，第三天接着去BJOI集训。从开始到现在集（hua训（shui了几次，心情还是不错的。</p>\n<p>感觉每次去某个比赛或者集训啥的，都能收获不少的正反馈。想NOIP的时候连<code>Dijkstra</code>都不会写，想冬令营的时候还完全听不懂什么是费用流，而现在也能切比较简单的费用流的省选题了。虽然这次去集训还是听不太懂什么点分治、数学乱七八糟的，但我相信我还是会学到的。</p>\n<p>仔细回想的话，离冬令营都过去两个半月了。这两个半月其实也没学什么…平衡树、图论、一点字符串…仅此而已。时间不会等人，一切都是要抓紧的。</p>\n<p>今天出去春游了。玩的还算开心，和同学一起逛逛园子，赏赏花，也算一件乐事。转眼期中就要到了。时间过的真快啊。</p>\n<p>下一周会比较忙。目前的计划是两道树链剖分，三四道平衡树，三四道费用流。估计不太能全做完，能做多少是多少吧。</p>\n<blockquote>\n<p>一万年太久 只争朝夕</p>\n</blockquote>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=56028801\" target=\"_blank\" rel=\"noopener\">Ninsou [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li><code>AC</code>自动机模版 ✔ 完成</li>\n<li>\b<code>Splay</code>若干题 ✘ 不存在的 倒是看了不少遍自己的代码</li>\n<li>任务清单 ✔ 稳步完成（雾</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>任务清单*10</li>\n<li>复习历史 &amp;&amp; 政治</li>\n<li>测试<code>15min</code>敲完<code>Splay</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年四月 第二周</strong></p>\n<p><strong>2018.4.2-2018.4.8</strong><br>","more":"</p>\n<p>按理说明天或者后天写貌似更符合一周写一篇的周期，但明明已经周日，而且这一周也挺有意义的，所以今天就来写一写吧，也作为生活正常起来的一个标志。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=512616771&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一篇总结也就是一个假期前的事情。这个假期其实还是蛮充实的。</p>\n<p>前两天主要是在家里写作业，第三天接着去BJOI集训。从开始到现在集（hua训（shui了几次，心情还是不错的。</p>\n<p>感觉每次去某个比赛或者集训啥的，都能收获不少的正反馈。想NOIP的时候连<code>Dijkstra</code>都不会写，想冬令营的时候还完全听不懂什么是费用流，而现在也能切比较简单的费用流的省选题了。虽然这次去集训还是听不太懂什么点分治、数学乱七八糟的，但我相信我还是会学到的。</p>\n<p>仔细回想的话，离冬令营都过去两个半月了。这两个半月其实也没学什么…平衡树、图论、一点字符串…仅此而已。时间不会等人，一切都是要抓紧的。</p>\n<p>今天出去春游了。玩的还算开心，和同学一起逛逛园子，赏赏花，也算一件乐事。转眼期中就要到了。时间过的真快啊。</p>\n<p>下一周会比较忙。目前的计划是两道树链剖分，三四道平衡树，三四道费用流。估计不太能全做完，能做多少是多少吧。</p>\n<blockquote>\n<p>一万年太久 只争朝夕</p>\n</blockquote>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=56028801\" target=\"_blank\" rel=\"noopener\">Ninsou [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li><code>AC</code>自动机模版 ✔ 完成</li>\n<li>\b<code>Splay</code>若干题 ✘ 不存在的 倒是看了不少遍自己的代码</li>\n<li>任务清单 ✔ 稳步完成（雾</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>任务清单*10</li>\n<li>复习历史 &amp;&amp; 政治</li>\n<li>测试<code>15min</code>敲完<code>Splay</code></li>\n</ul>"},{"title":"2018 AprWeek3&4","urlname":"2018-AprWeek3-4","date":"2018-04-21T05:28:04.000Z","visible":null,"_content":"\n**2018年四月 第三到四周**\n\n**2018.4.9-2018.4.22**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=110 src=\"//music.163.com/outchain/player?type=2&id=28830410&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一篇总结是两周之前的事情了。上周由于去省选了，差点连作业都写不完，所以只好先好歹赶完一篇游记发了，周总结有没的写了。\n\n上周其实还是做了不少事情的。每天都在晚自习刷题莫，也算是刷了不少题，还是有好多仍然不会做的题。考试里面被考了一次点分治，于是就想着要学这个东西。上一周没有什么事情，也记不太清了。\n\n这一周也很坎坷。从上周日省选回来，到这周五放学，我都没有再怎么碰过电脑，沉迷学习。唯一跟OI有关的事情就是在路上看了一周的点分治，终于把模版给写会了，然而并没有什么卵用...该不会的还是不会，于是现在还是在想着一道题，然而马上又要去滚去复习了...\n\n好像WF北大拿了金牌？祝贺北大。也不知道，我在大学的时候会不会有机会去参加这个有趣的竞赛呢...\n\n这一周比较麻木，就是不停的复习，并且淹没在卷子的苦海中。所以也没有什么感慨好发，也就随便写写，也可以节省点时间。\n\n在屋里敲着键盘的时候，屋外的雨已经连绵了整整一个上午。雨水把天地都罩上了一层灰纱，向窗外看去，只有一片白茫茫的水雾。人们只好打着伞，躲着雨和地上的水，踽踽前行。再过一会，再过一会，雨终究是会停的。太阳终究是会出来的。\n\n![](title.jpg)\n\n## TodoList\n\n### 上周完成\n\n+ 任务清单*10 ✔ 大约6-7道？\n+ 复习历史 && 政治 ✔ 还凑活吧\n+ 测试`15min`敲完`Splay` ✘ 不存在的\n\n### 这周完成\n\n+ 点分治*2\n+ 学习`LCT`\n+ 补档`AC`自动机&&点分治","source":"_posts/2018-AprWeek3-4.md","raw":"---\ntitle: 2018 AprWeek3&4\nurlname: 2018-AprWeek3-4\ndate: 2018-04-21 13:28:04\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年四月 第三到四周**\n\n**2018.4.9-2018.4.22**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=110 src=\"//music.163.com/outchain/player?type=2&id=28830410&auto=0&height=66\"></iframe>\n\n## 正文\n\n上一篇总结是两周之前的事情了。上周由于去省选了，差点连作业都写不完，所以只好先好歹赶完一篇游记发了，周总结有没的写了。\n\n上周其实还是做了不少事情的。每天都在晚自习刷题莫，也算是刷了不少题，还是有好多仍然不会做的题。考试里面被考了一次点分治，于是就想着要学这个东西。上一周没有什么事情，也记不太清了。\n\n这一周也很坎坷。从上周日省选回来，到这周五放学，我都没有再怎么碰过电脑，沉迷学习。唯一跟OI有关的事情就是在路上看了一周的点分治，终于把模版给写会了，然而并没有什么卵用...该不会的还是不会，于是现在还是在想着一道题，然而马上又要去滚去复习了...\n\n好像WF北大拿了金牌？祝贺北大。也不知道，我在大学的时候会不会有机会去参加这个有趣的竞赛呢...\n\n这一周比较麻木，就是不停的复习，并且淹没在卷子的苦海中。所以也没有什么感慨好发，也就随便写写，也可以节省点时间。\n\n在屋里敲着键盘的时候，屋外的雨已经连绵了整整一个上午。雨水把天地都罩上了一层灰纱，向窗外看去，只有一片白茫茫的水雾。人们只好打着伞，躲着雨和地上的水，踽踽前行。再过一会，再过一会，雨终究是会停的。太阳终究是会出来的。\n\n![](title.jpg)\n\n## TodoList\n\n### 上周完成\n\n+ 任务清单*10 ✔ 大约6-7道？\n+ 复习历史 && 政治 ✔ 还凑活吧\n+ 测试`15min`敲完`Splay` ✘ 不存在的\n\n### 这周完成\n\n+ 点分治*2\n+ 学习`LCT`\n+ 补档`AC`自动机&&点分治","slug":"2018-AprWeek3-4","published":1,"updated":"2018-04-21T06:01:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3fb0007bljrmd9uw6b7","content":"<p><strong>2018年四月 第三到四周</strong></p>\n<p><strong>2018.4.9-2018.4.22</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"110\" src=\"//music.163.com/outchain/player?type=2&id=28830410&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一篇总结是两周之前的事情了。上周由于去省选了，差点连作业都写不完，所以只好先好歹赶完一篇游记发了，周总结有没的写了。</p>\n<p>上周其实还是做了不少事情的。每天都在晚自习刷题莫，也算是刷了不少题，还是有好多仍然不会做的题。考试里面被考了一次点分治，于是就想着要学这个东西。上一周没有什么事情，也记不太清了。</p>\n<p>这一周也很坎坷。从上周日省选回来，到这周五放学，我都没有再怎么碰过电脑，沉迷学习。唯一跟OI有关的事情就是在路上看了一周的点分治，终于把模版给写会了，然而并没有什么卵用…该不会的还是不会，于是现在还是在想着一道题，然而马上又要去滚去复习了…</p>\n<p>好像WF北大拿了金牌？祝贺北大。也不知道，我在大学的时候会不会有机会去参加这个有趣的竞赛呢…</p>\n<p>这一周比较麻木，就是不停的复习，并且淹没在卷子的苦海中。所以也没有什么感慨好发，也就随便写写，也可以节省点时间。</p>\n<p>在屋里敲着键盘的时候，屋外的雨已经连绵了整整一个上午。雨水把天地都罩上了一层灰纱，向窗外看去，只有一片白茫茫的水雾。人们只好打着伞，躲着雨和地上的水，踽踽前行。再过一会，再过一会，雨终究是会停的。太阳终究是会出来的。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li>任务清单*10 ✔ 大约6-7道？</li>\n<li>复习历史 &amp;&amp; 政治 ✔ 还凑活吧</li>\n<li>测试<code>15min</code>敲完<code>Splay</code> ✘ 不存在的</li>\n</ul>\n<h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>点分治*2</li>\n<li>学习<code>LCT</code></li>\n<li>补档<code>AC</code>自动机&amp;&amp;点分治</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年四月 第三到四周</strong></p>\n<p><strong>2018.4.9-2018.4.22</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"110\" src=\"//music.163.com/outchain/player?type=2&id=28830410&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>上一篇总结是两周之前的事情了。上周由于去省选了，差点连作业都写不完，所以只好先好歹赶完一篇游记发了，周总结有没的写了。</p>\n<p>上周其实还是做了不少事情的。每天都在晚自习刷题莫，也算是刷了不少题，还是有好多仍然不会做的题。考试里面被考了一次点分治，于是就想着要学这个东西。上一周没有什么事情，也记不太清了。</p>\n<p>这一周也很坎坷。从上周日省选回来，到这周五放学，我都没有再怎么碰过电脑，沉迷学习。唯一跟OI有关的事情就是在路上看了一周的点分治，终于把模版给写会了，然而并没有什么卵用…该不会的还是不会，于是现在还是在想着一道题，然而马上又要去滚去复习了…</p>\n<p>好像WF北大拿了金牌？祝贺北大。也不知道，我在大学的时候会不会有机会去参加这个有趣的竞赛呢…</p>\n<p>这一周比较麻木，就是不停的复习，并且淹没在卷子的苦海中。所以也没有什么感慨好发，也就随便写写，也可以节省点时间。</p>\n<p>在屋里敲着键盘的时候，屋外的雨已经连绵了整整一个上午。雨水把天地都罩上了一层灰纱，向窗外看去，只有一片白茫茫的水雾。人们只好打着伞，躲着雨和地上的水，踽踽前行。再过一会，再过一会，雨终究是会停的。太阳终究是会出来的。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li>任务清单*10 ✔ 大约6-7道？</li>\n<li>复习历史 &amp;&amp; 政治 ✔ 还凑活吧</li>\n<li>测试<code>15min</code>敲完<code>Splay</code> ✘ 不存在的</li>\n</ul>\n<h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>点分治*2</li>\n<li>学习<code>LCT</code></li>\n<li>补档<code>AC</code>自动机&amp;&amp;点分治</li>\n</ul>"},{"title":"2018 AprWeek5","urlname":"2018-AprWeek5","date":"2018-04-28T10:47:21.000Z","visible":null,"_content":"\n**2018年四月 第五周**\n\n**2018.4.23-2018.4.29**\n\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=410161057&auto=0&height=100\"></iframe>\n\n## 正文\n\b这一周可以说是很漫长了。周一复习，周二周三考期中，周四奇葩的接着回家复习，周五接着考试，今天就把卷子讲了。\n\n先说考试。\n{% fold %}\n- - -\n这次期中考试可以说是相当扯淡了。第一天不考语文，而在理化生的考试里全天梦游，的确损失了不少的不应当的分数，也是这次考试考的不太好的一个原因。第二天还是不太在状态，而且语文和英语的新的试卷结构一时也不太适应，所以就相当的难受，主要的扣分也都从这天产生。最后一天上午的两科总体上感觉还不错，但是还是有一些莫名其妙的地方丢分。\n\n发现每次大考，出成绩简直都是一场惊惊惊惊惊惊惊惊惊惊惊喜惊的体验。出分之后自己算了算，比年级第一低了50分，心里顿时凉凉。然而竟没有料到，九科排名的容错性这么的好...不过危机还是很大的...高考的情况下语数英的分数还是非常的不友善的。前路漫浩浩。\n- - -\n{% endfold %}\n\n这一周其实也就不过于考试，考试。\n\n今天终于结束了几乎所有关于期中考试的一切，背着五一作业走路回家。北京的夏天真的到了，在漫长冬天的记忆里似乎仍是全秃的枝桠也被绿色簇拥了起来，天空更是一种充满暖意的澄澈的蓝色。街上的行人衣衫渐渐轻薄，而空气也渐渐打破了那由冬天的寒冷设下的枷锁。忽然也就想到数学考试最后两分钟解出最后一道大题的畅快，那种如释重负的感觉。\n\n时间真快啊。\n\n![](title.png)\n\n来源： * [17:30|mocha[pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68296699) *\n\n## Todolist\n### 本周刷题\n{% fold %}\n+ [NOI2009]二叉查找树 \n    - 区间dp\n+ [HEOI2016/TJOI2016]游戏  \n    - 二分图匹配\n+ [HNOI2010]合唱队 \n    - 区间dp\n+ [NOI2009]变换序列 \n    - 二分图／网络流\n+ [SCOI2010]连续攻击游戏 \n    - 二分图\n+ [Luogu P3765]总统选举 \n    - 平衡树&线段树\n+ [Luogu P2664]树上游戏\n    - 点分治\n{% endfold %}\n\n### 本周完成\n> 专心考试 本项不存在的\n\n### 下周目标\n+ 若干dp的题目\n+ 关于Splay的课件\n+ `LCT`模板题","source":"_posts/2018-AprWeek5.md","raw":"---\ntitle: 2018 AprWeek5\nurlname: 2018-AprWeek5\ndate: 2018-04-28 18:47:21\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年四月 第五周**\n\n**2018.4.23-2018.4.29**\n\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=410161057&auto=0&height=100\"></iframe>\n\n## 正文\n\b这一周可以说是很漫长了。周一复习，周二周三考期中，周四奇葩的接着回家复习，周五接着考试，今天就把卷子讲了。\n\n先说考试。\n{% fold %}\n- - -\n这次期中考试可以说是相当扯淡了。第一天不考语文，而在理化生的考试里全天梦游，的确损失了不少的不应当的分数，也是这次考试考的不太好的一个原因。第二天还是不太在状态，而且语文和英语的新的试卷结构一时也不太适应，所以就相当的难受，主要的扣分也都从这天产生。最后一天上午的两科总体上感觉还不错，但是还是有一些莫名其妙的地方丢分。\n\n发现每次大考，出成绩简直都是一场惊惊惊惊惊惊惊惊惊惊惊喜惊的体验。出分之后自己算了算，比年级第一低了50分，心里顿时凉凉。然而竟没有料到，九科排名的容错性这么的好...不过危机还是很大的...高考的情况下语数英的分数还是非常的不友善的。前路漫浩浩。\n- - -\n{% endfold %}\n\n这一周其实也就不过于考试，考试。\n\n今天终于结束了几乎所有关于期中考试的一切，背着五一作业走路回家。北京的夏天真的到了，在漫长冬天的记忆里似乎仍是全秃的枝桠也被绿色簇拥了起来，天空更是一种充满暖意的澄澈的蓝色。街上的行人衣衫渐渐轻薄，而空气也渐渐打破了那由冬天的寒冷设下的枷锁。忽然也就想到数学考试最后两分钟解出最后一道大题的畅快，那种如释重负的感觉。\n\n时间真快啊。\n\n![](title.png)\n\n来源： * [17:30|mocha[pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=68296699) *\n\n## Todolist\n### 本周刷题\n{% fold %}\n+ [NOI2009]二叉查找树 \n    - 区间dp\n+ [HEOI2016/TJOI2016]游戏  \n    - 二分图匹配\n+ [HNOI2010]合唱队 \n    - 区间dp\n+ [NOI2009]变换序列 \n    - 二分图／网络流\n+ [SCOI2010]连续攻击游戏 \n    - 二分图\n+ [Luogu P3765]总统选举 \n    - 平衡树&线段树\n+ [Luogu P2664]树上游戏\n    - 点分治\n{% endfold %}\n\n### 本周完成\n> 专心考试 本项不存在的\n\n### 下周目标\n+ 若干dp的题目\n+ 关于Splay的课件\n+ `LCT`模板题","slug":"2018-AprWeek5","published":1,"updated":"2018-04-28T13:27:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ff0009bljrk7ffur97","content":"<p><strong>2018年四月 第五周</strong></p>\n<p><strong>2018.4.23-2018.4.29</strong></p>\n<a id=\"more\"></a>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=410161057&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>\b这一周可以说是很漫长了。周一复习，周二周三考期中，周四奇葩的接着回家复习，周五接着考试，今天就把卷子讲了。</p>\n<p>先说考试。<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<hr>\n<p>这次期中考试可以说是相当扯淡了。第一天不考语文，而在理化生的考试里全天梦游，的确损失了不少的不应当的分数，也是这次考试考的不太好的一个原因。第二天还是不太在状态，而且语文和英语的新的试卷结构一时也不太适应，所以就相当的难受，主要的扣分也都从这天产生。最后一天上午的两科总体上感觉还不错，但是还是有一些莫名其妙的地方丢分。</p>\n<p>发现每次大考，出成绩简直都是一场惊惊惊惊惊惊惊惊惊惊惊喜惊的体验。出分之后自己算了算，比年级第一低了50分，心里顿时凉凉。然而竟没有料到，九科排名的容错性这么的好…不过危机还是很大的…高考的情况下语数英的分数还是非常的不友善的。前路漫浩浩。</p>\n<hr>\n\n</div></div></p>\n<p>这一周其实也就不过于考试，考试。</p>\n<p>今天终于结束了几乎所有关于期中考试的一切，背着五一作业走路回家。北京的夏天真的到了，在漫长冬天的记忆里似乎仍是全秃的枝桠也被绿色簇拥了起来，天空更是一种充满暖意的澄澈的蓝色。街上的行人衣衫渐渐轻薄，而空气也渐渐打破了那由冬天的寒冷设下的枷锁。忽然也就想到数学考试最后两分钟解出最后一道大题的畅快，那种如释重负的感觉。</p>\n<p>时间真快啊。</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<p>来源： <em> <a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=68296699\" target=\"_blank\" rel=\"noopener\">17:30|mocha[pixiv]</a> </em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[NOI2009]二叉查找树 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n<li>[HEOI2016/TJOI2016]游戏  <ul>\n<li>二分图匹配</li>\n</ul>\n</li>\n<li>[HNOI2010]合唱队 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n<li>[NOI2009]变换序列 <ul>\n<li>二分图／网络流</li>\n</ul>\n</li>\n<li>[SCOI2010]连续攻击游戏 <ul>\n<li>二分图</li>\n</ul>\n</li>\n<li>[Luogu P3765]总统选举 <ul>\n<li>平衡树&amp;线段树</li>\n</ul>\n</li>\n<li>[Luogu P2664]树上游戏<ul>\n<li>点分治</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><blockquote>\n<p>专心考试 本项不存在的</p>\n</blockquote>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>若干dp的题目</li>\n<li>关于Splay的课件</li>\n<li><code>LCT</code>模板题</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年四月 第五周</strong></p>\n<p><strong>2018.4.23-2018.4.29</strong></p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=410161057&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>\b这一周可以说是很漫长了。周一复习，周二周三考期中，周四奇葩的接着回家复习，周五接着考试，今天就把卷子讲了。</p>\n<p>先说考试。<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<hr>\n<p>这次期中考试可以说是相当扯淡了。第一天不考语文，而在理化生的考试里全天梦游，的确损失了不少的不应当的分数，也是这次考试考的不太好的一个原因。第二天还是不太在状态，而且语文和英语的新的试卷结构一时也不太适应，所以就相当的难受，主要的扣分也都从这天产生。最后一天上午的两科总体上感觉还不错，但是还是有一些莫名其妙的地方丢分。</p>\n<p>发现每次大考，出成绩简直都是一场惊惊惊惊惊惊惊惊惊惊惊喜惊的体验。出分之后自己算了算，比年级第一低了50分，心里顿时凉凉。然而竟没有料到，九科排名的容错性这么的好…不过危机还是很大的…高考的情况下语数英的分数还是非常的不友善的。前路漫浩浩。</p>\n<hr>\n\n</div></div></p>\n<p>这一周其实也就不过于考试，考试。</p>\n<p>今天终于结束了几乎所有关于期中考试的一切，背着五一作业走路回家。北京的夏天真的到了，在漫长冬天的记忆里似乎仍是全秃的枝桠也被绿色簇拥了起来，天空更是一种充满暖意的澄澈的蓝色。街上的行人衣衫渐渐轻薄，而空气也渐渐打破了那由冬天的寒冷设下的枷锁。忽然也就想到数学考试最后两分钟解出最后一道大题的畅快，那种如释重负的感觉。</p>\n<p>时间真快啊。</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<p>来源： <em> <a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=68296699\" target=\"_blank\" rel=\"noopener\">17:30|mocha[pixiv]</a> </em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[NOI2009]二叉查找树 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n<li>[HEOI2016/TJOI2016]游戏  <ul>\n<li>二分图匹配</li>\n</ul>\n</li>\n<li>[HNOI2010]合唱队 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n<li>[NOI2009]变换序列 <ul>\n<li>二分图／网络流</li>\n</ul>\n</li>\n<li>[SCOI2010]连续攻击游戏 <ul>\n<li>二分图</li>\n</ul>\n</li>\n<li>[Luogu P3765]总统选举 <ul>\n<li>平衡树&amp;线段树</li>\n</ul>\n</li>\n<li>[Luogu P2664]树上游戏<ul>\n<li>点分治</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><blockquote>\n<p>专心考试 本项不存在的</p>\n</blockquote>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>若干dp的题目</li>\n<li>关于Splay的课件</li>\n<li><code>LCT</code>模板题</li>\n</ul>"},{"title":"2018 FebWeek1","urlname":"2018-FebWeek1","date":"2018-02-05T11:05:57.000Z","visible":null,"_content":"\n**2018年二月 第一周**\n\n**2018.1.29-2018.2.4**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=432511412&auto=0&height=66\"></iframe>\n\n## 正文\n这一周好像没干什么事情。\n\n学数据结构学的不可自拔，颓出了Splay。不过这好像并不是我本来想学的东西。不过这周的后半部分主要就是在往图论的方面去转啦。刷了一些生成树和最短路的水题，莫名的就去学了最大流。然后迷迷糊糊的照着模板把代码打出来然后过了模板...过几天做几道关于最大流什么的题吧。\n\n还有一个就是莫队。坐在公交车上看到julao的莫队实现，顿时就会了莫队。然后做了几道水题...争取下周做几道稍微难些的莫队吧。\n\n寒假一半都要过去了。可怕。作业还没写到一半。更可怕了。\n\n不过天天9点起，想出去玩就出去玩的生活还是很美好的。嗯。\n\n![](title.jpg)\n\n## TodoList\n\n### 这周完成\n+ 实现AC自动机 ✘ 优先级目前不够高\n+ 学会非旋Treap或者Splay ✔Splay成功学会 非旋Treap一直懒得写...\n+ 写完至少物理、地理、一小半数学的寒假作业 ✔物理和数学颓完了...地理作业是什么...\n+ 至少写一篇题解发到这里 ✔目前有三篇啦\n+ 出去玩```\\(≧▽≦)/``` ✔成功啦\n+ 实现了一个最大流膜版... ✔（图论太难了\n\n### 下周完成\n\n+ 完成莫队算法学习笔记（普通 待修改 强制在线 树上\n+ 写...语文作业...\n+ 接着学网络流 费用流\n+ 接着做题啦\n","source":"_posts/2018-FebWeek1.md","raw":"---\ntitle: 2018 FebWeek1\nurlname: 2018-FebWeek1\ndate: 2018-02-05 19:05:57\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年二月 第一周**\n\n**2018.1.29-2018.2.4**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=432511412&auto=0&height=66\"></iframe>\n\n## 正文\n这一周好像没干什么事情。\n\n学数据结构学的不可自拔，颓出了Splay。不过这好像并不是我本来想学的东西。不过这周的后半部分主要就是在往图论的方面去转啦。刷了一些生成树和最短路的水题，莫名的就去学了最大流。然后迷迷糊糊的照着模板把代码打出来然后过了模板...过几天做几道关于最大流什么的题吧。\n\n还有一个就是莫队。坐在公交车上看到julao的莫队实现，顿时就会了莫队。然后做了几道水题...争取下周做几道稍微难些的莫队吧。\n\n寒假一半都要过去了。可怕。作业还没写到一半。更可怕了。\n\n不过天天9点起，想出去玩就出去玩的生活还是很美好的。嗯。\n\n![](title.jpg)\n\n## TodoList\n\n### 这周完成\n+ 实现AC自动机 ✘ 优先级目前不够高\n+ 学会非旋Treap或者Splay ✔Splay成功学会 非旋Treap一直懒得写...\n+ 写完至少物理、地理、一小半数学的寒假作业 ✔物理和数学颓完了...地理作业是什么...\n+ 至少写一篇题解发到这里 ✔目前有三篇啦\n+ 出去玩```\\(≧▽≦)/``` ✔成功啦\n+ 实现了一个最大流膜版... ✔（图论太难了\n\n### 下周完成\n\n+ 完成莫队算法学习笔记（普通 待修改 强制在线 树上\n+ 写...语文作业...\n+ 接着学网络流 费用流\n+ 接着做题啦\n","slug":"2018-FebWeek1","published":1,"updated":"2018-03-17T13:19:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3fi000bbljreegj9ch9","content":"<p><strong>2018年二月 第一周</strong></p>\n<p><strong>2018.1.29-2018.2.4</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=432511412&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周好像没干什么事情。</p>\n<p>学数据结构学的不可自拔，颓出了Splay。不过这好像并不是我本来想学的东西。不过这周的后半部分主要就是在往图论的方面去转啦。刷了一些生成树和最短路的水题，莫名的就去学了最大流。然后迷迷糊糊的照着模板把代码打出来然后过了模板…过几天做几道关于最大流什么的题吧。</p>\n<p>还有一个就是莫队。坐在公交车上看到julao的莫队实现，顿时就会了莫队。然后做了几道水题…争取下周做几道稍微难些的莫队吧。</p>\n<p>寒假一半都要过去了。可怕。作业还没写到一半。更可怕了。</p>\n<p>不过天天9点起，想出去玩就出去玩的生活还是很美好的。嗯。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>实现AC自动机 ✘ 优先级目前不够高</li>\n<li>学会非旋Treap或者Splay ✔Splay成功学会 非旋Treap一直懒得写…</li>\n<li>写完至少物理、地理、一小半数学的寒假作业 ✔物理和数学颓完了…地理作业是什么…</li>\n<li>至少写一篇题解发到这里 ✔目前有三篇啦</li>\n<li>出去玩<code>\\(≧▽≦)/</code> ✔成功啦</li>\n<li>实现了一个最大流膜版… ✔（图论太难了</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>完成莫队算法学习笔记（普通 待修改 强制在线 树上</li>\n<li>写…语文作业…</li>\n<li>接着学网络流 费用流</li>\n<li>接着做题啦</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年二月 第一周</strong></p>\n<p><strong>2018.1.29-2018.2.4</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=432511412&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周好像没干什么事情。</p>\n<p>学数据结构学的不可自拔，颓出了Splay。不过这好像并不是我本来想学的东西。不过这周的后半部分主要就是在往图论的方面去转啦。刷了一些生成树和最短路的水题，莫名的就去学了最大流。然后迷迷糊糊的照着模板把代码打出来然后过了模板…过几天做几道关于最大流什么的题吧。</p>\n<p>还有一个就是莫队。坐在公交车上看到julao的莫队实现，顿时就会了莫队。然后做了几道水题…争取下周做几道稍微难些的莫队吧。</p>\n<p>寒假一半都要过去了。可怕。作业还没写到一半。更可怕了。</p>\n<p>不过天天9点起，想出去玩就出去玩的生活还是很美好的。嗯。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>实现AC自动机 ✘ 优先级目前不够高</li>\n<li>学会非旋Treap或者Splay ✔Splay成功学会 非旋Treap一直懒得写…</li>\n<li>写完至少物理、地理、一小半数学的寒假作业 ✔物理和数学颓完了…地理作业是什么…</li>\n<li>至少写一篇题解发到这里 ✔目前有三篇啦</li>\n<li>出去玩<code>\\(≧▽≦)/</code> ✔成功啦</li>\n<li>实现了一个最大流膜版… ✔（图论太难了</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>完成莫队算法学习笔记（普通 待修改 强制在线 树上</li>\n<li>写…语文作业…</li>\n<li>接着学网络流 费用流</li>\n<li>接着做题啦</li>\n</ul>"},{"title":"2018 FebWeek2","urlname":"2018-FebWeek2","date":"2018-02-11T08:28:27.000Z","visible":null,"_content":"\n**2018年二月 第二周**\n\n**2018.2.5-2018.2.11**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=36117196&auto=0&height=66\"></iframe>\n\n## 正文\n\n这一周没干什么事...这么一想忽然就颓废了...\n\n写了几道并查集，写了几道二分图，写了几道图和树的题。仿佛就是毫无目的的一般。不过还是把看了很久的几道并查集的题给A了。还是蛮激动的。\n\n抱了洛谷的网课，于是体会到了一上午学平衡树、主席树、树套树的酸爽。好多的东西还没来得及实现，只好等一等了。不过倒是深刻意识到了自己的蒟蒻。啧啧。\n\n春节就快要到了。良宵佳节，不如好好补补作业。\n\n![](title.png)\n\n## TodoList\n\n### 这周完成\n\n+ 完成莫队算法学习笔记 ✔ 写了一篇\n+ 写...语文作业... ✔写了一点\n+ 接着学网络流 费用流 ✘并没有写费用流\n+ 接着做题啦 ✔做了几道水题...\n\n### 下周完成\n\n+ 写完语文寒假作业！！！\n{% spoiler 我觉得上面的事情够充满整整一周了嗯。 %}\n","source":"_posts/2018-FebWeek2.md","raw":"---\ntitle: 2018 FebWeek2\nurlname: 2018-FebWeek2\ndate: 2018-02-11 16:28:27\ntags: \ncategories: 总结\nvisible:\n---\n\n**2018年二月 第二周**\n\n**2018.2.5-2018.2.11**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=36117196&auto=0&height=66\"></iframe>\n\n## 正文\n\n这一周没干什么事...这么一想忽然就颓废了...\n\n写了几道并查集，写了几道二分图，写了几道图和树的题。仿佛就是毫无目的的一般。不过还是把看了很久的几道并查集的题给A了。还是蛮激动的。\n\n抱了洛谷的网课，于是体会到了一上午学平衡树、主席树、树套树的酸爽。好多的东西还没来得及实现，只好等一等了。不过倒是深刻意识到了自己的蒟蒻。啧啧。\n\n春节就快要到了。良宵佳节，不如好好补补作业。\n\n![](title.png)\n\n## TodoList\n\n### 这周完成\n\n+ 完成莫队算法学习笔记 ✔ 写了一篇\n+ 写...语文作业... ✔写了一点\n+ 接着学网络流 费用流 ✘并没有写费用流\n+ 接着做题啦 ✔做了几道水题...\n\n### 下周完成\n\n+ 写完语文寒假作业！！！\n{% spoiler 我觉得上面的事情够充满整整一周了嗯。 %}\n","slug":"2018-FebWeek2","published":1,"updated":"2018-03-17T13:19:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3fp000dbljr8a0a6g8h","content":"<p><strong>2018&#x5E74;&#x4E8C;&#x6708; &#x7B2C;&#x4E8C;&#x5468;</strong></p>\n<p><strong>2018.2.5-2018.2.11</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&amp;id=36117196&amp;auto=0&amp;height=66\"></iframe>\n\n<h2 id=\"&#x6B63;&#x6587;\"><a href=\"#&#x6B63;&#x6587;\" class=\"headerlink\" title=\"&#x6B63;&#x6587;\"></a>&#x6B63;&#x6587;</h2><p>&#x8FD9;&#x4E00;&#x5468;&#x6CA1;&#x5E72;&#x4EC0;&#x4E48;&#x4E8B;&#x2026;&#x8FD9;&#x4E48;&#x4E00;&#x60F3;&#x5FFD;&#x7136;&#x5C31;&#x9893;&#x5E9F;&#x4E86;&#x2026;</p>\n<p>&#x5199;&#x4E86;&#x51E0;&#x9053;&#x5E76;&#x67E5;&#x96C6;&#xFF0C;&#x5199;&#x4E86;&#x51E0;&#x9053;&#x4E8C;&#x5206;&#x56FE;&#xFF0C;&#x5199;&#x4E86;&#x51E0;&#x9053;&#x56FE;&#x548C;&#x6811;&#x7684;&#x9898;&#x3002;&#x4EFF;&#x4F5B;&#x5C31;&#x662F;&#x6BEB;&#x65E0;&#x76EE;&#x7684;&#x7684;&#x4E00;&#x822C;&#x3002;&#x4E0D;&#x8FC7;&#x8FD8;&#x662F;&#x628A;&#x770B;&#x4E86;&#x5F88;&#x4E45;&#x7684;&#x51E0;&#x9053;&#x5E76;&#x67E5;&#x96C6;&#x7684;&#x9898;&#x7ED9;A&#x4E86;&#x3002;&#x8FD8;&#x662F;&#x86EE;&#x6FC0;&#x52A8;&#x7684;&#x3002;</p>\n<p>&#x62B1;&#x4E86;&#x6D1B;&#x8C37;&#x7684;&#x7F51;&#x8BFE;&#xFF0C;&#x4E8E;&#x662F;&#x4F53;&#x4F1A;&#x5230;&#x4E86;&#x4E00;&#x4E0A;&#x5348;&#x5B66;&#x5E73;&#x8861;&#x6811;&#x3001;&#x4E3B;&#x5E2D;&#x6811;&#x3001;&#x6811;&#x5957;&#x6811;&#x7684;&#x9178;&#x723D;&#x3002;&#x597D;&#x591A;&#x7684;&#x4E1C;&#x897F;&#x8FD8;&#x6CA1;&#x6765;&#x5F97;&#x53CA;&#x5B9E;&#x73B0;&#xFF0C;&#x53EA;&#x597D;&#x7B49;&#x4E00;&#x7B49;&#x4E86;&#x3002;&#x4E0D;&#x8FC7;&#x5012;&#x662F;&#x6DF1;&#x523B;&#x610F;&#x8BC6;&#x5230;&#x4E86;&#x81EA;&#x5DF1;&#x7684;&#x849F;&#x84BB;&#x3002;&#x5567;&#x5567;&#x3002;</p>\n<p>&#x6625;&#x8282;&#x5C31;&#x5FEB;&#x8981;&#x5230;&#x4E86;&#x3002;&#x826F;&#x5BB5;&#x4F73;&#x8282;&#xFF0C;&#x4E0D;&#x5982;&#x597D;&#x597D;&#x8865;&#x8865;&#x4F5C;&#x4E1A;&#x3002;</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"&#x8FD9;&#x5468;&#x5B8C;&#x6210;\"><a href=\"#&#x8FD9;&#x5468;&#x5B8C;&#x6210;\" class=\"headerlink\" title=\"&#x8FD9;&#x5468;&#x5B8C;&#x6210;\"></a>&#x8FD9;&#x5468;&#x5B8C;&#x6210;</h3><ul>\n<li>&#x5B8C;&#x6210;&#x83AB;&#x961F;&#x7B97;&#x6CD5;&#x5B66;&#x4E60;&#x7B14;&#x8BB0; &#x2714; &#x5199;&#x4E86;&#x4E00;&#x7BC7;</li>\n<li>&#x5199;&#x2026;&#x8BED;&#x6587;&#x4F5C;&#x4E1A;&#x2026; &#x2714;&#x5199;&#x4E86;&#x4E00;&#x70B9;</li>\n<li>&#x63A5;&#x7740;&#x5B66;&#x7F51;&#x7EDC;&#x6D41; &#x8D39;&#x7528;&#x6D41; &#x2718;&#x5E76;&#x6CA1;&#x6709;&#x5199;&#x8D39;&#x7528;&#x6D41;</li>\n<li>&#x63A5;&#x7740;&#x505A;&#x9898;&#x5566; &#x2714;&#x505A;&#x4E86;&#x51E0;&#x9053;&#x6C34;&#x9898;&#x2026;</li>\n</ul>\n<h3 id=\"&#x4E0B;&#x5468;&#x5B8C;&#x6210;\"><a href=\"#&#x4E0B;&#x5468;&#x5B8C;&#x6210;\" class=\"headerlink\" title=\"&#x4E0B;&#x5468;&#x5B8C;&#x6210;\"></a>&#x4E0B;&#x5468;&#x5B8C;&#x6210;</h3><ul>\n<li>&#x5199;&#x5B8C;&#x8BED;&#x6587;&#x5BD2;&#x5047;&#x4F5C;&#x4E1A;&#xFF01;&#xFF01;&#xFF01;<span class=\"spoiler\">&#x6211;&#x89C9;&#x5F97;&#x4E0A;&#x9762;&#x7684;&#x4E8B;&#x60C5;&#x591F;&#x5145;&#x6EE1;&#x6574;&#x6574;&#x4E00;&#x5468;&#x4E86;&#x55EF;&#x3002;\n</span>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018&#x5E74;&#x4E8C;&#x6708; &#x7B2C;&#x4E8C;&#x5468;</strong></p>\n<p><strong>2018.2.5-2018.2.11</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&amp;id=36117196&amp;auto=0&amp;height=66\"></iframe>\n\n<h2 id=\"&#x6B63;&#x6587;\"><a href=\"#&#x6B63;&#x6587;\" class=\"headerlink\" title=\"&#x6B63;&#x6587;\"></a>&#x6B63;&#x6587;</h2><p>&#x8FD9;&#x4E00;&#x5468;&#x6CA1;&#x5E72;&#x4EC0;&#x4E48;&#x4E8B;&#x2026;&#x8FD9;&#x4E48;&#x4E00;&#x60F3;&#x5FFD;&#x7136;&#x5C31;&#x9893;&#x5E9F;&#x4E86;&#x2026;</p>\n<p>&#x5199;&#x4E86;&#x51E0;&#x9053;&#x5E76;&#x67E5;&#x96C6;&#xFF0C;&#x5199;&#x4E86;&#x51E0;&#x9053;&#x4E8C;&#x5206;&#x56FE;&#xFF0C;&#x5199;&#x4E86;&#x51E0;&#x9053;&#x56FE;&#x548C;&#x6811;&#x7684;&#x9898;&#x3002;&#x4EFF;&#x4F5B;&#x5C31;&#x662F;&#x6BEB;&#x65E0;&#x76EE;&#x7684;&#x7684;&#x4E00;&#x822C;&#x3002;&#x4E0D;&#x8FC7;&#x8FD8;&#x662F;&#x628A;&#x770B;&#x4E86;&#x5F88;&#x4E45;&#x7684;&#x51E0;&#x9053;&#x5E76;&#x67E5;&#x96C6;&#x7684;&#x9898;&#x7ED9;A&#x4E86;&#x3002;&#x8FD8;&#x662F;&#x86EE;&#x6FC0;&#x52A8;&#x7684;&#x3002;</p>\n<p>&#x62B1;&#x4E86;&#x6D1B;&#x8C37;&#x7684;&#x7F51;&#x8BFE;&#xFF0C;&#x4E8E;&#x662F;&#x4F53;&#x4F1A;&#x5230;&#x4E86;&#x4E00;&#x4E0A;&#x5348;&#x5B66;&#x5E73;&#x8861;&#x6811;&#x3001;&#x4E3B;&#x5E2D;&#x6811;&#x3001;&#x6811;&#x5957;&#x6811;&#x7684;&#x9178;&#x723D;&#x3002;&#x597D;&#x591A;&#x7684;&#x4E1C;&#x897F;&#x8FD8;&#x6CA1;&#x6765;&#x5F97;&#x53CA;&#x5B9E;&#x73B0;&#xFF0C;&#x53EA;&#x597D;&#x7B49;&#x4E00;&#x7B49;&#x4E86;&#x3002;&#x4E0D;&#x8FC7;&#x5012;&#x662F;&#x6DF1;&#x523B;&#x610F;&#x8BC6;&#x5230;&#x4E86;&#x81EA;&#x5DF1;&#x7684;&#x849F;&#x84BB;&#x3002;&#x5567;&#x5567;&#x3002;</p>\n<p>&#x6625;&#x8282;&#x5C31;&#x5FEB;&#x8981;&#x5230;&#x4E86;&#x3002;&#x826F;&#x5BB5;&#x4F73;&#x8282;&#xFF0C;&#x4E0D;&#x5982;&#x597D;&#x597D;&#x8865;&#x8865;&#x4F5C;&#x4E1A;&#x3002;</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"&#x8FD9;&#x5468;&#x5B8C;&#x6210;\"><a href=\"#&#x8FD9;&#x5468;&#x5B8C;&#x6210;\" class=\"headerlink\" title=\"&#x8FD9;&#x5468;&#x5B8C;&#x6210;\"></a>&#x8FD9;&#x5468;&#x5B8C;&#x6210;</h3><ul>\n<li>&#x5B8C;&#x6210;&#x83AB;&#x961F;&#x7B97;&#x6CD5;&#x5B66;&#x4E60;&#x7B14;&#x8BB0; &#x2714; &#x5199;&#x4E86;&#x4E00;&#x7BC7;</li>\n<li>&#x5199;&#x2026;&#x8BED;&#x6587;&#x4F5C;&#x4E1A;&#x2026; &#x2714;&#x5199;&#x4E86;&#x4E00;&#x70B9;</li>\n<li>&#x63A5;&#x7740;&#x5B66;&#x7F51;&#x7EDC;&#x6D41; &#x8D39;&#x7528;&#x6D41; &#x2718;&#x5E76;&#x6CA1;&#x6709;&#x5199;&#x8D39;&#x7528;&#x6D41;</li>\n<li>&#x63A5;&#x7740;&#x505A;&#x9898;&#x5566; &#x2714;&#x505A;&#x4E86;&#x51E0;&#x9053;&#x6C34;&#x9898;&#x2026;</li>\n</ul>\n<h3 id=\"&#x4E0B;&#x5468;&#x5B8C;&#x6210;\"><a href=\"#&#x4E0B;&#x5468;&#x5B8C;&#x6210;\" class=\"headerlink\" title=\"&#x4E0B;&#x5468;&#x5B8C;&#x6210;\"></a>&#x4E0B;&#x5468;&#x5B8C;&#x6210;</h3><ul>\n<li>&#x5199;&#x5B8C;&#x8BED;&#x6587;&#x5BD2;&#x5047;&#x4F5C;&#x4E1A;&#xFF01;&#xFF01;&#xFF01;<span class=\"spoiler\">&#x6211;&#x89C9;&#x5F97;&#x4E0A;&#x9762;&#x7684;&#x4E8B;&#x60C5;&#x591F;&#x5145;&#x6EE1;&#x6574;&#x6574;&#x4E00;&#x5468;&#x4E86;&#x55EF;&#x3002;\n</span>\n</li>\n</ul>"},{"title":"2018 FebWeek3","urlname":"2018-FebWeek3","date":"2018-02-18T09:45:58.000Z","visible":null,"_content":"\n**2018年二月 第三周**\n\n**2018.2.12-2018.2.18**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=26672926&auto=0&height=66\"></iframe>\n\n## 正文\n\n又是一个颓废的一周。啧啧。\n\n这一周更是颓废着写作业，学了不知道有没有一点东西。写了一个$Treap$从早上调到晚上，然后才苟下来这么一道题。\n\n实在是被作业所困很深。不过这一周开发了几个新技能。`CF`，`LOJ`，`P`站之类（咦这什么鬼。这也算是苦中偷趣。一切还是很有趣很有趣的。\n\n回顾寒假，学了不少东西，但是更多的还是在各种奇怪的地方（比如玩手机的什么）浪费了不少的时间。以后也应该好好的珍惜时间，多写作业，多写程序，多学算法嘛。开始寒假的时候，还立下了洛谷AC300的`Flag`...然后...GG...这个寒假最多也就到60题了...而且省选级别的题也没做几道。\n\n想到一句话：\n\n> *身后有余忘缩手 眼前无路想回头*\n\n愿自己能够\b\b安然过到高三吧。\n\n最近真的很忙。很抱歉。\n\n![](title.jpg)\n\n*来源：[Pixiv](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59959101)*\n\n## TodoList\n\n### 这周完成\n\n+ 学了差分约束和强连通分量 ✔ 图论真可怕\n+ 写了一道无旋转Treap  ✔ 太难啦\n+ 写完语文寒假作业 ✘ 失败...失败了...\n\n### 下周完成\n\n+ 苟完...作业...\n+ 活到开学...\n+ 学...费用流...\n","source":"_posts/2018-FebWeek3.md","raw":"---\ntitle: 2018 FebWeek3\nurlname: 2018-FebWeek3\ndate: 2018-02-18 17:45:58\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年二月 第三周**\n\n**2018.2.12-2018.2.18**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=26672926&auto=0&height=66\"></iframe>\n\n## 正文\n\n又是一个颓废的一周。啧啧。\n\n这一周更是颓废着写作业，学了不知道有没有一点东西。写了一个$Treap$从早上调到晚上，然后才苟下来这么一道题。\n\n实在是被作业所困很深。不过这一周开发了几个新技能。`CF`，`LOJ`，`P`站之类（咦这什么鬼。这也算是苦中偷趣。一切还是很有趣很有趣的。\n\n回顾寒假，学了不少东西，但是更多的还是在各种奇怪的地方（比如玩手机的什么）浪费了不少的时间。以后也应该好好的珍惜时间，多写作业，多写程序，多学算法嘛。开始寒假的时候，还立下了洛谷AC300的`Flag`...然后...GG...这个寒假最多也就到60题了...而且省选级别的题也没做几道。\n\n想到一句话：\n\n> *身后有余忘缩手 眼前无路想回头*\n\n愿自己能够\b\b安然过到高三吧。\n\n最近真的很忙。很抱歉。\n\n![](title.jpg)\n\n*来源：[Pixiv](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=59959101)*\n\n## TodoList\n\n### 这周完成\n\n+ 学了差分约束和强连通分量 ✔ 图论真可怕\n+ 写了一道无旋转Treap  ✔ 太难啦\n+ 写完语文寒假作业 ✘ 失败...失败了...\n\n### 下周完成\n\n+ 苟完...作业...\n+ 活到开学...\n+ 学...费用流...\n","slug":"2018-FebWeek3","published":1,"updated":"2018-03-17T13:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3fs000ebljro8332wjr","content":"<p><strong>2018年二月 第三周</strong></p>\n<p><strong>2018.2.12-2018.2.18</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=26672926&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>又是一个颓废的一周。啧啧。</p>\n<p>这一周更是颓废着写作业，学了不知道有没有一点东西。写了一个$Treap$从早上调到晚上，然后才苟下来这么一道题。</p>\n<p>实在是被作业所困很深。不过这一周开发了几个新技能。<code>CF</code>，<code>LOJ</code>，<code>P</code>站之类（咦这什么鬼。这也算是苦中偷趣。一切还是很有趣很有趣的。</p>\n<p>回顾寒假，学了不少东西，但是更多的还是在各种奇怪的地方（比如玩手机的什么）浪费了不少的时间。以后也应该好好的珍惜时间，多写作业，多写程序，多学算法嘛。开始寒假的时候，还立下了洛谷AC300的<code>Flag</code>…然后…GG…这个寒假最多也就到60题了…而且省选级别的题也没做几道。</p>\n<p>想到一句话：</p>\n<blockquote>\n<p><em>身后有余忘缩手 眼前无路想回头</em></p>\n</blockquote>\n<p>愿自己能够\b\b安然过到高三吧。</p>\n<p>最近真的很忙。很抱歉。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=59959101\" target=\"_blank\" rel=\"noopener\">Pixiv</a></em></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>学了差分约束和强连通分量 ✔ 图论真可怕</li>\n<li>写了一道无旋转Treap  ✔ 太难啦</li>\n<li>写完语文寒假作业 ✘ 失败…失败了…</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>苟完…作业…</li>\n<li>活到开学…</li>\n<li>学…费用流…</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年二月 第三周</strong></p>\n<p><strong>2018.2.12-2018.2.18</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=26672926&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>又是一个颓废的一周。啧啧。</p>\n<p>这一周更是颓废着写作业，学了不知道有没有一点东西。写了一个$Treap$从早上调到晚上，然后才苟下来这么一道题。</p>\n<p>实在是被作业所困很深。不过这一周开发了几个新技能。<code>CF</code>，<code>LOJ</code>，<code>P</code>站之类（咦这什么鬼。这也算是苦中偷趣。一切还是很有趣很有趣的。</p>\n<p>回顾寒假，学了不少东西，但是更多的还是在各种奇怪的地方（比如玩手机的什么）浪费了不少的时间。以后也应该好好的珍惜时间，多写作业，多写程序，多学算法嘛。开始寒假的时候，还立下了洛谷AC300的<code>Flag</code>…然后…GG…这个寒假最多也就到60题了…而且省选级别的题也没做几道。</p>\n<p>想到一句话：</p>\n<blockquote>\n<p><em>身后有余忘缩手 眼前无路想回头</em></p>\n</blockquote>\n<p>愿自己能够\b\b安然过到高三吧。</p>\n<p>最近真的很忙。很抱歉。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=59959101\" target=\"_blank\" rel=\"noopener\">Pixiv</a></em></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>学了差分约束和强连通分量 ✔ 图论真可怕</li>\n<li>写了一道无旋转Treap  ✔ 太难啦</li>\n<li>写完语文寒假作业 ✘ 失败…失败了…</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>苟完…作业…</li>\n<li>活到开学…</li>\n<li>学…费用流…</li>\n</ul>"},{"title":"2018 FebWeek4","urlname":"2018-FebWeek4","date":"2018-02-25T09:59:18.000Z","visible":null,"_content":"\n**2018年二月 第四周**\n\n**2018.2.19-2018.2.25**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=446940024&auto=0&height=66\"></iframe>\n\n## 正文\n\n开学了。\n\n该总结一下寒假了。\n\n寒假刷题：\n{% fold %}\n为了篇幅短小，只把不是水题的题放在这里。\n\nLuogu刷题：\n状压dp：\n+ `P1879` [USACO06NOV]玉米田Corn Fields \n+ `P1896` [SCOI2005]互不侵犯King \n+ `P1433` 吃奶酪 \n+ `P2704` [NOI2001]炮兵阵地 \n\ndp：\n+ `P2577` [ZJOI2005]午餐 \n\n线段树：\n+ `P2894` [USACO08FEB]酒店Hotel \n+ `P1438` 无聊的数列 \n+ `P1558` 色板游戏 \n+ `T21778` 过年\n\n平衡树：\n+ `P2073` 送花 \n+ `P2596` [ZJOI2006]书架 \n+ `P1486` [NOI2004]郁闷的出纳员 \n+ `P2234` [HNOI2002]营业额统计 \n+ `P2286` [HNOI2004]宠物收养场 \n+ `P3165` [CQOI2014]排序机械臂\n+ `P2042` [NOI2005]维护数列  \n\n并查集：\n+ `P1396` 营救\n+ `P1536` 村村通\n+ `P1525` 关押罪犯 \n+ `P2024` 食物链 \n+ `P1197` [JSOI2008]星球大战 \n+ `P1196` [NOI2002]银河英雄传说 \n\n最短路：\n+ `P1342` 请柬\n+ `P1629` 邮递员送信 \n+ `P1608` 路径统计\n\n生成树：\n+ `P1195` 口袋的天空\n+ `P2820` 局域网 \n+ `P1194` 买礼物 \n\n差分约束：\n+ `P1993` 小 K 的农场\n\n强连通分量：\n+ `P1726` 上白泽慧音 \n\n网络流：\n+ `P2055` [ZJOI2009]假期的宿舍 \n+ `P1231` 教辅的组成 \n+ `P2756` 飞行员配对方案问题 \n+ `P1345` [USACO5.4]奶牛的电信Telecowmunication \n\n其他图论：\n+ `P1268` 树的重量 \n+ `P1113` 杂务 \n+ `P3183` [HAOI2016]食物链\n\n单调队列：\n+ `P2032` 扫描\n\n莫队：\n+ `P2709` 小B的询问 \n+ `P1972` [SDOI2009]HH的项链 \n+ `P1494` [国家集训队]小Z的袜子 \n\n二分：\n+ `P1314` 聪明的质监员 \n\n数论：\n+ `P1082` 同余方程 \n\n模板：\n+ `P3379` 【模板】最近公共祖先（LCA） \n+ `P3375` 【模板】KM`P字符串匹配 \n+ `P3369` 【模板】普通平衡树（Treap/SBT） \n+ `P3865` 【模板】ST表 \n+ `P3382` 【模板】三分法 \n+ `P3370` 【模板】字符串哈希 \n+ `P3391` 【模板】文艺平衡树（Splay） \n+ `P3376` 【模板】网络最大流 \n+ `P3386` 【模板】二分图匹配 \n+ `P3385` 【模板】负环 \n\n一些水题：\n+ `P1083` 借教室 \n+ `P1168` 中位数 \n+ `P4231` 三步必杀\n+ `P1116` 车厢重组\n \n\nCodeforce：\n+ `#462`\n+ `#463`\n+ `#464`\n\n（写完感觉好少啊）\n{% endfold %}\n\n活过报到了，耶！不过开学第一周也不是好熬过去的呢。\n\n话说第一次考试考了`rank1`，然而出题人没做这套题，所以权当`rank2`吧。革命尚未成功，要直视和巨佬在图论、dp上的差距和距离，这个学期主要就要发展图论，dp，数学等方面的知识。\n\n\b\b寒假后期感觉有点心有余而力不足，反而显得\b平时上学的时候学习效率更高。真是奇怪呢。不过这也在一方面上反映了\b\b寒假作业的毒瘤。毒瘤！\n\n不过课内的学习也不能放下，只好再压榨一点时间了。学习好也就这点不好，两边都难割舍，害怕毁掉课内，也害怕一年竞赛一场空。\n\n> 「没有成绩时 学习不停止」\n\n\b新学期，自勉，共勉。\n\n![其实我想换张图片来着](title.jpg)\n\n## TodoList\n\n### 下周完成\n\n+ 学费用流\n+ 活过这周\n+ 好好学课内啊\n\n### 这学期完成（大略）\n\n+ 图论\n    - 树链剖分及相关\n    - 网络流相关\n    - 费用流\n    - 差分约束\n    - 缩点相关\n    - ...\n+ 数据结构\n    - 高级数据结构（veb啥的）\n    - ...\n+ 字符串相关\n+ 数学\n    - 扩欧\n    - 逆元\n    - FFT等多项式\n    - ...\n+ 奇奇怪怪的算法\n    - 博弈\n+ 研究春令营的课\n\n（一时想不到了 还有啥啊）\n\n说多不多，说少不少。\n","source":"_posts/2018-FebWeek4.md","raw":"---\ntitle: 2018 FebWeek4\nurlname: 2018-FebWeek4\ndate: 2018-02-25 17:59:18\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年二月 第四周**\n\n**2018.2.19-2018.2.25**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=446940024&auto=0&height=66\"></iframe>\n\n## 正文\n\n开学了。\n\n该总结一下寒假了。\n\n寒假刷题：\n{% fold %}\n为了篇幅短小，只把不是水题的题放在这里。\n\nLuogu刷题：\n状压dp：\n+ `P1879` [USACO06NOV]玉米田Corn Fields \n+ `P1896` [SCOI2005]互不侵犯King \n+ `P1433` 吃奶酪 \n+ `P2704` [NOI2001]炮兵阵地 \n\ndp：\n+ `P2577` [ZJOI2005]午餐 \n\n线段树：\n+ `P2894` [USACO08FEB]酒店Hotel \n+ `P1438` 无聊的数列 \n+ `P1558` 色板游戏 \n+ `T21778` 过年\n\n平衡树：\n+ `P2073` 送花 \n+ `P2596` [ZJOI2006]书架 \n+ `P1486` [NOI2004]郁闷的出纳员 \n+ `P2234` [HNOI2002]营业额统计 \n+ `P2286` [HNOI2004]宠物收养场 \n+ `P3165` [CQOI2014]排序机械臂\n+ `P2042` [NOI2005]维护数列  \n\n并查集：\n+ `P1396` 营救\n+ `P1536` 村村通\n+ `P1525` 关押罪犯 \n+ `P2024` 食物链 \n+ `P1197` [JSOI2008]星球大战 \n+ `P1196` [NOI2002]银河英雄传说 \n\n最短路：\n+ `P1342` 请柬\n+ `P1629` 邮递员送信 \n+ `P1608` 路径统计\n\n生成树：\n+ `P1195` 口袋的天空\n+ `P2820` 局域网 \n+ `P1194` 买礼物 \n\n差分约束：\n+ `P1993` 小 K 的农场\n\n强连通分量：\n+ `P1726` 上白泽慧音 \n\n网络流：\n+ `P2055` [ZJOI2009]假期的宿舍 \n+ `P1231` 教辅的组成 \n+ `P2756` 飞行员配对方案问题 \n+ `P1345` [USACO5.4]奶牛的电信Telecowmunication \n\n其他图论：\n+ `P1268` 树的重量 \n+ `P1113` 杂务 \n+ `P3183` [HAOI2016]食物链\n\n单调队列：\n+ `P2032` 扫描\n\n莫队：\n+ `P2709` 小B的询问 \n+ `P1972` [SDOI2009]HH的项链 \n+ `P1494` [国家集训队]小Z的袜子 \n\n二分：\n+ `P1314` 聪明的质监员 \n\n数论：\n+ `P1082` 同余方程 \n\n模板：\n+ `P3379` 【模板】最近公共祖先（LCA） \n+ `P3375` 【模板】KM`P字符串匹配 \n+ `P3369` 【模板】普通平衡树（Treap/SBT） \n+ `P3865` 【模板】ST表 \n+ `P3382` 【模板】三分法 \n+ `P3370` 【模板】字符串哈希 \n+ `P3391` 【模板】文艺平衡树（Splay） \n+ `P3376` 【模板】网络最大流 \n+ `P3386` 【模板】二分图匹配 \n+ `P3385` 【模板】负环 \n\n一些水题：\n+ `P1083` 借教室 \n+ `P1168` 中位数 \n+ `P4231` 三步必杀\n+ `P1116` 车厢重组\n \n\nCodeforce：\n+ `#462`\n+ `#463`\n+ `#464`\n\n（写完感觉好少啊）\n{% endfold %}\n\n活过报到了，耶！不过开学第一周也不是好熬过去的呢。\n\n话说第一次考试考了`rank1`，然而出题人没做这套题，所以权当`rank2`吧。革命尚未成功，要直视和巨佬在图论、dp上的差距和距离，这个学期主要就要发展图论，dp，数学等方面的知识。\n\n\b\b寒假后期感觉有点心有余而力不足，反而显得\b平时上学的时候学习效率更高。真是奇怪呢。不过这也在一方面上反映了\b\b寒假作业的毒瘤。毒瘤！\n\n不过课内的学习也不能放下，只好再压榨一点时间了。学习好也就这点不好，两边都难割舍，害怕毁掉课内，也害怕一年竞赛一场空。\n\n> 「没有成绩时 学习不停止」\n\n\b新学期，自勉，共勉。\n\n![其实我想换张图片来着](title.jpg)\n\n## TodoList\n\n### 下周完成\n\n+ 学费用流\n+ 活过这周\n+ 好好学课内啊\n\n### 这学期完成（大略）\n\n+ 图论\n    - 树链剖分及相关\n    - 网络流相关\n    - 费用流\n    - 差分约束\n    - 缩点相关\n    - ...\n+ 数据结构\n    - 高级数据结构（veb啥的）\n    - ...\n+ 字符串相关\n+ 数学\n    - 扩欧\n    - 逆元\n    - FFT等多项式\n    - ...\n+ 奇奇怪怪的算法\n    - 博弈\n+ 研究春令营的课\n\n（一时想不到了 还有啥啊）\n\n说多不多，说少不少。\n","slug":"2018-FebWeek4","published":1,"updated":"2018-03-17T13:19:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3fx000hbljr9en9ihw1","content":"<p><strong>2018年二月 第四周</strong></p>\n<p><strong>2018.2.19-2018.2.25</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=446940024&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>开学了。</p>\n<p>该总结一下寒假了。</p>\n<p>寒假刷题：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<p>为了篇幅短小，只把不是水题的题放在这里。</p>\n<p>Luogu刷题：<br>状压dp：</p>\n<ul>\n<li><code>P1879</code> [USACO06NOV]玉米田Corn Fields </li>\n<li><code>P1896</code> [SCOI2005]互不侵犯King </li>\n<li><code>P1433</code> 吃奶酪 </li>\n<li><code>P2704</code> [NOI2001]炮兵阵地 </li>\n</ul>\n<p>dp：</p>\n<ul>\n<li><code>P2577</code> [ZJOI2005]午餐 </li>\n</ul>\n<p>线段树：</p>\n<ul>\n<li><code>P2894</code> [USACO08FEB]酒店Hotel </li>\n<li><code>P1438</code> 无聊的数列 </li>\n<li><code>P1558</code> 色板游戏 </li>\n<li><code>T21778</code> 过年</li>\n</ul>\n<p>平衡树：</p>\n<ul>\n<li><code>P2073</code> 送花 </li>\n<li><code>P2596</code> [ZJOI2006]书架 </li>\n<li><code>P1486</code> [NOI2004]郁闷的出纳员 </li>\n<li><code>P2234</code> [HNOI2002]营业额统计 </li>\n<li><code>P2286</code> [HNOI2004]宠物收养场 </li>\n<li><code>P3165</code> [CQOI2014]排序机械臂</li>\n<li><code>P2042</code> [NOI2005]维护数列  </li>\n</ul>\n<p>并查集：</p>\n<ul>\n<li><code>P1396</code> 营救</li>\n<li><code>P1536</code> 村村通</li>\n<li><code>P1525</code> 关押罪犯 </li>\n<li><code>P2024</code> 食物链 </li>\n<li><code>P1197</code> [JSOI2008]星球大战 </li>\n<li><code>P1196</code> [NOI2002]银河英雄传说 </li>\n</ul>\n<p>最短路：</p>\n<ul>\n<li><code>P1342</code> 请柬</li>\n<li><code>P1629</code> 邮递员送信 </li>\n<li><code>P1608</code> 路径统计</li>\n</ul>\n<p>生成树：</p>\n<ul>\n<li><code>P1195</code> 口袋的天空</li>\n<li><code>P2820</code> 局域网 </li>\n<li><code>P1194</code> 买礼物 </li>\n</ul>\n<p>差分约束：</p>\n<ul>\n<li><code>P1993</code> 小 K 的农场</li>\n</ul>\n<p>强连通分量：</p>\n<ul>\n<li><code>P1726</code> 上白泽慧音 </li>\n</ul>\n<p>网络流：</p>\n<ul>\n<li><code>P2055</code> [ZJOI2009]假期的宿舍 </li>\n<li><code>P1231</code> 教辅的组成 </li>\n<li><code>P2756</code> 飞行员配对方案问题 </li>\n<li><code>P1345</code> [USACO5.4]奶牛的电信Telecowmunication </li>\n</ul>\n<p>其他图论：</p>\n<ul>\n<li><code>P1268</code> 树的重量 </li>\n<li><code>P1113</code> 杂务 </li>\n<li><code>P3183</code> [HAOI2016]食物链</li>\n</ul>\n<p>单调队列：</p>\n<ul>\n<li><code>P2032</code> 扫描</li>\n</ul>\n<p>莫队：</p>\n<ul>\n<li><code>P2709</code> 小B的询问 </li>\n<li><code>P1972</code> [SDOI2009]HH的项链 </li>\n<li><code>P1494</code> [国家集训队]小Z的袜子 </li>\n</ul>\n<p>二分：</p>\n<ul>\n<li><code>P1314</code> 聪明的质监员 </li>\n</ul>\n<p>数论：</p>\n<ul>\n<li><code>P1082</code> 同余方程 </li>\n</ul>\n<p>模板：</p>\n<ul>\n<li><code>P3379</code> 【模板】最近公共祖先（LCA） </li>\n<li><code>P3375</code> 【模板】KM`P字符串匹配 </li>\n<li><code>P3369</code> 【模板】普通平衡树（Treap/SBT） </li>\n<li><code>P3865</code> 【模板】ST表 </li>\n<li><code>P3382</code> 【模板】三分法 </li>\n<li><code>P3370</code> 【模板】字符串哈希 </li>\n<li><code>P3391</code> 【模板】文艺平衡树（Splay） </li>\n<li><code>P3376</code> 【模板】网络最大流 </li>\n<li><code>P3386</code> 【模板】二分图匹配 </li>\n<li><code>P3385</code> 【模板】负环 </li>\n</ul>\n<p>一些水题：</p>\n<ul>\n<li><code>P1083</code> 借教室 </li>\n<li><code>P1168</code> 中位数 </li>\n<li><code>P4231</code> 三步必杀</li>\n<li><code>P1116</code> 车厢重组</li>\n</ul>\n<p>Codeforce：</p>\n<ul>\n<li><code>#462</code></li>\n<li><code>#463</code></li>\n<li><code>#464</code></li>\n</ul>\n<p>（写完感觉好少啊）</p>\n\n</div></div></p>\n<p>活过报到了，耶！不过开学第一周也不是好熬过去的呢。</p>\n<p>话说第一次考试考了<code>rank1</code>，然而出题人没做这套题，所以权当<code>rank2</code>吧。革命尚未成功，要直视和巨佬在图论、dp上的差距和距离，这个学期主要就要发展图论，dp，数学等方面的知识。</p>\n<p>\b\b寒假后期感觉有点心有余而力不足，反而显得\b平时上学的时候学习效率更高。真是奇怪呢。不过这也在一方面上反映了\b\b寒假作业的毒瘤。毒瘤！</p>\n<p>不过课内的学习也不能放下，只好再压榨一点时间了。学习好也就这点不好，两边都难割舍，害怕毁掉课内，也害怕一年竞赛一场空。</p>\n<blockquote>\n<p>「没有成绩时 学习不停止」</p>\n</blockquote>\n<p>\b新学期，自勉，共勉。</p>\n<p><img src=\"title.jpg\" alt=\"其实我想换张图片来着\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>学费用流</li>\n<li>活过这周</li>\n<li>好好学课内啊</li>\n</ul>\n<h3 id=\"这学期完成（大略）\"><a href=\"#这学期完成（大略）\" class=\"headerlink\" title=\"这学期完成（大略）\"></a>这学期完成（大略）</h3><ul>\n<li>图论<ul>\n<li>树链剖分及相关</li>\n<li>网络流相关</li>\n<li>费用流</li>\n<li>差分约束</li>\n<li>缩点相关</li>\n<li>…</li>\n</ul>\n</li>\n<li>数据结构<ul>\n<li>高级数据结构（veb啥的）</li>\n<li>…</li>\n</ul>\n</li>\n<li>字符串相关</li>\n<li>数学<ul>\n<li>扩欧</li>\n<li>逆元</li>\n<li>FFT等多项式</li>\n<li>…</li>\n</ul>\n</li>\n<li>奇奇怪怪的算法<ul>\n<li>博弈</li>\n</ul>\n</li>\n<li>研究春令营的课</li>\n</ul>\n<p>（一时想不到了 还有啥啊）</p>\n<p>说多不多，说少不少。</p>\n","site":{"data":{}},"excerpt":"<p><strong>2018年二月 第四周</strong></p>\n<p><strong>2018.2.19-2018.2.25</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=446940024&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>开学了。</p>\n<p>该总结一下寒假了。</p>\n<p>寒假刷题：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<p>为了篇幅短小，只把不是水题的题放在这里。</p>\n<p>Luogu刷题：<br>状压dp：</p>\n<ul>\n<li><code>P1879</code> [USACO06NOV]玉米田Corn Fields </li>\n<li><code>P1896</code> [SCOI2005]互不侵犯King </li>\n<li><code>P1433</code> 吃奶酪 </li>\n<li><code>P2704</code> [NOI2001]炮兵阵地 </li>\n</ul>\n<p>dp：</p>\n<ul>\n<li><code>P2577</code> [ZJOI2005]午餐 </li>\n</ul>\n<p>线段树：</p>\n<ul>\n<li><code>P2894</code> [USACO08FEB]酒店Hotel </li>\n<li><code>P1438</code> 无聊的数列 </li>\n<li><code>P1558</code> 色板游戏 </li>\n<li><code>T21778</code> 过年</li>\n</ul>\n<p>平衡树：</p>\n<ul>\n<li><code>P2073</code> 送花 </li>\n<li><code>P2596</code> [ZJOI2006]书架 </li>\n<li><code>P1486</code> [NOI2004]郁闷的出纳员 </li>\n<li><code>P2234</code> [HNOI2002]营业额统计 </li>\n<li><code>P2286</code> [HNOI2004]宠物收养场 </li>\n<li><code>P3165</code> [CQOI2014]排序机械臂</li>\n<li><code>P2042</code> [NOI2005]维护数列  </li>\n</ul>\n<p>并查集：</p>\n<ul>\n<li><code>P1396</code> 营救</li>\n<li><code>P1536</code> 村村通</li>\n<li><code>P1525</code> 关押罪犯 </li>\n<li><code>P2024</code> 食物链 </li>\n<li><code>P1197</code> [JSOI2008]星球大战 </li>\n<li><code>P1196</code> [NOI2002]银河英雄传说 </li>\n</ul>\n<p>最短路：</p>\n<ul>\n<li><code>P1342</code> 请柬</li>\n<li><code>P1629</code> 邮递员送信 </li>\n<li><code>P1608</code> 路径统计</li>\n</ul>\n<p>生成树：</p>\n<ul>\n<li><code>P1195</code> 口袋的天空</li>\n<li><code>P2820</code> 局域网 </li>\n<li><code>P1194</code> 买礼物 </li>\n</ul>\n<p>差分约束：</p>\n<ul>\n<li><code>P1993</code> 小 K 的农场</li>\n</ul>\n<p>强连通分量：</p>\n<ul>\n<li><code>P1726</code> 上白泽慧音 </li>\n</ul>\n<p>网络流：</p>\n<ul>\n<li><code>P2055</code> [ZJOI2009]假期的宿舍 </li>\n<li><code>P1231</code> 教辅的组成 </li>\n<li><code>P2756</code> 飞行员配对方案问题 </li>\n<li><code>P1345</code> [USACO5.4]奶牛的电信Telecowmunication </li>\n</ul>\n<p>其他图论：</p>\n<ul>\n<li><code>P1268</code> 树的重量 </li>\n<li><code>P1113</code> 杂务 </li>\n<li><code>P3183</code> [HAOI2016]食物链</li>\n</ul>\n<p>单调队列：</p>\n<ul>\n<li><code>P2032</code> 扫描</li>\n</ul>\n<p>莫队：</p>\n<ul>\n<li><code>P2709</code> 小B的询问 </li>\n<li><code>P1972</code> [SDOI2009]HH的项链 </li>\n<li><code>P1494</code> [国家集训队]小Z的袜子 </li>\n</ul>\n<p>二分：</p>\n<ul>\n<li><code>P1314</code> 聪明的质监员 </li>\n</ul>\n<p>数论：</p>\n<ul>\n<li><code>P1082</code> 同余方程 </li>\n</ul>\n<p>模板：</p>\n<ul>\n<li><code>P3379</code> 【模板】最近公共祖先（LCA） </li>\n<li><code>P3375</code> 【模板】KM`P字符串匹配 </li>\n<li><code>P3369</code> 【模板】普通平衡树（Treap/SBT） </li>\n<li><code>P3865</code> 【模板】ST表 </li>\n<li><code>P3382</code> 【模板】三分法 </li>\n<li><code>P3370</code> 【模板】字符串哈希 </li>\n<li><code>P3391</code> 【模板】文艺平衡树（Splay） </li>\n<li><code>P3376</code> 【模板】网络最大流 </li>\n<li><code>P3386</code> 【模板】二分图匹配 </li>\n<li><code>P3385</code> 【模板】负环 </li>\n</ul>\n<p>一些水题：</p>\n<ul>\n<li><code>P1083</code> 借教室 </li>\n<li><code>P1168</code> 中位数 </li>\n<li><code>P4231</code> 三步必杀</li>\n<li><code>P1116</code> 车厢重组</li>\n</ul>\n<p>Codeforce：</p>\n<ul>\n<li><code>#462</code></li>\n<li><code>#463</code></li>\n<li><code>#464</code></li>\n</ul>\n<p>（写完感觉好少啊）</p>\n\n</div></div></p>\n<p>活过报到了，耶！不过开学第一周也不是好熬过去的呢。</p>\n<p>话说第一次考试考了<code>rank1</code>，然而出题人没做这套题，所以权当<code>rank2</code>吧。革命尚未成功，要直视和巨佬在图论、dp上的差距和距离，这个学期主要就要发展图论，dp，数学等方面的知识。</p>\n<p>\b\b寒假后期感觉有点心有余而力不足，反而显得\b平时上学的时候学习效率更高。真是奇怪呢。不过这也在一方面上反映了\b\b寒假作业的毒瘤。毒瘤！</p>\n<p>不过课内的学习也不能放下，只好再压榨一点时间了。学习好也就这点不好，两边都难割舍，害怕毁掉课内，也害怕一年竞赛一场空。</p>\n<blockquote>\n<p>「没有成绩时 学习不停止」</p>\n</blockquote>\n<p>\b新学期，自勉，共勉。</p>\n<p><img src=\"title.jpg\" alt=\"其实我想换张图片来着\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>学费用流</li>\n<li>活过这周</li>\n<li>好好学课内啊</li>\n</ul>\n<h3 id=\"这学期完成（大略）\"><a href=\"#这学期完成（大略）\" class=\"headerlink\" title=\"这学期完成（大略）\"></a>这学期完成（大略）</h3><ul>\n<li>图论<ul>\n<li>树链剖分及相关</li>\n<li>网络流相关</li>\n<li>费用流</li>\n<li>差分约束</li>\n<li>缩点相关</li>\n<li>…</li>\n</ul>\n</li>\n<li>数据结构<ul>\n<li>高级数据结构（veb啥的）</li>\n<li>…</li>\n</ul>\n</li>\n<li>字符串相关</li>\n<li>数学<ul>\n<li>扩欧</li>\n<li>逆元</li>\n<li>FFT等多项式</li>\n<li>…</li>\n</ul>\n</li>\n<li>奇奇怪怪的算法<ul>\n<li>博弈</li>\n</ul>\n</li>\n<li>研究春令营的课</li>\n</ul>\n<p>（一时想不到了 还有啥啊）</p>\n<p>说多不多，说少不少。</p>"},{"title":"2018 JanWeek2","date":"2018-01-13T07:59:08.000Z","visible":null,"urlname":"2018-JanWeek2","_content":"\n**2018年一月 第二周**\n\n**2018.1.7-2018.1.14**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=34179200&auto=0&height=66\"></iframe>\n\n## 写在前面\n莫名的就突然有一种做一做总结的欲望。\n想到爸爸。以前啊，总是能看到爸爸每周做一次周报，每月做一次月报，季报，年报，诸如此类。其实也未尝不是一种好想法吧。尤其对我这种健忘的人，以后只要看看这些总结，也就能知道一些好玩的事情了。\n\n## 正文\n转眼就2018了。这一周也没干什么正事，不过是写写作业、出出题，打打游戏。期末考试前的最后一周，真的很有趣呢。第二次轮到写班级日志，也只是草草敷衍了事。这一周没有竞赛课，也就更没有时间去督促自己coding了。看着某人luogu上一条直线的刷题数量，扎心。考完试后一定要玩命的学，玩命的刷题。这半个月复习期末带来的的损失真是不小的。\n\n![](title.png)\n\n## TodoList\n### 这周完成\n无\n\n### 下周\n+ 复习&考好期末\n+ 考完试学：\n    + Trie\n    + Treap\n+ 出没出完的题\n+ 准备好冬令营旅游\n","source":"_posts/2018-JanWeek2.md","raw":"---\ntitle: 2018 JanWeek2\ndate: 2018-01-13 15:59:08\ntags:\ncategories: 总结\nvisible:\nurlname: 2018-JanWeek2\n---\n\n**2018年一月 第二周**\n\n**2018.1.7-2018.1.14**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=34179200&auto=0&height=66\"></iframe>\n\n## 写在前面\n莫名的就突然有一种做一做总结的欲望。\n想到爸爸。以前啊，总是能看到爸爸每周做一次周报，每月做一次月报，季报，年报，诸如此类。其实也未尝不是一种好想法吧。尤其对我这种健忘的人，以后只要看看这些总结，也就能知道一些好玩的事情了。\n\n## 正文\n转眼就2018了。这一周也没干什么正事，不过是写写作业、出出题，打打游戏。期末考试前的最后一周，真的很有趣呢。第二次轮到写班级日志，也只是草草敷衍了事。这一周没有竞赛课，也就更没有时间去督促自己coding了。看着某人luogu上一条直线的刷题数量，扎心。考完试后一定要玩命的学，玩命的刷题。这半个月复习期末带来的的损失真是不小的。\n\n![](title.png)\n\n## TodoList\n### 这周完成\n无\n\n### 下周\n+ 复习&考好期末\n+ 考完试学：\n    + Trie\n    + Treap\n+ 出没出完的题\n+ 准备好冬令营旅游\n","slug":"2018-JanWeek2","published":1,"updated":"2018-03-17T13:19:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3g1000jbljrj7107zst","content":"<p><strong>2018年一月 第二周</strong></p>\n<p><strong>2018.1.7-2018.1.14</strong></p>\n<a id=\"more\"></a>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=34179200&auto=0&height=66\"></iframe>\n\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>莫名的就突然有一种做一做总结的欲望。<br>想到爸爸。以前啊，总是能看到爸爸每周做一次周报，每月做一次月报，季报，年报，诸如此类。其实也未尝不是一种好想法吧。尤其对我这种健忘的人，以后只要看看这些总结，也就能知道一些好玩的事情了。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>转眼就2018了。这一周也没干什么正事，不过是写写作业、出出题，打打游戏。期末考试前的最后一周，真的很有趣呢。第二次轮到写班级日志，也只是草草敷衍了事。这一周没有竞赛课，也就更没有时间去督促自己coding了。看着某人luogu上一条直线的刷题数量，扎心。考完试后一定要玩命的学，玩命的刷题。这半个月复习期末带来的的损失真是不小的。</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><p>无</p>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>复习&amp;考好期末</li>\n<li>考完试学：<ul>\n<li>Trie</li>\n<li>Treap</li>\n</ul>\n</li>\n<li>出没出完的题</li>\n<li>准备好冬令营旅游</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年一月 第二周</strong></p>\n<p><strong>2018.1.7-2018.1.14</strong></p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=34179200&auto=0&height=66\"></iframe>\n\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>莫名的就突然有一种做一做总结的欲望。<br>想到爸爸。以前啊，总是能看到爸爸每周做一次周报，每月做一次月报，季报，年报，诸如此类。其实也未尝不是一种好想法吧。尤其对我这种健忘的人，以后只要看看这些总结，也就能知道一些好玩的事情了。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>转眼就2018了。这一周也没干什么正事，不过是写写作业、出出题，打打游戏。期末考试前的最后一周，真的很有趣呢。第二次轮到写班级日志，也只是草草敷衍了事。这一周没有竞赛课，也就更没有时间去督促自己coding了。看着某人luogu上一条直线的刷题数量，扎心。考完试后一定要玩命的学，玩命的刷题。这半个月复习期末带来的的损失真是不小的。</p>\n<p><img src=\"title.png\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><p>无</p>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>复习&amp;考好期末</li>\n<li>考完试学：<ul>\n<li>Trie</li>\n<li>Treap</li>\n</ul>\n</li>\n<li>出没出完的题</li>\n<li>准备好冬令营旅游</li>\n</ul>"},{"title":"2018 JanWeek3","date":"2018-01-20T13:17:20.000Z","visible":null,"urlname":"2018-JanWeek3","_content":"\n**2018年一月 第三周**\n\n**2018.1.15-2018.1.21**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=35807133&auto=0&height=66\"></iframe>\n\n## 正文\n这一周可是干了不少事。期末考试考的也还算不错，校次竟然还前进了两名。所以看来也许可以寒假认真刷题了？？？\n这周学了不少东西。主要是线段树和状压dp，感觉也不是太难。冬令营今天是第一天，听了胡伟栋的“深度优先搜索”，估计也就是冬令营唯一能听懂的一节课了。\n要说还有什么的话就是洛谷的AC终于到了200。不容易啊。不过马上就能到寒假了。定一个目标，寒假刷过100题吧。所以，希望寒假再回来洛谷的AC能过300吧。\n\n![](title.jpg)\n\n## TodoList\n### 这周完成\n+ 考好期末 ✔考的还不错\n+ 考完试学：\n    + Trie ✘根本没学\n    + Treap ✘还没有实现\n+ 出没出完的题 ✘还是懒得出题\n+ 准备好冬令营旅游 ✔旅游目前顺利\n\n### 下周\n+ 愉快的度过冬令营\n+ 结课考试不爆0\n+ 每天保证3-5道的刷题效率\n+ 顺便写点寒假作业\n","source":"_posts/2018-JanWeek3.md","raw":"---\ntitle: 2018 JanWeek3\ndate: 2018-01-20 21:17:20\ntags:\ncategories: 总结\nvisible:\nurlname: 2018-JanWeek3\n---\n\n**2018年一月 第三周**\n\n**2018.1.15-2018.1.21**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=35807133&auto=0&height=66\"></iframe>\n\n## 正文\n这一周可是干了不少事。期末考试考的也还算不错，校次竟然还前进了两名。所以看来也许可以寒假认真刷题了？？？\n这周学了不少东西。主要是线段树和状压dp，感觉也不是太难。冬令营今天是第一天，听了胡伟栋的“深度优先搜索”，估计也就是冬令营唯一能听懂的一节课了。\n要说还有什么的话就是洛谷的AC终于到了200。不容易啊。不过马上就能到寒假了。定一个目标，寒假刷过100题吧。所以，希望寒假再回来洛谷的AC能过300吧。\n\n![](title.jpg)\n\n## TodoList\n### 这周完成\n+ 考好期末 ✔考的还不错\n+ 考完试学：\n    + Trie ✘根本没学\n    + Treap ✘还没有实现\n+ 出没出完的题 ✘还是懒得出题\n+ 准备好冬令营旅游 ✔旅游目前顺利\n\n### 下周\n+ 愉快的度过冬令营\n+ 结课考试不爆0\n+ 每天保证3-5道的刷题效率\n+ 顺便写点寒假作业\n","slug":"2018-JanWeek3","published":1,"updated":"2018-03-17T13:19:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3g4000lbljr8a086iyp","content":"<p><strong>2018年一月 第三周</strong></p>\n<p><strong>2018.1.15-2018.1.21</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=35807133&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周可是干了不少事。期末考试考的也还算不错，校次竟然还前进了两名。所以看来也许可以寒假认真刷题了？？？<br>这周学了不少东西。主要是线段树和状压dp，感觉也不是太难。冬令营今天是第一天，听了胡伟栋的“深度优先搜索”，估计也就是冬令营唯一能听懂的一节课了。<br>要说还有什么的话就是洛谷的AC终于到了200。不容易啊。不过马上就能到寒假了。定一个目标，寒假刷过100题吧。所以，希望寒假再回来洛谷的AC能过300吧。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>考好期末 ✔考的还不错</li>\n<li>考完试学：<ul>\n<li>Trie ✘根本没学</li>\n<li>Treap ✘还没有实现</li>\n</ul>\n</li>\n<li>出没出完的题 ✘还是懒得出题</li>\n<li>准备好冬令营旅游 ✔旅游目前顺利</li>\n</ul>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>愉快的度过冬令营</li>\n<li>结课考试不爆0</li>\n<li>每天保证3-5道的刷题效率</li>\n<li>顺便写点寒假作业</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年一月 第三周</strong></p>\n<p><strong>2018.1.15-2018.1.21</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=35807133&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周可是干了不少事。期末考试考的也还算不错，校次竟然还前进了两名。所以看来也许可以寒假认真刷题了？？？<br>这周学了不少东西。主要是线段树和状压dp，感觉也不是太难。冬令营今天是第一天，听了胡伟栋的“深度优先搜索”，估计也就是冬令营唯一能听懂的一节课了。<br>要说还有什么的话就是洛谷的AC终于到了200。不容易啊。不过马上就能到寒假了。定一个目标，寒假刷过100题吧。所以，希望寒假再回来洛谷的AC能过300吧。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>考好期末 ✔考的还不错</li>\n<li>考完试学：<ul>\n<li>Trie ✘根本没学</li>\n<li>Treap ✘还没有实现</li>\n</ul>\n</li>\n<li>出没出完的题 ✘还是懒得出题</li>\n<li>准备好冬令营旅游 ✔旅游目前顺利</li>\n</ul>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>愉快的度过冬令营</li>\n<li>结课考试不爆0</li>\n<li>每天保证3-5道的刷题效率</li>\n<li>顺便写点寒假作业</li>\n</ul>"},{"title":"2018 JanWeek4","date":"2018-01-28T01:22:46.000Z","visible":null,"urlname":"2018-JanWeek4","_content":"\n**2018年一月 第四周**\n**2018.1.22-2018.1.28**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=416890449&auto=0&height=66\"></iframe>\n\n## 正文\n\n其实本该昨天写的。但由于昨天上午考试，下午去参加一个会一直到12点，然后也就没有时间去写总结了。\n\n转眼间，一月就过去了呢。这一个月大约是高中生活以来最充实的一个月吧。截止我现在写总结的时候，寒假似乎还没有开始。前几天一直不停不停的从早上到晚课，然而今天却还是要考四个小时的试。啧啧。在一月里，期末也考完了，冬令营也搞完了，然而感觉生活还是很忙。也无比的怀念新年联欢的时候，那种轻松悠闲的感觉。而且，毕竟，那还是去年。\n\n不过忙也好，至少说明现在不是在碌碌无为。寒假也许都会这么充实下去吧。话说农历新年也快要来了，我也又要回老家了。\n\n这一周开始接着在冬令营颓废，然后去了两天学校，却还是不得已参加一坨令人无语的活动。真不知道该庆幸去了冬令营还是不去了。\n\n学期也算是正是结束了。下一个noip事实上也越来越近了。回首这一个学期，学会了很多，但同时也意识到，和高手们差的也很多。最后的十个月，我想将是不亚于中考冲刺的那10个月的一个体验吧（虽然我觉得那十个月就是颓过去的。想想也真是有趣，如果这一堆流程走完，大概也得到明年五六月份了。而那个时候，或许高三的总复习都快要开始了。\n\n然后高中生活就过去了。\n\n![](title.jpg)\n\n## TodoList\n### 这周完成\n\n+ 考完试学：\n    + Trie ✔成功学习\n    + Treap ✔成功实现\n+ 出没出完的题 ✔颓了一道膜版交上去了\n+ 愉快的度过冬令营 ✔旅游很顺利 愉快\n+ 结课考试不爆0 ✔5分哈哈哈\n+ 每天保证3-5道的刷题效率 ✘大概也就每天2.5道左右\n+ 顺便写点寒假作业 ✔强行水完了化学和一半的物理作业\n\n### 下周\n\n+ 实现AC自动机\n+ 学会fhq Treap或者Splay\n+ 写完至少物理、地理、一小半数学的寒假作业\n+ 至少写一篇题解发到这里（待选主题：线段树，状压dp\n+ 出去玩```\\(≧▽≦)/```\n\n","source":"_posts/2018-JanWeek4.md","raw":"---\ntitle: 2018 JanWeek4\ndate: 2018-01-28 09:22:46\ntags:\ncategories: 总结\nvisible:\nurlname: 2018-JanWeek4\n---\n\n**2018年一月 第四周**\n**2018.1.22-2018.1.28**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=416890449&auto=0&height=66\"></iframe>\n\n## 正文\n\n其实本该昨天写的。但由于昨天上午考试，下午去参加一个会一直到12点，然后也就没有时间去写总结了。\n\n转眼间，一月就过去了呢。这一个月大约是高中生活以来最充实的一个月吧。截止我现在写总结的时候，寒假似乎还没有开始。前几天一直不停不停的从早上到晚课，然而今天却还是要考四个小时的试。啧啧。在一月里，期末也考完了，冬令营也搞完了，然而感觉生活还是很忙。也无比的怀念新年联欢的时候，那种轻松悠闲的感觉。而且，毕竟，那还是去年。\n\n不过忙也好，至少说明现在不是在碌碌无为。寒假也许都会这么充实下去吧。话说农历新年也快要来了，我也又要回老家了。\n\n这一周开始接着在冬令营颓废，然后去了两天学校，却还是不得已参加一坨令人无语的活动。真不知道该庆幸去了冬令营还是不去了。\n\n学期也算是正是结束了。下一个noip事实上也越来越近了。回首这一个学期，学会了很多，但同时也意识到，和高手们差的也很多。最后的十个月，我想将是不亚于中考冲刺的那10个月的一个体验吧（虽然我觉得那十个月就是颓过去的。想想也真是有趣，如果这一堆流程走完，大概也得到明年五六月份了。而那个时候，或许高三的总复习都快要开始了。\n\n然后高中生活就过去了。\n\n![](title.jpg)\n\n## TodoList\n### 这周完成\n\n+ 考完试学：\n    + Trie ✔成功学习\n    + Treap ✔成功实现\n+ 出没出完的题 ✔颓了一道膜版交上去了\n+ 愉快的度过冬令营 ✔旅游很顺利 愉快\n+ 结课考试不爆0 ✔5分哈哈哈\n+ 每天保证3-5道的刷题效率 ✘大概也就每天2.5道左右\n+ 顺便写点寒假作业 ✔强行水完了化学和一半的物理作业\n\n### 下周\n\n+ 实现AC自动机\n+ 学会fhq Treap或者Splay\n+ 写完至少物理、地理、一小半数学的寒假作业\n+ 至少写一篇题解发到这里（待选主题：线段树，状压dp\n+ 出去玩```\\(≧▽≦)/```\n\n","slug":"2018-JanWeek4","published":1,"updated":"2018-03-17T13:18:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3gd000nbljrao2th7wk","content":"<p><strong>2018年一月 第四周</strong><br><strong>2018.1.22-2018.1.28</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=416890449&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>其实本该昨天写的。但由于昨天上午考试，下午去参加一个会一直到12点，然后也就没有时间去写总结了。</p>\n<p>转眼间，一月就过去了呢。这一个月大约是高中生活以来最充实的一个月吧。截止我现在写总结的时候，寒假似乎还没有开始。前几天一直不停不停的从早上到晚课，然而今天却还是要考四个小时的试。啧啧。在一月里，期末也考完了，冬令营也搞完了，然而感觉生活还是很忙。也无比的怀念新年联欢的时候，那种轻松悠闲的感觉。而且，毕竟，那还是去年。</p>\n<p>不过忙也好，至少说明现在不是在碌碌无为。寒假也许都会这么充实下去吧。话说农历新年也快要来了，我也又要回老家了。</p>\n<p>这一周开始接着在冬令营颓废，然后去了两天学校，却还是不得已参加一坨令人无语的活动。真不知道该庆幸去了冬令营还是不去了。</p>\n<p>学期也算是正是结束了。下一个noip事实上也越来越近了。回首这一个学期，学会了很多，但同时也意识到，和高手们差的也很多。最后的十个月，我想将是不亚于中考冲刺的那10个月的一个体验吧（虽然我觉得那十个月就是颓过去的。想想也真是有趣，如果这一堆流程走完，大概也得到明年五六月份了。而那个时候，或许高三的总复习都快要开始了。</p>\n<p>然后高中生活就过去了。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>考完试学：<ul>\n<li>Trie ✔成功学习</li>\n<li>Treap ✔成功实现</li>\n</ul>\n</li>\n<li>出没出完的题 ✔颓了一道膜版交上去了</li>\n<li>愉快的度过冬令营 ✔旅游很顺利 愉快</li>\n<li>结课考试不爆0 ✔5分哈哈哈</li>\n<li>每天保证3-5道的刷题效率 ✘大概也就每天2.5道左右</li>\n<li>顺便写点寒假作业 ✔强行水完了化学和一半的物理作业</li>\n</ul>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>实现AC自动机</li>\n<li>学会fhq Treap或者Splay</li>\n<li>写完至少物理、地理、一小半数学的寒假作业</li>\n<li>至少写一篇题解发到这里（待选主题：线段树，状压dp</li>\n<li>出去玩<code>\\(≧▽≦)/</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年一月 第四周</strong><br><strong>2018.1.22-2018.1.28</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=416890449&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>其实本该昨天写的。但由于昨天上午考试，下午去参加一个会一直到12点，然后也就没有时间去写总结了。</p>\n<p>转眼间，一月就过去了呢。这一个月大约是高中生活以来最充实的一个月吧。截止我现在写总结的时候，寒假似乎还没有开始。前几天一直不停不停的从早上到晚课，然而今天却还是要考四个小时的试。啧啧。在一月里，期末也考完了，冬令营也搞完了，然而感觉生活还是很忙。也无比的怀念新年联欢的时候，那种轻松悠闲的感觉。而且，毕竟，那还是去年。</p>\n<p>不过忙也好，至少说明现在不是在碌碌无为。寒假也许都会这么充实下去吧。话说农历新年也快要来了，我也又要回老家了。</p>\n<p>这一周开始接着在冬令营颓废，然后去了两天学校，却还是不得已参加一坨令人无语的活动。真不知道该庆幸去了冬令营还是不去了。</p>\n<p>学期也算是正是结束了。下一个noip事实上也越来越近了。回首这一个学期，学会了很多，但同时也意识到，和高手们差的也很多。最后的十个月，我想将是不亚于中考冲刺的那10个月的一个体验吧（虽然我觉得那十个月就是颓过去的。想想也真是有趣，如果这一堆流程走完，大概也得到明年五六月份了。而那个时候，或许高三的总复习都快要开始了。</p>\n<p>然后高中生活就过去了。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这周完成\"><a href=\"#这周完成\" class=\"headerlink\" title=\"这周完成\"></a>这周完成</h3><ul>\n<li>考完试学：<ul>\n<li>Trie ✔成功学习</li>\n<li>Treap ✔成功实现</li>\n</ul>\n</li>\n<li>出没出完的题 ✔颓了一道膜版交上去了</li>\n<li>愉快的度过冬令营 ✔旅游很顺利 愉快</li>\n<li>结课考试不爆0 ✔5分哈哈哈</li>\n<li>每天保证3-5道的刷题效率 ✘大概也就每天2.5道左右</li>\n<li>顺便写点寒假作业 ✔强行水完了化学和一半的物理作业</li>\n</ul>\n<h3 id=\"下周\"><a href=\"#下周\" class=\"headerlink\" title=\"下周\"></a>下周</h3><ul>\n<li>实现AC自动机</li>\n<li>学会fhq Treap或者Splay</li>\n<li>写完至少物理、地理、一小半数学的寒假作业</li>\n<li>至少写一篇题解发到这里（待选主题：线段树，状压dp</li>\n<li>出去玩<code>\\(≧▽≦)/</code></li>\n</ul>"},{"title":"2018 MarWeek1","urlname":"2018-MarWeek1","date":"2018-03-03T10:07:20.000Z","visible":null,"_content":"\n\n**2018年三月 第一周**\n\n**2018.2.26-2018.3.4**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=28660487&auto=0&height=66\"></iframe>\n\n## 正文\n\n侥幸混过第一周。\n\n这一周说起来还是在寒假的颓废状态中。平时的作业少，周末的作业多，大概就是开学初的特点。\n\n今天讲了下$zkw$线段树，然后这个果真耗掉了我小半个周末的时间。啧啧。话说讲课真的是累，超级累。\n\n三月份听说有省选？那就又可以去混一混了。考试能不爆零就好。\n\n听说，这一个学期很短，不过15周的时间。\b这十五周过去，接下来很快就要`NOIP`了呀。`NOIP`这个东西，不能炸啊。先定一个小目标...$480+$？？？不过以以往的经验来看，小目标一般都是能实现的。比如小升初，比如中考，比如分班，比如省选冬令营的考试（雾）。\n\n虽然我立的$flag$很有可能以一种玄学的方法实现。\n\n不过，能实现就很不错了呢。\n\n但无论如何，不能轻浮啊。\n\n> 脚踏实地 仰望星空\n\n![](title_1024px.jpg)\n\n## TodoList\n\n### 此周完成\n\n+ 侥幸度过开学第一周\n+ 第一次在`OI`讲台上讲课\n+ 做了两道缩点的水题\n+ 做了两道$dp$的水题\n\n### 下周完成\n\n+ 颓$dp$\n+ 费用流\n+ 树链剖分（以上两个这周必须过了模版！！！\n+ \b加紧的赶点进度（课内&&课外\n\n","source":"_posts/2018-MarWeek1.md","raw":"---\ntitle: 2018 MarWeek1\nurlname: 2018-MarWeek1\ndate: 2018-03-03 18:07:20\ntags:\ncategories: 总结\nvisible:\n---\n\n\n**2018年三月 第一周**\n\n**2018.2.26-2018.3.4**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=28660487&auto=0&height=66\"></iframe>\n\n## 正文\n\n侥幸混过第一周。\n\n这一周说起来还是在寒假的颓废状态中。平时的作业少，周末的作业多，大概就是开学初的特点。\n\n今天讲了下$zkw$线段树，然后这个果真耗掉了我小半个周末的时间。啧啧。话说讲课真的是累，超级累。\n\n三月份听说有省选？那就又可以去混一混了。考试能不爆零就好。\n\n听说，这一个学期很短，不过15周的时间。\b这十五周过去，接下来很快就要`NOIP`了呀。`NOIP`这个东西，不能炸啊。先定一个小目标...$480+$？？？不过以以往的经验来看，小目标一般都是能实现的。比如小升初，比如中考，比如分班，比如省选冬令营的考试（雾）。\n\n虽然我立的$flag$很有可能以一种玄学的方法实现。\n\n不过，能实现就很不错了呢。\n\n但无论如何，不能轻浮啊。\n\n> 脚踏实地 仰望星空\n\n![](title_1024px.jpg)\n\n## TodoList\n\n### 此周完成\n\n+ 侥幸度过开学第一周\n+ 第一次在`OI`讲台上讲课\n+ 做了两道缩点的水题\n+ 做了两道$dp$的水题\n\n### 下周完成\n\n+ 颓$dp$\n+ 费用流\n+ 树链剖分（以上两个这周必须过了模版！！！\n+ \b加紧的赶点进度（课内&&课外\n\n","slug":"2018-MarWeek1","published":1,"updated":"2018-03-17T13:18:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3gr000pbljrpsju4ca8","content":"<p><strong>2018年三月 第一周</strong></p>\n<p><strong>2018.2.26-2018.3.4</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=28660487&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>侥幸混过第一周。</p>\n<p>这一周说起来还是在寒假的颓废状态中。平时的作业少，周末的作业多，大概就是开学初的特点。</p>\n<p>今天讲了下$zkw$线段树，然后这个果真耗掉了我小半个周末的时间。啧啧。话说讲课真的是累，超级累。</p>\n<p>三月份听说有省选？那就又可以去混一混了。考试能不爆零就好。</p>\n<p>听说，这一个学期很短，不过15周的时间。\b这十五周过去，接下来很快就要<code>NOIP</code>了呀。<code>NOIP</code>这个东西，不能炸啊。先定一个小目标…$480+$？？？不过以以往的经验来看，小目标一般都是能实现的。比如小升初，比如中考，比如分班，比如省选冬令营的考试（雾）。</p>\n<p>虽然我立的$flag$很有可能以一种玄学的方法实现。</p>\n<p>不过，能实现就很不错了呢。</p>\n<p>但无论如何，不能轻浮啊。</p>\n<blockquote>\n<p>脚踏实地 仰望星空</p>\n</blockquote>\n<p><img src=\"title_1024px.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>侥幸度过开学第一周</li>\n<li>第一次在<code>OI</code>讲台上讲课</li>\n<li>做了两道缩点的水题</li>\n<li>做了两道$dp$的水题</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>颓$dp$</li>\n<li>费用流</li>\n<li>树链剖分（以上两个这周必须过了模版！！！</li>\n<li>\b加紧的赶点进度（课内&amp;&amp;课外</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年三月 第一周</strong></p>\n<p><strong>2018.2.26-2018.3.4</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=28660487&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>侥幸混过第一周。</p>\n<p>这一周说起来还是在寒假的颓废状态中。平时的作业少，周末的作业多，大概就是开学初的特点。</p>\n<p>今天讲了下$zkw$线段树，然后这个果真耗掉了我小半个周末的时间。啧啧。话说讲课真的是累，超级累。</p>\n<p>三月份听说有省选？那就又可以去混一混了。考试能不爆零就好。</p>\n<p>听说，这一个学期很短，不过15周的时间。\b这十五周过去，接下来很快就要<code>NOIP</code>了呀。<code>NOIP</code>这个东西，不能炸啊。先定一个小目标…$480+$？？？不过以以往的经验来看，小目标一般都是能实现的。比如小升初，比如中考，比如分班，比如省选冬令营的考试（雾）。</p>\n<p>虽然我立的$flag$很有可能以一种玄学的方法实现。</p>\n<p>不过，能实现就很不错了呢。</p>\n<p>但无论如何，不能轻浮啊。</p>\n<blockquote>\n<p>脚踏实地 仰望星空</p>\n</blockquote>\n<p><img src=\"title_1024px.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>侥幸度过开学第一周</li>\n<li>第一次在<code>OI</code>讲台上讲课</li>\n<li>做了两道缩点的水题</li>\n<li>做了两道$dp$的水题</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>颓$dp$</li>\n<li>费用流</li>\n<li>树链剖分（以上两个这周必须过了模版！！！</li>\n<li>\b加紧的赶点进度（课内&amp;&amp;课外</li>\n</ul>"},{"title":"2018 MarWeek2","urlname":"2018-MarWeek2","date":"2018-03-10T14:49:16.000Z","visible":null,"_content":"\n**2018年三月 第二周**\n\n**2018.3.5-2018.3.11**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=411314139&auto=0&height=66\"></iframe>\n\n## 正文\n\n开学的第二周。一切渐渐进入上学的节奏。\n\n颓废。这一周开始的时候可以说是真的颓废，课内数学物理变得越来越难，甚至课上的题有的都做不出来。回家，也不怎么想写作业，只是颓代码或者颓知乎。后几天慢慢的好了一点。作业稍多，倒也是免于不少杂念。这两天刷题的也稍稍多了点。总之，一切还是向好发展的吧。\n\n周末的作业不少，更是有不少奇怪的东西（忽然想起来还要背不少的课文），的确不太舒爽。周六一天都在`Coding`，幸亏作业不多。\n\n这周末APIO的一道题搞了个很气的95分。虽然我写的就是个暴力吧，但好歹时间复杂度优越啊，凭什么就剩下一个点空间爆炸呢...凭什么啊！！！\n\n---\n\n下周又是新的一周。然而下周一$Deadline$的好多作业还没有做完，真是`GG`。好像下下下周又要讲课？？？我明明就是一个什么都不会的蒟蒻啊。还得现学，心真累。\n\n没想到，$oscar$神犇居然是我校选手，是不是就是这几天一直就坐在我们隔壁机房的神犇啊。看朋友圈说什么冬令营`Ag`滚粗，也不知道我的`OI`生涯会不会有机会走到能至少看到一眼`Ag`的那一步？？？估计不太现实吧。\n\n---\n\n忽然也就想到初三的时候，十次月考，每次考完成绩分析的时候都会往放历次大考成绩单的信封里塞一张稿纸，每张上面只写了几个字：*“革命尚未成功，同志仍需努力。”* 最有趣的是考完中考，我还是往里面塞了一张稿纸：*“革命已经成功，同志仍需努力。”* \b当然，我现在只是希望，一年后，我也是能这样的吧。\n\n细细想来初三，发生的很多事情真是如梦似幻，如梦似幻啊。\n\n感觉最近挺累的。视力也越来越有些不好了。\n\n诶。\n\n![](title.jpg)\n\n*来源：[Wikipedia](https://commons.wikimedia.org/wiki/File:20020811203148_-_NOI_2002.jpg)*\n\n## TodoList\n\n### 此周完成\n\n+ 颓$dp$ ✘ 这一周课上开始颓图论了...\n+ 费用流 ✔大概算了吧...会写简单EK+SPFA了...\n+ 树链剖分 ✔ 成功写了好几道模版\n+ \b加紧的赶点进度 ¿大约吧\n+ 一些奇奇怪怪的图论\n\n### 下周完成\n\n+ 最小费用最大流模版\n+ dp试炼场！！！\n    - 顺便学习一下高级的dp\b优化\n+ 准备讲课（怎么着自己也得学会吧\n+ \b保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目\n","source":"_posts/2018-MarWeek2.md","raw":"---\ntitle: 2018 MarWeek2\nurlname: 2018-MarWeek2\ndate: 2018-03-10 22:49:16\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年三月 第二周**\n\n**2018.3.5-2018.3.11**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=411314139&auto=0&height=66\"></iframe>\n\n## 正文\n\n开学的第二周。一切渐渐进入上学的节奏。\n\n颓废。这一周开始的时候可以说是真的颓废，课内数学物理变得越来越难，甚至课上的题有的都做不出来。回家，也不怎么想写作业，只是颓代码或者颓知乎。后几天慢慢的好了一点。作业稍多，倒也是免于不少杂念。这两天刷题的也稍稍多了点。总之，一切还是向好发展的吧。\n\n周末的作业不少，更是有不少奇怪的东西（忽然想起来还要背不少的课文），的确不太舒爽。周六一天都在`Coding`，幸亏作业不多。\n\n这周末APIO的一道题搞了个很气的95分。虽然我写的就是个暴力吧，但好歹时间复杂度优越啊，凭什么就剩下一个点空间爆炸呢...凭什么啊！！！\n\n---\n\n下周又是新的一周。然而下周一$Deadline$的好多作业还没有做完，真是`GG`。好像下下下周又要讲课？？？我明明就是一个什么都不会的蒟蒻啊。还得现学，心真累。\n\n没想到，$oscar$神犇居然是我校选手，是不是就是这几天一直就坐在我们隔壁机房的神犇啊。看朋友圈说什么冬令营`Ag`滚粗，也不知道我的`OI`生涯会不会有机会走到能至少看到一眼`Ag`的那一步？？？估计不太现实吧。\n\n---\n\n忽然也就想到初三的时候，十次月考，每次考完成绩分析的时候都会往放历次大考成绩单的信封里塞一张稿纸，每张上面只写了几个字：*“革命尚未成功，同志仍需努力。”* 最有趣的是考完中考，我还是往里面塞了一张稿纸：*“革命已经成功，同志仍需努力。”* \b当然，我现在只是希望，一年后，我也是能这样的吧。\n\n细细想来初三，发生的很多事情真是如梦似幻，如梦似幻啊。\n\n感觉最近挺累的。视力也越来越有些不好了。\n\n诶。\n\n![](title.jpg)\n\n*来源：[Wikipedia](https://commons.wikimedia.org/wiki/File:20020811203148_-_NOI_2002.jpg)*\n\n## TodoList\n\n### 此周完成\n\n+ 颓$dp$ ✘ 这一周课上开始颓图论了...\n+ 费用流 ✔大概算了吧...会写简单EK+SPFA了...\n+ 树链剖分 ✔ 成功写了好几道模版\n+ \b加紧的赶点进度 ¿大约吧\n+ 一些奇奇怪怪的图论\n\n### 下周完成\n\n+ 最小费用最大流模版\n+ dp试炼场！！！\n    - 顺便学习一下高级的dp\b优化\n+ 准备讲课（怎么着自己也得学会吧\n+ \b保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目\n","slug":"2018-MarWeek2","published":1,"updated":"2018-03-17T13:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3gw000rbljrj9wlr587","content":"<p><strong>2018年三月 第二周</strong></p>\n<p><strong>2018.3.5-2018.3.11</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=411314139&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>开学的第二周。一切渐渐进入上学的节奏。</p>\n<p>颓废。这一周开始的时候可以说是真的颓废，课内数学物理变得越来越难，甚至课上的题有的都做不出来。回家，也不怎么想写作业，只是颓代码或者颓知乎。后几天慢慢的好了一点。作业稍多，倒也是免于不少杂念。这两天刷题的也稍稍多了点。总之，一切还是向好发展的吧。</p>\n<p>周末的作业不少，更是有不少奇怪的东西（忽然想起来还要背不少的课文），的确不太舒爽。周六一天都在<code>Coding</code>，幸亏作业不多。</p>\n<p>这周末APIO的一道题搞了个很气的95分。虽然我写的就是个暴力吧，但好歹时间复杂度优越啊，凭什么就剩下一个点空间爆炸呢…凭什么啊！！！</p>\n<hr>\n<p>下周又是新的一周。然而下周一$Deadline$的好多作业还没有做完，真是<code>GG</code>。好像下下下周又要讲课？？？我明明就是一个什么都不会的蒟蒻啊。还得现学，心真累。</p>\n<p>没想到，$oscar$神犇居然是我校选手，是不是就是这几天一直就坐在我们隔壁机房的神犇啊。看朋友圈说什么冬令营<code>Ag</code>滚粗，也不知道我的<code>OI</code>生涯会不会有机会走到能至少看到一眼<code>Ag</code>的那一步？？？估计不太现实吧。</p>\n<hr>\n<p>忽然也就想到初三的时候，十次月考，每次考完成绩分析的时候都会往放历次大考成绩单的信封里塞一张稿纸，每张上面只写了几个字：<em>“革命尚未成功，同志仍需努力。”</em> 最有趣的是考完中考，我还是往里面塞了一张稿纸：<em>“革命已经成功，同志仍需努力。”</em> \b当然，我现在只是希望，一年后，我也是能这样的吧。</p>\n<p>细细想来初三，发生的很多事情真是如梦似幻，如梦似幻啊。</p>\n<p>感觉最近挺累的。视力也越来越有些不好了。</p>\n<p>诶。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://commons.wikimedia.org/wiki/File:20020811203148_-_NOI_2002.jpg\" target=\"_blank\" rel=\"noopener\">Wikipedia</a></em></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>颓$dp$ ✘ 这一周课上开始颓图论了…</li>\n<li>费用流 ✔大概算了吧…会写简单EK+SPFA了…</li>\n<li>树链剖分 ✔ 成功写了好几道模版</li>\n<li>\b加紧的赶点进度 ¿大约吧</li>\n<li>一些奇奇怪怪的图论</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>最小费用最大流模版</li>\n<li>dp试炼场！！！<ul>\n<li>顺便学习一下高级的dp\b优化</li>\n</ul>\n</li>\n<li>准备讲课（怎么着自己也得学会吧</li>\n<li>\b保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年三月 第二周</strong></p>\n<p><strong>2018.3.5-2018.3.11</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=411314139&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>开学的第二周。一切渐渐进入上学的节奏。</p>\n<p>颓废。这一周开始的时候可以说是真的颓废，课内数学物理变得越来越难，甚至课上的题有的都做不出来。回家，也不怎么想写作业，只是颓代码或者颓知乎。后几天慢慢的好了一点。作业稍多，倒也是免于不少杂念。这两天刷题的也稍稍多了点。总之，一切还是向好发展的吧。</p>\n<p>周末的作业不少，更是有不少奇怪的东西（忽然想起来还要背不少的课文），的确不太舒爽。周六一天都在<code>Coding</code>，幸亏作业不多。</p>\n<p>这周末APIO的一道题搞了个很气的95分。虽然我写的就是个暴力吧，但好歹时间复杂度优越啊，凭什么就剩下一个点空间爆炸呢…凭什么啊！！！</p>\n<hr>\n<p>下周又是新的一周。然而下周一$Deadline$的好多作业还没有做完，真是<code>GG</code>。好像下下下周又要讲课？？？我明明就是一个什么都不会的蒟蒻啊。还得现学，心真累。</p>\n<p>没想到，$oscar$神犇居然是我校选手，是不是就是这几天一直就坐在我们隔壁机房的神犇啊。看朋友圈说什么冬令营<code>Ag</code>滚粗，也不知道我的<code>OI</code>生涯会不会有机会走到能至少看到一眼<code>Ag</code>的那一步？？？估计不太现实吧。</p>\n<hr>\n<p>忽然也就想到初三的时候，十次月考，每次考完成绩分析的时候都会往放历次大考成绩单的信封里塞一张稿纸，每张上面只写了几个字：<em>“革命尚未成功，同志仍需努力。”</em> 最有趣的是考完中考，我还是往里面塞了一张稿纸：<em>“革命已经成功，同志仍需努力。”</em> \b当然，我现在只是希望，一年后，我也是能这样的吧。</p>\n<p>细细想来初三，发生的很多事情真是如梦似幻，如梦似幻啊。</p>\n<p>感觉最近挺累的。视力也越来越有些不好了。</p>\n<p>诶。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://commons.wikimedia.org/wiki/File:20020811203148_-_NOI_2002.jpg\" target=\"_blank\" rel=\"noopener\">Wikipedia</a></em></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>颓$dp$ ✘ 这一周课上开始颓图论了…</li>\n<li>费用流 ✔大概算了吧…会写简单EK+SPFA了…</li>\n<li>树链剖分 ✔ 成功写了好几道模版</li>\n<li>\b加紧的赶点进度 ¿大约吧</li>\n<li>一些奇奇怪怪的图论</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>最小费用最大流模版</li>\n<li>dp试炼场！！！<ul>\n<li>顺便学习一下高级的dp\b优化</li>\n</ul>\n</li>\n<li>准备讲课（怎么着自己也得学会吧</li>\n<li>\b保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目</li>\n</ul>"},{"title":"2018 MarWeek3","urlname":"2018-MarWeek3","date":"2018-03-17T12:22:00.000Z","visible":null,"_content":"\n**2018年三月 第三周**\n\n**2018.3.12-2018.3.18**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 src=\"//music.163.com/outchain/player?type=2&id=429460399&auto=0&height=66\"></iframe>\n\n## 正文\n\n转眼都过去三周了啊。\n\n一切渐入正轨吧。但是最近总是感觉课内学习做到的题超级的难。不知道是老师变态呢，还是我变弱了呢...而且有的时候还不想写作业。恐怕是药丸。以后上课还是应该好好听讲啊。\n\n暂且不管吧。但是现在还面临着一个比较尴尬的事情：如果做一些五三之类的大水练习册觉得无聊，可是做像什么小绿本小蓝本需要的时间又太多。\n\n啊。下定决心。要刷题，刷题。不管是数学、物理，还是信息。对于目前来看，只有刷题才能让自己从颓废中出去了。\n\n两周之后还要讲课。我还不会。感觉gg。\n\n- - - \n\n有的时候，我也在想，如果我没有选择OI，那我现在的生活会是一个什么样子的。\n\n如果没有选择OI，那么现在，我多半是在打物理竞赛。最近上物理自招的课，却也觉得物理也比较有趣，而且物理毕竟是高考学科，比信息学也有一定的好处。\n\n但怎么说呢，我觉得选择OI就是命吧。\n\n在初三的时候，我还没有学过关于程序设计的任何知识（说来真是后悔哈。那个时候，学校的计算机课学的是`Scratch`的编程。想想也真的是不可思议。当时的我就用着那个可怜的图形界面的编程，自己写了好多有趣的程序。而且那个时候，虽然我还不知道任何关于什么递归啊，栈的概念，硬生生写了好几周，写出了一个能够解数独的程序。\n\n一切，也许都是注定的吧。诶。不应该说这么多的。\n\n- - -\n\n北京下雪了呢。四个多月没有下过雨，也没有下过雪，今天终于得见。俗话说，瑞雪兆丰年。可我看着这雪，倒一点不像是丰年的兆头。\n\n![](title.jpg)\n\n来源:[Painterly snow | mclelun [pixiv] ](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=54902957)\n\n## TodoList\n\n### 此周完成\n\n+ 最小费用最大流模版 ✔终于颓了模版！\n+ dp试炼场！！！✘ 荒废\n+ 准备讲课（怎么着自己也得学会吧 ✘ 还有两周\n+ \b保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✔ 省选-好像也不是很难\n\n### 下周完成\n\n+ 图论关于连通分量、网络流、费用流的习题\n+ 刷题可以适当的少一点\n+ 学习更用心些吧 课上认真听课\n+ 看完《老人与海》\n+ 做一点物理小绿本的题\n","source":"_posts/2018-MarWeek3.md","raw":"---\ntitle: 2018 MarWeek3\nurlname: 2018-MarWeek3\ndate: 2018-03-17 20:22:00\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年三月 第三周**\n\n**2018.3.12-2018.3.18**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=500 height=86 src=\"//music.163.com/outchain/player?type=2&id=429460399&auto=0&height=66\"></iframe>\n\n## 正文\n\n转眼都过去三周了啊。\n\n一切渐入正轨吧。但是最近总是感觉课内学习做到的题超级的难。不知道是老师变态呢，还是我变弱了呢...而且有的时候还不想写作业。恐怕是药丸。以后上课还是应该好好听讲啊。\n\n暂且不管吧。但是现在还面临着一个比较尴尬的事情：如果做一些五三之类的大水练习册觉得无聊，可是做像什么小绿本小蓝本需要的时间又太多。\n\n啊。下定决心。要刷题，刷题。不管是数学、物理，还是信息。对于目前来看，只有刷题才能让自己从颓废中出去了。\n\n两周之后还要讲课。我还不会。感觉gg。\n\n- - - \n\n有的时候，我也在想，如果我没有选择OI，那我现在的生活会是一个什么样子的。\n\n如果没有选择OI，那么现在，我多半是在打物理竞赛。最近上物理自招的课，却也觉得物理也比较有趣，而且物理毕竟是高考学科，比信息学也有一定的好处。\n\n但怎么说呢，我觉得选择OI就是命吧。\n\n在初三的时候，我还没有学过关于程序设计的任何知识（说来真是后悔哈。那个时候，学校的计算机课学的是`Scratch`的编程。想想也真的是不可思议。当时的我就用着那个可怜的图形界面的编程，自己写了好多有趣的程序。而且那个时候，虽然我还不知道任何关于什么递归啊，栈的概念，硬生生写了好几周，写出了一个能够解数独的程序。\n\n一切，也许都是注定的吧。诶。不应该说这么多的。\n\n- - -\n\n北京下雪了呢。四个多月没有下过雨，也没有下过雪，今天终于得见。俗话说，瑞雪兆丰年。可我看着这雪，倒一点不像是丰年的兆头。\n\n![](title.jpg)\n\n来源:[Painterly snow | mclelun [pixiv] ](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=54902957)\n\n## TodoList\n\n### 此周完成\n\n+ 最小费用最大流模版 ✔终于颓了模版！\n+ dp试炼场！！！✘ 荒废\n+ 准备讲课（怎么着自己也得学会吧 ✘ 还有两周\n+ \b保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✔ 省选-好像也不是很难\n\n### 下周完成\n\n+ 图论关于连通分量、网络流、费用流的习题\n+ 刷题可以适当的少一点\n+ 学习更用心些吧 课上认真听课\n+ 看完《老人与海》\n+ 做一点物理小绿本的题\n","slug":"2018-MarWeek3","published":1,"updated":"2018-03-17T13:18:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3gz000tbljr1m3zd4td","content":"<p><strong>2018年三月 第三周</strong></p>\n<p><strong>2018.3.12-2018.3.18</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"500\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=429460399&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>转眼都过去三周了啊。</p>\n<p>一切渐入正轨吧。但是最近总是感觉课内学习做到的题超级的难。不知道是老师变态呢，还是我变弱了呢…而且有的时候还不想写作业。恐怕是药丸。以后上课还是应该好好听讲啊。</p>\n<p>暂且不管吧。但是现在还面临着一个比较尴尬的事情：如果做一些五三之类的大水练习册觉得无聊，可是做像什么小绿本小蓝本需要的时间又太多。</p>\n<p>啊。下定决心。要刷题，刷题。不管是数学、物理，还是信息。对于目前来看，只有刷题才能让自己从颓废中出去了。</p>\n<p>两周之后还要讲课。我还不会。感觉gg。</p>\n<hr>\n<p>有的时候，我也在想，如果我没有选择OI，那我现在的生活会是一个什么样子的。</p>\n<p>如果没有选择OI，那么现在，我多半是在打物理竞赛。最近上物理自招的课，却也觉得物理也比较有趣，而且物理毕竟是高考学科，比信息学也有一定的好处。</p>\n<p>但怎么说呢，我觉得选择OI就是命吧。</p>\n<p>在初三的时候，我还没有学过关于程序设计的任何知识（说来真是后悔哈。那个时候，学校的计算机课学的是<code>Scratch</code>的编程。想想也真的是不可思议。当时的我就用着那个可怜的图形界面的编程，自己写了好多有趣的程序。而且那个时候，虽然我还不知道任何关于什么递归啊，栈的概念，硬生生写了好几周，写出了一个能够解数独的程序。</p>\n<p>一切，也许都是注定的吧。诶。不应该说这么多的。</p>\n<hr>\n<p>北京下雪了呢。四个多月没有下过雨，也没有下过雪，今天终于得见。俗话说，瑞雪兆丰年。可我看着这雪，倒一点不像是丰年的兆头。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=54902957\" target=\"_blank\" rel=\"noopener\">Painterly snow | mclelun [pixiv] </a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>最小费用最大流模版 ✔终于颓了模版！</li>\n<li>dp试炼场！！！✘ 荒废</li>\n<li>准备讲课（怎么着自己也得学会吧 ✘ 还有两周</li>\n<li>\b保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✔ 省选-好像也不是很难</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>图论关于连通分量、网络流、费用流的习题</li>\n<li>刷题可以适当的少一点</li>\n<li>学习更用心些吧 课上认真听课</li>\n<li>看完《老人与海》</li>\n<li>做一点物理小绿本的题</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年三月 第三周</strong></p>\n<p><strong>2018.3.12-2018.3.18</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"500\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=429460399&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>转眼都过去三周了啊。</p>\n<p>一切渐入正轨吧。但是最近总是感觉课内学习做到的题超级的难。不知道是老师变态呢，还是我变弱了呢…而且有的时候还不想写作业。恐怕是药丸。以后上课还是应该好好听讲啊。</p>\n<p>暂且不管吧。但是现在还面临着一个比较尴尬的事情：如果做一些五三之类的大水练习册觉得无聊，可是做像什么小绿本小蓝本需要的时间又太多。</p>\n<p>啊。下定决心。要刷题，刷题。不管是数学、物理，还是信息。对于目前来看，只有刷题才能让自己从颓废中出去了。</p>\n<p>两周之后还要讲课。我还不会。感觉gg。</p>\n<hr>\n<p>有的时候，我也在想，如果我没有选择OI，那我现在的生活会是一个什么样子的。</p>\n<p>如果没有选择OI，那么现在，我多半是在打物理竞赛。最近上物理自招的课，却也觉得物理也比较有趣，而且物理毕竟是高考学科，比信息学也有一定的好处。</p>\n<p>但怎么说呢，我觉得选择OI就是命吧。</p>\n<p>在初三的时候，我还没有学过关于程序设计的任何知识（说来真是后悔哈。那个时候，学校的计算机课学的是<code>Scratch</code>的编程。想想也真的是不可思议。当时的我就用着那个可怜的图形界面的编程，自己写了好多有趣的程序。而且那个时候，虽然我还不知道任何关于什么递归啊，栈的概念，硬生生写了好几周，写出了一个能够解数独的程序。</p>\n<p>一切，也许都是注定的吧。诶。不应该说这么多的。</p>\n<hr>\n<p>北京下雪了呢。四个多月没有下过雨，也没有下过雪，今天终于得见。俗话说，瑞雪兆丰年。可我看着这雪，倒一点不像是丰年的兆头。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=54902957\" target=\"_blank\" rel=\"noopener\">Painterly snow | mclelun [pixiv] </a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"此周完成\"><a href=\"#此周完成\" class=\"headerlink\" title=\"此周完成\"></a>此周完成</h3><ul>\n<li>最小费用最大流模版 ✔终于颓了模版！</li>\n<li>dp试炼场！！！✘ 荒废</li>\n<li>准备讲课（怎么着自己也得学会吧 ✘ 还有两周</li>\n<li>\b保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✔ 省选-好像也不是很难</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>图论关于连通分量、网络流、费用流的习题</li>\n<li>刷题可以适当的少一点</li>\n<li>学习更用心些吧 课上认真听课</li>\n<li>看完《老人与海》</li>\n<li>做一点物理小绿本的题</li>\n</ul>"},{"title":"2018 MarWeek4","urlname":"2018-MarWeek4","date":"2018-03-25T14:11:27.000Z","visible":null,"_content":"\n**2018年三月 第四周**\n\n**2018.3.19-2018.3.25**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=120 src=\"//music.163.com/outchain/player?type=2&id=406355&auto=0&height=66\"></iframe>\n\n## 正文\n\n三月的最后一周。事情也不算少。周末有点事情，所以周一才发了出来。\n\n逸夫楼前的桃花开了。一年一度，到今年应当也是第四年了。想在这所学校里，不知度过了多少的青春岁月啊。每一年，这棵桃树都会盛放。虽说今年晚了一些，但是该来的总会来的。\n\n> 你若盛开，鲜花自来。\n\n- - -\n\n夏天真的要到了。口口声声的跟某人说了一个冬天，而等天气一天天的暖和起来，眼看着夏天就要来了，却真的感到痛彻的无能为力。\n\n最近总感觉学习有点不顺利。这几周没有什么考试，不能检验状态。但是以前还没有留意，今天一仔细回顾作业，就发现真的错了不少，跟以前的自己差了很多。我也在反思，这到底是为什么...或许是上课不认真？或许是精力付出的不够？或许只是一时马虎？暂且也不太清楚。\n\n感觉情况不容太多的乐观。但偏偏事情还是不少。OI在一个关键的时期，课内还有问题。付出的不够，收获也会缩水。我真的很想付出时间，尤其是`OI`，但真的，如果一天能掰成`48`个小时去用，如果，也许一切都会好一点吧。\n\n马上就四月了。感觉`NOIP`马上好像就要到了。离`NOIP2018`还有`229`天。\n\n忽然就想到，在离中考`229`天的时候，我在干些什么。那个时候应该还没有什么“考试欲来”的气氛，周末还能找个人玩玩，满市乱转。还记得在中考还有`255`天的时候，我在西直门的地铁站拍下一张照片发到了朋友圈，配上了中考倒数日。那个时候也许只是好玩，但现在虽说离`NOIP`还有`200`多天，但等到暑假能放开刷题的时候，时间恐怕也就一百天左右了。\n\n去年我校省队貌似只有六个人。等到高二退役，排掉两三个变态，我真的就能排进全年级前三吗？任重而道远啊。\n\n需要加倍的努力了，不管是在课内还是`OI`。\n\n- - -\n\n最近越写越长了，恳请各位的原谅。\n\n![](title.jpg)\n\n来源:[沁心 | 闭上眼听雨声 [pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57978165)\n\n## TodoList\n\n### 本周完成\n\n+ 图论关于连通分量、网络流、费用流的习题 ✔ 做了一些...\n+ 刷题可以适当的少一点 ✔ 差不多吧\n+ 学习更用心些吧 课上认真听课 ✔ 坚定的在课上没写什么作业\n+ 看完《老人与海》✔成功 虽然不记得什么了\n+ 做一点物理小绿本的题 ✔认真读了读并且坐了几道例题\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✔正好七道...\n\n### 下周完成\n\n+ 网络流 && 费用流的模型 && 习题\n+ 码课件！怼分块...\n+ 在晚自习上认真的写作业...\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 （这周可能要咕\n+ 学习`FFT`并过掉模版`P3803`\n","source":"_posts/2018-Marweek4.md","raw":"---\ntitle: 2018 MarWeek4\nurlname: 2018-MarWeek4\ndate: 2018-03-25 22:11:27\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年三月 第四周**\n\n**2018.3.19-2018.3.25**\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=120 src=\"//music.163.com/outchain/player?type=2&id=406355&auto=0&height=66\"></iframe>\n\n## 正文\n\n三月的最后一周。事情也不算少。周末有点事情，所以周一才发了出来。\n\n逸夫楼前的桃花开了。一年一度，到今年应当也是第四年了。想在这所学校里，不知度过了多少的青春岁月啊。每一年，这棵桃树都会盛放。虽说今年晚了一些，但是该来的总会来的。\n\n> 你若盛开，鲜花自来。\n\n- - -\n\n夏天真的要到了。口口声声的跟某人说了一个冬天，而等天气一天天的暖和起来，眼看着夏天就要来了，却真的感到痛彻的无能为力。\n\n最近总感觉学习有点不顺利。这几周没有什么考试，不能检验状态。但是以前还没有留意，今天一仔细回顾作业，就发现真的错了不少，跟以前的自己差了很多。我也在反思，这到底是为什么...或许是上课不认真？或许是精力付出的不够？或许只是一时马虎？暂且也不太清楚。\n\n感觉情况不容太多的乐观。但偏偏事情还是不少。OI在一个关键的时期，课内还有问题。付出的不够，收获也会缩水。我真的很想付出时间，尤其是`OI`，但真的，如果一天能掰成`48`个小时去用，如果，也许一切都会好一点吧。\n\n马上就四月了。感觉`NOIP`马上好像就要到了。离`NOIP2018`还有`229`天。\n\n忽然就想到，在离中考`229`天的时候，我在干些什么。那个时候应该还没有什么“考试欲来”的气氛，周末还能找个人玩玩，满市乱转。还记得在中考还有`255`天的时候，我在西直门的地铁站拍下一张照片发到了朋友圈，配上了中考倒数日。那个时候也许只是好玩，但现在虽说离`NOIP`还有`200`多天，但等到暑假能放开刷题的时候，时间恐怕也就一百天左右了。\n\n去年我校省队貌似只有六个人。等到高二退役，排掉两三个变态，我真的就能排进全年级前三吗？任重而道远啊。\n\n需要加倍的努力了，不管是在课内还是`OI`。\n\n- - -\n\n最近越写越长了，恳请各位的原谅。\n\n![](title.jpg)\n\n来源:[沁心 | 闭上眼听雨声 [pixiv]](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=57978165)\n\n## TodoList\n\n### 本周完成\n\n+ 图论关于连通分量、网络流、费用流的习题 ✔ 做了一些...\n+ 刷题可以适当的少一点 ✔ 差不多吧\n+ 学习更用心些吧 课上认真听课 ✔ 坚定的在课上没写什么作业\n+ 看完《老人与海》✔成功 虽然不记得什么了\n+ 做一点物理小绿本的题 ✔认真读了读并且坐了几道例题\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 ✔正好七道...\n\n### 下周完成\n\n+ 网络流 && 费用流的模型 && 习题\n+ 码课件！怼分块...\n+ 在晚自习上认真的写作业...\n+ 保证$1$天$1$道`Luogu` 省选- 及以上\b难度\b题目 （这周可能要咕\n+ 学习`FFT`并过掉模版`P3803`\n","slug":"2018-Marweek4","published":1,"updated":"2018-04-04T12:07:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3h5000vbljr3bmqg07s","content":"<p><strong>2018年三月 第四周</strong></p>\n<p><strong>2018.3.19-2018.3.25</strong><br><a id=\"more\"></a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"120\" src=\"//music.163.com/outchain/player?type=2&id=406355&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>三月的最后一周。事情也不算少。周末有点事情，所以周一才发了出来。</p>\n<p>逸夫楼前的桃花开了。一年一度，到今年应当也是第四年了。想在这所学校里，不知度过了多少的青春岁月啊。每一年，这棵桃树都会盛放。虽说今年晚了一些，但是该来的总会来的。</p>\n<blockquote>\n<p>你若盛开，鲜花自来。</p>\n</blockquote>\n<hr>\n<p>夏天真的要到了。口口声声的跟某人说了一个冬天，而等天气一天天的暖和起来，眼看着夏天就要来了，却真的感到痛彻的无能为力。</p>\n<p>最近总感觉学习有点不顺利。这几周没有什么考试，不能检验状态。但是以前还没有留意，今天一仔细回顾作业，就发现真的错了不少，跟以前的自己差了很多。我也在反思，这到底是为什么…或许是上课不认真？或许是精力付出的不够？或许只是一时马虎？暂且也不太清楚。</p>\n<p>感觉情况不容太多的乐观。但偏偏事情还是不少。OI在一个关键的时期，课内还有问题。付出的不够，收获也会缩水。我真的很想付出时间，尤其是<code>OI</code>，但真的，如果一天能掰成<code>48</code>个小时去用，如果，也许一切都会好一点吧。</p>\n<p>马上就四月了。感觉<code>NOIP</code>马上好像就要到了。离<code>NOIP2018</code>还有<code>229</code>天。</p>\n<p>忽然就想到，在离中考<code>229</code>天的时候，我在干些什么。那个时候应该还没有什么“考试欲来”的气氛，周末还能找个人玩玩，满市乱转。还记得在中考还有<code>255</code>天的时候，我在西直门的地铁站拍下一张照片发到了朋友圈，配上了中考倒数日。那个时候也许只是好玩，但现在虽说离<code>NOIP</code>还有<code>200</code>多天，但等到暑假能放开刷题的时候，时间恐怕也就一百天左右了。</p>\n<p>去年我校省队貌似只有六个人。等到高二退役，排掉两三个变态，我真的就能排进全年级前三吗？任重而道远啊。</p>\n<p>需要加倍的努力了，不管是在课内还是<code>OI</code>。</p>\n<hr>\n<p>最近越写越长了，恳请各位的原谅。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=57978165\" target=\"_blank\" rel=\"noopener\">沁心 | 闭上眼听雨声 [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>图论关于连通分量、网络流、费用流的习题 ✔ 做了一些…</li>\n<li>刷题可以适当的少一点 ✔ 差不多吧</li>\n<li>学习更用心些吧 课上认真听课 ✔ 坚定的在课上没写什么作业</li>\n<li>看完《老人与海》✔成功 虽然不记得什么了</li>\n<li>做一点物理小绿本的题 ✔认真读了读并且坐了几道例题</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✔正好七道…</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>网络流 &amp;&amp; 费用流的模型 &amp;&amp; 习题</li>\n<li>码课件！怼分块…</li>\n<li>在晚自习上认真的写作业…</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 （这周可能要咕</li>\n<li>学习<code>FFT</code>并过掉模版<code>P3803</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年三月 第四周</strong></p>\n<p><strong>2018.3.19-2018.3.25</strong><br>","more":"</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"120\" src=\"//music.163.com/outchain/player?type=2&id=406355&auto=0&height=66\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>三月的最后一周。事情也不算少。周末有点事情，所以周一才发了出来。</p>\n<p>逸夫楼前的桃花开了。一年一度，到今年应当也是第四年了。想在这所学校里，不知度过了多少的青春岁月啊。每一年，这棵桃树都会盛放。虽说今年晚了一些，但是该来的总会来的。</p>\n<blockquote>\n<p>你若盛开，鲜花自来。</p>\n</blockquote>\n<hr>\n<p>夏天真的要到了。口口声声的跟某人说了一个冬天，而等天气一天天的暖和起来，眼看着夏天就要来了，却真的感到痛彻的无能为力。</p>\n<p>最近总感觉学习有点不顺利。这几周没有什么考试，不能检验状态。但是以前还没有留意，今天一仔细回顾作业，就发现真的错了不少，跟以前的自己差了很多。我也在反思，这到底是为什么…或许是上课不认真？或许是精力付出的不够？或许只是一时马虎？暂且也不太清楚。</p>\n<p>感觉情况不容太多的乐观。但偏偏事情还是不少。OI在一个关键的时期，课内还有问题。付出的不够，收获也会缩水。我真的很想付出时间，尤其是<code>OI</code>，但真的，如果一天能掰成<code>48</code>个小时去用，如果，也许一切都会好一点吧。</p>\n<p>马上就四月了。感觉<code>NOIP</code>马上好像就要到了。离<code>NOIP2018</code>还有<code>229</code>天。</p>\n<p>忽然就想到，在离中考<code>229</code>天的时候，我在干些什么。那个时候应该还没有什么“考试欲来”的气氛，周末还能找个人玩玩，满市乱转。还记得在中考还有<code>255</code>天的时候，我在西直门的地铁站拍下一张照片发到了朋友圈，配上了中考倒数日。那个时候也许只是好玩，但现在虽说离<code>NOIP</code>还有<code>200</code>多天，但等到暑假能放开刷题的时候，时间恐怕也就一百天左右了。</p>\n<p>去年我校省队貌似只有六个人。等到高二退役，排掉两三个变态，我真的就能排进全年级前三吗？任重而道远啊。</p>\n<p>需要加倍的努力了，不管是在课内还是<code>OI</code>。</p>\n<hr>\n<p>最近越写越长了，恳请各位的原谅。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=57978165\" target=\"_blank\" rel=\"noopener\">沁心 | 闭上眼听雨声 [pixiv]</a></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>图论关于连通分量、网络流、费用流的习题 ✔ 做了一些…</li>\n<li>刷题可以适当的少一点 ✔ 差不多吧</li>\n<li>学习更用心些吧 课上认真听课 ✔ 坚定的在课上没写什么作业</li>\n<li>看完《老人与海》✔成功 虽然不记得什么了</li>\n<li>做一点物理小绿本的题 ✔认真读了读并且坐了几道例题</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 ✔正好七道…</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>网络流 &amp;&amp; 费用流的模型 &amp;&amp; 习题</li>\n<li>码课件！怼分块…</li>\n<li>在晚自习上认真的写作业…</li>\n<li>保证$1$天$1$道<code>Luogu</code> 省选- 及以上\b难度\b题目 （这周可能要咕</li>\n<li>学习<code>FFT</code>并过掉模版<code>P3803</code></li>\n</ul>"},{"title":"2018 MayWeek1","urlname":"2018-MayWeek1","date":"2018-05-05T03:24:07.000Z","visible":null,"_content":"\n**2018年五月 第一周**\n\n**2018.4.30-2018.5.6**\n\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=413829859&auto=0&height=100\"></iframe>\n\n## 正文\n\n这一周其实没干什么事情。\n\n期中平静的过去了，学习却永远不会停止。物理开了选修3-1，数学开始了解析几何，生物也进入了进化区域的学习。\n\n最近其实感觉压力很大。数学的解析真的不简单，虽然只是算算算但是还是对于技巧的要求比较高。以前没有接触过，很心累。\n\n听说北京的高考方案出了。对我这样的人谈不上非常有利，但我认为如果我去拼一拼的话也不是不可以忍受的一个制度，毕竟按北京市大排名对我们这样的学校还是有一定的优势的。但是谈何易，行何难啊。\n\n最近不停的在问自己：到底能不能在竞赛上取得成绩？需要付出自己的全部吗？\n\n有的时候，内心笃定；有的时候，却很犹疑。\n\n无论如何，半年之后，一切分晓。\n\n![](title.jpg)\n\n*来源：[Dear Earth | pixiv ](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58898030)*\n\n## Todolist\n### 本周刷题\n{% fold %}\n+ [SDOI2006]保安站岗 \n    - 树形dp\n+ [POI2007]MEG-Megalopolis \n    - dfs序 + 树状数组\n+ [NOI2011]道路修建 \n    - dfs + 暴力\n+ [NOI2012]美食节 \n+ [SDOI2009]晨跑 \n    - 费用流\n+ [NOIP2017]时间复杂度 \n    - 模拟\n+ [ZJOI2007]棋盘制作 \n    - dp\n+ 最小路径覆盖问题\n    - 网络流 二分图\n+ [Luogu P3919]【模板】可持久化数组\n    - 可持久化线段树\n+ [Luogu P3381]【模板】最小费用最大流 \n    - 费用流的原始对偶算法\n+ [Luogu P3834] 【模板】可持久化线段树 1\n+ [POI2014]KUR-Couriers \n    - 可持久化权值线段树（主席树）\n{% endfold %}\n\n### 本周完成\n+ 若干dp的题目 ✔\n+ 关于Splay的课件 ✘\n+ `LCT`模板题 ✘\n\n### 下周目标\n\n+ 可持久化系列\n+ 平衡树课件\n+ 一天一道 `Luogu` 省选-以上的题目\n","source":"_posts/2018-MayWeek1.md","raw":"---\ntitle: 2018 MayWeek1\nurlname: 2018-MayWeek1\ndate: 2018-05-05 11:24:07\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年五月 第一周**\n\n**2018.4.30-2018.5.6**\n\n<!-- more -->\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=413829859&auto=0&height=100\"></iframe>\n\n## 正文\n\n这一周其实没干什么事情。\n\n期中平静的过去了，学习却永远不会停止。物理开了选修3-1，数学开始了解析几何，生物也进入了进化区域的学习。\n\n最近其实感觉压力很大。数学的解析真的不简单，虽然只是算算算但是还是对于技巧的要求比较高。以前没有接触过，很心累。\n\n听说北京的高考方案出了。对我这样的人谈不上非常有利，但我认为如果我去拼一拼的话也不是不可以忍受的一个制度，毕竟按北京市大排名对我们这样的学校还是有一定的优势的。但是谈何易，行何难啊。\n\n最近不停的在问自己：到底能不能在竞赛上取得成绩？需要付出自己的全部吗？\n\n有的时候，内心笃定；有的时候，却很犹疑。\n\n无论如何，半年之后，一切分晓。\n\n![](title.jpg)\n\n*来源：[Dear Earth | pixiv ](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58898030)*\n\n## Todolist\n### 本周刷题\n{% fold %}\n+ [SDOI2006]保安站岗 \n    - 树形dp\n+ [POI2007]MEG-Megalopolis \n    - dfs序 + 树状数组\n+ [NOI2011]道路修建 \n    - dfs + 暴力\n+ [NOI2012]美食节 \n+ [SDOI2009]晨跑 \n    - 费用流\n+ [NOIP2017]时间复杂度 \n    - 模拟\n+ [ZJOI2007]棋盘制作 \n    - dp\n+ 最小路径覆盖问题\n    - 网络流 二分图\n+ [Luogu P3919]【模板】可持久化数组\n    - 可持久化线段树\n+ [Luogu P3381]【模板】最小费用最大流 \n    - 费用流的原始对偶算法\n+ [Luogu P3834] 【模板】可持久化线段树 1\n+ [POI2014]KUR-Couriers \n    - 可持久化权值线段树（主席树）\n{% endfold %}\n\n### 本周完成\n+ 若干dp的题目 ✔\n+ 关于Splay的课件 ✘\n+ `LCT`模板题 ✘\n\n### 下周目标\n\n+ 可持久化系列\n+ 平衡树课件\n+ 一天一道 `Luogu` 省选-以上的题目\n","slug":"2018-MayWeek1","published":1,"updated":"2018-05-05T15:03:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3h9000xbljr74t9zysk","content":"<p><strong>2018年五月 第一周</strong></p>\n<p><strong>2018.4.30-2018.5.6</strong></p>\n<a id=\"more\"></a>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=413829859&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周其实没干什么事情。</p>\n<p>期中平静的过去了，学习却永远不会停止。物理开了选修3-1，数学开始了解析几何，生物也进入了进化区域的学习。</p>\n<p>最近其实感觉压力很大。数学的解析真的不简单，虽然只是算算算但是还是对于技巧的要求比较高。以前没有接触过，很心累。</p>\n<p>听说北京的高考方案出了。对我这样的人谈不上非常有利，但我认为如果我去拼一拼的话也不是不可以忍受的一个制度，毕竟按北京市大排名对我们这样的学校还是有一定的优势的。但是谈何易，行何难啊。</p>\n<p>最近不停的在问自己：到底能不能在竞赛上取得成绩？需要付出自己的全部吗？</p>\n<p>有的时候，内心笃定；有的时候，却很犹疑。</p>\n<p>无论如何，半年之后，一切分晓。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=58898030\" target=\"_blank\" rel=\"noopener\">Dear Earth | pixiv </a></em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2006]保安站岗 <ul>\n<li>树形dp</li>\n</ul>\n</li>\n<li>[POI2007]MEG-Megalopolis <ul>\n<li>dfs序 + 树状数组</li>\n</ul>\n</li>\n<li>[NOI2011]道路修建 <ul>\n<li>dfs + 暴力</li>\n</ul>\n</li>\n<li>[NOI2012]美食节 </li>\n<li>[SDOI2009]晨跑 <ul>\n<li>费用流</li>\n</ul>\n</li>\n<li>[NOIP2017]时间复杂度 <ul>\n<li>模拟</li>\n</ul>\n</li>\n<li>[ZJOI2007]棋盘制作 <ul>\n<li>dp</li>\n</ul>\n</li>\n<li>最小路径覆盖问题<ul>\n<li>网络流 二分图</li>\n</ul>\n</li>\n<li>[Luogu P3919]【模板】可持久化数组<ul>\n<li>可持久化线段树</li>\n</ul>\n</li>\n<li>[Luogu P3381]【模板】最小费用最大流 <ul>\n<li>费用流的原始对偶算法</li>\n</ul>\n</li>\n<li>[Luogu P3834] 【模板】可持久化线段树 1</li>\n<li>[POI2014]KUR-Couriers <ul>\n<li>可持久化权值线段树（主席树）</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>若干dp的题目 ✔</li>\n<li>关于Splay的课件 ✘</li>\n<li><code>LCT</code>模板题 ✘</li>\n</ul>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>可持久化系列</li>\n<li>平衡树课件</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年五月 第一周</strong></p>\n<p><strong>2018.4.30-2018.5.6</strong></p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=413829859&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这一周其实没干什么事情。</p>\n<p>期中平静的过去了，学习却永远不会停止。物理开了选修3-1，数学开始了解析几何，生物也进入了进化区域的学习。</p>\n<p>最近其实感觉压力很大。数学的解析真的不简单，虽然只是算算算但是还是对于技巧的要求比较高。以前没有接触过，很心累。</p>\n<p>听说北京的高考方案出了。对我这样的人谈不上非常有利，但我认为如果我去拼一拼的话也不是不可以忍受的一个制度，毕竟按北京市大排名对我们这样的学校还是有一定的优势的。但是谈何易，行何难啊。</p>\n<p>最近不停的在问自己：到底能不能在竞赛上取得成绩？需要付出自己的全部吗？</p>\n<p>有的时候，内心笃定；有的时候，却很犹疑。</p>\n<p>无论如何，半年之后，一切分晓。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=58898030\" target=\"_blank\" rel=\"noopener\">Dear Earth | pixiv </a></em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2006]保安站岗 <ul>\n<li>树形dp</li>\n</ul>\n</li>\n<li>[POI2007]MEG-Megalopolis <ul>\n<li>dfs序 + 树状数组</li>\n</ul>\n</li>\n<li>[NOI2011]道路修建 <ul>\n<li>dfs + 暴力</li>\n</ul>\n</li>\n<li>[NOI2012]美食节 </li>\n<li>[SDOI2009]晨跑 <ul>\n<li>费用流</li>\n</ul>\n</li>\n<li>[NOIP2017]时间复杂度 <ul>\n<li>模拟</li>\n</ul>\n</li>\n<li>[ZJOI2007]棋盘制作 <ul>\n<li>dp</li>\n</ul>\n</li>\n<li>最小路径覆盖问题<ul>\n<li>网络流 二分图</li>\n</ul>\n</li>\n<li>[Luogu P3919]【模板】可持久化数组<ul>\n<li>可持久化线段树</li>\n</ul>\n</li>\n<li>[Luogu P3381]【模板】最小费用最大流 <ul>\n<li>费用流的原始对偶算法</li>\n</ul>\n</li>\n<li>[Luogu P3834] 【模板】可持久化线段树 1</li>\n<li>[POI2014]KUR-Couriers <ul>\n<li>可持久化权值线段树（主席树）</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>若干dp的题目 ✔</li>\n<li>关于Splay的课件 ✘</li>\n<li><code>LCT</code>模板题 ✘</li>\n</ul>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>可持久化系列</li>\n<li>平衡树课件</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目</li>\n</ul>"},{"title":"2018 MayWeek2","urlname":"2018-MayWeek2","date":"2018-05-12T13:19:12.000Z","visible":null,"_content":"\n**2018年五月 第二周**\n\n**2018.5.7-2018.5.13**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=520059410&auto=1&height=100\"></iframe>\n\n## 正文\n\n这周其实很平淡。没有什么特殊的事情。\n\n只不过比较颓废。期中刚过，就只剩下一个月就要期末考试。虽然听说不难，但七科都不是本校出题，还是有点慌的。这一周还有就是被各种乱七八糟的活动烦个半死。不喜欢这种感觉。我想，我还是更喜欢啥都不管。比起没有权力，还是没有义务比较惬意。不过话说回来，主要还是这个东西太烦人，又要搞什么图片文字说明这个学期做了啥大事...可真的没什么大事可做啊...真是令人无话可说（绝望脸\n\n这几周一直有点迷茫。到底选什么科...到底学竞赛还是主攻课内...都是问题。不过时间大约还是够的吧。现在还是在自己喜欢的方向多去拼一拼吧，毕竟，人生不再啊。\n\n生竞明天初赛。他们还有两次机会，我只有一次。\n\n> 距离NOIP2018还有5个月30天\n\n我相信，明年再来看的时候，我一定能说出：我为了梦想，拼搏过。\n- - -\n![](title.jpg)\n\n*汶川大地震10周年。愿逝者安息，生者坚强。*\n\n\n## Todolist\n### 本周刷题\n\n{% fold %}\n+ [SDOI2013]直径 \n    - 树的直径\n+ [湖南集训]谈笑风生 \n    - 主席树／dfs\n+ [Luogu P4178] Tree\n    - 点分治\n+ [Luogu P2633] Count on a tree \n    - 树上主席树\n+ [Luogu P2617] Dynamic Rankings \n    - 树状数组+可持久化线段树\n+ [SDOI2008]洞穴勘测 \n    - LCT\n+ [Luogu P3690]【模板】Link Cut Tree\n    - LCT\n+ [SDOI2008]郁闷的小J \n    - 平衡树\n+ [NOIP2017]跳房子\n    - 单调队列\n{% endfold %}\n\n### 本周完成\n\n+ 可持久化系列 ✔一点\n+ 平衡树课件 ✔一点\n+ 一天一道 `Luogu` 省选-以上的题目 ✔大概够吧\n\n### 下周目标\n\n+ LCT的较高端应用\n+ 后缀数组的$SA-IS$、倍增算法\n+ 可持久化系列\n+ 一天一道 `Luogu` 省选-以上的题目\n","source":"_posts/2018-MayWeek2.md","raw":"---\ntitle: 2018 MayWeek2\nurlname: 2018-MayWeek2\ndate: 2018-05-12 21:19:12\ntags:\ncategories: 总结\nvisible:\n---\n\n**2018年五月 第二周**\n\n**2018.5.7-2018.5.13**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=520059410&auto=1&height=100\"></iframe>\n\n## 正文\n\n这周其实很平淡。没有什么特殊的事情。\n\n只不过比较颓废。期中刚过，就只剩下一个月就要期末考试。虽然听说不难，但七科都不是本校出题，还是有点慌的。这一周还有就是被各种乱七八糟的活动烦个半死。不喜欢这种感觉。我想，我还是更喜欢啥都不管。比起没有权力，还是没有义务比较惬意。不过话说回来，主要还是这个东西太烦人，又要搞什么图片文字说明这个学期做了啥大事...可真的没什么大事可做啊...真是令人无话可说（绝望脸\n\n这几周一直有点迷茫。到底选什么科...到底学竞赛还是主攻课内...都是问题。不过时间大约还是够的吧。现在还是在自己喜欢的方向多去拼一拼吧，毕竟，人生不再啊。\n\n生竞明天初赛。他们还有两次机会，我只有一次。\n\n> 距离NOIP2018还有5个月30天\n\n我相信，明年再来看的时候，我一定能说出：我为了梦想，拼搏过。\n- - -\n![](title.jpg)\n\n*汶川大地震10周年。愿逝者安息，生者坚强。*\n\n\n## Todolist\n### 本周刷题\n\n{% fold %}\n+ [SDOI2013]直径 \n    - 树的直径\n+ [湖南集训]谈笑风生 \n    - 主席树／dfs\n+ [Luogu P4178] Tree\n    - 点分治\n+ [Luogu P2633] Count on a tree \n    - 树上主席树\n+ [Luogu P2617] Dynamic Rankings \n    - 树状数组+可持久化线段树\n+ [SDOI2008]洞穴勘测 \n    - LCT\n+ [Luogu P3690]【模板】Link Cut Tree\n    - LCT\n+ [SDOI2008]郁闷的小J \n    - 平衡树\n+ [NOIP2017]跳房子\n    - 单调队列\n{% endfold %}\n\n### 本周完成\n\n+ 可持久化系列 ✔一点\n+ 平衡树课件 ✔一点\n+ 一天一道 `Luogu` 省选-以上的题目 ✔大概够吧\n\n### 下周目标\n\n+ LCT的较高端应用\n+ 后缀数组的$SA-IS$、倍增算法\n+ 可持久化系列\n+ 一天一道 `Luogu` 省选-以上的题目\n","slug":"2018-MayWeek2","published":1,"updated":"2018-05-12T23:59:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hb000zbljr1cxdhxdl","content":"<p><strong>2018年五月 第二周</strong></p>\n<p><strong>2018.5.7-2018.5.13</strong></p>\n<a id=\"more\"></a>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=520059410&auto=1&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这周其实很平淡。没有什么特殊的事情。</p>\n<p>只不过比较颓废。期中刚过，就只剩下一个月就要期末考试。虽然听说不难，但七科都不是本校出题，还是有点慌的。这一周还有就是被各种乱七八糟的活动烦个半死。不喜欢这种感觉。我想，我还是更喜欢啥都不管。比起没有权力，还是没有义务比较惬意。不过话说回来，主要还是这个东西太烦人，又要搞什么图片文字说明这个学期做了啥大事…可真的没什么大事可做啊…真是令人无话可说（绝望脸</p>\n<p>这几周一直有点迷茫。到底选什么科…到底学竞赛还是主攻课内…都是问题。不过时间大约还是够的吧。现在还是在自己喜欢的方向多去拼一拼吧，毕竟，人生不再啊。</p>\n<p>生竞明天初赛。他们还有两次机会，我只有一次。</p>\n<blockquote>\n<p>距离NOIP2018还有5个月30天</p>\n</blockquote>\n<p>我相信，明年再来看的时候，我一定能说出：我为了梦想，拼搏过。</p>\n<hr>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>汶川大地震10周年。愿逝者安息，生者坚强。</em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2013]直径 <ul>\n<li>树的直径</li>\n</ul>\n</li>\n<li>[湖南集训]谈笑风生 <ul>\n<li>主席树／dfs</li>\n</ul>\n</li>\n<li>[Luogu P4178] Tree<ul>\n<li>点分治</li>\n</ul>\n</li>\n<li>[Luogu P2633] Count on a tree <ul>\n<li>树上主席树</li>\n</ul>\n</li>\n<li>[Luogu P2617] Dynamic Rankings <ul>\n<li>树状数组+可持久化线段树</li>\n</ul>\n</li>\n<li>[SDOI2008]洞穴勘测 <ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[Luogu P3690]【模板】Link Cut Tree<ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[SDOI2008]郁闷的小J <ul>\n<li>平衡树</li>\n</ul>\n</li>\n<li>[NOIP2017]跳房子<ul>\n<li>单调队列</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>可持久化系列 ✔一点</li>\n<li>平衡树课件 ✔一点</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔大概够吧</li>\n</ul>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>LCT的较高端应用</li>\n<li>后缀数组的$SA-IS$、倍增算法</li>\n<li>可持久化系列</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>2018年五月 第二周</strong></p>\n<p><strong>2018.5.7-2018.5.13</strong></p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=520059410&auto=1&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这周其实很平淡。没有什么特殊的事情。</p>\n<p>只不过比较颓废。期中刚过，就只剩下一个月就要期末考试。虽然听说不难，但七科都不是本校出题，还是有点慌的。这一周还有就是被各种乱七八糟的活动烦个半死。不喜欢这种感觉。我想，我还是更喜欢啥都不管。比起没有权力，还是没有义务比较惬意。不过话说回来，主要还是这个东西太烦人，又要搞什么图片文字说明这个学期做了啥大事…可真的没什么大事可做啊…真是令人无话可说（绝望脸</p>\n<p>这几周一直有点迷茫。到底选什么科…到底学竞赛还是主攻课内…都是问题。不过时间大约还是够的吧。现在还是在自己喜欢的方向多去拼一拼吧，毕竟，人生不再啊。</p>\n<p>生竞明天初赛。他们还有两次机会，我只有一次。</p>\n<blockquote>\n<p>距离NOIP2018还有5个月30天</p>\n</blockquote>\n<p>我相信，明年再来看的时候，我一定能说出：我为了梦想，拼搏过。</p>\n<hr>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p><em>汶川大地震10周年。愿逝者安息，生者坚强。</em></p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2013]直径 <ul>\n<li>树的直径</li>\n</ul>\n</li>\n<li>[湖南集训]谈笑风生 <ul>\n<li>主席树／dfs</li>\n</ul>\n</li>\n<li>[Luogu P4178] Tree<ul>\n<li>点分治</li>\n</ul>\n</li>\n<li>[Luogu P2633] Count on a tree <ul>\n<li>树上主席树</li>\n</ul>\n</li>\n<li>[Luogu P2617] Dynamic Rankings <ul>\n<li>树状数组+可持久化线段树</li>\n</ul>\n</li>\n<li>[SDOI2008]洞穴勘测 <ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[Luogu P3690]【模板】Link Cut Tree<ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[SDOI2008]郁闷的小J <ul>\n<li>平衡树</li>\n</ul>\n</li>\n<li>[NOIP2017]跳房子<ul>\n<li>单调队列</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h3><ul>\n<li>可持久化系列 ✔一点</li>\n<li>平衡树课件 ✔一点</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔大概够吧</li>\n</ul>\n<h3 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h3><ul>\n<li>LCT的较高端应用</li>\n<li>后缀数组的$SA-IS$、倍增算法</li>\n<li>可持久化系列</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目</li>\n</ul>"},{"title":"2018 MayWeek3","urlname":"2018-MayWeek3","date":"2018-05-20T14:08:28.000Z","visible":null,"_content":"\n**二〇一八年五月 第三周**\n\n**2018.5.14-2018.5.20**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=106107&auto=0&height=100\"></iframe>\n\n## 正文\n\n一周无事。\n\n期中也过去了不止一周了，还有三周就要期末了。（nc的学期规划\n\n这一周真的没有什么新闻。学习了超过两周的SA-IS终于敲出来了，耶！不过`xehoth`大神的常数着实可怕...我目前还想不到什么好的可以再优化内存使用的办法了...巨佬的常数只有我的1/2...真是令人绝望。\n\n打了一次luogu月赛，在令人绝望的卡顿中做题，在FST之前居然获得了第三的排名...真是令人惊讶。看来打CF着实能锻炼人的xjb猜结论的能力...\n\n最近北京经常下雨，这一周就被雨堵在各种地方好几次，不过下下大雨总比闷着好几天要好到不知道哪里去了。\n\n今天5.20。自己祝自己快乐。\n\n![](title.jpg)\n\n来源:pixiv\n\n## Todolist\n\n### 本周刷题\n\n{% fold %}\n+ [SDOI2011]消防 \n    - 树的直径+单调队列\n+ [Luogu P3809] 【模板】后缀排序\n    - SA-IS算法\n+ [HNOI2009]梦幻布丁 \n    - 平衡树（set）启发式合并\n+ [ZJOI2012]旅游\n    - 对偶图+树的直径\n+ [Luogu P2195] HXY造公园 \n    - 树的直径\n+ [HAOI2007]理想的正方形\n    - 二维单调队列\n+ [HNOI2010]弹飞绵羊 \n    - LCT\n+ [CQOI2015]任务查询系统\n    - 主席树+扫描线\n+ [SDOI2013]森林\n    - 树上主席树+启发式合并\n+ [LGR-047]洛谷5月月赛\n    - A:取石子-简单博弈\n    - B:偷上网-随机化\n    - D:太极剑-随机化+贪心（非正解） \n\n{% endfold %}\n\n## 本周完成\n\n+ LCT的较高端应用 ✘目前只会垃圾应用\n+ 后缀数组的$SA-IS$、倍增算法 ✔倍增算法还是没学\n+ 可持久化系列 ✔2*超级大主席树\n+ 一天一道 `Luogu` 省选-以上的题目 ✔9道\n\n## 下周完成\n\n+ 后缀数组试炼场（老师留的）2-3题\n+ 温习AC自动机并补上学习笔记\n+ 补课件...\n+ 一天一道 `Luogu` 省选-以上的题目 ","source":"_posts/2018-MayWeek3.md","raw":"---\ntitle: 2018 MayWeek3\nurlname: 2018-MayWeek3\ndate: 2018-05-20 22:08:28\ntags: \ncategories: 总结\nvisible:\n---\n\n**二〇一八年五月 第三周**\n\n**2018.5.14-2018.5.20**\n\n<!-- more -->\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=106107&auto=0&height=100\"></iframe>\n\n## 正文\n\n一周无事。\n\n期中也过去了不止一周了，还有三周就要期末了。（nc的学期规划\n\n这一周真的没有什么新闻。学习了超过两周的SA-IS终于敲出来了，耶！不过`xehoth`大神的常数着实可怕...我目前还想不到什么好的可以再优化内存使用的办法了...巨佬的常数只有我的1/2...真是令人绝望。\n\n打了一次luogu月赛，在令人绝望的卡顿中做题，在FST之前居然获得了第三的排名...真是令人惊讶。看来打CF着实能锻炼人的xjb猜结论的能力...\n\n最近北京经常下雨，这一周就被雨堵在各种地方好几次，不过下下大雨总比闷着好几天要好到不知道哪里去了。\n\n今天5.20。自己祝自己快乐。\n\n![](title.jpg)\n\n来源:pixiv\n\n## Todolist\n\n### 本周刷题\n\n{% fold %}\n+ [SDOI2011]消防 \n    - 树的直径+单调队列\n+ [Luogu P3809] 【模板】后缀排序\n    - SA-IS算法\n+ [HNOI2009]梦幻布丁 \n    - 平衡树（set）启发式合并\n+ [ZJOI2012]旅游\n    - 对偶图+树的直径\n+ [Luogu P2195] HXY造公园 \n    - 树的直径\n+ [HAOI2007]理想的正方形\n    - 二维单调队列\n+ [HNOI2010]弹飞绵羊 \n    - LCT\n+ [CQOI2015]任务查询系统\n    - 主席树+扫描线\n+ [SDOI2013]森林\n    - 树上主席树+启发式合并\n+ [LGR-047]洛谷5月月赛\n    - A:取石子-简单博弈\n    - B:偷上网-随机化\n    - D:太极剑-随机化+贪心（非正解） \n\n{% endfold %}\n\n## 本周完成\n\n+ LCT的较高端应用 ✘目前只会垃圾应用\n+ 后缀数组的$SA-IS$、倍增算法 ✔倍增算法还是没学\n+ 可持久化系列 ✔2*超级大主席树\n+ 一天一道 `Luogu` 省选-以上的题目 ✔9道\n\n## 下周完成\n\n+ 后缀数组试炼场（老师留的）2-3题\n+ 温习AC自动机并补上学习笔记\n+ 补课件...\n+ 一天一道 `Luogu` 省选-以上的题目 ","slug":"2018-MayWeek3","published":1,"updated":"2018-06-02T15:30:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hc0011bljrc2qwlqpw","content":"<p><strong>二〇一八年五月 第三周</strong></p>\n<p><strong>2018.5.14-2018.5.20</strong></p>\n<a id=\"more\"></a>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=106107&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>一周无事。</p>\n<p>期中也过去了不止一周了，还有三周就要期末了。（nc的学期规划</p>\n<p>这一周真的没有什么新闻。学习了超过两周的SA-IS终于敲出来了，耶！不过<code>xehoth</code>大神的常数着实可怕…我目前还想不到什么好的可以再优化内存使用的办法了…巨佬的常数只有我的1/2…真是令人绝望。</p>\n<p>打了一次luogu月赛，在令人绝望的卡顿中做题，在FST之前居然获得了第三的排名…真是令人惊讶。看来打CF着实能锻炼人的xjb猜结论的能力…</p>\n<p>最近北京经常下雨，这一周就被雨堵在各种地方好几次，不过下下大雨总比闷着好几天要好到不知道哪里去了。</p>\n<p>今天5.20。自己祝自己快乐。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:pixiv</p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2011]消防 <ul>\n<li>树的直径+单调队列</li>\n</ul>\n</li>\n<li>[Luogu P3809] 【模板】后缀排序<ul>\n<li>SA-IS算法</li>\n</ul>\n</li>\n<li>[HNOI2009]梦幻布丁 <ul>\n<li>平衡树（set）启发式合并</li>\n</ul>\n</li>\n<li>[ZJOI2012]旅游<ul>\n<li>对偶图+树的直径</li>\n</ul>\n</li>\n<li>[Luogu P2195] HXY造公园 <ul>\n<li>树的直径</li>\n</ul>\n</li>\n<li>[HAOI2007]理想的正方形<ul>\n<li>二维单调队列</li>\n</ul>\n</li>\n<li>[HNOI2010]弹飞绵羊 <ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[CQOI2015]任务查询系统<ul>\n<li>主席树+扫描线</li>\n</ul>\n</li>\n<li>[SDOI2013]森林<ul>\n<li>树上主席树+启发式合并</li>\n</ul>\n</li>\n<li>[LGR-047]洛谷5月月赛<ul>\n<li>A:取石子-简单博弈</li>\n<li>B:偷上网-随机化</li>\n<li>D:太极剑-随机化+贪心（非正解） </li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h2 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h2><ul>\n<li>LCT的较高端应用 ✘目前只会垃圾应用</li>\n<li>后缀数组的$SA-IS$、倍增算法 ✔倍增算法还是没学</li>\n<li>可持久化系列 ✔2*超级大主席树</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔9道</li>\n</ul>\n<h2 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h2><ul>\n<li>后缀数组试炼场（老师留的）2-3题</li>\n<li>温习AC自动机并补上学习笔记</li>\n<li>补课件…</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 </li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>二〇一八年五月 第三周</strong></p>\n<p><strong>2018.5.14-2018.5.20</strong></p>","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=106107&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>一周无事。</p>\n<p>期中也过去了不止一周了，还有三周就要期末了。（nc的学期规划</p>\n<p>这一周真的没有什么新闻。学习了超过两周的SA-IS终于敲出来了，耶！不过<code>xehoth</code>大神的常数着实可怕…我目前还想不到什么好的可以再优化内存使用的办法了…巨佬的常数只有我的1/2…真是令人绝望。</p>\n<p>打了一次luogu月赛，在令人绝望的卡顿中做题，在FST之前居然获得了第三的排名…真是令人惊讶。看来打CF着实能锻炼人的xjb猜结论的能力…</p>\n<p>最近北京经常下雨，这一周就被雨堵在各种地方好几次，不过下下大雨总比闷着好几天要好到不知道哪里去了。</p>\n<p>今天5.20。自己祝自己快乐。</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<p>来源:pixiv</p>\n<h2 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h2><h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[SDOI2011]消防 <ul>\n<li>树的直径+单调队列</li>\n</ul>\n</li>\n<li>[Luogu P3809] 【模板】后缀排序<ul>\n<li>SA-IS算法</li>\n</ul>\n</li>\n<li>[HNOI2009]梦幻布丁 <ul>\n<li>平衡树（set）启发式合并</li>\n</ul>\n</li>\n<li>[ZJOI2012]旅游<ul>\n<li>对偶图+树的直径</li>\n</ul>\n</li>\n<li>[Luogu P2195] HXY造公园 <ul>\n<li>树的直径</li>\n</ul>\n</li>\n<li>[HAOI2007]理想的正方形<ul>\n<li>二维单调队列</li>\n</ul>\n</li>\n<li>[HNOI2010]弹飞绵羊 <ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[CQOI2015]任务查询系统<ul>\n<li>主席树+扫描线</li>\n</ul>\n</li>\n<li>[SDOI2013]森林<ul>\n<li>树上主席树+启发式合并</li>\n</ul>\n</li>\n<li>[LGR-047]洛谷5月月赛<ul>\n<li>A:取石子-简单博弈</li>\n<li>B:偷上网-随机化</li>\n<li>D:太极剑-随机化+贪心（非正解） </li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h2 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h2><ul>\n<li>LCT的较高端应用 ✘目前只会垃圾应用</li>\n<li>后缀数组的$SA-IS$、倍增算法 ✔倍增算法还是没学</li>\n<li>可持久化系列 ✔2*超级大主席树</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔9道</li>\n</ul>\n<h2 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h2><ul>\n<li>后缀数组试炼场（老师留的）2-3题</li>\n<li>温习AC自动机并补上学习笔记</li>\n<li>补课件…</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 </li>\n</ul>"},{"title":"2018 MayWeek4&5","urlname":"2018-MayWeek4-5","date":"2018-06-02T14:46:57.000Z","visible":null,"_content":"\n**二〇一八年五月 第四至五周**\n\n**2018.5.21-2018.6.3**\n\n从此以后，总结改为两周一篇，一月两到三篇，命名方式为「xxxx年 x月上（下）」。\n\n<!-- more -->\n\n但事实上我尽量还是每周写一次，只不过把两篇合成一篇罢了。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=477922&auto=0&height=100\"></iframe>\n\n## 正文\n\n这两周很忙，所以我到了这一周才有时间总结一下这两周的学习和生活。\n\n其实我都快忘了上周做了写什么，那就只说说这一周吧。\n\n如果我没记错的话，这一周考了若干次统练。其实我最反感的就是贵校把统练堆到最后一周的行为，真的让人一周都无法安宁。首先是复习生物，考完生物复习历史地理，然后又复习化学政治啥啥，强迫你在这一周进行大规模的复习。真的很烦。而且这一周我的绝大多数时间都用在了做Splay的ppt上，真的非常痛苦。抱着一个配置不高的笔记本做ppt到50+的酸爽，真的让人绝望啊。\n\n所幸这周末终于讲完了，所幸一切又有了喘息的机会。\n\n选科，是第二个话题。学校里，大家见面，除了“您太强了”，第二句话就是“您选什么科”？大家各有各的想法。有的人认为自己毫无退路，只好选上理化生，有的人纠结再三，还是选了理化生，有的人本来意向坚定，但被老师一说，又开始犹豫起来。\n\n总之吧，一同乱象。有的人说的很好：中国人，最擅长的就是忙一些没有什么用的事情，而且乐在其中。我想，这大概就是典型的案例吧。\n\n选完科之后也不太平。机读卡一交上去，学校仿佛也会慌。大家都不知道会发生什么，也不知道学校的目的是什么。\n\n如果让我用几个字来概括这件事情的话，我恐怕只能说：“纯粹瞎搞。”\n\n![](title.jpg)\n\n## TodoList\n\n### 这两周刷题\n\n{% fold %}\n+ [LNOI2014]LCA \n    + 树链剖分\n+ 【模板】普通平衡树（Treap/SBT） \n    + Splay版\n+ [SCOI2013]多项式的运算 \n    + Splay维护区间\n+ [HNOI2012]永无乡\n    + Splay启发式合并\n+ [SDOI2008]Sandy的卡片 \n    + 后缀数组\n+ [ZJOI2012]灾难\n    + LCA + 并查集\n+ [SDOI2014]旅行\n    + 动态开点线段树+树链剖分\n+ [SCOI2016]萌萌哒 \n    + 神级并查集\n+ 【模板】可持久化并查集 \n    + 可持久化线段树\n{% endfold %}\n\n### 上周完成\n\n+ 后缀数组试炼场（老师留的）2-3题 ✘1道\n+ 温习AC自动机并补上学习笔记 ✘大失败\n+ 补课件... ✔成功.jpeg\n+ 一天一道 `Luogu` 省选-以上的题目 ✔2周10道\n\n\n### 下周完成\n\n+ 学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)\n+ 学习后缀自动机`SAM`\n+ 做一些简单的dp题目\n+ 好好复习期末\n+ 补觉","source":"_posts/2018-MayWeek4-5.md","raw":"---\ntitle: 2018 MayWeek4&5\nurlname: 2018-MayWeek4-5\ndate: 2018-06-02 22:46:57\ntags:\ncategories: 总结\nvisible:\n---\n\n**二〇一八年五月 第四至五周**\n\n**2018.5.21-2018.6.3**\n\n从此以后，总结改为两周一篇，一月两到三篇，命名方式为「xxxx年 x月上（下）」。\n\n<!-- more -->\n\n但事实上我尽量还是每周写一次，只不过把两篇合成一篇罢了。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=477922&auto=0&height=100\"></iframe>\n\n## 正文\n\n这两周很忙，所以我到了这一周才有时间总结一下这两周的学习和生活。\n\n其实我都快忘了上周做了写什么，那就只说说这一周吧。\n\n如果我没记错的话，这一周考了若干次统练。其实我最反感的就是贵校把统练堆到最后一周的行为，真的让人一周都无法安宁。首先是复习生物，考完生物复习历史地理，然后又复习化学政治啥啥，强迫你在这一周进行大规模的复习。真的很烦。而且这一周我的绝大多数时间都用在了做Splay的ppt上，真的非常痛苦。抱着一个配置不高的笔记本做ppt到50+的酸爽，真的让人绝望啊。\n\n所幸这周末终于讲完了，所幸一切又有了喘息的机会。\n\n选科，是第二个话题。学校里，大家见面，除了“您太强了”，第二句话就是“您选什么科”？大家各有各的想法。有的人认为自己毫无退路，只好选上理化生，有的人纠结再三，还是选了理化生，有的人本来意向坚定，但被老师一说，又开始犹豫起来。\n\n总之吧，一同乱象。有的人说的很好：中国人，最擅长的就是忙一些没有什么用的事情，而且乐在其中。我想，这大概就是典型的案例吧。\n\n选完科之后也不太平。机读卡一交上去，学校仿佛也会慌。大家都不知道会发生什么，也不知道学校的目的是什么。\n\n如果让我用几个字来概括这件事情的话，我恐怕只能说：“纯粹瞎搞。”\n\n![](title.jpg)\n\n## TodoList\n\n### 这两周刷题\n\n{% fold %}\n+ [LNOI2014]LCA \n    + 树链剖分\n+ 【模板】普通平衡树（Treap/SBT） \n    + Splay版\n+ [SCOI2013]多项式的运算 \n    + Splay维护区间\n+ [HNOI2012]永无乡\n    + Splay启发式合并\n+ [SDOI2008]Sandy的卡片 \n    + 后缀数组\n+ [ZJOI2012]灾难\n    + LCA + 并查集\n+ [SDOI2014]旅行\n    + 动态开点线段树+树链剖分\n+ [SCOI2016]萌萌哒 \n    + 神级并查集\n+ 【模板】可持久化并查集 \n    + 可持久化线段树\n{% endfold %}\n\n### 上周完成\n\n+ 后缀数组试炼场（老师留的）2-3题 ✘1道\n+ 温习AC自动机并补上学习笔记 ✘大失败\n+ 补课件... ✔成功.jpeg\n+ 一天一道 `Luogu` 省选-以上的题目 ✔2周10道\n\n\n### 下周完成\n\n+ 学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)\n+ 学习后缀自动机`SAM`\n+ 做一些简单的dp题目\n+ 好好复习期末\n+ 补觉","slug":"2018-MayWeek4-5","published":1,"updated":"2018-06-02T15:35:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3he0013bljrbuds2s4r","content":"<p><strong>二〇一八年五月 第四至五周</strong></p>\n<p><strong>2018.5.21-2018.6.3</strong></p>\n<p>从此以后，总结改为两周一篇，一月两到三篇，命名方式为「xxxx年 x月上（下）」。</p>\n<a id=\"more\"></a>\n<p>但事实上我尽量还是每周写一次，只不过把两篇合成一篇罢了。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=477922&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这两周很忙，所以我到了这一周才有时间总结一下这两周的学习和生活。</p>\n<p>其实我都快忘了上周做了写什么，那就只说说这一周吧。</p>\n<p>如果我没记错的话，这一周考了若干次统练。其实我最反感的就是贵校把统练堆到最后一周的行为，真的让人一周都无法安宁。首先是复习生物，考完生物复习历史地理，然后又复习化学政治啥啥，强迫你在这一周进行大规模的复习。真的很烦。而且这一周我的绝大多数时间都用在了做Splay的ppt上，真的非常痛苦。抱着一个配置不高的笔记本做ppt到50+的酸爽，真的让人绝望啊。</p>\n<p>所幸这周末终于讲完了，所幸一切又有了喘息的机会。</p>\n<p>选科，是第二个话题。学校里，大家见面，除了“您太强了”，第二句话就是“您选什么科”？大家各有各的想法。有的人认为自己毫无退路，只好选上理化生，有的人纠结再三，还是选了理化生，有的人本来意向坚定，但被老师一说，又开始犹豫起来。</p>\n<p>总之吧，一同乱象。有的人说的很好：中国人，最擅长的就是忙一些没有什么用的事情，而且乐在其中。我想，这大概就是典型的案例吧。</p>\n<p>选完科之后也不太平。机读卡一交上去，学校仿佛也会慌。大家都不知道会发生什么，也不知道学校的目的是什么。</p>\n<p>如果让我用几个字来概括这件事情的话，我恐怕只能说：“纯粹瞎搞。”</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这两周刷题\"><a href=\"#这两周刷题\" class=\"headerlink\" title=\"这两周刷题\"></a>这两周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[LNOI2014]LCA <ul>\n<li>树链剖分</li>\n</ul>\n</li>\n<li>【模板】普通平衡树（Treap/SBT） <ul>\n<li>Splay版</li>\n</ul>\n</li>\n<li>[SCOI2013]多项式的运算 <ul>\n<li>Splay维护区间</li>\n</ul>\n</li>\n<li>[HNOI2012]永无乡<ul>\n<li>Splay启发式合并</li>\n</ul>\n</li>\n<li>[SDOI2008]Sandy的卡片 <ul>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>[ZJOI2012]灾难<ul>\n<li>LCA + 并查集</li>\n</ul>\n</li>\n<li>[SDOI2014]旅行<ul>\n<li>动态开点线段树+树链剖分</li>\n</ul>\n</li>\n<li>[SCOI2016]萌萌哒 <ul>\n<li>神级并查集</li>\n</ul>\n</li>\n<li>【模板】可持久化并查集 <ul>\n<li>可持久化线段树</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li>后缀数组试炼场（老师留的）2-3题 ✘1道</li>\n<li>温习AC自动机并补上学习笔记 ✘大失败</li>\n<li>补课件… ✔成功.jpeg</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔2周10道</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a></li>\n<li>学习后缀自动机<code>SAM</code></li>\n<li>做一些简单的dp题目</li>\n<li>好好复习期末</li>\n<li>补觉</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>二〇一八年五月 第四至五周</strong></p>\n<p><strong>2018.5.21-2018.6.3</strong></p>\n<p>从此以后，总结改为两周一篇，一月两到三篇，命名方式为「xxxx年 x月上（下）」。</p>","more":"<p>但事实上我尽量还是每周写一次，只不过把两篇合成一篇罢了。</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=477922&auto=0&height=100\"></iframe>\n\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>这两周很忙，所以我到了这一周才有时间总结一下这两周的学习和生活。</p>\n<p>其实我都快忘了上周做了写什么，那就只说说这一周吧。</p>\n<p>如果我没记错的话，这一周考了若干次统练。其实我最反感的就是贵校把统练堆到最后一周的行为，真的让人一周都无法安宁。首先是复习生物，考完生物复习历史地理，然后又复习化学政治啥啥，强迫你在这一周进行大规模的复习。真的很烦。而且这一周我的绝大多数时间都用在了做Splay的ppt上，真的非常痛苦。抱着一个配置不高的笔记本做ppt到50+的酸爽，真的让人绝望啊。</p>\n<p>所幸这周末终于讲完了，所幸一切又有了喘息的机会。</p>\n<p>选科，是第二个话题。学校里，大家见面，除了“您太强了”，第二句话就是“您选什么科”？大家各有各的想法。有的人认为自己毫无退路，只好选上理化生，有的人纠结再三，还是选了理化生，有的人本来意向坚定，但被老师一说，又开始犹豫起来。</p>\n<p>总之吧，一同乱象。有的人说的很好：中国人，最擅长的就是忙一些没有什么用的事情，而且乐在其中。我想，这大概就是典型的案例吧。</p>\n<p>选完科之后也不太平。机读卡一交上去，学校仿佛也会慌。大家都不知道会发生什么，也不知道学校的目的是什么。</p>\n<p>如果让我用几个字来概括这件事情的话，我恐怕只能说：“纯粹瞎搞。”</p>\n<p><img src=\"title.jpg\" alt=\"\"></p>\n<h2 id=\"TodoList\"><a href=\"#TodoList\" class=\"headerlink\" title=\"TodoList\"></a>TodoList</h2><h3 id=\"这两周刷题\"><a href=\"#这两周刷题\" class=\"headerlink\" title=\"这两周刷题\"></a>这两周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[LNOI2014]LCA <ul>\n<li>树链剖分</li>\n</ul>\n</li>\n<li>【模板】普通平衡树（Treap/SBT） <ul>\n<li>Splay版</li>\n</ul>\n</li>\n<li>[SCOI2013]多项式的运算 <ul>\n<li>Splay维护区间</li>\n</ul>\n</li>\n<li>[HNOI2012]永无乡<ul>\n<li>Splay启发式合并</li>\n</ul>\n</li>\n<li>[SDOI2008]Sandy的卡片 <ul>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>[ZJOI2012]灾难<ul>\n<li>LCA + 并查集</li>\n</ul>\n</li>\n<li>[SDOI2014]旅行<ul>\n<li>动态开点线段树+树链剖分</li>\n</ul>\n</li>\n<li>[SCOI2016]萌萌哒 <ul>\n<li>神级并查集</li>\n</ul>\n</li>\n<li>【模板】可持久化并查集 <ul>\n<li>可持久化线段树</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h3><ul>\n<li>后缀数组试炼场（老师留的）2-3题 ✘1道</li>\n<li>温习AC自动机并补上学习笔记 ✘大失败</li>\n<li>补课件… ✔成功.jpeg</li>\n<li>一天一道 <code>Luogu</code> 省选-以上的题目 ✔2周10道</li>\n</ul>\n<h3 id=\"下周完成\"><a href=\"#下周完成\" class=\"headerlink\" title=\"下周完成\"></a>下周完成</h3><ul>\n<li>学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a></li>\n<li>学习后缀自动机<code>SAM</code></li>\n<li>做一些简单的dp题目</li>\n<li>好好复习期末</li>\n<li>补觉</li>\n</ul>"},{"title":"2018年6月·下","urlname":"2018June-Late","date":"2018-06-30T15:59:59.000Z","visible":null,"_content":"\n**二零一八年六月下**\n**2018.6.18-2018.7.1**\n\n<!-- more -->\n\n## 第一周 2018.6.18-2018.6.24\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=4257618&auto=0&height=66\"></iframe>\n\n### 正文\n\n这一周只上了四天课，却还讲了好几天的期末考试卷子，可以说是很混乱了。在这混乱中也算能偷得不少欢乐，带着我走过这样一个压力很大的期末。\n\n这周二回去上课，发了期末考试的成绩。考的不是非常理想，也说不好跟卷子出的简单有没有关系。不过这次考试也不排名。可隐患总会徘徊在生活的暗处，在不注意的时候给你一个措手不及的打击。\n\n这一周主要在复习物理自招课的考试。每当这个时候，班里总会出现一学期一度的复习热潮，仿佛整个班都在学物理竞赛，可以说是非常搞笑了。\n\n> 「要是这么学自招，怎么学都没有用！」——某巨佬如是说道。\n\n我对此感到一百分的认同。\n\n周六我班考了一学期以来的第一次OI的考试，其实我感觉...这个考试密度太低了2333这么学下去怕不是只能靠CF度日...然后打CF还要爆肝...这就非常尴尬了。\n\n考试考了rk2。不过有个julao没有来。按理说我应当可以考的更好。但是我感觉我能做的题也都差不多做到了。没有办法了。如果这样的话，今年省一都堪忧啊。\n\n一切本可以更好，只是看你愿不愿意去争取。\n\n这周看到一篇江苏省委书记关于高考改革的发言稿，感觉说的很中肯，比较符合实际，摘录一两句放在下面。\n\n> *我们考虑问题，绝不能脱离江苏的实际，不能将折腾当改革。*\n> *浙江新方案搞6选3，有20多种组合，太多了，学生大量跑班，师资跟不上，教室不够用，我们不要高估学生的能力，让学生到处跑班。*\n> *不能拿孩子做试验品，一定要对标中央，坚持教育规律、人民立场，对历史和人民负责。*\n\n熬夜到四点看德国的球，幸运的赢了。最后Kroos打进那个任意球的时候，真的顿时就懵了。\n\n*Mia San Mia.*\n\n![](/images/20180623-germany.jpeg)\n\n### 本周刷题\n\n{% fold %}\n+ 【模板】高斯消元法 \n+ [TJOI2017]DNA \n\t+ 后缀数组\n+ [CQOI2016]手机号码 \n\t+ 数位dp\n+ [HNOI2001]产品加工 \n\t+ 简单dp\n+ [SCOI2009]生日礼物 \n\t+ 单调队列\n+ [LGR-048] 洛谷6月月赛\n\t+ 「生物」能量流动\n\t+ 「物理」平抛运动 \n\t+ 「化学」相对分子质量 \n+ Codeforces Round #491 (Div.2)\n\t+ A.If at first you don't succeed...(Accepted)\n\t+ B.Getting an A(Accepted)\n\t+ C.Candies(FST)\n\t+ D.Bishwock(Hacked)\n\t+ E.Bus Number(Acceptd)\n{% endfold %}\n\n### Todolist\n\n#### 上周完成\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 没学完\n+ 学习后缀自动机`SAM` ✔ 大概懂了一点点？\n+ 考好期末 ✘ boom\n\n#### 本周目标\n\n+ 做一定的后缀数组的题（优秀的拆分、品酒...）\n+ 过掉后缀自动机`SAM` 模版题 和 其简单应用\n+ 复习学业水平合格性考试\n\n","source":"_posts/2018年6月·下.md","raw":"---\ntitle: 2018年6月·下\nurlname: 2018June-Late\ndate: 2018-06-30 23:59:59\ntags:\ncategories: 总结\nvisible:\n---\n\n**二零一八年六月下**\n**2018.6.18-2018.7.1**\n\n<!-- more -->\n\n## 第一周 2018.6.18-2018.6.24\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=4257618&auto=0&height=66\"></iframe>\n\n### 正文\n\n这一周只上了四天课，却还讲了好几天的期末考试卷子，可以说是很混乱了。在这混乱中也算能偷得不少欢乐，带着我走过这样一个压力很大的期末。\n\n这周二回去上课，发了期末考试的成绩。考的不是非常理想，也说不好跟卷子出的简单有没有关系。不过这次考试也不排名。可隐患总会徘徊在生活的暗处，在不注意的时候给你一个措手不及的打击。\n\n这一周主要在复习物理自招课的考试。每当这个时候，班里总会出现一学期一度的复习热潮，仿佛整个班都在学物理竞赛，可以说是非常搞笑了。\n\n> 「要是这么学自招，怎么学都没有用！」——某巨佬如是说道。\n\n我对此感到一百分的认同。\n\n周六我班考了一学期以来的第一次OI的考试，其实我感觉...这个考试密度太低了2333这么学下去怕不是只能靠CF度日...然后打CF还要爆肝...这就非常尴尬了。\n\n考试考了rk2。不过有个julao没有来。按理说我应当可以考的更好。但是我感觉我能做的题也都差不多做到了。没有办法了。如果这样的话，今年省一都堪忧啊。\n\n一切本可以更好，只是看你愿不愿意去争取。\n\n这周看到一篇江苏省委书记关于高考改革的发言稿，感觉说的很中肯，比较符合实际，摘录一两句放在下面。\n\n> *我们考虑问题，绝不能脱离江苏的实际，不能将折腾当改革。*\n> *浙江新方案搞6选3，有20多种组合，太多了，学生大量跑班，师资跟不上，教室不够用，我们不要高估学生的能力，让学生到处跑班。*\n> *不能拿孩子做试验品，一定要对标中央，坚持教育规律、人民立场，对历史和人民负责。*\n\n熬夜到四点看德国的球，幸运的赢了。最后Kroos打进那个任意球的时候，真的顿时就懵了。\n\n*Mia San Mia.*\n\n![](/images/20180623-germany.jpeg)\n\n### 本周刷题\n\n{% fold %}\n+ 【模板】高斯消元法 \n+ [TJOI2017]DNA \n\t+ 后缀数组\n+ [CQOI2016]手机号码 \n\t+ 数位dp\n+ [HNOI2001]产品加工 \n\t+ 简单dp\n+ [SCOI2009]生日礼物 \n\t+ 单调队列\n+ [LGR-048] 洛谷6月月赛\n\t+ 「生物」能量流动\n\t+ 「物理」平抛运动 \n\t+ 「化学」相对分子质量 \n+ Codeforces Round #491 (Div.2)\n\t+ A.If at first you don't succeed...(Accepted)\n\t+ B.Getting an A(Accepted)\n\t+ C.Candies(FST)\n\t+ D.Bishwock(Hacked)\n\t+ E.Bus Number(Acceptd)\n{% endfold %}\n\n### Todolist\n\n#### 上周完成\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 没学完\n+ 学习后缀自动机`SAM` ✔ 大概懂了一点点？\n+ 考好期末 ✘ boom\n\n#### 本周目标\n\n+ 做一定的后缀数组的题（优秀的拆分、品酒...）\n+ 过掉后缀自动机`SAM` 模版题 和 其简单应用\n+ 复习学业水平合格性考试\n\n","slug":"2018年6月·下","published":1,"updated":"2018-06-24T09:17:18.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hg0015bljryvrlq1ws","content":"<p><strong>二零一八年六月下</strong><br><strong>2018.6.18-2018.7.1</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"第一周-2018-6-18-2018-6-24\"><a href=\"#第一周-2018-6-18-2018-6-24\" class=\"headerlink\" title=\"第一周 2018.6.18-2018.6.24\"></a>第一周 2018.6.18-2018.6.24</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=4257618&auto=0&height=66\"></iframe>\n\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>这一周只上了四天课，却还讲了好几天的期末考试卷子，可以说是很混乱了。在这混乱中也算能偷得不少欢乐，带着我走过这样一个压力很大的期末。</p>\n<p>这周二回去上课，发了期末考试的成绩。考的不是非常理想，也说不好跟卷子出的简单有没有关系。不过这次考试也不排名。可隐患总会徘徊在生活的暗处，在不注意的时候给你一个措手不及的打击。</p>\n<p>这一周主要在复习物理自招课的考试。每当这个时候，班里总会出现一学期一度的复习热潮，仿佛整个班都在学物理竞赛，可以说是非常搞笑了。</p>\n<blockquote>\n<p>「要是这么学自招，怎么学都没有用！」——某巨佬如是说道。</p>\n</blockquote>\n<p>我对此感到一百分的认同。</p>\n<p>周六我班考了一学期以来的第一次OI的考试，其实我感觉…这个考试密度太低了2333这么学下去怕不是只能靠CF度日…然后打CF还要爆肝…这就非常尴尬了。</p>\n<p>考试考了rk2。不过有个julao没有来。按理说我应当可以考的更好。但是我感觉我能做的题也都差不多做到了。没有办法了。如果这样的话，今年省一都堪忧啊。</p>\n<p>一切本可以更好，只是看你愿不愿意去争取。</p>\n<p>这周看到一篇江苏省委书记关于高考改革的发言稿，感觉说的很中肯，比较符合实际，摘录一两句放在下面。</p>\n<blockquote>\n<p><em>我们考虑问题，绝不能脱离江苏的实际，不能将折腾当改革。</em><br><em>浙江新方案搞6选3，有20多种组合，太多了，学生大量跑班，师资跟不上，教室不够用，我们不要高估学生的能力，让学生到处跑班。</em><br><em>不能拿孩子做试验品，一定要对标中央，坚持教育规律、人民立场，对历史和人民负责。</em></p>\n</blockquote>\n<p>熬夜到四点看德国的球，幸运的赢了。最后Kroos打进那个任意球的时候，真的顿时就懵了。</p>\n<p><em>Mia San Mia.</em></p>\n<p><img src=\"/images/20180623-germany.jpeg\" alt=\"\"></p>\n<h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>【模板】高斯消元法 </li>\n<li>[TJOI2017]DNA <ul>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>[CQOI2016]手机号码 <ul>\n<li>数位dp</li>\n</ul>\n</li>\n<li>[HNOI2001]产品加工 <ul>\n<li>简单dp</li>\n</ul>\n</li>\n<li>[SCOI2009]生日礼物 <ul>\n<li>单调队列</li>\n</ul>\n</li>\n<li>[LGR-048] 洛谷6月月赛<ul>\n<li>「生物」能量流动</li>\n<li>「物理」平抛运动 </li>\n<li>「化学」相对分子质量 </li>\n</ul>\n</li>\n<li>Codeforces Round #491 (Div.2)<ul>\n<li>A.If at first you don’t succeed…(Accepted)</li>\n<li>B.Getting an A(Accepted)</li>\n<li>C.Candies(FST)</li>\n<li>D.Bishwock(Hacked)</li>\n<li>E.Bus Number(Acceptd)</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✔ 大概懂了一点点？</li>\n<li>考好期末 ✘ boom</li>\n</ul>\n<h4 id=\"本周目标\"><a href=\"#本周目标\" class=\"headerlink\" title=\"本周目标\"></a>本周目标</h4><ul>\n<li>做一定的后缀数组的题（优秀的拆分、品酒…）</li>\n<li>过掉后缀自动机<code>SAM</code> 模版题 和 其简单应用</li>\n<li>复习学业水平合格性考试</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>二零一八年六月下</strong><br><strong>2018.6.18-2018.7.1</strong></p>","more":"<h2 id=\"第一周-2018-6-18-2018-6-24\"><a href=\"#第一周-2018-6-18-2018-6-24\" class=\"headerlink\" title=\"第一周 2018.6.18-2018.6.24\"></a>第一周 2018.6.18-2018.6.24</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=4257618&auto=0&height=66\"></iframe>\n\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>这一周只上了四天课，却还讲了好几天的期末考试卷子，可以说是很混乱了。在这混乱中也算能偷得不少欢乐，带着我走过这样一个压力很大的期末。</p>\n<p>这周二回去上课，发了期末考试的成绩。考的不是非常理想，也说不好跟卷子出的简单有没有关系。不过这次考试也不排名。可隐患总会徘徊在生活的暗处，在不注意的时候给你一个措手不及的打击。</p>\n<p>这一周主要在复习物理自招课的考试。每当这个时候，班里总会出现一学期一度的复习热潮，仿佛整个班都在学物理竞赛，可以说是非常搞笑了。</p>\n<blockquote>\n<p>「要是这么学自招，怎么学都没有用！」——某巨佬如是说道。</p>\n</blockquote>\n<p>我对此感到一百分的认同。</p>\n<p>周六我班考了一学期以来的第一次OI的考试，其实我感觉…这个考试密度太低了2333这么学下去怕不是只能靠CF度日…然后打CF还要爆肝…这就非常尴尬了。</p>\n<p>考试考了rk2。不过有个julao没有来。按理说我应当可以考的更好。但是我感觉我能做的题也都差不多做到了。没有办法了。如果这样的话，今年省一都堪忧啊。</p>\n<p>一切本可以更好，只是看你愿不愿意去争取。</p>\n<p>这周看到一篇江苏省委书记关于高考改革的发言稿，感觉说的很中肯，比较符合实际，摘录一两句放在下面。</p>\n<blockquote>\n<p><em>我们考虑问题，绝不能脱离江苏的实际，不能将折腾当改革。</em><br><em>浙江新方案搞6选3，有20多种组合，太多了，学生大量跑班，师资跟不上，教室不够用，我们不要高估学生的能力，让学生到处跑班。</em><br><em>不能拿孩子做试验品，一定要对标中央，坚持教育规律、人民立场，对历史和人民负责。</em></p>\n</blockquote>\n<p>熬夜到四点看德国的球，幸运的赢了。最后Kroos打进那个任意球的时候，真的顿时就懵了。</p>\n<p><em>Mia San Mia.</em></p>\n<p><img src=\"/images/20180623-germany.jpeg\" alt=\"\"></p>\n<h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>【模板】高斯消元法 </li>\n<li>[TJOI2017]DNA <ul>\n<li>后缀数组</li>\n</ul>\n</li>\n<li>[CQOI2016]手机号码 <ul>\n<li>数位dp</li>\n</ul>\n</li>\n<li>[HNOI2001]产品加工 <ul>\n<li>简单dp</li>\n</ul>\n</li>\n<li>[SCOI2009]生日礼物 <ul>\n<li>单调队列</li>\n</ul>\n</li>\n<li>[LGR-048] 洛谷6月月赛<ul>\n<li>「生物」能量流动</li>\n<li>「物理」平抛运动 </li>\n<li>「化学」相对分子质量 </li>\n</ul>\n</li>\n<li>Codeforces Round #491 (Div.2)<ul>\n<li>A.If at first you don’t succeed…(Accepted)</li>\n<li>B.Getting an A(Accepted)</li>\n<li>C.Candies(FST)</li>\n<li>D.Bishwock(Hacked)</li>\n<li>E.Bus Number(Acceptd)</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✔ 大概懂了一点点？</li>\n<li>考好期末 ✘ boom</li>\n</ul>\n<h4 id=\"本周目标\"><a href=\"#本周目标\" class=\"headerlink\" title=\"本周目标\"></a>本周目标</h4><ul>\n<li>做一定的后缀数组的题（优秀的拆分、品酒…）</li>\n<li>过掉后缀自动机<code>SAM</code> 模版题 和 其简单应用</li>\n<li>复习学业水平合格性考试</li>\n</ul>"},{"title":"2018年六月·上","urlname":"2018June-Early","date":"2018-06-14T16:00:00.000Z","visible":null,"_content":"\n**二零一八年六月上**\n**2018.6.3-2018.6.17**\n\n<!-- more -->\n\n## 第一周\n\n### 正文\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=420008229&auto=0&height=100\"></iframe>\n\n总结会缩水一些篇幅，因为我发现...我写的实在是太多了...\n\n这周就是放了个高考假。高考假期就只有两件事情：颓题，颓作业。\n\n高考假里面所有的竞赛课补了三次课...于是就在三师的教室里听着早四的铃声一起上了三天的课。~~不过我个人觉得三师的电脑比高中楼机房的键盘好使...~~大概就是这个样子。在我写下这篇文章的时候，假期已经快要过完了，于是只有四天就要到期末考试了...然后还没有开始复习...\n\n只能说，祈求这次期末考试不会影响到我的OI生活吧。\n\n![](title1.jpg)\n\n### 本周刷题\n\n{% fold %}\n+ [HAOI2015]树上染色 \n+ [Luogu P1273]有线电视网\n\t- 树上背包\n+ [SCOI2015]小凸玩密室 \n+ [HAOI2009]毛毛虫 \n\t- 树形dp \n+ [CQOI2011]动态逆序对\n+ [Luogu P3810]三维偏序 \n\t- CDQ分治\n+ [ZJOI2013]K大数查询 \n\t- 整体二分\n+ [SCOI2007]压缩 \n+ [JSOI2007]祖码 \n\t- 区间dp\n{% endfold %}\n\n### Todolist\n\n#### 本周完成\n\n+ 学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 还没学完\n+ 学习后缀自动机`SAM` ✘没学会...\n+ 做一些简单的dp题目 ✔一些\n+ 好好复习期末 ✘大约期末是要炸了\n+ 补觉 ✔ 放假好啊...\n\n#### 下周目标\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)\n+ 学习后缀自动机`SAM`\n+ 考好期末\n\n-----------------------\n\n## 第二周\n\n### 正文\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=423849401&auto=0&height=100\"></iframe>\n\n这一周是考试周。\n\n混乱的六月已然进入了最繁忙的时间段。高三的同学们考完高考，已经不在学校。曾经路过高三的楼层。平日繁华的楼层此时已是孤寂一片，只有零星个班的灯还开着，苍白的洒在斑驳的大理石地面上。\n\n曾经路过六楼的机房。除了小屋里面的四位高二学长之外，也就没有什么人了。背着书包走过暗淡的走廊，真的突然就惆怅起来。\n\n等我到了高二，恐怕也是很难有机会坐到这个小屋子里的。就算坐到这个屋子里，真的就能获得什么吗？到最后恐怕只有一纸废约，一场大梦，一身毛病，和不忍直视的课内成绩。何况最有可能的却是故事在第一句话就戛然而止了。\n\n你得有实力，才能去谈梦想。\n\n![](title2.jpg)\n\n### 本周刷题\n\n{% fold %}\n+ [NOI2014] 魔法森林\n\t+ LCT\n+ [JSOI2016] 最佳团队\n\t+ 0/1 分数规划 + 树形dp\n{% endfold %}\n\n### Todolist\n\n#### 上周完成\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 没学完\n+ 学习后缀自动机`SAM` ✔ 大概懂了一点点？\n+ 考好期末 ✘ boom\n\n#### 本周目标\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)并完成实现 ✘ 没学完\n+ 过掉后缀自动机`SAM` 模版题 和 其简单应用\n+ 学习高端dp\n+ 完成语文作业\n","source":"_posts/2018年六月·上.md","raw":"---\ntitle: 2018年六月·上\nurlname: 2018June-Early\ndate: 2018-06-15 00:00:00\ntags: \ncategories: 总结\nvisible:\n---\n\n**二零一八年六月上**\n**2018.6.3-2018.6.17**\n\n<!-- more -->\n\n## 第一周\n\n### 正文\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=420008229&auto=0&height=100\"></iframe>\n\n总结会缩水一些篇幅，因为我发现...我写的实在是太多了...\n\n这周就是放了个高考假。高考假期就只有两件事情：颓题，颓作业。\n\n高考假里面所有的竞赛课补了三次课...于是就在三师的教室里听着早四的铃声一起上了三天的课。~~不过我个人觉得三师的电脑比高中楼机房的键盘好使...~~大概就是这个样子。在我写下这篇文章的时候，假期已经快要过完了，于是只有四天就要到期末考试了...然后还没有开始复习...\n\n只能说，祈求这次期末考试不会影响到我的OI生活吧。\n\n![](title1.jpg)\n\n### 本周刷题\n\n{% fold %}\n+ [HAOI2015]树上染色 \n+ [Luogu P1273]有线电视网\n\t- 树上背包\n+ [SCOI2015]小凸玩密室 \n+ [HAOI2009]毛毛虫 \n\t- 树形dp \n+ [CQOI2011]动态逆序对\n+ [Luogu P3810]三维偏序 \n\t- CDQ分治\n+ [ZJOI2013]K大数查询 \n\t- 整体二分\n+ [SCOI2007]压缩 \n+ [JSOI2007]祖码 \n\t- 区间dp\n{% endfold %}\n\n### Todolist\n\n#### 本周完成\n\n+ 学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 还没学完\n+ 学习后缀自动机`SAM` ✘没学会...\n+ 做一些简单的dp题目 ✔一些\n+ 好好复习期末 ✘大约期末是要炸了\n+ 补觉 ✔ 放假好啊...\n\n#### 下周目标\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)\n+ 学习后缀自动机`SAM`\n+ 考好期末\n\n-----------------------\n\n## 第二周\n\n### 正文\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=400 height=100 src=\"//music.163.com/outchain/player?type=2&id=423849401&auto=0&height=100\"></iframe>\n\n这一周是考试周。\n\n混乱的六月已然进入了最繁忙的时间段。高三的同学们考完高考，已经不在学校。曾经路过高三的楼层。平日繁华的楼层此时已是孤寂一片，只有零星个班的灯还开着，苍白的洒在斑驳的大理石地面上。\n\n曾经路过六楼的机房。除了小屋里面的四位高二学长之外，也就没有什么人了。背着书包走过暗淡的走廊，真的突然就惆怅起来。\n\n等我到了高二，恐怕也是很难有机会坐到这个小屋子里的。就算坐到这个屋子里，真的就能获得什么吗？到最后恐怕只有一纸废约，一场大梦，一身毛病，和不忍直视的课内成绩。何况最有可能的却是故事在第一句话就戛然而止了。\n\n你得有实力，才能去谈梦想。\n\n![](title2.jpg)\n\n### 本周刷题\n\n{% fold %}\n+ [NOI2014] 魔法森林\n\t+ LCT\n+ [JSOI2016] 最佳团队\n\t+ 0/1 分数规划 + 树形dp\n{% endfold %}\n\n### Todolist\n\n#### 上周完成\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415) ✘ 没学完\n+ 学习后缀自动机`SAM` ✔ 大概懂了一点点？\n+ 考好期末 ✘ boom\n\n#### 本周目标\n\n+ 继续学习[SA-IS的简单实现](https://zhuanlan.zhihu.com/p/28331415)并完成实现 ✘ 没学完\n+ 过掉后缀自动机`SAM` 模版题 和 其简单应用\n+ 学习高端dp\n+ 完成语文作业\n","slug":"2018年六月·上","published":1,"updated":"2018-06-23T13:16:14.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hi0017bljrg4d3h9rz","content":"<p><strong>二零一八年六月上</strong><br><strong>2018.6.3-2018.6.17</strong></p>\n<a id=\"more\"></a>\n<h2 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h2><h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=420008229&auto=0&height=100\"></iframe>\n\n<p>总结会缩水一些篇幅，因为我发现…我写的实在是太多了…</p>\n<p>这周就是放了个高考假。高考假期就只有两件事情：颓题，颓作业。</p>\n<p>高考假里面所有的竞赛课补了三次课…于是就在三师的教室里听着早四的铃声一起上了三天的课。<del>不过我个人觉得三师的电脑比高中楼机房的键盘好使…</del>大概就是这个样子。在我写下这篇文章的时候，假期已经快要过完了，于是只有四天就要到期末考试了…然后还没有开始复习…</p>\n<p>只能说，祈求这次期末考试不会影响到我的OI生活吧。</p>\n<p><img src=\"title1.jpg\" alt=\"\"></p>\n<h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[HAOI2015]树上染色 </li>\n<li>[Luogu P1273]有线电视网<ul>\n<li>树上背包</li>\n</ul>\n</li>\n<li>[SCOI2015]小凸玩密室 </li>\n<li>[HAOI2009]毛毛虫 <ul>\n<li>树形dp </li>\n</ul>\n</li>\n<li>[CQOI2011]动态逆序对</li>\n<li>[Luogu P3810]三维偏序 <ul>\n<li>CDQ分治</li>\n</ul>\n</li>\n<li>[ZJOI2013]K大数查询 <ul>\n<li>整体二分</li>\n</ul>\n</li>\n<li>[SCOI2007]压缩 </li>\n<li>[JSOI2007]祖码 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h4><ul>\n<li>学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 还没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✘没学会…</li>\n<li>做一些简单的dp题目 ✔一些</li>\n<li>好好复习期末 ✘大约期末是要炸了</li>\n<li>补觉 ✔ 放假好啊…</li>\n</ul>\n<h4 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a></li>\n<li>学习后缀自动机<code>SAM</code></li>\n<li>考好期末</li>\n</ul>\n<hr>\n<h2 id=\"第二周\"><a href=\"#第二周\" class=\"headerlink\" title=\"第二周\"></a>第二周</h2><h3 id=\"正文-1\"><a href=\"#正文-1\" class=\"headerlink\" title=\"正文\"></a>正文</h3><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=423849401&auto=0&height=100\"></iframe>\n\n<p>这一周是考试周。</p>\n<p>混乱的六月已然进入了最繁忙的时间段。高三的同学们考完高考，已经不在学校。曾经路过高三的楼层。平日繁华的楼层此时已是孤寂一片，只有零星个班的灯还开着，苍白的洒在斑驳的大理石地面上。</p>\n<p>曾经路过六楼的机房。除了小屋里面的四位高二学长之外，也就没有什么人了。背着书包走过暗淡的走廊，真的突然就惆怅起来。</p>\n<p>等我到了高二，恐怕也是很难有机会坐到这个小屋子里的。就算坐到这个屋子里，真的就能获得什么吗？到最后恐怕只有一纸废约，一场大梦，一身毛病，和不忍直视的课内成绩。何况最有可能的却是故事在第一句话就戛然而止了。</p>\n<p>你得有实力，才能去谈梦想。</p>\n<p><img src=\"title2.jpg\" alt=\"\"></p>\n<h3 id=\"本周刷题-1\"><a href=\"#本周刷题-1\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[NOI2014] 魔法森林<ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[JSOI2016] 最佳团队<ul>\n<li>0/1 分数规划 + 树形dp</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist-1\"><a href=\"#Todolist-1\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✔ 大概懂了一点点？</li>\n<li>考好期末 ✘ boom</li>\n</ul>\n<h4 id=\"本周目标\"><a href=\"#本周目标\" class=\"headerlink\" title=\"本周目标\"></a>本周目标</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a>并完成实现 ✘ 没学完</li>\n<li>过掉后缀自动机<code>SAM</code> 模版题 和 其简单应用</li>\n<li>学习高端dp</li>\n<li>完成语文作业</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>二零一八年六月上</strong><br><strong>2018.6.3-2018.6.17</strong></p>","more":"<h2 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h2><h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=420008229&auto=0&height=100\"></iframe>\n\n<p>总结会缩水一些篇幅，因为我发现…我写的实在是太多了…</p>\n<p>这周就是放了个高考假。高考假期就只有两件事情：颓题，颓作业。</p>\n<p>高考假里面所有的竞赛课补了三次课…于是就在三师的教室里听着早四的铃声一起上了三天的课。<del>不过我个人觉得三师的电脑比高中楼机房的键盘好使…</del>大概就是这个样子。在我写下这篇文章的时候，假期已经快要过完了，于是只有四天就要到期末考试了…然后还没有开始复习…</p>\n<p>只能说，祈求这次期末考试不会影响到我的OI生活吧。</p>\n<p><img src=\"title1.jpg\" alt=\"\"></p>\n<h3 id=\"本周刷题\"><a href=\"#本周刷题\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[HAOI2015]树上染色 </li>\n<li>[Luogu P1273]有线电视网<ul>\n<li>树上背包</li>\n</ul>\n</li>\n<li>[SCOI2015]小凸玩密室 </li>\n<li>[HAOI2009]毛毛虫 <ul>\n<li>树形dp </li>\n</ul>\n</li>\n<li>[CQOI2011]动态逆序对</li>\n<li>[Luogu P3810]三维偏序 <ul>\n<li>CDQ分治</li>\n</ul>\n</li>\n<li>[ZJOI2013]K大数查询 <ul>\n<li>整体二分</li>\n</ul>\n</li>\n<li>[SCOI2007]压缩 </li>\n<li>[JSOI2007]祖码 <ul>\n<li>区间dp</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist\"><a href=\"#Todolist\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"本周完成\"><a href=\"#本周完成\" class=\"headerlink\" title=\"本周完成\"></a>本周完成</h4><ul>\n<li>学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 还没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✘没学会…</li>\n<li>做一些简单的dp题目 ✔一些</li>\n<li>好好复习期末 ✘大约期末是要炸了</li>\n<li>补觉 ✔ 放假好啊…</li>\n</ul>\n<h4 id=\"下周目标\"><a href=\"#下周目标\" class=\"headerlink\" title=\"下周目标\"></a>下周目标</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a></li>\n<li>学习后缀自动机<code>SAM</code></li>\n<li>考好期末</li>\n</ul>\n<hr>\n<h2 id=\"第二周\"><a href=\"#第二周\" class=\"headerlink\" title=\"第二周\"></a>第二周</h2><h3 id=\"正文-1\"><a href=\"#正文-1\" class=\"headerlink\" title=\"正文\"></a>正文</h3><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"400\" height=\"100\" src=\"//music.163.com/outchain/player?type=2&id=423849401&auto=0&height=100\"></iframe>\n\n<p>这一周是考试周。</p>\n<p>混乱的六月已然进入了最繁忙的时间段。高三的同学们考完高考，已经不在学校。曾经路过高三的楼层。平日繁华的楼层此时已是孤寂一片，只有零星个班的灯还开着，苍白的洒在斑驳的大理石地面上。</p>\n<p>曾经路过六楼的机房。除了小屋里面的四位高二学长之外，也就没有什么人了。背着书包走过暗淡的走廊，真的突然就惆怅起来。</p>\n<p>等我到了高二，恐怕也是很难有机会坐到这个小屋子里的。就算坐到这个屋子里，真的就能获得什么吗？到最后恐怕只有一纸废约，一场大梦，一身毛病，和不忍直视的课内成绩。何况最有可能的却是故事在第一句话就戛然而止了。</p>\n<p>你得有实力，才能去谈梦想。</p>\n<p><img src=\"title2.jpg\" alt=\"\"></p>\n<h3 id=\"本周刷题-1\"><a href=\"#本周刷题-1\" class=\"headerlink\" title=\"本周刷题\"></a>本周刷题</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<ul>\n<li>[NOI2014] 魔法森林<ul>\n<li>LCT</li>\n</ul>\n</li>\n<li>[JSOI2016] 最佳团队<ul>\n<li>0/1 分数规划 + 树形dp</li>\n</ul>\n</li>\n</ul>\n\n</div></div>\n<h3 id=\"Todolist-1\"><a href=\"#Todolist-1\" class=\"headerlink\" title=\"Todolist\"></a>Todolist</h3><h4 id=\"上周完成\"><a href=\"#上周完成\" class=\"headerlink\" title=\"上周完成\"></a>上周完成</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a> ✘ 没学完</li>\n<li>学习后缀自动机<code>SAM</code> ✔ 大概懂了一点点？</li>\n<li>考好期末 ✘ boom</li>\n</ul>\n<h4 id=\"本周目标\"><a href=\"#本周目标\" class=\"headerlink\" title=\"本周目标\"></a>本周目标</h4><ul>\n<li>继续学习<a href=\"https://zhuanlan.zhihu.com/p/28331415\" target=\"_blank\" rel=\"noopener\">SA-IS的简单实现</a>并完成实现 ✘ 没学完</li>\n<li>过掉后缀自动机<code>SAM</code> 模版题 和 其简单应用</li>\n<li>学习高端dp</li>\n<li>完成语文作业</li>\n</ul>"},{"title":"AC自动机学习笔记","urlname":"ac_automaton-notes","date":"2018-04-05T09:10:36.000Z","visible":null,"_content":"\n\n`Aho–Corasick`\b算法，常叫做AC自动机。是一种字符串多模式串匹配算法。能在线性时间内完成多个模式串对一个查询串的匹配。\n\n> 能自动AC哦。\n\n<!-- more -->\n\nTo be finished.\n\n## 思想\n\n### \b树型结构\n\n### \b建树\n\n### 查询\n\n### 其他\n\n## 实现\n\n### 基本\n\n### 一些改进\n\n## 代码\n\n## 例题\n","source":"_posts/AC自动机学习笔记.md","raw":"---\ntitle: AC自动机学习笔记\nurlname: ac_automaton-notes\ndate: 2018-04-05 17:10:36\ntags:\n- 笔记\n- 字符串\n- AC自动机\n- 模板\ncategories: OI\nvisible:\n---\n\n\n`Aho–Corasick`\b算法，常叫做AC自动机。是一种字符串多模式串匹配算法。能在线性时间内完成多个模式串对一个查询串的匹配。\n\n> 能自动AC哦。\n\n<!-- more -->\n\nTo be finished.\n\n## 思想\n\n### \b树型结构\n\n### \b建树\n\n### 查询\n\n### 其他\n\n## 实现\n\n### 基本\n\n### 一些改进\n\n## 代码\n\n## 例题\n","slug":"AC自动机学习笔记","published":1,"updated":"2018-04-05T12:11:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hn0019bljrglcbvb25","content":"<p><code>Aho–Corasick</code>\b算法，常叫做AC自动机。是一种字符串多模式串匹配算法。能在线性时间内完成多个模式串对一个查询串的匹配。</p>\n<blockquote>\n<p>能自动AC哦。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>To be finished.</p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><h3 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"\b树型结构\"></a>\b树型结构</h3><h3 id=\"建树\"><a href=\"#建树\" class=\"headerlink\" title=\"\b建树\"></a>\b建树</h3><h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><h3 id=\"一些改进\"><a href=\"#一些改进\" class=\"headerlink\" title=\"一些改进\"></a>一些改进</h3><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2>","site":{"data":{}},"excerpt":"<p><code>Aho–Corasick</code>\b算法，常叫做AC自动机。是一种字符串多模式串匹配算法。能在线性时间内完成多个模式串对一个查询串的匹配。</p>\n<blockquote>\n<p>能自动AC哦。</p>\n</blockquote>","more":"<p>To be finished.</p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><h3 id=\"树型结构\"><a href=\"#树型结构\" class=\"headerlink\" title=\"\b树型结构\"></a>\b树型结构</h3><h3 id=\"建树\"><a href=\"#建树\" class=\"headerlink\" title=\"\b建树\"></a>\b建树</h3><h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"基本\"><a href=\"#基本\" class=\"headerlink\" title=\"基本\"></a>基本</h3><h3 id=\"一些改进\"><a href=\"#一些改进\" class=\"headerlink\" title=\"一些改进\"></a>一些改进</h3><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2>"},{"title":"BJOI2018游记","urlname":"bjoi2018-trip","date":"2018-04-15T13:46:43.000Z","visible":null,"_content":"\n\n爆零滚粗。\n\n<!-- more -->\n\n## 集训\n\n在考试之前先有两个周末的集训。\n\n第一个周末是让我印象最为深刻的。开始没仔细看说明，结果一不小心就跑到了北师大附属实验。急忙打车，跑回到首师大附中，还好没有迟到。\n\n![](1.jpg)\n\n第一天上午的题非常有趣。`T1`比较简单，也成为了我四次考试以来唯一`A`掉的一道题。`T2 sumsum`好像是奇怪的点分治，还没有学过，所以自然也就不会做，甚至最后连暴力都懒得打。不过好像十分弱智的暴力也能过到`60`分？？也没有想到。`T3`是提答题，第一次做到，非常有趣。这个提答还是比较友善的，手玩竟然能有四十多分，可以说是很友善了。第一天就这么过去了，排了一个三四十名的名次。\n\n第二天就比较难了，竟然是三道数学题...于是我一道都不会做...做是不会做的，还把网给断了，于是就很绝望的去瞎搞。`T1`好像是个找规律+构造，`T2`不记得了...`T3`正解貌似也是构造...然而我在大佬的指点下写了个随机化，竟然搞到了三十多分，令人惊讶。\n\n两天的集训就这么结束了。也没有听懂什么，周末好几次险些写不完作业... \n<!-- 倒是又见到了冬令营的时候坐在我前面的妹子，这次知道她是哪个学校的叫什么了，嘿嘿。 -->\n\n## Day1\n\nDay1不太想说什么。\n\n`T1`好像是个线段树，不过正解是三个`set`，不知道为什么写的暴力稀里糊涂的就爆`0`了。\n\n`T2`是一道找规律的题目。然而蒟蒻如我像这种东西肯定是分析不出来的...随便推了个规律...然而发现一大堆反例，令人发指...\n\n`T3`貌似最简单。就是一个简单的`LCA`+前缀和查询，然而...没想到竟然挂在了取模上...这也一方面体现出了我的对拍人眼执行`diff`命令的不可靠，一方面也涨了知识：取模意义下的前缀和一定要加足够的$p$！！！要不然就`WA*n`了...出题人瞎随机的数据出了点锅，暴力$O(n^2)$的算法居然在平衡的树上跑到了$O(n \\log{n})$，然后...就过了？？？啊啊啊我要学`.bat`对拍！！！\n\n第一天期望得分`140`，实际得分`10`。\n\n## Day2\n\n正式考试的第二天。第一天就只有`10`分，所以考试之前有点慌，昨天讲的有上下界的网络流还不怎么会，而去年一道网络流都没有考过，考试前匆匆茫茫的看了看，希望能用到。\n\n然而，然而喜出望外的是，我最近一个多月学的东西，全部都没有考到。反而是考了一些奇奇怪怪的东西。\n\n`T1`是个提交答案题，琢磨一番样例之后发现自己连样例都推不出来，瞎玩了`10`分就看第二题。\n\n`T2`跟集训第一周的题很像，好像是徐明宽巨佬在考场上想出了某种特殊情况的解法...然后就出成了题。貌似40分的$O(n^2)$暴力很好想，然而我只写了个$O(n^3)$的二十分暴力。最后还被出题人坑了一分都没有...伤心...\n\n`T3`看了一眼...概率是啥？？？咋对分数取模来着...期望怎么算啊...不会啊...于是放弃。\n\n于是就陷入了颓废的状态。感觉中间三个小时过的特别的快，前后一个小时就非常的漫长...漫长到心态爆炸。\n\n第二天期望得分`30`，最后得分`8`分。\n\n讲完题等成绩的时候，出现了省队巨佬连连玩扫雷，大家纷纷围观，以及巨佬玩我不知道名字的Windows游戏的壮观景象。\n\n![](3.jpg)\n\n\n最后我校有了四个省队，所有去的高二 + `dmy`全都进了省队。\n\n`Day2 dmy`竟然`AK`了！第二名`140`分！总评`dmy`比第二名高了`80`分！害怕...\n\n## 最后\n\n今年初三有三个省队，高一三个省队，剩下的全都是高二。\n\n任务十分的艰巨啊。如果想要进到省队，不仅要打败高一，还要打败更为恐怖的初三。有的时候也在追问，我真的有天赋吗？真的能付得起这样的时间、精力的支出吗？如果今年的联赛和明年的省选季要停课的话，能接受失败的打击吗？\n\n如果其中任何一个的答案是否，我想这门竞赛或许也就没有必要去继续了吧。\n\n所幸，现在，我还认为这三个答案全都是`True`。\n\n如果明年的NOIP在发挥正常的情况下没有拿到`450+`，我想我就应该退役了。也不必再去耗它更多的半年，徒费时间，徒费神思。\n\n这次的考试也折射出一定的问题。虽然我比较长于代码实现，但是在思维上明显还是和巨佬有一定的差距。巨佬在现场没准可以现推结论，而我记住结论的情况下还是连暴力都没有敲出最优复杂度，令人窒息。而且思维上也很怠惰，明明`10`分就是`2.5`个积点却不想去写...下次千万不能有这样的情况...而且就是有的时候暴力代码写起来甚至都需要半个小时，还是有点长了。\n\n不管如何，这剩下的`200`天也要努力吧，不能让一年的努力白费啊。近一段时间打算学一下点分治、动态树、后缀数组、`AC`自动机啥的算法，以及刷一刷网络流二十四题和一些更多的数据结构题吧。远期目标还有就是一些基本的数学...比如高斯消元，`FFT`，矩阵，期望啥的。\n\n明年再战。希望明年的明天或者后天，我能够要么坦然的面对，要么昂起头，继续前进。\n\n![](4.jpg)\n\n\n","source":"_posts/BJOI2018游记.md","raw":"---\ntitle: BJOI2018游记\nurlname: bjoi2018-trip\ndate: 2018-04-15 21:46:43\ntags:\n- 省选\ncategories: OI\nvisible:\n---\n\n\n爆零滚粗。\n\n<!-- more -->\n\n## 集训\n\n在考试之前先有两个周末的集训。\n\n第一个周末是让我印象最为深刻的。开始没仔细看说明，结果一不小心就跑到了北师大附属实验。急忙打车，跑回到首师大附中，还好没有迟到。\n\n![](1.jpg)\n\n第一天上午的题非常有趣。`T1`比较简单，也成为了我四次考试以来唯一`A`掉的一道题。`T2 sumsum`好像是奇怪的点分治，还没有学过，所以自然也就不会做，甚至最后连暴力都懒得打。不过好像十分弱智的暴力也能过到`60`分？？也没有想到。`T3`是提答题，第一次做到，非常有趣。这个提答还是比较友善的，手玩竟然能有四十多分，可以说是很友善了。第一天就这么过去了，排了一个三四十名的名次。\n\n第二天就比较难了，竟然是三道数学题...于是我一道都不会做...做是不会做的，还把网给断了，于是就很绝望的去瞎搞。`T1`好像是个找规律+构造，`T2`不记得了...`T3`正解貌似也是构造...然而我在大佬的指点下写了个随机化，竟然搞到了三十多分，令人惊讶。\n\n两天的集训就这么结束了。也没有听懂什么，周末好几次险些写不完作业... \n<!-- 倒是又见到了冬令营的时候坐在我前面的妹子，这次知道她是哪个学校的叫什么了，嘿嘿。 -->\n\n## Day1\n\nDay1不太想说什么。\n\n`T1`好像是个线段树，不过正解是三个`set`，不知道为什么写的暴力稀里糊涂的就爆`0`了。\n\n`T2`是一道找规律的题目。然而蒟蒻如我像这种东西肯定是分析不出来的...随便推了个规律...然而发现一大堆反例，令人发指...\n\n`T3`貌似最简单。就是一个简单的`LCA`+前缀和查询，然而...没想到竟然挂在了取模上...这也一方面体现出了我的对拍人眼执行`diff`命令的不可靠，一方面也涨了知识：取模意义下的前缀和一定要加足够的$p$！！！要不然就`WA*n`了...出题人瞎随机的数据出了点锅，暴力$O(n^2)$的算法居然在平衡的树上跑到了$O(n \\log{n})$，然后...就过了？？？啊啊啊我要学`.bat`对拍！！！\n\n第一天期望得分`140`，实际得分`10`。\n\n## Day2\n\n正式考试的第二天。第一天就只有`10`分，所以考试之前有点慌，昨天讲的有上下界的网络流还不怎么会，而去年一道网络流都没有考过，考试前匆匆茫茫的看了看，希望能用到。\n\n然而，然而喜出望外的是，我最近一个多月学的东西，全部都没有考到。反而是考了一些奇奇怪怪的东西。\n\n`T1`是个提交答案题，琢磨一番样例之后发现自己连样例都推不出来，瞎玩了`10`分就看第二题。\n\n`T2`跟集训第一周的题很像，好像是徐明宽巨佬在考场上想出了某种特殊情况的解法...然后就出成了题。貌似40分的$O(n^2)$暴力很好想，然而我只写了个$O(n^3)$的二十分暴力。最后还被出题人坑了一分都没有...伤心...\n\n`T3`看了一眼...概率是啥？？？咋对分数取模来着...期望怎么算啊...不会啊...于是放弃。\n\n于是就陷入了颓废的状态。感觉中间三个小时过的特别的快，前后一个小时就非常的漫长...漫长到心态爆炸。\n\n第二天期望得分`30`，最后得分`8`分。\n\n讲完题等成绩的时候，出现了省队巨佬连连玩扫雷，大家纷纷围观，以及巨佬玩我不知道名字的Windows游戏的壮观景象。\n\n![](3.jpg)\n\n\n最后我校有了四个省队，所有去的高二 + `dmy`全都进了省队。\n\n`Day2 dmy`竟然`AK`了！第二名`140`分！总评`dmy`比第二名高了`80`分！害怕...\n\n## 最后\n\n今年初三有三个省队，高一三个省队，剩下的全都是高二。\n\n任务十分的艰巨啊。如果想要进到省队，不仅要打败高一，还要打败更为恐怖的初三。有的时候也在追问，我真的有天赋吗？真的能付得起这样的时间、精力的支出吗？如果今年的联赛和明年的省选季要停课的话，能接受失败的打击吗？\n\n如果其中任何一个的答案是否，我想这门竞赛或许也就没有必要去继续了吧。\n\n所幸，现在，我还认为这三个答案全都是`True`。\n\n如果明年的NOIP在发挥正常的情况下没有拿到`450+`，我想我就应该退役了。也不必再去耗它更多的半年，徒费时间，徒费神思。\n\n这次的考试也折射出一定的问题。虽然我比较长于代码实现，但是在思维上明显还是和巨佬有一定的差距。巨佬在现场没准可以现推结论，而我记住结论的情况下还是连暴力都没有敲出最优复杂度，令人窒息。而且思维上也很怠惰，明明`10`分就是`2.5`个积点却不想去写...下次千万不能有这样的情况...而且就是有的时候暴力代码写起来甚至都需要半个小时，还是有点长了。\n\n不管如何，这剩下的`200`天也要努力吧，不能让一年的努力白费啊。近一段时间打算学一下点分治、动态树、后缀数组、`AC`自动机啥的算法，以及刷一刷网络流二十四题和一些更多的数据结构题吧。远期目标还有就是一些基本的数学...比如高斯消元，`FFT`，矩阵，期望啥的。\n\n明年再战。希望明年的明天或者后天，我能够要么坦然的面对，要么昂起头，继续前进。\n\n![](4.jpg)\n\n\n","slug":"BJOI2018游记","published":1,"updated":"2018-04-15T14:52:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hp001bbljrjac1f20m","content":"<p>爆零滚粗。</p>\n<a id=\"more\"></a>\n<h2 id=\"集训\"><a href=\"#集训\" class=\"headerlink\" title=\"集训\"></a>集训</h2><p>在考试之前先有两个周末的集训。</p>\n<p>第一个周末是让我印象最为深刻的。开始没仔细看说明，结果一不小心就跑到了北师大附属实验。急忙打车，跑回到首师大附中，还好没有迟到。</p>\n<p><img src=\"1.jpg\" alt=\"\"></p>\n<p>第一天上午的题非常有趣。<code>T1</code>比较简单，也成为了我四次考试以来唯一<code>A</code>掉的一道题。<code>T2 sumsum</code>好像是奇怪的点分治，还没有学过，所以自然也就不会做，甚至最后连暴力都懒得打。不过好像十分弱智的暴力也能过到<code>60</code>分？？也没有想到。<code>T3</code>是提答题，第一次做到，非常有趣。这个提答还是比较友善的，手玩竟然能有四十多分，可以说是很友善了。第一天就这么过去了，排了一个三四十名的名次。</p>\n<p>第二天就比较难了，竟然是三道数学题…于是我一道都不会做…做是不会做的，还把网给断了，于是就很绝望的去瞎搞。<code>T1</code>好像是个找规律+构造，<code>T2</code>不记得了…<code>T3</code>正解貌似也是构造…然而我在大佬的指点下写了个随机化，竟然搞到了三十多分，令人惊讶。</p>\n<p>两天的集训就这么结束了。也没有听懂什么，周末好几次险些写不完作业…<br><!-- 倒是又见到了冬令营的时候坐在我前面的妹子，这次知道她是哪个学校的叫什么了，嘿嘿。 --></p>\n<h2 id=\"Day1\"><a href=\"#Day1\" class=\"headerlink\" title=\"Day1\"></a>Day1</h2><p>Day1不太想说什么。</p>\n<p><code>T1</code>好像是个线段树，不过正解是三个<code>set</code>，不知道为什么写的暴力稀里糊涂的就爆<code>0</code>了。</p>\n<p><code>T2</code>是一道找规律的题目。然而蒟蒻如我像这种东西肯定是分析不出来的…随便推了个规律…然而发现一大堆反例，令人发指…</p>\n<p><code>T3</code>貌似最简单。就是一个简单的<code>LCA</code>+前缀和查询，然而…没想到竟然挂在了取模上…这也一方面体现出了我的对拍人眼执行<code>diff</code>命令的不可靠，一方面也涨了知识：取模意义下的前缀和一定要加足够的$p$！！！要不然就<code>WA*n</code>了…出题人瞎随机的数据出了点锅，暴力$O(n^2)$的算法居然在平衡的树上跑到了$O(n \\log{n})$，然后…就过了？？？啊啊啊我要学<code>.bat</code>对拍！！！</p>\n<p>第一天期望得分<code>140</code>，实际得分<code>10</code>。</p>\n<h2 id=\"Day2\"><a href=\"#Day2\" class=\"headerlink\" title=\"Day2\"></a>Day2</h2><p>正式考试的第二天。第一天就只有<code>10</code>分，所以考试之前有点慌，昨天讲的有上下界的网络流还不怎么会，而去年一道网络流都没有考过，考试前匆匆茫茫的看了看，希望能用到。</p>\n<p>然而，然而喜出望外的是，我最近一个多月学的东西，全部都没有考到。反而是考了一些奇奇怪怪的东西。</p>\n<p><code>T1</code>是个提交答案题，琢磨一番样例之后发现自己连样例都推不出来，瞎玩了<code>10</code>分就看第二题。</p>\n<p><code>T2</code>跟集训第一周的题很像，好像是徐明宽巨佬在考场上想出了某种特殊情况的解法…然后就出成了题。貌似40分的$O(n^2)$暴力很好想，然而我只写了个$O(n^3)$的二十分暴力。最后还被出题人坑了一分都没有…伤心…</p>\n<p><code>T3</code>看了一眼…概率是啥？？？咋对分数取模来着…期望怎么算啊…不会啊…于是放弃。</p>\n<p>于是就陷入了颓废的状态。感觉中间三个小时过的特别的快，前后一个小时就非常的漫长…漫长到心态爆炸。</p>\n<p>第二天期望得分<code>30</code>，最后得分<code>8</code>分。</p>\n<p>讲完题等成绩的时候，出现了省队巨佬连连玩扫雷，大家纷纷围观，以及巨佬玩我不知道名字的Windows游戏的壮观景象。</p>\n<p><img src=\"3.jpg\" alt=\"\"></p>\n<p>最后我校有了四个省队，所有去的高二 + <code>dmy</code>全都进了省队。</p>\n<p><code>Day2 dmy</code>竟然<code>AK</code>了！第二名<code>140</code>分！总评<code>dmy</code>比第二名高了<code>80</code>分！害怕…</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>今年初三有三个省队，高一三个省队，剩下的全都是高二。</p>\n<p>任务十分的艰巨啊。如果想要进到省队，不仅要打败高一，还要打败更为恐怖的初三。有的时候也在追问，我真的有天赋吗？真的能付得起这样的时间、精力的支出吗？如果今年的联赛和明年的省选季要停课的话，能接受失败的打击吗？</p>\n<p>如果其中任何一个的答案是否，我想这门竞赛或许也就没有必要去继续了吧。</p>\n<p>所幸，现在，我还认为这三个答案全都是<code>True</code>。</p>\n<p>如果明年的NOIP在发挥正常的情况下没有拿到<code>450+</code>，我想我就应该退役了。也不必再去耗它更多的半年，徒费时间，徒费神思。</p>\n<p>这次的考试也折射出一定的问题。虽然我比较长于代码实现，但是在思维上明显还是和巨佬有一定的差距。巨佬在现场没准可以现推结论，而我记住结论的情况下还是连暴力都没有敲出最优复杂度，令人窒息。而且思维上也很怠惰，明明<code>10</code>分就是<code>2.5</code>个积点却不想去写…下次千万不能有这样的情况…而且就是有的时候暴力代码写起来甚至都需要半个小时，还是有点长了。</p>\n<p>不管如何，这剩下的<code>200</code>天也要努力吧，不能让一年的努力白费啊。近一段时间打算学一下点分治、动态树、后缀数组、<code>AC</code>自动机啥的算法，以及刷一刷网络流二十四题和一些更多的数据结构题吧。远期目标还有就是一些基本的数学…比如高斯消元，<code>FFT</code>，矩阵，期望啥的。</p>\n<p>明年再战。希望明年的明天或者后天，我能够要么坦然的面对，要么昂起头，继续前进。</p>\n<p><img src=\"4.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>爆零滚粗。</p>","more":"<h2 id=\"集训\"><a href=\"#集训\" class=\"headerlink\" title=\"集训\"></a>集训</h2><p>在考试之前先有两个周末的集训。</p>\n<p>第一个周末是让我印象最为深刻的。开始没仔细看说明，结果一不小心就跑到了北师大附属实验。急忙打车，跑回到首师大附中，还好没有迟到。</p>\n<p><img src=\"1.jpg\" alt=\"\"></p>\n<p>第一天上午的题非常有趣。<code>T1</code>比较简单，也成为了我四次考试以来唯一<code>A</code>掉的一道题。<code>T2 sumsum</code>好像是奇怪的点分治，还没有学过，所以自然也就不会做，甚至最后连暴力都懒得打。不过好像十分弱智的暴力也能过到<code>60</code>分？？也没有想到。<code>T3</code>是提答题，第一次做到，非常有趣。这个提答还是比较友善的，手玩竟然能有四十多分，可以说是很友善了。第一天就这么过去了，排了一个三四十名的名次。</p>\n<p>第二天就比较难了，竟然是三道数学题…于是我一道都不会做…做是不会做的，还把网给断了，于是就很绝望的去瞎搞。<code>T1</code>好像是个找规律+构造，<code>T2</code>不记得了…<code>T3</code>正解貌似也是构造…然而我在大佬的指点下写了个随机化，竟然搞到了三十多分，令人惊讶。</p>\n<p>两天的集训就这么结束了。也没有听懂什么，周末好几次险些写不完作业…<br><!-- 倒是又见到了冬令营的时候坐在我前面的妹子，这次知道她是哪个学校的叫什么了，嘿嘿。 --></p>\n<h2 id=\"Day1\"><a href=\"#Day1\" class=\"headerlink\" title=\"Day1\"></a>Day1</h2><p>Day1不太想说什么。</p>\n<p><code>T1</code>好像是个线段树，不过正解是三个<code>set</code>，不知道为什么写的暴力稀里糊涂的就爆<code>0</code>了。</p>\n<p><code>T2</code>是一道找规律的题目。然而蒟蒻如我像这种东西肯定是分析不出来的…随便推了个规律…然而发现一大堆反例，令人发指…</p>\n<p><code>T3</code>貌似最简单。就是一个简单的<code>LCA</code>+前缀和查询，然而…没想到竟然挂在了取模上…这也一方面体现出了我的对拍人眼执行<code>diff</code>命令的不可靠，一方面也涨了知识：取模意义下的前缀和一定要加足够的$p$！！！要不然就<code>WA*n</code>了…出题人瞎随机的数据出了点锅，暴力$O(n^2)$的算法居然在平衡的树上跑到了$O(n \\log{n})$，然后…就过了？？？啊啊啊我要学<code>.bat</code>对拍！！！</p>\n<p>第一天期望得分<code>140</code>，实际得分<code>10</code>。</p>\n<h2 id=\"Day2\"><a href=\"#Day2\" class=\"headerlink\" title=\"Day2\"></a>Day2</h2><p>正式考试的第二天。第一天就只有<code>10</code>分，所以考试之前有点慌，昨天讲的有上下界的网络流还不怎么会，而去年一道网络流都没有考过，考试前匆匆茫茫的看了看，希望能用到。</p>\n<p>然而，然而喜出望外的是，我最近一个多月学的东西，全部都没有考到。反而是考了一些奇奇怪怪的东西。</p>\n<p><code>T1</code>是个提交答案题，琢磨一番样例之后发现自己连样例都推不出来，瞎玩了<code>10</code>分就看第二题。</p>\n<p><code>T2</code>跟集训第一周的题很像，好像是徐明宽巨佬在考场上想出了某种特殊情况的解法…然后就出成了题。貌似40分的$O(n^2)$暴力很好想，然而我只写了个$O(n^3)$的二十分暴力。最后还被出题人坑了一分都没有…伤心…</p>\n<p><code>T3</code>看了一眼…概率是啥？？？咋对分数取模来着…期望怎么算啊…不会啊…于是放弃。</p>\n<p>于是就陷入了颓废的状态。感觉中间三个小时过的特别的快，前后一个小时就非常的漫长…漫长到心态爆炸。</p>\n<p>第二天期望得分<code>30</code>，最后得分<code>8</code>分。</p>\n<p>讲完题等成绩的时候，出现了省队巨佬连连玩扫雷，大家纷纷围观，以及巨佬玩我不知道名字的Windows游戏的壮观景象。</p>\n<p><img src=\"3.jpg\" alt=\"\"></p>\n<p>最后我校有了四个省队，所有去的高二 + <code>dmy</code>全都进了省队。</p>\n<p><code>Day2 dmy</code>竟然<code>AK</code>了！第二名<code>140</code>分！总评<code>dmy</code>比第二名高了<code>80</code>分！害怕…</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>今年初三有三个省队，高一三个省队，剩下的全都是高二。</p>\n<p>任务十分的艰巨啊。如果想要进到省队，不仅要打败高一，还要打败更为恐怖的初三。有的时候也在追问，我真的有天赋吗？真的能付得起这样的时间、精力的支出吗？如果今年的联赛和明年的省选季要停课的话，能接受失败的打击吗？</p>\n<p>如果其中任何一个的答案是否，我想这门竞赛或许也就没有必要去继续了吧。</p>\n<p>所幸，现在，我还认为这三个答案全都是<code>True</code>。</p>\n<p>如果明年的NOIP在发挥正常的情况下没有拿到<code>450+</code>，我想我就应该退役了。也不必再去耗它更多的半年，徒费时间，徒费神思。</p>\n<p>这次的考试也折射出一定的问题。虽然我比较长于代码实现，但是在思维上明显还是和巨佬有一定的差距。巨佬在现场没准可以现推结论，而我记住结论的情况下还是连暴力都没有敲出最优复杂度，令人窒息。而且思维上也很怠惰，明明<code>10</code>分就是<code>2.5</code>个积点却不想去写…下次千万不能有这样的情况…而且就是有的时候暴力代码写起来甚至都需要半个小时，还是有点长了。</p>\n<p>不管如何，这剩下的<code>200</code>天也要努力吧，不能让一年的努力白费啊。近一段时间打算学一下点分治、动态树、后缀数组、<code>AC</code>自动机啥的算法，以及刷一刷网络流二十四题和一些更多的数据结构题吧。远期目标还有就是一些基本的数学…比如高斯消元，<code>FFT</code>，矩阵，期望啥的。</p>\n<p>明年再战。希望明年的明天或者后天，我能够要么坦然的面对，要么昂起头，继续前进。</p>\n<p><img src=\"4.jpg\" alt=\"\"></p>"},{"title":"Dinic学习笔记","urlname":"dinic-notes","date":"2018-02-08T06:31:15.000Z","visible":null,"_content":"\nDinic算法是一种用于网络流中最大流的增广路算法，其时间复杂度为$O(n^2 \\times m)$，但大多数情况下会远远优于此时间复杂度。\n\n<!-- more -->\n\n## 基本概念\n\n从Menci神犇的[博客](https://oi.men.ci/dinic-notes/)复制而来。我觉得这写的是很好的一篇介绍，除了代码风格不太喜欢。\n\n- 容量： ${capacity}(e)$ 表示一条有向边 $e(u,v)$ 的最大允许的流量。\n\n- 流量： ${flow}(e)$ 表示一条有向边 $e(u,v)$ 总容量中已被占用的流量。\n\n- 剩余容量（残量）：即 $capacity(e)−flow(e)$，表示当前时刻某条有向边 $e(u,v)$ 总流量中未被占用的部分。\n\n- 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为$0$，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n- 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n- 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。\n\n- 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。\n\n- 层次： $level(u)$ 表示节点 $u$ 在层次图中与源点的距离。\n\n- 层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。\n\n## 思路\n\n用文字叙述大概如下：\n\n```\n1. 建立以出发点为源点的层次图（即源点到各店的距离）\n2. 在层次图&残量网络中寻找增广路，并增广流量\n3. 重复2直到找不到增广路\n4. 重复123直到不存在层次图\n```\n\n## 实现\n\n建立层次图使用bfs，而寻找增广路则是使用dfs递归增广。\n具体实现的时候也有一定的技巧，在代码里面有注释。\n\n反向边存在的意义是什么呢？形象来说其实就是给你一个后悔的机会，往一边流去之后还能再回来。注意反向边的容量在我这里初始为0。\n\n有一个优化就是当前弧优化。这个优化是很显而易见的。如果这条边在当前层次图下找不到路，那么这条边在当前层次图内就再也不会用到。所以我们单开一个cur数组，记录目前遍历到的边，这样就可以进行优化。\n\n## 代码\n\n以[Luogu P3376](https://www.luogu.org/problemnew/show/P3376)为例\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge{\n    int from,to,flow,cap;\n    int next;\n}edge[201000];\nint fir[10100],dis[10100],cur[10100];\n\nint n,m,s,t,tot = 2;//tot从2开始是最舒服的，既可以直接异或，后面的终止条件也不用想来想去。\n\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));//清空当前边\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int nowe = fir[nown];nowe!=0;nowe = edge[nowe].next){\n            int v = edge[nowe].to;\n            if(dis[v] == 0 && edge[nowe].cap > edge[nowe].flow){\n                //两个条件：未遍历而且边可以增广\n                dis[v] = dis[nown]+1;\n                q.push(v);\n                //由于我们只沿最短路增广，所以这里就可以直接break掉了。\n                if(v == t)\n                    return dis[t];\n            }\n        }\n    }\n    return dis[t];\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    //找到终点或没得可找 这个优化很重要\n    if(nown == t || limit == 0)\n        return limit;\n    for(int &nowe = cur[nown];nowe!=0;nowe = edge[nowe].next){\n        //这里有当前弧优化\n        int v = edge[nowe].to;\n        if(dis[v] == dis[nown]+1 && edge[nowe].flow < edge[nowe].cap){\n            //满足层次图条件(沿着最短路)\n            int f = dfs(v,min(edge[nowe].cap-edge[nowe].flow,limit));\n            if(f>0){\n                //更改当前边\n                edge[nowe].flow+=f;\n                edge[nowe^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs()){//bfs是步骤1\n        while( (f = dfs(s)) > 0)//dfs是步骤2\n            ans+=f;\n    }\n    return ans;\n}\n\nvoid addedge(int a,int b,int c){\n    edge[tot].from = a;edge[tot].to = b;\n    edge[tot].cap = c;edge[tot].flow = 0;\n    edge[tot].next = fir[a];fir[a] = tot;\n    tot++;\n}\n\nint main(){\n    scanf(\"%d %d %d %d\",&n,&m,&s,&t);\n    for(int i = 0;i<m;i++){\n        int a,b,c;\n        scanf(\"%d %d %d\",&a,&b,&c);\n        addedge(a,b,c);\n        addedge(b,a,0);//需要加反向边\n    }\n    printf(\"%d\\n\",dinic());\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/Dinic学习笔记.md","raw":"---\ntitle: Dinic学习笔记\nurlname: dinic-notes\ndate: 2018-02-08 14:31:15\ntags:\n- 笔记\n- 图论\n- Dinic\n- 模板\ncategories: OI\nvisible:\n---\n\nDinic算法是一种用于网络流中最大流的增广路算法，其时间复杂度为$O(n^2 \\times m)$，但大多数情况下会远远优于此时间复杂度。\n\n<!-- more -->\n\n## 基本概念\n\n从Menci神犇的[博客](https://oi.men.ci/dinic-notes/)复制而来。我觉得这写的是很好的一篇介绍，除了代码风格不太喜欢。\n\n- 容量： ${capacity}(e)$ 表示一条有向边 $e(u,v)$ 的最大允许的流量。\n\n- 流量： ${flow}(e)$ 表示一条有向边 $e(u,v)$ 总容量中已被占用的流量。\n\n- 剩余容量（残量）：即 $capacity(e)−flow(e)$，表示当前时刻某条有向边 $e(u,v)$ 总流量中未被占用的部分。\n\n- 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为$0$，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n- 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n- 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。\n\n- 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。\n\n- 层次： $level(u)$ 表示节点 $u$ 在层次图中与源点的距离。\n\n- 层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。\n\n## 思路\n\n用文字叙述大概如下：\n\n```\n1. 建立以出发点为源点的层次图（即源点到各店的距离）\n2. 在层次图&残量网络中寻找增广路，并增广流量\n3. 重复2直到找不到增广路\n4. 重复123直到不存在层次图\n```\n\n## 实现\n\n建立层次图使用bfs，而寻找增广路则是使用dfs递归增广。\n具体实现的时候也有一定的技巧，在代码里面有注释。\n\n反向边存在的意义是什么呢？形象来说其实就是给你一个后悔的机会，往一边流去之后还能再回来。注意反向边的容量在我这里初始为0。\n\n有一个优化就是当前弧优化。这个优化是很显而易见的。如果这条边在当前层次图下找不到路，那么这条边在当前层次图内就再也不会用到。所以我们单开一个cur数组，记录目前遍历到的边，这样就可以进行优化。\n\n## 代码\n\n以[Luogu P3376](https://www.luogu.org/problemnew/show/P3376)为例\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge{\n    int from,to,flow,cap;\n    int next;\n}edge[201000];\nint fir[10100],dis[10100],cur[10100];\n\nint n,m,s,t,tot = 2;//tot从2开始是最舒服的，既可以直接异或，后面的终止条件也不用想来想去。\n\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));//清空当前边\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int nowe = fir[nown];nowe!=0;nowe = edge[nowe].next){\n            int v = edge[nowe].to;\n            if(dis[v] == 0 && edge[nowe].cap > edge[nowe].flow){\n                //两个条件：未遍历而且边可以增广\n                dis[v] = dis[nown]+1;\n                q.push(v);\n                //由于我们只沿最短路增广，所以这里就可以直接break掉了。\n                if(v == t)\n                    return dis[t];\n            }\n        }\n    }\n    return dis[t];\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    //找到终点或没得可找 这个优化很重要\n    if(nown == t || limit == 0)\n        return limit;\n    for(int &nowe = cur[nown];nowe!=0;nowe = edge[nowe].next){\n        //这里有当前弧优化\n        int v = edge[nowe].to;\n        if(dis[v] == dis[nown]+1 && edge[nowe].flow < edge[nowe].cap){\n            //满足层次图条件(沿着最短路)\n            int f = dfs(v,min(edge[nowe].cap-edge[nowe].flow,limit));\n            if(f>0){\n                //更改当前边\n                edge[nowe].flow+=f;\n                edge[nowe^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs()){//bfs是步骤1\n        while( (f = dfs(s)) > 0)//dfs是步骤2\n            ans+=f;\n    }\n    return ans;\n}\n\nvoid addedge(int a,int b,int c){\n    edge[tot].from = a;edge[tot].to = b;\n    edge[tot].cap = c;edge[tot].flow = 0;\n    edge[tot].next = fir[a];fir[a] = tot;\n    tot++;\n}\n\nint main(){\n    scanf(\"%d %d %d %d\",&n,&m,&s,&t);\n    for(int i = 0;i<m;i++){\n        int a,b,c;\n        scanf(\"%d %d %d\",&a,&b,&c);\n        addedge(a,b,c);\n        addedge(b,a,0);//需要加反向边\n    }\n    printf(\"%d\\n\",dinic());\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"Dinic学习笔记","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hs001fbljrpi0ar20g","content":"<p>Dinic算法是一种用于网络流中最大流的增广路算法，其时间复杂度为$O(n^2 \\times m)$，但大多数情况下会远远优于此时间复杂度。</p>\n<a id=\"more\"></a>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>从Menci神犇的<a href=\"https://oi.men.ci/dinic-notes/\" target=\"_blank\" rel=\"noopener\">博客</a>复制而来。我觉得这写的是很好的一篇介绍，除了代码风格不太喜欢。</p>\n<ul>\n<li><p>容量： ${capacity}(e)$ 表示一条有向边 $e(u,v)$ 的最大允许的流量。</p>\n</li>\n<li><p>流量： ${flow}(e)$ 表示一条有向边 $e(u,v)$ 总容量中已被占用的流量。</p>\n</li>\n<li><p>剩余容量（残量）：即 $capacity(e)−flow(e)$，表示当前时刻某条有向边 $e(u,v)$ 总流量中未被占用的部分。</p>\n</li>\n<li><p>反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为$0$，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。</p>\n</li>\n<li><p>残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。</p>\n</li>\n<li><p>增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。</p>\n</li>\n<li><p>增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。</p>\n</li>\n<li><p>层次： $level(u)$ 表示节点 $u$ 在层次图中与源点的距离。</p>\n</li>\n<li><p>层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>用文字叙述大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 建立以出发点为源点的层次图（即源点到各店的距离）</span><br><span class=\"line\">2. 在层次图&amp;残量网络中寻找增广路，并增广流量</span><br><span class=\"line\">3. 重复2直到找不到增广路</span><br><span class=\"line\">4. 重复123直到不存在层次图</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>建立层次图使用bfs，而寻找增广路则是使用dfs递归增广。<br>具体实现的时候也有一定的技巧，在代码里面有注释。</p>\n<p>反向边存在的意义是什么呢？形象来说其实就是给你一个后悔的机会，往一边流去之后还能再回来。注意反向边的容量在我这里初始为0。</p>\n<p>有一个优化就是当前弧优化。这个优化是很显而易见的。如果这条边在当前层次图下找不到路，那么这条边在当前层次图内就再也不会用到。所以我们单开一个cur数组，记录目前遍历到的边，这样就可以进行优化。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3376\" target=\"_blank\" rel=\"noopener\">Luogu P3376</a>为例</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,flow,cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">201000</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[<span class=\"number\">10100</span>],dis[<span class=\"number\">10100</span>],cur[<span class=\"number\">10100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,tot = <span class=\"number\">2</span>;<span class=\"comment\">//tot从2开始是最舒服的，既可以直接异或，后面的终止条件也不用想来想去。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(cur,fir,<span class=\"keyword\">sizeof</span>(fir));<span class=\"comment\">//清空当前边</span></span><br><span class=\"line\">    q.push(s);dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe!=<span class=\"number\">0</span>;nowe = edge[nowe].next)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[v] == <span class=\"number\">0</span> &amp;&amp; edge[nowe].cap &gt; edge[nowe].flow)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//两个条件：未遍历而且边可以增广</span></span><br><span class=\"line\">                dis[v] = dis[nown]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                q.push(v);</span><br><span class=\"line\">                <span class=\"comment\">//由于我们只沿最短路增广，所以这里就可以直接break掉了。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(v == t)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> dis[t];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> limit = <span class=\"number\">0x3f3f3f3f</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到终点或没得可找 这个优化很重要</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nown == t || limit == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> limit;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> &amp;nowe = cur[nown];nowe!=<span class=\"number\">0</span>;nowe = edge[nowe].next)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里有当前弧优化</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[v] == dis[nown]+<span class=\"number\">1</span> &amp;&amp; edge[nowe].flow &lt; edge[nowe].cap)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//满足层次图条件(沿着最短路)</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> f = dfs(v,min(edge[nowe].cap-edge[nowe].flow,limit));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//更改当前边</span></span><br><span class=\"line\">                edge[nowe].flow+=f;</span><br><span class=\"line\">                edge[nowe^<span class=\"number\">1</span>].flow-=f;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dinic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>,f;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(bfs())&#123;<span class=\"comment\">//bfs是步骤1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>( (f = dfs(s)) &gt; <span class=\"number\">0</span>)<span class=\"comment\">//dfs是步骤2</span></span><br><span class=\"line\">            ans+=f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    edge[tot].from = a;edge[tot].to = b;</span><br><span class=\"line\">    edge[tot].cap = c;edge[tot].flow = <span class=\"number\">0</span>;</span><br><span class=\"line\">    edge[tot].next = fir[a];fir[a] = tot;</span><br><span class=\"line\">    tot++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d %d\"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        addedge(a,b,c);</span><br><span class=\"line\">        addedge(b,a,<span class=\"number\">0</span>);<span class=\"comment\">//需要加反向边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,dinic());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>Dinic算法是一种用于网络流中最大流的增广路算法，其时间复杂度为$O(n^2 \\times m)$，但大多数情况下会远远优于此时间复杂度。</p>","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>从Menci神犇的<a href=\"https://oi.men.ci/dinic-notes/\" target=\"_blank\" rel=\"noopener\">博客</a>复制而来。我觉得这写的是很好的一篇介绍，除了代码风格不太喜欢。</p>\n<ul>\n<li><p>容量： ${capacity}(e)$ 表示一条有向边 $e(u,v)$ 的最大允许的流量。</p>\n</li>\n<li><p>流量： ${flow}(e)$ 表示一条有向边 $e(u,v)$ 总容量中已被占用的流量。</p>\n</li>\n<li><p>剩余容量（残量）：即 $capacity(e)−flow(e)$，表示当前时刻某条有向边 $e(u,v)$ 总流量中未被占用的部分。</p>\n</li>\n<li><p>反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为$0$，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。</p>\n</li>\n<li><p>残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。</p>\n</li>\n<li><p>增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。</p>\n</li>\n<li><p>增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。</p>\n</li>\n<li><p>层次： $level(u)$ 表示节点 $u$ 在层次图中与源点的距离。</p>\n</li>\n<li><p>层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>用文字叙述大概如下：</p>\n<!--�0-->\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>建立层次图使用bfs，而寻找增广路则是使用dfs递归增广。<br>具体实现的时候也有一定的技巧，在代码里面有注释。</p>\n<p>反向边存在的意义是什么呢？形象来说其实就是给你一个后悔的机会，往一边流去之后还能再回来。注意反向边的容量在我这里初始为0。</p>\n<p>有一个优化就是当前弧优化。这个优化是很显而易见的。如果这条边在当前层次图下找不到路，那么这条边在当前层次图内就再也不会用到。所以我们单开一个cur数组，记录目前遍历到的边，这样就可以进行优化。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3376\" target=\"_blank\" rel=\"noopener\">Luogu P3376</a>为例</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�1-->\n\n</div></div>"},{"title":"OI大事记","date":"2017-12-13T14:10:57.000Z","visible":"hide","urlname":"milestone","_content":"## 里程碑\n<!-- more -->\n\n2017-10-17 21:00 Luogu AC*1\n\n2017-10-23 08:50 Luogu 第一次蓝名\n\n2017-10-29 10:05 Luogu 第一次绿名\n\n2017-11-01 20:07 Luogu AC*50\n\n2017-11-11 ~ 12   NOIp2017 tg观光游省二\n\n2017-11-25 11:51 Luogu AC*100\n\n2017-11-29 17:55 Luogu 第一次橙名\n\n2017-12-17 22:28 Luogu AC*150\n\n2017-12-22 21:03 Luogu 提交*500\n\n2018-01-03 19:16 Luogu 第一次红名\n\n2018-01-20 20:34 Luogu AC*200\n\n2018-01-20 ~ 27   BJWC2018旅游\n\n2018-02-14 15:44 Luogu AC*250\n\n2018-02-23 13:47 Luogu 提交*1000\n\n2018-04-05 16:45 Luogu AC*300\n\n2018-04-01 ~ 15 BJOI2018旅游\n\n","source":"_posts/OI大事记.md","raw":"---\ntitle: OI大事记\ndate: 2017-12-13 22:10:57\ntags:\ncategories: OI\nvisible: hide\nurlname: milestone\n---\n## 里程碑\n<!-- more -->\n\n2017-10-17 21:00 Luogu AC*1\n\n2017-10-23 08:50 Luogu 第一次蓝名\n\n2017-10-29 10:05 Luogu 第一次绿名\n\n2017-11-01 20:07 Luogu AC*50\n\n2017-11-11 ~ 12   NOIp2017 tg观光游省二\n\n2017-11-25 11:51 Luogu AC*100\n\n2017-11-29 17:55 Luogu 第一次橙名\n\n2017-12-17 22:28 Luogu AC*150\n\n2017-12-22 21:03 Luogu 提交*500\n\n2018-01-03 19:16 Luogu 第一次红名\n\n2018-01-20 20:34 Luogu AC*200\n\n2018-01-20 ~ 27   BJWC2018旅游\n\n2018-02-14 15:44 Luogu AC*250\n\n2018-02-23 13:47 Luogu 提交*1000\n\n2018-04-05 16:45 Luogu AC*300\n\n2018-04-01 ~ 15 BJOI2018旅游\n\n","slug":"OI大事记","published":1,"updated":"2018-04-05T09:20:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ht001hbljrz7uroccc","content":"<h2 id=\"里程碑\"><a href=\"#里程碑\" class=\"headerlink\" title=\"里程碑\"></a>里程碑</h2><a id=\"more\"></a>\n<p>2017-10-17 21:00 Luogu AC*1</p>\n<p>2017-10-23 08:50 Luogu 第一次蓝名</p>\n<p>2017-10-29 10:05 Luogu 第一次绿名</p>\n<p>2017-11-01 20:07 Luogu AC*50</p>\n<p>2017-11-11 ~ 12   NOIp2017 tg观光游省二</p>\n<p>2017-11-25 11:51 Luogu AC*100</p>\n<p>2017-11-29 17:55 Luogu 第一次橙名</p>\n<p>2017-12-17 22:28 Luogu AC*150</p>\n<p>2017-12-22 21:03 Luogu 提交*500</p>\n<p>2018-01-03 19:16 Luogu 第一次红名</p>\n<p>2018-01-20 20:34 Luogu AC*200</p>\n<p>2018-01-20 ~ 27   BJWC2018旅游</p>\n<p>2018-02-14 15:44 Luogu AC*250</p>\n<p>2018-02-23 13:47 Luogu 提交*1000</p>\n<p>2018-04-05 16:45 Luogu AC*300</p>\n<p>2018-04-01 ~ 15 BJOI2018旅游</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"里程碑\"><a href=\"#里程碑\" class=\"headerlink\" title=\"里程碑\"></a>里程碑</h2>","more":"<p>2017-10-17 21:00 Luogu AC*1</p>\n<p>2017-10-23 08:50 Luogu 第一次蓝名</p>\n<p>2017-10-29 10:05 Luogu 第一次绿名</p>\n<p>2017-11-01 20:07 Luogu AC*50</p>\n<p>2017-11-11 ~ 12   NOIp2017 tg观光游省二</p>\n<p>2017-11-25 11:51 Luogu AC*100</p>\n<p>2017-11-29 17:55 Luogu 第一次橙名</p>\n<p>2017-12-17 22:28 Luogu AC*150</p>\n<p>2017-12-22 21:03 Luogu 提交*500</p>\n<p>2018-01-03 19:16 Luogu 第一次红名</p>\n<p>2018-01-20 20:34 Luogu AC*200</p>\n<p>2018-01-20 ~ 27   BJWC2018旅游</p>\n<p>2018-02-14 15:44 Luogu AC*250</p>\n<p>2018-02-23 13:47 Luogu 提交*1000</p>\n<p>2018-04-05 16:45 Luogu AC*300</p>\n<p>2018-04-01 ~ 15 BJOI2018旅游</p>"},{"title":"Splay学习笔记","urlname":"Splay-note","date":"2018-06-02T14:29:18.000Z","visible":null,"_content":"\n伸展树（`Splay Tree`）是一种二叉查找树，它能在$O(log n)$内完成插入、查找和删除操作。它是由丹尼尔·斯立特`(Daniel Sleator)`和罗伯特·塔扬`(Robert Tarjan)`在1985年发明的。其也可以维护区间信息，当作类似线段树的数据结构。\n\n<!-- more -->\n\n## 233\n\n后面再补。\n\n最近做了个ppt。先扔上来，以后再补。\n\n{% pdf splay_cqq.pdf %}\n\n## 附件\n\ntarjan原始论文：\n\n{% pdf splay_tarjan.pdf %}\n","source":"_posts/Splay学习笔记.md","raw":"---\ntitle: Splay学习笔记\nurlname: Splay-note\ndate: 2018-06-02 22:29:18\ntags:\n- 笔记\n- Splay\n- 平衡树\n- 数据结构\ncategories: OI\nvisible:\n---\n\n伸展树（`Splay Tree`）是一种二叉查找树，它能在$O(log n)$内完成插入、查找和删除操作。它是由丹尼尔·斯立特`(Daniel Sleator)`和罗伯特·塔扬`(Robert Tarjan)`在1985年发明的。其也可以维护区间信息，当作类似线段树的数据结构。\n\n<!-- more -->\n\n## 233\n\n后面再补。\n\n最近做了个ppt。先扔上来，以后再补。\n\n{% pdf splay_cqq.pdf %}\n\n## 附件\n\ntarjan原始论文：\n\n{% pdf splay_tarjan.pdf %}\n","slug":"Splay学习笔记","published":1,"updated":"2018-06-07T15:04:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3hx001jbljriy2ai74z","content":"<p>伸展树（<code>Splay Tree</code>）是一种二叉查找树，它能在$O(log n)$内完成插入、查找和删除操作。它是由丹尼尔·斯立特<code>(Daniel Sleator)</code>和罗伯特·塔扬<code>(Robert Tarjan)</code>在1985年发明的。其也可以维护区间信息，当作类似线段树的数据结构。</p>\n<a id=\"more\"></a>\n<h2 id=\"233\"><a href=\"#233\" class=\"headerlink\" title=\"233\"></a>233</h2><p>后面再补。</p>\n<p>最近做了个ppt。先扔上来，以后再补。</p>\n\n\n\t<div class=\"row\">\n    <embed src=\"splay_cqq.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h2 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h2><p>tarjan原始论文：</p>\n\n\n\t<div class=\"row\">\n    <embed src=\"splay_tarjan.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n","site":{"data":{}},"excerpt":"<p>伸展树（<code>Splay Tree</code>）是一种二叉查找树，它能在$O(log n)$内完成插入、查找和删除操作。它是由丹尼尔·斯立特<code>(Daniel Sleator)</code>和罗伯特·塔扬<code>(Robert Tarjan)</code>在1985年发明的。其也可以维护区间信息，当作类似线段树的数据结构。</p>","more":"<h2 id=\"233\"><a href=\"#233\" class=\"headerlink\" title=\"233\"></a>233</h2><p>后面再补。</p>\n<p>最近做了个ppt。先扔上来，以后再补。</p>\n\n\n\t<div class=\"row\">\n    <embed src=\"splay_cqq.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n\n<h2 id=\"附件\"><a href=\"#附件\" class=\"headerlink\" title=\"附件\"></a>附件</h2><p>tarjan原始论文：</p>\n\n\n\t<div class=\"row\">\n    <embed src=\"splay_tarjan.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>"},{"title":"Treap学习笔记","date":"2018-01-30T10:41:41.000Z","visible":null,"mathjax":true,"urlname":"treap-notes","_content":"\n闲下来了，开始写一点学习笔记，也希望能给后人造福吧。\n\n第一篇来说一说Treap。\n<!-- more -->\n\n## Treap是什么\n### Tree + Heap\n树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为$O(\\log {n})$。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。\n<!-- more -->\n\n## 基本思想及操作\n一般在Treap里面维护一个最小堆。\n### 旋转\n旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作在代码部分解释。\n旋转的时间复杂度是$O(1)$，因为只需要修改常数个指针。\n\n### 按关键字寻找\n可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。\n\n### 插入\n在Treap中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整Treap的堆性质。\n\n### 删除\n如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。\n\n### 查询排名\n在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。\n\n### 按排名查找\n需要对每一个节点维护一个`size`值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的`size`值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。\n\n### 前驱&后继\n在这里，前驱定义为小于x，且最大的数。后继同理。这个的寻找稍微复杂。\n以前驱为例。\n\n如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。\n\n第一种很容易想明白，第二种稍难一些。\n\n![前驱和后继](lower_upper.gif)\n\n以此图为例。比如我们寻找12的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现12的前驱是11，因为11是最后一个向右寻找，即下一次寻找是其右儿子（16）的节点。\n\n可以注意到，11的左子树上的点全都比6小，不符合要求；12的左子树不存在，12的右子树上的点都比12大，而11-12的路径上的点，其应当是全都是向左寻找的，也都比12要大，而在11以上的点，应当都比12要大（11是左儿子的时候），或者比11要小（11是右儿子的时候），所以，6就是7的前驱。\n\n后继同理。\n\n插入、删除等以上操作的\b期望时间复杂度都是$O(\\log {n})$，因为树的期望高度h是$\\log {n}$。\n\n\n## 代码\n以[洛谷P3369 普通平衡树](https://www.luogu.org/problemnew/show/P3369)为例。代码是指针版，不记录父节点，递归操作，有轻微压行，采用java换行风格。\n\n（其实我还是觉得数组好写\n\n### 结构体的定义\n\n```cpp\ntemplate<typename T,size_t siz>\nstruct treap{\n    struct node_t{\n        T val;\n        int p,size,cnt;\n        node_t *son[2];\n    };\n    int treapcnt;\n    node_t pool[siz<<1],*root,*null;\n```\n\n在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。\n\n对于每一个节点，我们维护以下几个信息：\b关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。\n\n在结构体的变量中，我们维护了一个静态内存池，\b内存池已经使用的数量，根节点的指针，以及一个虚的空节点。\n\n在这里自己定义一个空节点的好处主要是可以避免`NULL`导致的`segmentation fault`，以及让函数编写变得更加简单。\n\n需要注意的是，视题目不同，`cnt`变量可能可以省去。\n\n### 一些简单函数\n\n```cpp\n    void newnode(node_t *&r){\n        r = &pool[Treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void update(node_t *r){\n        r->size = r->son[0]->size + r->son[1]->size + r->cnt;\n    }\n    node_t* find_minormax(node_t *r,int tmp){//0最小 1最大\n        while(r->son[tmp]!=null)\n            r = r->son[tmp];\n        return r;\n    }\n```\n\nnewnode函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用newnode函数对null赋值了，因为会产生`NULL`这种可怕的东西。其实在这里也可以把赋关键字、随机值、`size`值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。\n\nupdate函数在这里完成对节点`size`值的更新，很好理解。\n\nfind_minormax函数在这里完成对以r为根节点的树上最大或最小节点的寻找。也很简单，就不解释了。\n\n后两个函数可以放到node结构体里面，但是我不太喜欢那么做，因为那样会使箭头的数目大大增多，从而导致头疼（雾。\n\n### 结构体的初始化\n\n```cpp\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        null->size = null->val = 0;\n        null->p = MAXINT;\n        root = null;\n        srand(time(NULL));\n    }\n```\n\n结构体的初始化不难，有几点需要注意：\n\b\n+ 空指针的`size`需要为0\n+ 空指针的随机值需要**足够大**（最大堆中足够小，最好是maxint，否则有可能在之后的删除操作中被转上去，然后树就断了\n+ 最好srand一下\n\n### 旋转\n\n```cpp\n    void rotate(node_t *&r,int tmp){//0左旋，1右旋\n        node_t *t = r->son[1-tmp];\n        r->son[1-tmp] = t->son[tmp];\n        t->son[tmp] = r;\n        update(r),update(t);\n        r = t;\n    }\n```\n\n![旋转图片](rotate.gif)\n\n旋转操作的文字叙述：\n（括号里文字以左旋为例）\n\n1. 选定当前节点r *（图中的x）*\n2. 找到并记录需要旋上来的节点t（左旋旋右儿子，右旋左儿子）*（图中的y）*\n3. 把t将要被覆盖的儿子（与旋转方向相同的儿子）接到t在r原来的位置上 *（把b接在x的右子位置上）*\n4. 把r接到t空出来的位置上 *（把x接到y的x的左子树上）*\n5. 更新`size`值 *（更新x，y的`size`）*\n\n由于我们没有记录父节点，所以这个旋转的写法跟Splay的旋转写法不太像。但其实Splay也可以这么写，只不过没有必要。\n\n其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误\n\n但需要注意的是，旋转很有可能（就是会破坏一个合法Treap的堆性质，所以旋转在Treap中只用来维护堆的性质，而不用在其他的地方。而且这里的指针是**引用**传递，才能修改对应父节点的儿子指针。\n\n有一点很重要的就是要维护`size`的值，而且是从下到上。\n\n### 插入\n\n```cpp\n    void __insert(node_t *&r,T v){\n        if(r == null){\n            newnode(r);\n            r->val = v,r->cnt = 1,r->p = rand();\n        }\n        else{\n            if(r->val == v)\n                r->cnt++;\n            else{\n                int tmp = r->val < v;\n                __insert(r->son[tmp],v);\n                if(r->son[tmp]->p < r->p)\n                    rotate(r,1-tmp);\n            }\n        }\n        update(r);\n    }\n```\n\n用文字说明Treap的插入策略：\n\n1. 递归边界：寻找到节点，cnt++或者已经到达空节点，赋值一个新节点\n2. 递归添加节点，比当前节点小向左，比当前节点大向右\n3. 维护最小堆的性质\n4. 更新`size`值\n\n在维护最小堆的性质的时候，如果子节点的权值较小，那我们就需要把它转上来。\n\n需要注意，这里的节点是**引用**方式传入，这样才能对父节点的儿子指针进行修改，从而完成树的连接\n再次重复，不要忘记更新`size`值。\n\n### 删除\n\n```cpp\n    void __erase(node_t *&r,T v){\n        if(r->val == v){\n            if(r->cnt > 1) r->cnt--;\n            else{\n                if(r->son[0]==null && r->son[1]==null){\n                    r = null;return;\n                }\n                else{//还有子节点，\n                    int tmp = r->son[1]->p < r->son[0]->p;\n                    rotate(r,1-tmp);\n                    __erase(r,v);\n                }\n            }\n        }\n        else{\n            int tmp = r->val < v;\n            __erase(r->son[tmp],v);\n        }\n        update(r);\n    }\n```\n\n用文字说明Treap的删除策略：\n\n1. 递归边界：要删除的节点没有儿子节点\n2. 寻找到当前节点，减少数量或者向下旋转\n3. 维护最小堆的性质，即把两个儿子中权值较小的旋转上来\n4. 递归删除节点**注意此处的节点指针仍是r，因为r在旋转中已经发生了变化**\n5. 更新`size`值\n\n删除的时候最需要注意的已经在上面指出。\n\n还有在旋转比较的时候一定比较的是优先级！！！\n\nTreap的删除和插入其实很像，只不过递归的位置相反。插入是先递归再维护，而删除是先维护再递归。\n\n### 查询排名&排名查询\n\n```cpp\n    int __getrank(node_t *r,T v){//查找数v的排名\n        if(r->val == v||r == null)//记得判空！\n            return r->son[0]->size + 1;\n        else if(v < r->val)\n            return __getrank(r->son[0],v);\n        else\n            return __getrank(r->son[1],v) + r->son[0]->size + r->cnt;\n    }\n    node_t* __qrank(node_t *r,int rank){//查找以rank排名的数\n        rank -= r->son[0]->size;\n        if(rank<=0)\n            return __qrank(r->son[0],rank + r->son[0]->size);\n        else if(rank <= r->cnt)\n            return r;\n        else\n            return __qrank(r->son[1],rank - r->cnt);\n    }\n```\n\n这两个比较简单，而且在上面也讲的很详细了，所以就一块说。\n\n查询排名和排名查询其实是相反的操作，只需要注意将+1，-1和空节点等问题处理好了就可以了。\n\n### 前驱和后继\n\n```cpp\n    node_t *loworup(T v,int t){//0代表前驱，1代表后继\n        node_t *last = null,*nown = root;\n        while(nown->val!=v && nown!=null){\n            int tmp =  nown->val < v;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null)\n            last = find_minormax(nown->son[t],1-t);\n        return last;\n    }\n```\n\n这两个操作其实是完全相反的，所以合到了一个函数里面，在后面的进一步的封装中再分开。\n\n思路在上面已经提到，在这里只需要注意对不存在的值的前驱／后继进行处理。我们查不到不存在的值的节点，但我们可以假装那里有一个节点。因为null的孩子也是null，所以这段代码也可以直接使用在值的前驱和后继里面。\n\n~~多说一句，在Splay里面，我们可以直接把待查节点splay到根然后瞎搞一通~~\n\n### 输出树\n\n```cpp\n    void __print(node_t *r,int depth = 0){\n        if(r == null) return;\n        else{\n            __print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');//打印深度\n            printf(\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->size,r->p,r->son[0]!=null,r->son[1]!=null);\n            __print(r->son[1],depth+1);\n        }\n    }\n```\n\n按照中序遍历打印一棵树。主要在调试的时候用的多。有一个小技巧就是记录一个深度，然后把深度长度的空格打印出来，这样就可以更直观的看到各个节点的深度什么的。\n\n\n### 封装\n\n```cpp\n    void insert(T v){__insert(root,v);}\n    void erase(T v){__erase(root,v);}\n    int getrank(T v){return __getrank(root,v);}\n    int qrank(int rank){return __qrank(root,rank)->val;}\n    int lower(T v){return loworup(v,0)->val;}\n    int upper(T v){return loworup(v,1)->val;}\n    void print(){__print(root);}\n```\n\n封装其实没有必要，可以用一些判断来代替。但是我们为了让代码更像工程的代码，而且让前面的代码更美观，更令人赏心悦目，所以我们封装一下吧。\n\n\n## 完整代码及注释\n\n题目：[洛谷P3369 普通平衡树](https://www.luogu.org/problemnew/show/P3369)\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#define maxint  2147483647\nusing namespace std;\n\ntemplate<typename T,size_t siz>//模版T,需要有等于不等于和小于运算符\nstruct treap{\n    private:\n    struct node_t{\n        T val;\n        int p,size,cnt;\n        node_t *son[2];\n    };\n    int treapcnt;\n    node_t pool[siz<<1],*root,*null;\n    void newnode(node_t *&r){\n        r = &pool[treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void update(node_t *r){\n        r->size = r->son[0]->size+r->son[1]->size+r->cnt;\n    }\n    void rotate(node_t *&r,int tmp){//0左旋，1右旋\n        node_t *t = r->son[1-tmp];//找到需要旋上来的节点\n        r->son[1-tmp] = t->son[tmp];//将被选节点的被遮蔽的儿子交给上面的节点\n        t->son[tmp] = r;//将r作为t的儿子\n        update(r),update(t);//注意更新顺序！先儿子后父亲\n        r = t;//通过引用更改上方节点的儿子\n    }\n    void __insert(node_t *&r,T v){//r代表当前节点，v代表关键字\n        if(r == null){//如果r的地方已经没有节点\n            newnode(r);//新建节点，并通过引用添加至上面节点的儿子\n            r->val = v,r->cnt = 1,r->p = rand();//对相关信息的设置\n        }\n        else{\n            if(r->val == v) //如果已经添加过，直接给数量++\n                r->cnt++;\n            else{\n                int tmp = r->val < v;\n                __insert(r->son[tmp],v);//递归更改\n                if(r->son[tmp]->p < r->p)//维护treap性质\n                    rotate(r,1-tmp);\n            }\n        }\n        update(r);//不要忘了更新！\n    }\n    void __erase(node_t *&r,T v){\n        if(r->val == v){//已经找到\n            if(r->cnt > 1) r->cnt--;\n            else{\n                if(r->son[0]==null && r->son[1]==null){//已经没有子节点，直接删除\n                    r = null;return;\n                }\n                else{//还有子节点，\n                    int tmp = r->son[1]->p < r->son[0]->p;\n                    rotate(r,1-tmp); //找到其中随机权值较小的一个旋转替换当前节点\n                    __erase(r,v);//递归删除 注意此处r已经发生了变化\n                }\n            }\n        }\n        else{//还没找到\n            int tmp = r->val < v;\n            __erase(r->son[tmp],v);//递归寻找\n        }\n        update(r);//不要忘了更新！\n    }\n    void __print(node_t *r,int depth = 0){//调试用\n        if(r == null) return;\n        else{\n            __print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');//打印深度\n            printf(\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->size,r->p,r->son[0]!=null,r->son[1]!=null);\n            __print(r->son[1],depth+1);\n        }\n    }\n    int __getrank(node_t *r,T v){//查找数v的排名\n        if(r->val == v||r == null)//记得判空！\n            return r->son[0]->size +1;\n        else if(v < r->val)\n            return __getrank(r->son[0],v);\n        else\n            return __getrank(r->son[1],v) + r->son[0]->size + r->cnt;\n    }\n    node_t* __qrank(node_t *r,int rank){//查找以rank排名的数\n        rank -= r->son[0]->size;\n        if(rank<=0)\n            return __qrank(r->son[0],rank + r->son[0]->size);\n        else if(rank <= r->cnt)\n            return r;\n        else\n            return __qrank(r->son[1],rank - r->cnt);\n    }\n    node_t *find_minormax(node_t *r,int tmp){\n        //寻找以r为根节点的树上最大或最小节点\n        while(r->son[tmp]!=null)\n            r = r->son[tmp];\n        return r;\n    }\n    node_t *loworup(T v,int t){//0代表前驱，1代表后继\n        node_t *last = null,*nown = root;//last表示上一个没有当前寻找方向的节点\n        while(nown->val!=v && nown!=null){//记得判空!\n            int tmp =  nown->val < v;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null)//有子节点\n            last = find_minormax(nown->son[t],1-t);//寻找对应方向子节点的最小or最大值\n        return last;\n    }\n    public:\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        null->size = null->val=0;\n        null->p = maxint;\n        root = null;\n        srand(time(NULL));\n    }\n    void insert(T v){__insert(root,v);}\n    void erase(T v){__erase(root,v);}\n    int getrank(T v){return __getrank(root,v);}\n    int qrank(int rank){return __qrank(root,rank)->val;}\n    int lower(T v){return loworup(v,0)->val;}\n    int upper(T v){return loworup(v,1)->val;}\n    void print(){__print(root);}\n};\n\ntreap<int,200000> w;\n\nint n;\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 0;i<n;i++){\n        int op, x;\n        scanf(\"%d %d\",&op,&x);\n        if(op == 1)      w.insert(x);\n        else if(op == 2) w.erase(x);\n        else if(op == 3) printf(\"%d\\n\",w.getrank(x));\n        else if(op == 4) printf(\"%d\\n\",w.qrank(x));\n        else if(op == 5) printf(\"%d\\n\",w.lower(x));\n        else if(op == 6) printf(\"%d\\n\",w.upper(x));\n        else if(op == 0) w.print();\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n## 例题\n\n{% post_link 「ZJOI2007」报表统计-平衡树 「ZJOI2007」报表统计 %}\n","source":"_posts/Treap学习笔记.md","raw":"---\ntitle: Treap学习笔记\ndate: 2018-01-30 18:41:41\ntags: \n- 数据结构\n- 平衡树\n- Treap\n- 笔记\n- 模板\ncategories: OI\nvisible:\nmathjax: true\nurlname: treap-notes\n---\n\n闲下来了，开始写一点学习笔记，也希望能给后人造福吧。\n\n第一篇来说一说Treap。\n<!-- more -->\n\n## Treap是什么\n### Tree + Heap\n树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为$O(\\log {n})$。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。\n<!-- more -->\n\n## 基本思想及操作\n一般在Treap里面维护一个最小堆。\n### 旋转\n旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作在代码部分解释。\n旋转的时间复杂度是$O(1)$，因为只需要修改常数个指针。\n\n### 按关键字寻找\n可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。\n\n### 插入\n在Treap中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整Treap的堆性质。\n\n### 删除\n如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。\n\n### 查询排名\n在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。\n\n### 按排名查找\n需要对每一个节点维护一个`size`值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的`size`值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。\n\n### 前驱&后继\n在这里，前驱定义为小于x，且最大的数。后继同理。这个的寻找稍微复杂。\n以前驱为例。\n\n如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。\n\n第一种很容易想明白，第二种稍难一些。\n\n![前驱和后继](lower_upper.gif)\n\n以此图为例。比如我们寻找12的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现12的前驱是11，因为11是最后一个向右寻找，即下一次寻找是其右儿子（16）的节点。\n\n可以注意到，11的左子树上的点全都比6小，不符合要求；12的左子树不存在，12的右子树上的点都比12大，而11-12的路径上的点，其应当是全都是向左寻找的，也都比12要大，而在11以上的点，应当都比12要大（11是左儿子的时候），或者比11要小（11是右儿子的时候），所以，6就是7的前驱。\n\n后继同理。\n\n插入、删除等以上操作的\b期望时间复杂度都是$O(\\log {n})$，因为树的期望高度h是$\\log {n}$。\n\n\n## 代码\n以[洛谷P3369 普通平衡树](https://www.luogu.org/problemnew/show/P3369)为例。代码是指针版，不记录父节点，递归操作，有轻微压行，采用java换行风格。\n\n（其实我还是觉得数组好写\n\n### 结构体的定义\n\n```cpp\ntemplate<typename T,size_t siz>\nstruct treap{\n    struct node_t{\n        T val;\n        int p,size,cnt;\n        node_t *son[2];\n    };\n    int treapcnt;\n    node_t pool[siz<<1],*root,*null;\n```\n\n在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。\n\n对于每一个节点，我们维护以下几个信息：\b关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。\n\n在结构体的变量中，我们维护了一个静态内存池，\b内存池已经使用的数量，根节点的指针，以及一个虚的空节点。\n\n在这里自己定义一个空节点的好处主要是可以避免`NULL`导致的`segmentation fault`，以及让函数编写变得更加简单。\n\n需要注意的是，视题目不同，`cnt`变量可能可以省去。\n\n### 一些简单函数\n\n```cpp\n    void newnode(node_t *&r){\n        r = &pool[Treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void update(node_t *r){\n        r->size = r->son[0]->size + r->son[1]->size + r->cnt;\n    }\n    node_t* find_minormax(node_t *r,int tmp){//0最小 1最大\n        while(r->son[tmp]!=null)\n            r = r->son[tmp];\n        return r;\n    }\n```\n\nnewnode函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用newnode函数对null赋值了，因为会产生`NULL`这种可怕的东西。其实在这里也可以把赋关键字、随机值、`size`值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。\n\nupdate函数在这里完成对节点`size`值的更新，很好理解。\n\nfind_minormax函数在这里完成对以r为根节点的树上最大或最小节点的寻找。也很简单，就不解释了。\n\n后两个函数可以放到node结构体里面，但是我不太喜欢那么做，因为那样会使箭头的数目大大增多，从而导致头疼（雾。\n\n### 结构体的初始化\n\n```cpp\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        null->size = null->val = 0;\n        null->p = MAXINT;\n        root = null;\n        srand(time(NULL));\n    }\n```\n\n结构体的初始化不难，有几点需要注意：\n\b\n+ 空指针的`size`需要为0\n+ 空指针的随机值需要**足够大**（最大堆中足够小，最好是maxint，否则有可能在之后的删除操作中被转上去，然后树就断了\n+ 最好srand一下\n\n### 旋转\n\n```cpp\n    void rotate(node_t *&r,int tmp){//0左旋，1右旋\n        node_t *t = r->son[1-tmp];\n        r->son[1-tmp] = t->son[tmp];\n        t->son[tmp] = r;\n        update(r),update(t);\n        r = t;\n    }\n```\n\n![旋转图片](rotate.gif)\n\n旋转操作的文字叙述：\n（括号里文字以左旋为例）\n\n1. 选定当前节点r *（图中的x）*\n2. 找到并记录需要旋上来的节点t（左旋旋右儿子，右旋左儿子）*（图中的y）*\n3. 把t将要被覆盖的儿子（与旋转方向相同的儿子）接到t在r原来的位置上 *（把b接在x的右子位置上）*\n4. 把r接到t空出来的位置上 *（把x接到y的x的左子树上）*\n5. 更新`size`值 *（更新x，y的`size`）*\n\n由于我们没有记录父节点，所以这个旋转的写法跟Splay的旋转写法不太像。但其实Splay也可以这么写，只不过没有必要。\n\n其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误\n\n但需要注意的是，旋转很有可能（就是会破坏一个合法Treap的堆性质，所以旋转在Treap中只用来维护堆的性质，而不用在其他的地方。而且这里的指针是**引用**传递，才能修改对应父节点的儿子指针。\n\n有一点很重要的就是要维护`size`的值，而且是从下到上。\n\n### 插入\n\n```cpp\n    void __insert(node_t *&r,T v){\n        if(r == null){\n            newnode(r);\n            r->val = v,r->cnt = 1,r->p = rand();\n        }\n        else{\n            if(r->val == v)\n                r->cnt++;\n            else{\n                int tmp = r->val < v;\n                __insert(r->son[tmp],v);\n                if(r->son[tmp]->p < r->p)\n                    rotate(r,1-tmp);\n            }\n        }\n        update(r);\n    }\n```\n\n用文字说明Treap的插入策略：\n\n1. 递归边界：寻找到节点，cnt++或者已经到达空节点，赋值一个新节点\n2. 递归添加节点，比当前节点小向左，比当前节点大向右\n3. 维护最小堆的性质\n4. 更新`size`值\n\n在维护最小堆的性质的时候，如果子节点的权值较小，那我们就需要把它转上来。\n\n需要注意，这里的节点是**引用**方式传入，这样才能对父节点的儿子指针进行修改，从而完成树的连接\n再次重复，不要忘记更新`size`值。\n\n### 删除\n\n```cpp\n    void __erase(node_t *&r,T v){\n        if(r->val == v){\n            if(r->cnt > 1) r->cnt--;\n            else{\n                if(r->son[0]==null && r->son[1]==null){\n                    r = null;return;\n                }\n                else{//还有子节点，\n                    int tmp = r->son[1]->p < r->son[0]->p;\n                    rotate(r,1-tmp);\n                    __erase(r,v);\n                }\n            }\n        }\n        else{\n            int tmp = r->val < v;\n            __erase(r->son[tmp],v);\n        }\n        update(r);\n    }\n```\n\n用文字说明Treap的删除策略：\n\n1. 递归边界：要删除的节点没有儿子节点\n2. 寻找到当前节点，减少数量或者向下旋转\n3. 维护最小堆的性质，即把两个儿子中权值较小的旋转上来\n4. 递归删除节点**注意此处的节点指针仍是r，因为r在旋转中已经发生了变化**\n5. 更新`size`值\n\n删除的时候最需要注意的已经在上面指出。\n\n还有在旋转比较的时候一定比较的是优先级！！！\n\nTreap的删除和插入其实很像，只不过递归的位置相反。插入是先递归再维护，而删除是先维护再递归。\n\n### 查询排名&排名查询\n\n```cpp\n    int __getrank(node_t *r,T v){//查找数v的排名\n        if(r->val == v||r == null)//记得判空！\n            return r->son[0]->size + 1;\n        else if(v < r->val)\n            return __getrank(r->son[0],v);\n        else\n            return __getrank(r->son[1],v) + r->son[0]->size + r->cnt;\n    }\n    node_t* __qrank(node_t *r,int rank){//查找以rank排名的数\n        rank -= r->son[0]->size;\n        if(rank<=0)\n            return __qrank(r->son[0],rank + r->son[0]->size);\n        else if(rank <= r->cnt)\n            return r;\n        else\n            return __qrank(r->son[1],rank - r->cnt);\n    }\n```\n\n这两个比较简单，而且在上面也讲的很详细了，所以就一块说。\n\n查询排名和排名查询其实是相反的操作，只需要注意将+1，-1和空节点等问题处理好了就可以了。\n\n### 前驱和后继\n\n```cpp\n    node_t *loworup(T v,int t){//0代表前驱，1代表后继\n        node_t *last = null,*nown = root;\n        while(nown->val!=v && nown!=null){\n            int tmp =  nown->val < v;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null)\n            last = find_minormax(nown->son[t],1-t);\n        return last;\n    }\n```\n\n这两个操作其实是完全相反的，所以合到了一个函数里面，在后面的进一步的封装中再分开。\n\n思路在上面已经提到，在这里只需要注意对不存在的值的前驱／后继进行处理。我们查不到不存在的值的节点，但我们可以假装那里有一个节点。因为null的孩子也是null，所以这段代码也可以直接使用在值的前驱和后继里面。\n\n~~多说一句，在Splay里面，我们可以直接把待查节点splay到根然后瞎搞一通~~\n\n### 输出树\n\n```cpp\n    void __print(node_t *r,int depth = 0){\n        if(r == null) return;\n        else{\n            __print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');//打印深度\n            printf(\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->size,r->p,r->son[0]!=null,r->son[1]!=null);\n            __print(r->son[1],depth+1);\n        }\n    }\n```\n\n按照中序遍历打印一棵树。主要在调试的时候用的多。有一个小技巧就是记录一个深度，然后把深度长度的空格打印出来，这样就可以更直观的看到各个节点的深度什么的。\n\n\n### 封装\n\n```cpp\n    void insert(T v){__insert(root,v);}\n    void erase(T v){__erase(root,v);}\n    int getrank(T v){return __getrank(root,v);}\n    int qrank(int rank){return __qrank(root,rank)->val;}\n    int lower(T v){return loworup(v,0)->val;}\n    int upper(T v){return loworup(v,1)->val;}\n    void print(){__print(root);}\n```\n\n封装其实没有必要，可以用一些判断来代替。但是我们为了让代码更像工程的代码，而且让前面的代码更美观，更令人赏心悦目，所以我们封装一下吧。\n\n\n## 完整代码及注释\n\n题目：[洛谷P3369 普通平衡树](https://www.luogu.org/problemnew/show/P3369)\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#define maxint  2147483647\nusing namespace std;\n\ntemplate<typename T,size_t siz>//模版T,需要有等于不等于和小于运算符\nstruct treap{\n    private:\n    struct node_t{\n        T val;\n        int p,size,cnt;\n        node_t *son[2];\n    };\n    int treapcnt;\n    node_t pool[siz<<1],*root,*null;\n    void newnode(node_t *&r){\n        r = &pool[treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void update(node_t *r){\n        r->size = r->son[0]->size+r->son[1]->size+r->cnt;\n    }\n    void rotate(node_t *&r,int tmp){//0左旋，1右旋\n        node_t *t = r->son[1-tmp];//找到需要旋上来的节点\n        r->son[1-tmp] = t->son[tmp];//将被选节点的被遮蔽的儿子交给上面的节点\n        t->son[tmp] = r;//将r作为t的儿子\n        update(r),update(t);//注意更新顺序！先儿子后父亲\n        r = t;//通过引用更改上方节点的儿子\n    }\n    void __insert(node_t *&r,T v){//r代表当前节点，v代表关键字\n        if(r == null){//如果r的地方已经没有节点\n            newnode(r);//新建节点，并通过引用添加至上面节点的儿子\n            r->val = v,r->cnt = 1,r->p = rand();//对相关信息的设置\n        }\n        else{\n            if(r->val == v) //如果已经添加过，直接给数量++\n                r->cnt++;\n            else{\n                int tmp = r->val < v;\n                __insert(r->son[tmp],v);//递归更改\n                if(r->son[tmp]->p < r->p)//维护treap性质\n                    rotate(r,1-tmp);\n            }\n        }\n        update(r);//不要忘了更新！\n    }\n    void __erase(node_t *&r,T v){\n        if(r->val == v){//已经找到\n            if(r->cnt > 1) r->cnt--;\n            else{\n                if(r->son[0]==null && r->son[1]==null){//已经没有子节点，直接删除\n                    r = null;return;\n                }\n                else{//还有子节点，\n                    int tmp = r->son[1]->p < r->son[0]->p;\n                    rotate(r,1-tmp); //找到其中随机权值较小的一个旋转替换当前节点\n                    __erase(r,v);//递归删除 注意此处r已经发生了变化\n                }\n            }\n        }\n        else{//还没找到\n            int tmp = r->val < v;\n            __erase(r->son[tmp],v);//递归寻找\n        }\n        update(r);//不要忘了更新！\n    }\n    void __print(node_t *r,int depth = 0){//调试用\n        if(r == null) return;\n        else{\n            __print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');//打印深度\n            printf(\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->size,r->p,r->son[0]!=null,r->son[1]!=null);\n            __print(r->son[1],depth+1);\n        }\n    }\n    int __getrank(node_t *r,T v){//查找数v的排名\n        if(r->val == v||r == null)//记得判空！\n            return r->son[0]->size +1;\n        else if(v < r->val)\n            return __getrank(r->son[0],v);\n        else\n            return __getrank(r->son[1],v) + r->son[0]->size + r->cnt;\n    }\n    node_t* __qrank(node_t *r,int rank){//查找以rank排名的数\n        rank -= r->son[0]->size;\n        if(rank<=0)\n            return __qrank(r->son[0],rank + r->son[0]->size);\n        else if(rank <= r->cnt)\n            return r;\n        else\n            return __qrank(r->son[1],rank - r->cnt);\n    }\n    node_t *find_minormax(node_t *r,int tmp){\n        //寻找以r为根节点的树上最大或最小节点\n        while(r->son[tmp]!=null)\n            r = r->son[tmp];\n        return r;\n    }\n    node_t *loworup(T v,int t){//0代表前驱，1代表后继\n        node_t *last = null,*nown = root;//last表示上一个没有当前寻找方向的节点\n        while(nown->val!=v && nown!=null){//记得判空!\n            int tmp =  nown->val < v;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null)//有子节点\n            last = find_minormax(nown->son[t],1-t);//寻找对应方向子节点的最小or最大值\n        return last;\n    }\n    public:\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        null->size = null->val=0;\n        null->p = maxint;\n        root = null;\n        srand(time(NULL));\n    }\n    void insert(T v){__insert(root,v);}\n    void erase(T v){__erase(root,v);}\n    int getrank(T v){return __getrank(root,v);}\n    int qrank(int rank){return __qrank(root,rank)->val;}\n    int lower(T v){return loworup(v,0)->val;}\n    int upper(T v){return loworup(v,1)->val;}\n    void print(){__print(root);}\n};\n\ntreap<int,200000> w;\n\nint n;\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 0;i<n;i++){\n        int op, x;\n        scanf(\"%d %d\",&op,&x);\n        if(op == 1)      w.insert(x);\n        else if(op == 2) w.erase(x);\n        else if(op == 3) printf(\"%d\\n\",w.getrank(x));\n        else if(op == 4) printf(\"%d\\n\",w.qrank(x));\n        else if(op == 5) printf(\"%d\\n\",w.lower(x));\n        else if(op == 6) printf(\"%d\\n\",w.upper(x));\n        else if(op == 0) w.print();\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n## 例题\n\n{% post_link 「ZJOI2007」报表统计-平衡树 「ZJOI2007」报表统计 %}\n","slug":"Treap学习笔记","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i0001nbljr0oyrrtlw","content":"<p>闲下来了，开始写一点学习笔记，也希望能给后人造福吧。</p>\n<p>第一篇来说一说Treap。<br><a id=\"more\"></a></p>\n<h2 id=\"Treap是什么\"><a href=\"#Treap是什么\" class=\"headerlink\" title=\"Treap是什么\"></a>Treap是什么</h2><h3 id=\"Tree-Heap\"><a href=\"#Tree-Heap\" class=\"headerlink\" title=\"Tree + Heap\"></a>Tree + Heap</h3><p>树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为$O(\\log {n})$。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。<br><!-- more --></p>\n<h2 id=\"基本思想及操作\"><a href=\"#基本思想及操作\" class=\"headerlink\" title=\"基本思想及操作\"></a>基本思想及操作</h2><p>一般在Treap里面维护一个最小堆。</p>\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p>旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作在代码部分解释。<br>旋转的时间复杂度是$O(1)$，因为只需要修改常数个指针。</p>\n<h3 id=\"按关键字寻找\"><a href=\"#按关键字寻找\" class=\"headerlink\" title=\"按关键字寻找\"></a>按关键字寻找</h3><p>可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>在Treap中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整Treap的堆性质。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。</p>\n<h3 id=\"查询排名\"><a href=\"#查询排名\" class=\"headerlink\" title=\"查询排名\"></a>查询排名</h3><p>在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。</p>\n<h3 id=\"按排名查找\"><a href=\"#按排名查找\" class=\"headerlink\" title=\"按排名查找\"></a>按排名查找</h3><p>需要对每一个节点维护一个<code>size</code>值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的<code>size</code>值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。</p>\n<h3 id=\"前驱-amp-后继\"><a href=\"#前驱-amp-后继\" class=\"headerlink\" title=\"前驱&amp;后继\"></a>前驱&amp;后继</h3><p>在这里，前驱定义为小于x，且最大的数。后继同理。这个的寻找稍微复杂。<br>以前驱为例。</p>\n<p>如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。</p>\n<p>第一种很容易想明白，第二种稍难一些。</p>\n<p><img src=\"lower_upper.gif\" alt=\"前驱和后继\"></p>\n<p>以此图为例。比如我们寻找12的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现12的前驱是11，因为11是最后一个向右寻找，即下一次寻找是其右儿子（16）的节点。</p>\n<p>可以注意到，11的左子树上的点全都比6小，不符合要求；12的左子树不存在，12的右子树上的点都比12大，而11-12的路径上的点，其应当是全都是向左寻找的，也都比12要大，而在11以上的点，应当都比12要大（11是左儿子的时候），或者比11要小（11是右儿子的时候），所以，6就是7的前驱。</p>\n<p>后继同理。</p>\n<p>插入、删除等以上操作的\b期望时间复杂度都是$O(\\log {n})$，因为树的期望高度h是$\\log {n}$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3369\" target=\"_blank\" rel=\"noopener\">洛谷P3369 普通平衡树</a>为例。代码是指针版，不记录父节点，递归操作，有轻微压行，采用java换行风格。</p>\n<p>（其实我还是觉得数组好写</p>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">size_t</span> siz&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">treap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">        T val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,size,cnt;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> treapcnt;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[siz&lt;&lt;<span class=\"number\">1</span>],*root,*null;</span><br></pre></td></tr></table></figure>\n<p>在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。</p>\n<p>对于每一个节点，我们维护以下几个信息：\b关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。</p>\n<p>在结构体的变量中，我们维护了一个静态内存池，\b内存池已经使用的数量，根节点的指针，以及一个虚的空节点。</p>\n<p>在这里自己定义一个空节点的好处主要是可以避免<code>NULL</code>导致的<code>segmentation fault</code>，以及让函数编写变得更加简单。</p>\n<p>需要注意的是，视题目不同，<code>cnt</code>变量可能可以省去。</p>\n<h3 id=\"一些简单函数\"><a href=\"#一些简单函数\" class=\"headerlink\" title=\"一些简单函数\"></a>一些简单函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r)</span></span>&#123;</span><br><span class=\"line\">    r = &amp;pool[Treapcnt++];</span><br><span class=\"line\">    r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r)</span></span>&#123;</span><br><span class=\"line\">    r-&gt;size = r-&gt;son[<span class=\"number\">0</span>]-&gt;size + r-&gt;son[<span class=\"number\">1</span>]-&gt;size + r-&gt;cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">node_t</span>* find_minormax(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> tmp)&#123;<span class=\"comment\">//0最小 1最大</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-&gt;son[tmp]!=null)</span><br><span class=\"line\">        r = r-&gt;son[tmp];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>newnode函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用newnode函数对null赋值了，因为会产生<code>NULL</code>这种可怕的东西。其实在这里也可以把赋关键字、随机值、<code>size</code>值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。</p>\n<p>update函数在这里完成对节点<code>size</code>值的更新，很好理解。</p>\n<p>find_minormax函数在这里完成对以r为根节点的树上最大或最小节点的寻找。也很简单，就不解释了。</p>\n<p>后两个函数可以放到node结构体里面，但是我不太喜欢那么做，因为那样会使箭头的数目大大增多，从而导致头疼（雾。</p>\n<h3 id=\"结构体的初始化\"><a href=\"#结构体的初始化\" class=\"headerlink\" title=\"结构体的初始化\"></a>结构体的初始化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">treap()&#123;</span><br><span class=\"line\">    treapcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    newnode(null);</span><br><span class=\"line\">    null-&gt;size = null-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">    null-&gt;p = MAXINT;</span><br><span class=\"line\">    root = null;</span><br><span class=\"line\">    srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体的初始化不难，有几点需要注意：<br>\b</p>\n<ul>\n<li>空指针的<code>size</code>需要为0</li>\n<li>空指针的随机值需要<strong>足够大</strong>（最大堆中足够小，最好是maxint，否则有可能在之后的删除操作中被转上去，然后树就断了</li>\n<li>最好srand一下</li>\n</ul>\n<h3 id=\"旋转-1\"><a href=\"#旋转-1\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> tmp)</span></span>&#123;<span class=\"comment\">//0左旋，1右旋</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *t = r-&gt;son[<span class=\"number\">1</span>-tmp];</span><br><span class=\"line\">    r-&gt;son[<span class=\"number\">1</span>-tmp] = t-&gt;son[tmp];</span><br><span class=\"line\">    t-&gt;son[tmp] = r;</span><br><span class=\"line\">    update(r),update(t);</span><br><span class=\"line\">    r = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"rotate.gif\" alt=\"旋转图片\"></p>\n<p>旋转操作的文字叙述：<br>（括号里文字以左旋为例）</p>\n<ol>\n<li>选定当前节点r <em>（图中的x）</em></li>\n<li>找到并记录需要旋上来的节点t（左旋旋右儿子，右旋左儿子）<em>（图中的y）</em></li>\n<li>把t将要被覆盖的儿子（与旋转方向相同的儿子）接到t在r原来的位置上 <em>（把b接在x的右子位置上）</em></li>\n<li>把r接到t空出来的位置上 <em>（把x接到y的x的左子树上）</em></li>\n<li>更新<code>size</code>值 <em>（更新x，y的<code>size</code>）</em></li>\n</ol>\n<p>由于我们没有记录父节点，所以这个旋转的写法跟Splay的旋转写法不太像。但其实Splay也可以这么写，只不过没有必要。</p>\n<p>其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误</p>\n<p>但需要注意的是，旋转很有可能（就是会破坏一个合法Treap的堆性质，所以旋转在Treap中只用来维护堆的性质，而不用在其他的地方。而且这里的指针是<strong>引用</strong>传递，才能修改对应父节点的儿子指针。</p>\n<p>有一点很重要的就是要维护<code>size</code>的值，而且是从下到上。</p>\n<h3 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __insert(<span class=\"keyword\">node_t</span> *&amp;r,T v)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r == null)&#123;</span><br><span class=\"line\">        newnode(r);</span><br><span class=\"line\">        r-&gt;val = v,r-&gt;cnt = <span class=\"number\">1</span>,r-&gt;p = rand();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;val == v)</span><br><span class=\"line\">            r-&gt;cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = r-&gt;val &lt; v;</span><br><span class=\"line\">            __insert(r-&gt;son[tmp],v);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;son[tmp]-&gt;p &lt; r-&gt;p)</span><br><span class=\"line\">                rotate(r,<span class=\"number\">1</span>-tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用文字说明Treap的插入策略：</p>\n<ol>\n<li>递归边界：寻找到节点，cnt++或者已经到达空节点，赋值一个新节点</li>\n<li>递归添加节点，比当前节点小向左，比当前节点大向右</li>\n<li>维护最小堆的性质</li>\n<li>更新<code>size</code>值</li>\n</ol>\n<p>在维护最小堆的性质的时候，如果子节点的权值较小，那我们就需要把它转上来。</p>\n<p>需要注意，这里的节点是<strong>引用</strong>方式传入，这样才能对父节点的儿子指针进行修改，从而完成树的连接<br>再次重复，不要忘记更新<code>size</code>值。</p>\n<h3 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __erase(<span class=\"keyword\">node_t</span> *&amp;r,T v)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r-&gt;val == v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;cnt &gt; <span class=\"number\">1</span>) r-&gt;cnt--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>]==null &amp;&amp; r-&gt;son[<span class=\"number\">1</span>]==null)&#123;</span><br><span class=\"line\">                r = null;<span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//还有子节点，</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = r-&gt;son[<span class=\"number\">1</span>]-&gt;p &lt; r-&gt;son[<span class=\"number\">0</span>]-&gt;p;</span><br><span class=\"line\">                rotate(r,<span class=\"number\">1</span>-tmp);</span><br><span class=\"line\">                __erase(r,v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = r-&gt;val &lt; v;</span><br><span class=\"line\">        __erase(r-&gt;son[tmp],v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用文字说明Treap的删除策略：</p>\n<ol>\n<li>递归边界：要删除的节点没有儿子节点</li>\n<li>寻找到当前节点，减少数量或者向下旋转</li>\n<li>维护最小堆的性质，即把两个儿子中权值较小的旋转上来</li>\n<li>递归删除节点<strong>注意此处的节点指针仍是r，因为r在旋转中已经发生了变化</strong></li>\n<li>更新<code>size</code>值</li>\n</ol>\n<p>删除的时候最需要注意的已经在上面指出。</p>\n<p>还有在旋转比较的时候一定比较的是优先级！！！</p>\n<p>Treap的删除和插入其实很像，只不过递归的位置相反。插入是先递归再维护，而删除是先维护再递归。</p>\n<h3 id=\"查询排名-amp-排名查询\"><a href=\"#查询排名-amp-排名查询\" class=\"headerlink\" title=\"查询排名&amp;排名查询\"></a>查询排名&amp;排名查询</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> __getrank(<span class=\"keyword\">node_t</span> *r,T v)&#123;<span class=\"comment\">//查找数v的排名</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r-&gt;val == v||r == null)<span class=\"comment\">//记得判空！</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r-&gt;son[<span class=\"number\">0</span>]-&gt;size + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(v &lt; r-&gt;val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __getrank(r-&gt;son[<span class=\"number\">0</span>],v);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> __getrank(r-&gt;son[<span class=\"number\">1</span>],v) + r-&gt;son[<span class=\"number\">0</span>]-&gt;size + r-&gt;cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">node_t</span>* __qrank(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> rank)&#123;<span class=\"comment\">//查找以rank排名的数</span></span><br><span class=\"line\">    rank -= r-&gt;son[<span class=\"number\">0</span>]-&gt;size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rank&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> __qrank(r-&gt;son[<span class=\"number\">0</span>],rank + r-&gt;son[<span class=\"number\">0</span>]-&gt;size);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rank &lt;= r-&gt;cnt)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> __qrank(r-&gt;son[<span class=\"number\">1</span>],rank - r-&gt;cnt);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个比较简单，而且在上面也讲的很详细了，所以就一块说。</p>\n<p>查询排名和排名查询其实是相反的操作，只需要注意将+1，-1和空节点等问题处理好了就可以了。</p>\n<h3 id=\"前驱和后继\"><a href=\"#前驱和后继\" class=\"headerlink\" title=\"前驱和后继\"></a>前驱和后继</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node_t</span> *loworup(T v,<span class=\"keyword\">int</span> t)&#123;<span class=\"comment\">//0代表前驱，1代表后继</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *last = null,*nown = root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown-&gt;val!=v &amp;&amp; nown!=null)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp =  nown-&gt;val &lt; v;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp!=t) last = nown;</span><br><span class=\"line\">        nown = nown-&gt;son[tmp];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nown-&gt;son[t]!=null)</span><br><span class=\"line\">        last = find_minormax(nown-&gt;son[t],<span class=\"number\">1</span>-t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个操作其实是完全相反的，所以合到了一个函数里面，在后面的进一步的封装中再分开。</p>\n<p>思路在上面已经提到，在这里只需要注意对不存在的值的前驱／后继进行处理。我们查不到不存在的值的节点，但我们可以假装那里有一个节点。因为null的孩子也是null，所以这段代码也可以直接使用在值的前驱和后继里面。</p>\n<p><del>多说一句，在Splay里面，我们可以直接把待查节点splay到根然后瞎搞一通</del></p>\n<h3 id=\"输出树\"><a href=\"#输出树\" class=\"headerlink\" title=\"输出树\"></a>输出树</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> __print(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        __print(r-&gt;son[<span class=\"number\">0</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;depth;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);<span class=\"comment\">//打印深度</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\"</span>,r-&gt;val,r-&gt;cnt,r-&gt;size,r-&gt;p,r-&gt;son[<span class=\"number\">0</span>]!=null,r-&gt;son[<span class=\"number\">1</span>]!=null);</span><br><span class=\"line\">        __print(r-&gt;son[<span class=\"number\">1</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>按照中序遍历打印一棵树。主要在调试的时候用的多。有一个小技巧就是记录一个深度，然后把深度长度的空格打印出来，这样就可以更直观的看到各个节点的深度什么的。</p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(T v)</span></span>&#123;__insert(root,v);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">(T v)</span></span>&#123;__erase(root,v);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getrank</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> __getrank(root,v);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">qrank</span><span class=\"params\">(<span class=\"keyword\">int</span> rank)</span></span>&#123;<span class=\"keyword\">return</span> __qrank(root,rank)-&gt;val;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lower</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> loworup(v,<span class=\"number\">0</span>)-&gt;val;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">upper</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> loworup(v,<span class=\"number\">1</span>)-&gt;val;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;__print(root);&#125;</span><br></pre></td></tr></table></figure>\n<p>封装其实没有必要，可以用一些判断来代替。但是我们为了让代码更像工程的代码，而且让前面的代码更美观，更令人赏心悦目，所以我们封装一下吧。</p>\n<h2 id=\"完整代码及注释\"><a href=\"#完整代码及注释\" class=\"headerlink\" title=\"完整代码及注释\"></a>完整代码及注释</h2><p>题目：<a href=\"https://www.luogu.org/problemnew/show/P3369\" target=\"_blank\" rel=\"noopener\">洛谷P3369 普通平衡树</a></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxint  2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T,<span class=\"keyword\">size_t</span> siz&gt;<span class=\"comment\">//模版T,需要有等于不等于和小于运算符</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">treap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">        T val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p,size,cnt;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> treapcnt;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[siz&lt;&lt;<span class=\"number\">1</span>],*root,*null;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r)</span></span>&#123;</span><br><span class=\"line\">        r = &amp;pool[treapcnt++];</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r)</span></span>&#123;</span><br><span class=\"line\">        r-&gt;size = r-&gt;son[<span class=\"number\">0</span>]-&gt;size+r-&gt;son[<span class=\"number\">1</span>]-&gt;size+r-&gt;cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> tmp)</span></span>&#123;<span class=\"comment\">//0左旋，1右旋</span></span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *t = r-&gt;son[<span class=\"number\">1</span>-tmp];<span class=\"comment\">//找到需要旋上来的节点</span></span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">1</span>-tmp] = t-&gt;son[tmp];<span class=\"comment\">//将被选节点的被遮蔽的儿子交给上面的节点</span></span><br><span class=\"line\">        t-&gt;son[tmp] = r;<span class=\"comment\">//将r作为t的儿子</span></span><br><span class=\"line\">        update(r),update(t);<span class=\"comment\">//注意更新顺序！先儿子后父亲</span></span><br><span class=\"line\">        r = t;<span class=\"comment\">//通过引用更改上方节点的儿子</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __insert(<span class=\"keyword\">node_t</span> *&amp;r,T v)&#123;<span class=\"comment\">//r代表当前节点，v代表关键字</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null)&#123;<span class=\"comment\">//如果r的地方已经没有节点</span></span><br><span class=\"line\">            newnode(r);<span class=\"comment\">//新建节点，并通过引用添加至上面节点的儿子</span></span><br><span class=\"line\">            r-&gt;val = v,r-&gt;cnt = <span class=\"number\">1</span>,r-&gt;p = rand();<span class=\"comment\">//对相关信息的设置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;val == v) <span class=\"comment\">//如果已经添加过，直接给数量++</span></span><br><span class=\"line\">                r-&gt;cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = r-&gt;val &lt; v;</span><br><span class=\"line\">                __insert(r-&gt;son[tmp],v);<span class=\"comment\">//递归更改</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r-&gt;son[tmp]-&gt;p &lt; r-&gt;p)<span class=\"comment\">//维护treap性质</span></span><br><span class=\"line\">                    rotate(r,<span class=\"number\">1</span>-tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update(r);<span class=\"comment\">//不要忘了更新！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __erase(<span class=\"keyword\">node_t</span> *&amp;r,T v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;val == v)&#123;<span class=\"comment\">//已经找到</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;cnt &gt; <span class=\"number\">1</span>) r-&gt;cnt--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>]==null &amp;&amp; r-&gt;son[<span class=\"number\">1</span>]==null)&#123;<span class=\"comment\">//已经没有子节点，直接删除</span></span><br><span class=\"line\">                    r = null;<span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//还有子节点，</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tmp = r-&gt;son[<span class=\"number\">1</span>]-&gt;p &lt; r-&gt;son[<span class=\"number\">0</span>]-&gt;p;</span><br><span class=\"line\">                    rotate(r,<span class=\"number\">1</span>-tmp); <span class=\"comment\">//找到其中随机权值较小的一个旋转替换当前节点</span></span><br><span class=\"line\">                    __erase(r,v);<span class=\"comment\">//递归删除 注意此处r已经发生了变化</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//还没找到</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = r-&gt;val &lt; v;</span><br><span class=\"line\">            __erase(r-&gt;son[tmp],v);<span class=\"comment\">//递归寻找</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        update(r);<span class=\"comment\">//不要忘了更新！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __print(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)&#123;<span class=\"comment\">//调试用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            __print(r-&gt;son[<span class=\"number\">0</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;depth;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);<span class=\"comment\">//打印深度</span></span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"val:%d cnt:%d size:%d P:%d son?:%d %d\\n\"</span>,r-&gt;val,r-&gt;cnt,r-&gt;size,r-&gt;p,r-&gt;son[<span class=\"number\">0</span>]!=null,r-&gt;son[<span class=\"number\">1</span>]!=null);</span><br><span class=\"line\">            __print(r-&gt;son[<span class=\"number\">1</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> __getrank(<span class=\"keyword\">node_t</span> *r,T v)&#123;<span class=\"comment\">//查找数v的排名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;val == v||r == null)<span class=\"comment\">//记得判空！</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> r-&gt;son[<span class=\"number\">0</span>]-&gt;size +<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(v &lt; r-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> __getrank(r-&gt;son[<span class=\"number\">0</span>],v);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> __getrank(r-&gt;son[<span class=\"number\">1</span>],v) + r-&gt;son[<span class=\"number\">0</span>]-&gt;size + r-&gt;cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span>* __qrank(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> rank)&#123;<span class=\"comment\">//查找以rank排名的数</span></span><br><span class=\"line\">        rank -= r-&gt;son[<span class=\"number\">0</span>]-&gt;size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rank&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> __qrank(r-&gt;son[<span class=\"number\">0</span>],rank + r-&gt;son[<span class=\"number\">0</span>]-&gt;size);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(rank &lt;= r-&gt;cnt)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> __qrank(r-&gt;son[<span class=\"number\">1</span>],rank - r-&gt;cnt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *find_minormax(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> tmp)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//寻找以r为根节点的树上最大或最小节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r-&gt;son[tmp]!=null)</span><br><span class=\"line\">            r = r-&gt;son[tmp];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *loworup(T v,<span class=\"keyword\">int</span> t)&#123;<span class=\"comment\">//0代表前驱，1代表后继</span></span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *last = null,*nown = root;<span class=\"comment\">//last表示上一个没有当前寻找方向的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nown-&gt;val!=v &amp;&amp; nown!=null)&#123;<span class=\"comment\">//记得判空!</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp =  nown-&gt;val &lt; v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp!=t) last = nown;</span><br><span class=\"line\">            nown = nown-&gt;son[tmp];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nown-&gt;son[t]!=null)<span class=\"comment\">//有子节点</span></span><br><span class=\"line\">            last = find_minormax(nown-&gt;son[t],<span class=\"number\">1</span>-t);<span class=\"comment\">//寻找对应方向子节点的最小or最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    treap()&#123;</span><br><span class=\"line\">        treapcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        newnode(null);</span><br><span class=\"line\">        null-&gt;size = null-&gt;val=<span class=\"number\">0</span>;</span><br><span class=\"line\">        null-&gt;p = maxint;</span><br><span class=\"line\">        root = null;</span><br><span class=\"line\">        srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(T v)</span></span>&#123;__insert(root,v);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">(T v)</span></span>&#123;__erase(root,v);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getrank</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> __getrank(root,v);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">qrank</span><span class=\"params\">(<span class=\"keyword\">int</span> rank)</span></span>&#123;<span class=\"keyword\">return</span> __qrank(root,rank)-&gt;val;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lower</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> loworup(v,<span class=\"number\">0</span>)-&gt;val;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">upper</span><span class=\"params\">(T v)</span></span>&#123;<span class=\"keyword\">return</span> loworup(v,<span class=\"number\">1</span>)-&gt;val;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;__print(root);&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">treap&lt;<span class=\"keyword\">int</span>,<span class=\"number\">200000</span>&gt; w;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> op, x;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;op,&amp;x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>)      w.insert(x);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">2</span>) w.erase(x);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">3</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.getrank(x));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">4</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.qrank(x));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">5</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.lower(x));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">6</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.upper(x));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">0</span>) w.print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180303-zjoi2007-count/\" title=\"「ZJOI2007」报表统计\">「ZJOI2007」报表统计</a>\n","site":{"data":{}},"excerpt":"<p>闲下来了，开始写一点学习笔记，也希望能给后人造福吧。</p>\n<p>第一篇来说一说Treap。<br>","more":"</p>\n<h2 id=\"Treap是什么\"><a href=\"#Treap是什么\" class=\"headerlink\" title=\"Treap是什么\"></a>Treap是什么</h2><h3 id=\"Tree-Heap\"><a href=\"#Tree-Heap\" class=\"headerlink\" title=\"Tree + Heap\"></a>Tree + Heap</h3><p>树堆（英语：Treap），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为$O(\\log {n})$。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。<br><!-- more --></p>\n<h2 id=\"基本思想及操作\"><a href=\"#基本思想及操作\" class=\"headerlink\" title=\"基本思想及操作\"></a>基本思想及操作</h2><p>一般在Treap里面维护一个最小堆。</p>\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p>旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作在代码部分解释。<br>旋转的时间复杂度是$O(1)$，因为只需要修改常数个指针。</p>\n<h3 id=\"按关键字寻找\"><a href=\"#按关键字寻找\" class=\"headerlink\" title=\"按关键字寻找\"></a>按关键字寻找</h3><p>可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>在Treap中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整Treap的堆性质。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。</p>\n<h3 id=\"查询排名\"><a href=\"#查询排名\" class=\"headerlink\" title=\"查询排名\"></a>查询排名</h3><p>在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。</p>\n<h3 id=\"按排名查找\"><a href=\"#按排名查找\" class=\"headerlink\" title=\"按排名查找\"></a>按排名查找</h3><p>需要对每一个节点维护一个<code>size</code>值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的<code>size</code>值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。</p>\n<h3 id=\"前驱-amp-后继\"><a href=\"#前驱-amp-后继\" class=\"headerlink\" title=\"前驱&amp;后继\"></a>前驱&amp;后继</h3><p>在这里，前驱定义为小于x，且最大的数。后继同理。这个的寻找稍微复杂。<br>以前驱为例。</p>\n<p>如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。</p>\n<p>第一种很容易想明白，第二种稍难一些。</p>\n<p><img src=\"lower_upper.gif\" alt=\"前驱和后继\"></p>\n<p>以此图为例。比如我们寻找12的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现12的前驱是11，因为11是最后一个向右寻找，即下一次寻找是其右儿子（16）的节点。</p>\n<p>可以注意到，11的左子树上的点全都比6小，不符合要求；12的左子树不存在，12的右子树上的点都比12大，而11-12的路径上的点，其应当是全都是向左寻找的，也都比12要大，而在11以上的点，应当都比12要大（11是左儿子的时候），或者比11要小（11是右儿子的时候），所以，6就是7的前驱。</p>\n<p>后继同理。</p>\n<p>插入、删除等以上操作的\b期望时间复杂度都是$O(\\log {n})$，因为树的期望高度h是$\\log {n}$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3369\" target=\"_blank\" rel=\"noopener\">洛谷P3369 普通平衡树</a>为例。代码是指针版，不记录父节点，递归操作，有轻微压行，采用java换行风格。</p>\n<p>（其实我还是觉得数组好写</p>\n<h3 id=\"结构体的定义\"><a href=\"#结构体的定义\" class=\"headerlink\" title=\"结构体的定义\"></a>结构体的定义</h3><!--�2-->\n<p>在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。</p>\n<p>对于每一个节点，我们维护以下几个信息：\b关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。</p>\n<p>在结构体的变量中，我们维护了一个静态内存池，\b内存池已经使用的数量，根节点的指针，以及一个虚的空节点。</p>\n<p>在这里自己定义一个空节点的好处主要是可以避免<code>NULL</code>导致的<code>segmentation fault</code>，以及让函数编写变得更加简单。</p>\n<p>需要注意的是，视题目不同，<code>cnt</code>变量可能可以省去。</p>\n<h3 id=\"一些简单函数\"><a href=\"#一些简单函数\" class=\"headerlink\" title=\"一些简单函数\"></a>一些简单函数</h3><!--�3-->\n<p>newnode函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用newnode函数对null赋值了，因为会产生<code>NULL</code>这种可怕的东西。其实在这里也可以把赋关键字、随机值、<code>size</code>值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。</p>\n<p>update函数在这里完成对节点<code>size</code>值的更新，很好理解。</p>\n<p>find_minormax函数在这里完成对以r为根节点的树上最大或最小节点的寻找。也很简单，就不解释了。</p>\n<p>后两个函数可以放到node结构体里面，但是我不太喜欢那么做，因为那样会使箭头的数目大大增多，从而导致头疼（雾。</p>\n<h3 id=\"结构体的初始化\"><a href=\"#结构体的初始化\" class=\"headerlink\" title=\"结构体的初始化\"></a>结构体的初始化</h3><!--�4-->\n<p>结构体的初始化不难，有几点需要注意：<br>\b</p>\n<ul>\n<li>空指针的<code>size</code>需要为0</li>\n<li>空指针的随机值需要<strong>足够大</strong>（最大堆中足够小，最好是maxint，否则有可能在之后的删除操作中被转上去，然后树就断了</li>\n<li>最好srand一下</li>\n</ul>\n<h3 id=\"旋转-1\"><a href=\"#旋转-1\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><!--�5-->\n<p><img src=\"rotate.gif\" alt=\"旋转图片\"></p>\n<p>旋转操作的文字叙述：<br>（括号里文字以左旋为例）</p>\n<ol>\n<li>选定当前节点r <em>（图中的x）</em></li>\n<li>找到并记录需要旋上来的节点t（左旋旋右儿子，右旋左儿子）<em>（图中的y）</em></li>\n<li>把t将要被覆盖的儿子（与旋转方向相同的儿子）接到t在r原来的位置上 <em>（把b接在x的右子位置上）</em></li>\n<li>把r接到t空出来的位置上 <em>（把x接到y的x的左子树上）</em></li>\n<li>更新<code>size</code>值 <em>（更新x，y的<code>size</code>）</em></li>\n</ol>\n<p>由于我们没有记录父节点，所以这个旋转的写法跟Splay的旋转写法不太像。但其实Splay也可以这么写，只不过没有必要。</p>\n<p>其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误</p>\n<p>但需要注意的是，旋转很有可能（就是会破坏一个合法Treap的堆性质，所以旋转在Treap中只用来维护堆的性质，而不用在其他的地方。而且这里的指针是<strong>引用</strong>传递，才能修改对应父节点的儿子指针。</p>\n<p>有一点很重要的就是要维护<code>size</code>的值，而且是从下到上。</p>\n<h3 id=\"插入-1\"><a href=\"#插入-1\" class=\"headerlink\" title=\"插入\"></a>插入</h3><!--�6-->\n<p>用文字说明Treap的插入策略：</p>\n<ol>\n<li>递归边界：寻找到节点，cnt++或者已经到达空节点，赋值一个新节点</li>\n<li>递归添加节点，比当前节点小向左，比当前节点大向右</li>\n<li>维护最小堆的性质</li>\n<li>更新<code>size</code>值</li>\n</ol>\n<p>在维护最小堆的性质的时候，如果子节点的权值较小，那我们就需要把它转上来。</p>\n<p>需要注意，这里的节点是<strong>引用</strong>方式传入，这样才能对父节点的儿子指针进行修改，从而完成树的连接<br>再次重复，不要忘记更新<code>size</code>值。</p>\n<h3 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h3><!--�7-->\n<p>用文字说明Treap的删除策略：</p>\n<ol>\n<li>递归边界：要删除的节点没有儿子节点</li>\n<li>寻找到当前节点，减少数量或者向下旋转</li>\n<li>维护最小堆的性质，即把两个儿子中权值较小的旋转上来</li>\n<li>递归删除节点<strong>注意此处的节点指针仍是r，因为r在旋转中已经发生了变化</strong></li>\n<li>更新<code>size</code>值</li>\n</ol>\n<p>删除的时候最需要注意的已经在上面指出。</p>\n<p>还有在旋转比较的时候一定比较的是优先级！！！</p>\n<p>Treap的删除和插入其实很像，只不过递归的位置相反。插入是先递归再维护，而删除是先维护再递归。</p>\n<h3 id=\"查询排名-amp-排名查询\"><a href=\"#查询排名-amp-排名查询\" class=\"headerlink\" title=\"查询排名&amp;排名查询\"></a>查询排名&amp;排名查询</h3><!--�8-->\n<p>这两个比较简单，而且在上面也讲的很详细了，所以就一块说。</p>\n<p>查询排名和排名查询其实是相反的操作，只需要注意将+1，-1和空节点等问题处理好了就可以了。</p>\n<h3 id=\"前驱和后继\"><a href=\"#前驱和后继\" class=\"headerlink\" title=\"前驱和后继\"></a>前驱和后继</h3><!--�9-->\n<p>这两个操作其实是完全相反的，所以合到了一个函数里面，在后面的进一步的封装中再分开。</p>\n<p>思路在上面已经提到，在这里只需要注意对不存在的值的前驱／后继进行处理。我们查不到不存在的值的节点，但我们可以假装那里有一个节点。因为null的孩子也是null，所以这段代码也可以直接使用在值的前驱和后继里面。</p>\n<p><del>多说一句，在Splay里面，我们可以直接把待查节点splay到根然后瞎搞一通</del></p>\n<h3 id=\"输出树\"><a href=\"#输出树\" class=\"headerlink\" title=\"输出树\"></a>输出树</h3><!--�10-->\n<p>按照中序遍历打印一棵树。主要在调试的时候用的多。有一个小技巧就是记录一个深度，然后把深度长度的空格打印出来，这样就可以更直观的看到各个节点的深度什么的。</p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><!--�11-->\n<p>封装其实没有必要，可以用一些判断来代替。但是我们为了让代码更像工程的代码，而且让前面的代码更美观，更令人赏心悦目，所以我们封装一下吧。</p>\n<h2 id=\"完整代码及注释\"><a href=\"#完整代码及注释\" class=\"headerlink\" title=\"完整代码及注释\"></a>完整代码及注释</h2><p>题目：<a href=\"https://www.luogu.org/problemnew/show/P3369\" target=\"_blank\" rel=\"noopener\">洛谷P3369 普通平衡树</a></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�12-->\n\n</div></div>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180303-zjoi2007-count/\" title=\"「ZJOI2007」报表统计\">「ZJOI2007」报表统计</a>"},{"title":"Hello World","urlname":"hello-world","date":"2017-11-30T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n### test fold\n\n{% fold %}\n\n```\ntest\n```\n\n{% endfold %}\n\n### test spoiler\n\n{% spoiler test %}","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nurlname: hello-world\ndate: 2017-12-01 00:00:00\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n### test fold\n\n{% fold %}\n\n```\ntest\n```\n\n{% endfold %}\n\n### test spoiler\n\n{% spoiler test %}","slug":"hello-world","published":1,"updated":"2018-03-24T04:15:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i1001pbljrhj5qdmtd","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h3 id=\"test-fold\"><a href=\"#test-fold\" class=\"headerlink\" title=\"test fold\"></a>test fold</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">test</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"test-spoiler\"><a href=\"#test-spoiler\" class=\"headerlink\" title=\"test spoiler\"></a>test spoiler</h3><span class=\"spoiler\">test\n</span>","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><!--�13-->\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><!--�14-->\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><!--�15-->\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><!--�16-->\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h3 id=\"test-fold\"><a href=\"#test-fold\" class=\"headerlink\" title=\"test fold\"></a>test fold</h3><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�17-->\n\n</div></div>\n<h3 id=\"test-spoiler\"><a href=\"#test-spoiler\" class=\"headerlink\" title=\"test spoiler\"></a>test spoiler</h3><span class=\"spoiler\">test\n</span>"},{"title":"“长大”","date":"2018-01-03T12:33:04.000Z","visible":null,"urlname":"grow","_content":"\n或许，我一直认为我早就长大了吧。\n<!-- more -->\n\n![](time.jpg)\n那应该是在五年级的时候。我又一次去找老师，又一次没有说成我心中最为完美的想法，又一次的陷入沉思。那个时候，我真正的意识到，或许并不是所有事情，都能按照我心中最好的方式去进行吧。或许从那以后，我以为我就再也不会为了我心中的梦想的世界——或者说更美好的事情，去与人争辩了吧。而初中，也确实是，和人争辩大多也都是做错了题或者做对了题去跟同学和老师的争辩了吧。\n\n一度，我竟真的以为我长大了。\n\n那些记忆已经很模糊了，而近几天发生的事情却还历历在目。\n\n看到某位同学的随笔，某位同学的批语，又想到了好多。\n\n最近写了不少随笔，也阅了不少随笔。而我写的随笔有不少却像是“抱怨”，“抱怨”班歌比赛的劳民伤财，抱怨体育运动的不切实际，抱怨《论语》的无理考法。\n\n最近和几位同学互相批判了一番。价值观的不同其实是必然的。或许你有一身嫉世热血，或许我有一颗如冰寒心。脚踏实地还是仰望星空？向理想前行还是于现实混沌？谁又会知道呢。想了很久要不要提笔写下自己的想法，最后还是放弃了。早就应该知道，这些事情，笑笑就好，何必去劳心费神呢？但又不知道为何，最近总是想写，想去表达所有一切一切的想法，或许应该收收了吧。\n\n*“这不是能随心所欲的年纪。”*\n说的真的是好啊。或许，从小学就应该想到的吧。但为什么现在又忘记了呢？谁会知道呢。也许是一颗心不再凉的彻骨，也许是一不小心就忘记了以前吧。\n\n这句话可以说是，“一语点破梦中人”。小学的无数经历让我曾以为我已经从这梦中醒来，再也不会去做那荒诞的梦；但如今发现，到底是梦还是现实却也分不太清。或许我仍然还在梦中？或许是我一直都错了？谁又知道呢。\n\n曾经以为长大，但恍然之间被人点醒，却才知道梦仍然在。有梦是不是一件好事呢？\n\n或许几年之后仍会有相同的感慨吧。但现在，真的没有时间去思考那么多。但也许julao们不一定吧。\n\n不如先滚去把作业写完。\n\n\n另祝各位2018吉祥快乐，万事如意。\n","source":"_posts/“长大”.md","raw":"---\ntitle: “长大”\ndate: 2018-01-03 20:33:04\ntags:\ncategories: 随笔\nvisible:\nurlname: grow\n---\n\n或许，我一直认为我早就长大了吧。\n<!-- more -->\n\n![](time.jpg)\n那应该是在五年级的时候。我又一次去找老师，又一次没有说成我心中最为完美的想法，又一次的陷入沉思。那个时候，我真正的意识到，或许并不是所有事情，都能按照我心中最好的方式去进行吧。或许从那以后，我以为我就再也不会为了我心中的梦想的世界——或者说更美好的事情，去与人争辩了吧。而初中，也确实是，和人争辩大多也都是做错了题或者做对了题去跟同学和老师的争辩了吧。\n\n一度，我竟真的以为我长大了。\n\n那些记忆已经很模糊了，而近几天发生的事情却还历历在目。\n\n看到某位同学的随笔，某位同学的批语，又想到了好多。\n\n最近写了不少随笔，也阅了不少随笔。而我写的随笔有不少却像是“抱怨”，“抱怨”班歌比赛的劳民伤财，抱怨体育运动的不切实际，抱怨《论语》的无理考法。\n\n最近和几位同学互相批判了一番。价值观的不同其实是必然的。或许你有一身嫉世热血，或许我有一颗如冰寒心。脚踏实地还是仰望星空？向理想前行还是于现实混沌？谁又会知道呢。想了很久要不要提笔写下自己的想法，最后还是放弃了。早就应该知道，这些事情，笑笑就好，何必去劳心费神呢？但又不知道为何，最近总是想写，想去表达所有一切一切的想法，或许应该收收了吧。\n\n*“这不是能随心所欲的年纪。”*\n说的真的是好啊。或许，从小学就应该想到的吧。但为什么现在又忘记了呢？谁会知道呢。也许是一颗心不再凉的彻骨，也许是一不小心就忘记了以前吧。\n\n这句话可以说是，“一语点破梦中人”。小学的无数经历让我曾以为我已经从这梦中醒来，再也不会去做那荒诞的梦；但如今发现，到底是梦还是现实却也分不太清。或许我仍然还在梦中？或许是我一直都错了？谁又知道呢。\n\n曾经以为长大，但恍然之间被人点醒，却才知道梦仍然在。有梦是不是一件好事呢？\n\n或许几年之后仍会有相同的感慨吧。但现在，真的没有时间去思考那么多。但也许julao们不一定吧。\n\n不如先滚去把作业写完。\n\n\n另祝各位2018吉祥快乐，万事如意。\n","slug":"“长大”","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i4001tbljrga27c1sy","content":"<p>或许，我一直认为我早就长大了吧。<br><a id=\"more\"></a></p>\n<p><img src=\"time.jpg\" alt=\"\"><br>那应该是在五年级的时候。我又一次去找老师，又一次没有说成我心中最为完美的想法，又一次的陷入沉思。那个时候，我真正的意识到，或许并不是所有事情，都能按照我心中最好的方式去进行吧。或许从那以后，我以为我就再也不会为了我心中的梦想的世界——或者说更美好的事情，去与人争辩了吧。而初中，也确实是，和人争辩大多也都是做错了题或者做对了题去跟同学和老师的争辩了吧。</p>\n<p>一度，我竟真的以为我长大了。</p>\n<p>那些记忆已经很模糊了，而近几天发生的事情却还历历在目。</p>\n<p>看到某位同学的随笔，某位同学的批语，又想到了好多。</p>\n<p>最近写了不少随笔，也阅了不少随笔。而我写的随笔有不少却像是“抱怨”，“抱怨”班歌比赛的劳民伤财，抱怨体育运动的不切实际，抱怨《论语》的无理考法。</p>\n<p>最近和几位同学互相批判了一番。价值观的不同其实是必然的。或许你有一身嫉世热血，或许我有一颗如冰寒心。脚踏实地还是仰望星空？向理想前行还是于现实混沌？谁又会知道呢。想了很久要不要提笔写下自己的想法，最后还是放弃了。早就应该知道，这些事情，笑笑就好，何必去劳心费神呢？但又不知道为何，最近总是想写，想去表达所有一切一切的想法，或许应该收收了吧。</p>\n<p><em>“这不是能随心所欲的年纪。”</em><br>说的真的是好啊。或许，从小学就应该想到的吧。但为什么现在又忘记了呢？谁会知道呢。也许是一颗心不再凉的彻骨，也许是一不小心就忘记了以前吧。</p>\n<p>这句话可以说是，“一语点破梦中人”。小学的无数经历让我曾以为我已经从这梦中醒来，再也不会去做那荒诞的梦；但如今发现，到底是梦还是现实却也分不太清。或许我仍然还在梦中？或许是我一直都错了？谁又知道呢。</p>\n<p>曾经以为长大，但恍然之间被人点醒，却才知道梦仍然在。有梦是不是一件好事呢？</p>\n<p>或许几年之后仍会有相同的感慨吧。但现在，真的没有时间去思考那么多。但也许julao们不一定吧。</p>\n<p>不如先滚去把作业写完。</p>\n<p>另祝各位2018吉祥快乐，万事如意。</p>\n","site":{"data":{}},"excerpt":"<p>或许，我一直认为我早就长大了吧。<br>","more":"</p>\n<p><img src=\"time.jpg\" alt=\"\"><br>那应该是在五年级的时候。我又一次去找老师，又一次没有说成我心中最为完美的想法，又一次的陷入沉思。那个时候，我真正的意识到，或许并不是所有事情，都能按照我心中最好的方式去进行吧。或许从那以后，我以为我就再也不会为了我心中的梦想的世界——或者说更美好的事情，去与人争辩了吧。而初中，也确实是，和人争辩大多也都是做错了题或者做对了题去跟同学和老师的争辩了吧。</p>\n<p>一度，我竟真的以为我长大了。</p>\n<p>那些记忆已经很模糊了，而近几天发生的事情却还历历在目。</p>\n<p>看到某位同学的随笔，某位同学的批语，又想到了好多。</p>\n<p>最近写了不少随笔，也阅了不少随笔。而我写的随笔有不少却像是“抱怨”，“抱怨”班歌比赛的劳民伤财，抱怨体育运动的不切实际，抱怨《论语》的无理考法。</p>\n<p>最近和几位同学互相批判了一番。价值观的不同其实是必然的。或许你有一身嫉世热血，或许我有一颗如冰寒心。脚踏实地还是仰望星空？向理想前行还是于现实混沌？谁又会知道呢。想了很久要不要提笔写下自己的想法，最后还是放弃了。早就应该知道，这些事情，笑笑就好，何必去劳心费神呢？但又不知道为何，最近总是想写，想去表达所有一切一切的想法，或许应该收收了吧。</p>\n<p><em>“这不是能随心所欲的年纪。”</em><br>说的真的是好啊。或许，从小学就应该想到的吧。但为什么现在又忘记了呢？谁会知道呢。也许是一颗心不再凉的彻骨，也许是一不小心就忘记了以前吧。</p>\n<p>这句话可以说是，“一语点破梦中人”。小学的无数经历让我曾以为我已经从这梦中醒来，再也不会去做那荒诞的梦；但如今发现，到底是梦还是现实却也分不太清。或许我仍然还在梦中？或许是我一直都错了？谁又知道呢。</p>\n<p>曾经以为长大，但恍然之间被人点醒，却才知道梦仍然在。有梦是不是一件好事呢？</p>\n<p>或许几年之后仍会有相同的感慨吧。但现在，真的没有时间去思考那么多。但也许julao们不一定吧。</p>\n<p>不如先滚去把作业写完。</p>\n<p>另祝各位2018吉祥快乐，万事如意。</p>"},{"title":"「AHOI2008」紧急集合-LCA","urlname":"AHOI2008-emergency","date":"2018-03-23T14:19:33.000Z","visible":null,"_content":"\n给出一颗$n$个节点的无权树，$m$次询问，每次给出三个点编号为$a$，$b$，$c$，询问到这三个点距离最小的点的编号以及其距离和。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4281](https://www.luogu.org/problemnew/show/P4281)\n\n## 题解\n\n\n首先，如果每次询问都只有两个点，这个问题就很简单，只要是树上的路径上的点就可以，寻找树上的路径其实就是寻找$LCA$的过程。这可以启发我们对于三个点的情况的思考。\n\n如果这里有三个点，我们来认真的思考一下。经过上一问的启发，我们来思考一下能不能运用$LCA$来解决这道题。\n\n我们可以发现，树上三个点的三对$LCA$一定有两个是相同的。这是一件想想的话比较显然的事情。必然能够找到某个节点，让三个点中的两个在一侧，一个在另一侧。而这个点就是两个公共的$LCA$。思考的再深入些（并且结合瞎蒙），我们会发现这个相同的$LCA$肯定是深度最小的一个$LCA$。\n\n这里，我们首先可以显而易见的发现，这个点必须在三个点互相通达的路径上。\n\n我们再思考一下$LCA$与路径和的关系。假设我们知道$a$和$b$的$LCA$是$x$，而且$x$是上述的3个$LCA$中深度最大的那个，那么可以发现从$x$到$a$的距离加上从$x$到$b$的距离一定是最小的。根据上面的结论，我们知道$a$，$c$和$b$，$c$的$LCA$点$y$一定在一个点上，而且这个$y$一定比$x$深度小。\n\n那么这个时候，我们会发现此时$a$，$b$，$c$到$x$的距离和是最小的。证明的话可以这么想：如果$x'$比$x$高，那么虽然$c$到$x$的距离减小了$w$，但是$a$，$b$到$x'$的距离均增大了$w$，显然距离和增大。如果$x'$比$x$低，有一个节点到$x'$的距离减小了$w$，剩下两个节点到$x'$的距离均增大了$w$，显然距离和也增大。\n\n所以我们就找到了到三个点距离和最小的点：这三个点的三对$LCA$中，深度大的那两个LCA就是答案。\n\n我们在求$LCA$之前，可以先预处理出深度$dep$，那么从节点$u$到$v$的路径长度就是$dis = dep[u] + dep[v] - 2*dep[lca(u,v)]$。运用这个式子分别算出$a$,$b$,$c$到$a1$,$b1$,$c1$（三个$LCA$）的距离，最后发现总的$dis$居然是轮换式：$ans = dep[a]+dep[b]+dep[c]-dep[a1]-dep[b1]-dep[c1]$， 所以就不用分类讨论了。\n\n$LCA$ 我用了树链剖分来求，顺带处理深度。\n\n## 代码\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace fast_io {\n    inline char read() {\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x+(x<<2))<<1) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if (x == 0) \n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nconst int MAXN = 510000;\n\nvector<int> edge[MAXN];\n\nint n,m;\nint dep[MAXN],siz[MAXN],fa[MAXN],son[MAXN],top[MAXN],id[MAXN],cnt = 1;\n\n\n//添加从a到b的无向边\nvoid addedge(int a,int b){\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n}\n\n//树链剖分的第一个dfs\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f,dep[nown] = depth;\n    int maxsum = -1;son[nown] = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        if(siz[to] > maxsum) maxsum = siz[to],son[nown] = to;\n        siz[nown] += siz[to];\n    }\n}\n\n//树链剖分的第二个dfs\nvoid dfs2(int nown,int topf){\n    id[nown] = cnt++;top[nown] = topf;\n    if(son[nown] == 0) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]|| to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//求a,b两点的LCA\nint lca(int a,int b){\n    while(top[a]!=top[b]){\n        if(dep[top[a]] < dep[top[b]]) swap(a,b);\n        a = fa[top[a]];\n    }\n    if(dep[a] < dep[b]) swap(a,b);\n    return b;\n}\n\n//初始化以及dfs\nvoid init(){\n    read(n),read(m);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        addedge(a,b);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n}\n\n//回应询问\nvoid solve(){\n    int a,b,c,a1,b1,c1,ans,dis;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b),read(c);\n        //a1,b1,c1的意义见下\n        a1 = lca(a,b),b1 = lca(b,c),c1 = lca(c,a);\n        dis = 0;\n        if(a1 == b1) \n            ans = c1;\n        else if(b1 == c1)\n            ans = a1;\n        else if(c1 == a1)\n            ans = b1;\n        //计算dis的公式\n        dis = dep[a] + dep[b] + dep[c] - dep[a1] - dep[b1] - dep[c1];\n        print(ans),print(' '),print(dis),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「AHOI2008」紧急集合-LCA.md","raw":"---\ntitle: 「AHOI2008」紧急集合-LCA\nurlname: AHOI2008-emergency\ndate: 2018-03-23 22:19:33\ntags: \n- 最近公共祖先\n- 图论\n- 题解\ncategories: OI\nvisible:\n---\n\n给出一颗$n$个节点的无权树，$m$次询问，每次给出三个点编号为$a$，$b$，$c$，询问到这三个点距离最小的点的编号以及其距离和。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4281](https://www.luogu.org/problemnew/show/P4281)\n\n## 题解\n\n\n首先，如果每次询问都只有两个点，这个问题就很简单，只要是树上的路径上的点就可以，寻找树上的路径其实就是寻找$LCA$的过程。这可以启发我们对于三个点的情况的思考。\n\n如果这里有三个点，我们来认真的思考一下。经过上一问的启发，我们来思考一下能不能运用$LCA$来解决这道题。\n\n我们可以发现，树上三个点的三对$LCA$一定有两个是相同的。这是一件想想的话比较显然的事情。必然能够找到某个节点，让三个点中的两个在一侧，一个在另一侧。而这个点就是两个公共的$LCA$。思考的再深入些（并且结合瞎蒙），我们会发现这个相同的$LCA$肯定是深度最小的一个$LCA$。\n\n这里，我们首先可以显而易见的发现，这个点必须在三个点互相通达的路径上。\n\n我们再思考一下$LCA$与路径和的关系。假设我们知道$a$和$b$的$LCA$是$x$，而且$x$是上述的3个$LCA$中深度最大的那个，那么可以发现从$x$到$a$的距离加上从$x$到$b$的距离一定是最小的。根据上面的结论，我们知道$a$，$c$和$b$，$c$的$LCA$点$y$一定在一个点上，而且这个$y$一定比$x$深度小。\n\n那么这个时候，我们会发现此时$a$，$b$，$c$到$x$的距离和是最小的。证明的话可以这么想：如果$x'$比$x$高，那么虽然$c$到$x$的距离减小了$w$，但是$a$，$b$到$x'$的距离均增大了$w$，显然距离和增大。如果$x'$比$x$低，有一个节点到$x'$的距离减小了$w$，剩下两个节点到$x'$的距离均增大了$w$，显然距离和也增大。\n\n所以我们就找到了到三个点距离和最小的点：这三个点的三对$LCA$中，深度大的那两个LCA就是答案。\n\n我们在求$LCA$之前，可以先预处理出深度$dep$，那么从节点$u$到$v$的路径长度就是$dis = dep[u] + dep[v] - 2*dep[lca(u,v)]$。运用这个式子分别算出$a$,$b$,$c$到$a1$,$b1$,$c1$（三个$LCA$）的距离，最后发现总的$dis$居然是轮换式：$ans = dep[a]+dep[b]+dep[c]-dep[a1]-dep[b1]-dep[c1]$， 所以就不用分类讨论了。\n\n$LCA$ 我用了树链剖分来求，顺带处理深度。\n\n## 代码\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace fast_io {\n    inline char read() {\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x+(x<<2))<<1) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if (x == 0) \n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nconst int MAXN = 510000;\n\nvector<int> edge[MAXN];\n\nint n,m;\nint dep[MAXN],siz[MAXN],fa[MAXN],son[MAXN],top[MAXN],id[MAXN],cnt = 1;\n\n\n//添加从a到b的无向边\nvoid addedge(int a,int b){\n    edge[a].push_back(b);\n    edge[b].push_back(a);\n}\n\n//树链剖分的第一个dfs\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f,dep[nown] = depth;\n    int maxsum = -1;son[nown] = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        if(siz[to] > maxsum) maxsum = siz[to],son[nown] = to;\n        siz[nown] += siz[to];\n    }\n}\n\n//树链剖分的第二个dfs\nvoid dfs2(int nown,int topf){\n    id[nown] = cnt++;top[nown] = topf;\n    if(son[nown] == 0) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]|| to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//求a,b两点的LCA\nint lca(int a,int b){\n    while(top[a]!=top[b]){\n        if(dep[top[a]] < dep[top[b]]) swap(a,b);\n        a = fa[top[a]];\n    }\n    if(dep[a] < dep[b]) swap(a,b);\n    return b;\n}\n\n//初始化以及dfs\nvoid init(){\n    read(n),read(m);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        addedge(a,b);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n}\n\n//回应询问\nvoid solve(){\n    int a,b,c,a1,b1,c1,ans,dis;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b),read(c);\n        //a1,b1,c1的意义见下\n        a1 = lca(a,b),b1 = lca(b,c),c1 = lca(c,a);\n        dis = 0;\n        if(a1 == b1) \n            ans = c1;\n        else if(b1 == c1)\n            ans = a1;\n        else if(c1 == a1)\n            ans = b1;\n        //计算dis的公式\n        dis = dep[a] + dep[b] + dep[c] - dep[a1] - dep[b1] - dep[c1];\n        print(ans),print(' '),print(dis),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「AHOI2008」紧急集合-LCA","published":1,"updated":"2018-03-24T04:12:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i6001vbljrsa3i7yqk","content":"<p>给出一颗$n$个节点的无权树，$m$次询问，每次给出三个点编号为$a$，$b$，$c$，询问到这三个点距离最小的点的编号以及其距离和。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4281\" target=\"_blank\" rel=\"noopener\">Luogu P4281</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先，如果每次询问都只有两个点，这个问题就很简单，只要是树上的路径上的点就可以，寻找树上的路径其实就是寻找$LCA$的过程。这可以启发我们对于三个点的情况的思考。</p>\n<p>如果这里有三个点，我们来认真的思考一下。经过上一问的启发，我们来思考一下能不能运用$LCA$来解决这道题。</p>\n<p>我们可以发现，树上三个点的三对$LCA$一定有两个是相同的。这是一件想想的话比较显然的事情。必然能够找到某个节点，让三个点中的两个在一侧，一个在另一侧。而这个点就是两个公共的$LCA$。思考的再深入些（并且结合瞎蒙），我们会发现这个相同的$LCA$肯定是深度最小的一个$LCA$。</p>\n<p>这里，我们首先可以显而易见的发现，这个点必须在三个点互相通达的路径上。</p>\n<p>我们再思考一下$LCA$与路径和的关系。假设我们知道$a$和$b$的$LCA$是$x$，而且$x$是上述的3个$LCA$中深度最大的那个，那么可以发现从$x$到$a$的距离加上从$x$到$b$的距离一定是最小的。根据上面的结论，我们知道$a$，$c$和$b$，$c$的$LCA$点$y$一定在一个点上，而且这个$y$一定比$x$深度小。</p>\n<p>那么这个时候，我们会发现此时$a$，$b$，$c$到$x$的距离和是最小的。证明的话可以这么想：如果$x’$比$x$高，那么虽然$c$到$x$的距离减小了$w$，但是$a$，$b$到$x’$的距离均增大了$w$，显然距离和增大。如果$x’$比$x$低，有一个节点到$x’$的距离减小了$w$，剩下两个节点到$x’$的距离均增大了$w$，显然距离和也增大。</p>\n<p>所以我们就找到了到三个点距离和最小的点：这三个点的三对$LCA$中，深度大的那两个LCA就是答案。</p>\n<p>我们在求$LCA$之前，可以先预处理出深度$dep$，那么从节点$u$到$v$的路径长度就是$dis = dep[u] + dep[v] - 2*dep[lca(u,v)]$。运用这个式子分别算出$a$,$b$,$c$到$a1$,$b1$,$c1$（三个$LCA$）的距离，最后发现总的$dis$居然是轮换式：$ans = dep[a]+dep[b]+dep[c]-dep[a1]-dep[b1]-dep[c1]$， 所以就不用分类讨论了。</p>\n<p>$LCA$ 我用了树链剖分来求，顺带处理深度。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN], *s, *t;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s==t?(((t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>))== s)?<span class=\"number\">-1</span>:*s++) : *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (iosig = <span class=\"literal\">false</span>, c = read(); !<span class=\"built_in\">isdigit</span>(c); c = read()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">'-'</span>) iosig = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (x = <span class=\"number\">0</span>; <span class=\"built_in\">isdigit</span>(c); c = read())</span><br><span class=\"line\">            x = ((x+(x&lt;&lt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>) + (c ^ <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iosig) x = -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;<span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ooh == obuf + OUT_LEN) fwrite(obuf, <span class=\"number\">1</span>, OUT_LEN, <span class=\"built_in\">stdout</span>), ooh = obuf;</span><br><span class=\"line\">        *ooh++ = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> buf[<span class=\"number\">30</span>], cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>) </span><br><span class=\"line\">            print(<span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) print(<span class=\"string\">'-'</span>), x = -x;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (cnt = <span class=\"number\">0</span>; x; x /= <span class=\"number\">10</span>) buf[++cnt] = x % <span class=\"number\">10</span> + <span class=\"number\">48</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt) print((<span class=\"keyword\">char</span>)buf[cnt--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        fwrite(obuf, <span class=\"number\">1</span>, ooh - obuf, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">510000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dep[MAXN],siz[MAXN],fa[MAXN],son[MAXN],top[MAXN],id[MAXN],cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加从a到b的无向边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    edge[a].push_back(b);</span><br><span class=\"line\">    edge[b].push_back(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树链剖分的第一个dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,fa[nown] = f,dep[nown] = depth;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxsum = <span class=\"number\">-1</span>;son[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(to,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[to] &gt; maxsum) maxsum = siz[to],son[nown] = to;</span><br><span class=\"line\">        siz[nown] += siz[to];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树链剖分的第二个dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    id[nown] = cnt++;top[nown] = topf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(son[nown] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == fa[nown]|| to == son[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(to,to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//求a,b两点的LCA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[a]!=top[b])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[a]] &lt; dep[top[b]]) swap(a,b);</span><br><span class=\"line\">        a = fa[top[a]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[a] &lt; dep[b]) swap(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化以及dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        addedge(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//回应询问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c,a1,b1,c1,ans,dis;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        <span class=\"comment\">//a1,b1,c1的意义见下</span></span><br><span class=\"line\">        a1 = lca(a,b),b1 = lca(b,c),c1 = lca(c,a);</span><br><span class=\"line\">        dis = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a1 == b1) </span><br><span class=\"line\">            ans = c1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(b1 == c1)</span><br><span class=\"line\">            ans = a1;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(c1 == a1)</span><br><span class=\"line\">            ans = b1;</span><br><span class=\"line\">        <span class=\"comment\">//计算dis的公式</span></span><br><span class=\"line\">        dis = dep[a] + dep[b] + dep[c] - dep[a1] - dep[b1] - dep[c1];</span><br><span class=\"line\">        print(ans),print(<span class=\"string\">' '</span>),print(dis),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给出一颗$n$个节点的无权树，$m$次询问，每次给出三个点编号为$a$，$b$，$c$，询问到这三个点距离最小的点的编号以及其距离和。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4281\" target=\"_blank\" rel=\"noopener\">Luogu P4281</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>首先，如果每次询问都只有两个点，这个问题就很简单，只要是树上的路径上的点就可以，寻找树上的路径其实就是寻找$LCA$的过程。这可以启发我们对于三个点的情况的思考。</p>\n<p>如果这里有三个点，我们来认真的思考一下。经过上一问的启发，我们来思考一下能不能运用$LCA$来解决这道题。</p>\n<p>我们可以发现，树上三个点的三对$LCA$一定有两个是相同的。这是一件想想的话比较显然的事情。必然能够找到某个节点，让三个点中的两个在一侧，一个在另一侧。而这个点就是两个公共的$LCA$。思考的再深入些（并且结合瞎蒙），我们会发现这个相同的$LCA$肯定是深度最小的一个$LCA$。</p>\n<p>这里，我们首先可以显而易见的发现，这个点必须在三个点互相通达的路径上。</p>\n<p>我们再思考一下$LCA$与路径和的关系。假设我们知道$a$和$b$的$LCA$是$x$，而且$x$是上述的3个$LCA$中深度最大的那个，那么可以发现从$x$到$a$的距离加上从$x$到$b$的距离一定是最小的。根据上面的结论，我们知道$a$，$c$和$b$，$c$的$LCA$点$y$一定在一个点上，而且这个$y$一定比$x$深度小。</p>\n<p>那么这个时候，我们会发现此时$a$，$b$，$c$到$x$的距离和是最小的。证明的话可以这么想：如果$x’$比$x$高，那么虽然$c$到$x$的距离减小了$w$，但是$a$，$b$到$x’$的距离均增大了$w$，显然距离和增大。如果$x’$比$x$低，有一个节点到$x’$的距离减小了$w$，剩下两个节点到$x’$的距离均增大了$w$，显然距离和也增大。</p>\n<p>所以我们就找到了到三个点距离和最小的点：这三个点的三对$LCA$中，深度大的那两个LCA就是答案。</p>\n<p>我们在求$LCA$之前，可以先预处理出深度$dep$，那么从节点$u$到$v$的路径长度就是$dis = dep[u] + dep[v] - 2*dep[lca(u,v)]$。运用这个式子分别算出$a$,$b$,$c$到$a1$,$b1$,$c1$（三个$LCA$）的距离，最后发现总的$dis$居然是轮换式：$ans = dep[a]+dep[b]+dep[c]-dep[a1]-dep[b1]-dep[c1]$， 所以就不用分类讨论了。</p>\n<p>$LCA$ 我用了树链剖分来求，顺带处理深度。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�18-->\n\n</div></div>"},{"title":"「CQOI2011」动态逆序对-CDQ分治","urlname":"cqoi2011-inverse","date":"2018-06-07T12:58:32.000Z","visible":null,"_content":"\n对于序列$A$，它的逆序对数定义为满足$i<j$，且$A_i>A_j$的数对$(i,j)$的个数。给$1$到$n$的一个排列，按照某种顺序依次删除$m$个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!-- more -->\n\n## 链接\n\n[BZOJ 3295](https://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n[Luogu P3157](https://www.luogu.org/problemnew/show/P3157)\n\n## 题解\n\nCDQ分治强啊。\n\n这道题可以用树状数组&主席树做，不过很难写。\n\nCDQ分治的话，实现难度上比较低一些吧。\n\n首先，我们转化问题为每次在某个位置添加一个数，并查询能贡献出来的逆序对个数。这个问题和题目是等价的。\n\n然后我们令这个删除的反着的顺序为$id$，其插入的位置为$b$，插入的值为$c$，我们要求的就是在$id \\in [1,id - 1]$的数中，满足$b_j < b_i,c_j > c_i$或者$b_j > b_i,c_j < c_i$的j有多少个。\n\n这个问题我们用CDQ归并解决。先按照id排序，然后对b进行归并，完成后正序和倒序各扫一遍，统计贡献，最后作前缀和即可。\n\n实现有一点点不好写。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 110000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nstruct Q{\n    bool w;\n    int id,b,c;\n    // id -> 加入时间 b -> 加入的位置 c -> 这个数的大小\n    Q(int x,int y,int z):id(x),b(y),c(z){}\n    Q(){}\n    bool operator < (Q w)const{//用于排序\n        if(id!=w.id) \n            return id < w.id;\n        if(b!=w.b)\n            return b < w.b;\n        return c < w.c;\n    }\n}q[MAXN];\n\nint n,m;\nint num[MAXN],pos[MAXN],del[MAXN];\nll ans[MAXN];\n// num -> 原数组\n// pos -> 值对应的位置\n// del -> 删除第 pos 个数的序顺 \n\nnamespace BIT{\n    ll sumn[MAXN];\n    int lowbit(int x){\n        return x & (-x);\n    }\n    void add(int x,int d){\n        while(x <= n) sumn[x] += d,x += lowbit(x);\n    }\n    ll query(int x){\n        ll ans = 0;\n        while(x >= 1) ans += sumn[x],x -= lowbit(x);\n        return ans;\n    }\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        pos[num[i]] = i;\n    }\n    int tmp; \n    for(int i = 1;i<=m;i++){\n        read(tmp);\n        del[pos[tmp]] = i;\n    }\n}\n\nint l,r,tot,tmp[MAXN];\n\ninline bool judge(int x,int y){\n    //判断归并顺序函数 这里因为不重复，可以不写其他维判定\n    return q[x].b < q[y].b;\n}\n\n\nvoid CDQ(int *t,int num){\n    if(num == 1) return;\n    int mid = num/2;\n    CDQ(t,mid),CDQ(t+mid,num-mid);//分治解决问题\n    //进行归并\n    for(l=0,r=mid,tot=0;tot < num;tot++){\n        if((r==num)||(l<mid && judge(t[l],t[r])))//这一行的条件易错\n            q[t[l]].w = 0,tmp[tot] = t[l++];\n        else\n            q[t[r]].w = 1,tmp[tot] = t[r++];\n    }\n    for(int i = 0;i<num;i++) t[i] = tmp[i];\n\n    //统计id(time)比其小 b(pos)比其小 c(val)比其大的数的个数\n    for(int i = 0;i<num;i++)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,1);\n        else ans[q[t[i]].id] += BIT::query(n)-BIT::query(q[t[i]].c);\n    for(int i = 0;i<num;i++)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,-1);\n    //统计id(time)比其小 b(pos)比其大 c(val)比其小的数的个数\n    for(int i = num-1;i>=0;--i)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,1);\n        else ans[q[t[i]].id] += BIT::query(q[t[i]].c-1);\n    for(int i = num-1;i>=0;--i)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,-1);\n}\n\nvoid solve(){\n    int nowcnt = 0;\n    static int tt[MAXN];\n    for(int i = 1;i<=n;i++){\n        //遍历每个pos \n        if(del[i] == 0) q[i] = Q(1,i,num[i]);\n        else q[i] = Q(m-del[i]+2,i,num[i]);\n    }\n    sort(q+1,q+1+n);\n    for(int i = 1;i<=n;i++)\n        tt[i] = i;\n    CDQ(tt+1,n);\n    // 前缀和统计答案\n    for(int i = 1;i<=m+1;i++)\n        ans[i] += ans[i-1];\n    for(int i = m+1;i>1;--i)\n        print(ans[i]),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「CQOI2011」动态逆序对-CDQ分治.md","raw":"---\ntitle: 「CQOI2011」动态逆序对-CDQ分治\nurlname: cqoi2011-inverse\ndate: 2018-06-07 20:58:32\ntags:\n- 题解 \n- CDQ分治\n- 数据结构\ncategories: OI\nvisible:\n---\n\n对于序列$A$，它的逆序对数定义为满足$i<j$，且$A_i>A_j$的数对$(i,j)$的个数。给$1$到$n$的一个排列，按照某种顺序依次删除$m$个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!-- more -->\n\n## 链接\n\n[BZOJ 3295](https://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n[Luogu P3157](https://www.luogu.org/problemnew/show/P3157)\n\n## 题解\n\nCDQ分治强啊。\n\n这道题可以用树状数组&主席树做，不过很难写。\n\nCDQ分治的话，实现难度上比较低一些吧。\n\n首先，我们转化问题为每次在某个位置添加一个数，并查询能贡献出来的逆序对个数。这个问题和题目是等价的。\n\n然后我们令这个删除的反着的顺序为$id$，其插入的位置为$b$，插入的值为$c$，我们要求的就是在$id \\in [1,id - 1]$的数中，满足$b_j < b_i,c_j > c_i$或者$b_j > b_i,c_j < c_i$的j有多少个。\n\n这个问题我们用CDQ归并解决。先按照id排序，然后对b进行归并，完成后正序和倒序各扫一遍，统计贡献，最后作前缀和即可。\n\n实现有一点点不好写。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 110000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nstruct Q{\n    bool w;\n    int id,b,c;\n    // id -> 加入时间 b -> 加入的位置 c -> 这个数的大小\n    Q(int x,int y,int z):id(x),b(y),c(z){}\n    Q(){}\n    bool operator < (Q w)const{//用于排序\n        if(id!=w.id) \n            return id < w.id;\n        if(b!=w.b)\n            return b < w.b;\n        return c < w.c;\n    }\n}q[MAXN];\n\nint n,m;\nint num[MAXN],pos[MAXN],del[MAXN];\nll ans[MAXN];\n// num -> 原数组\n// pos -> 值对应的位置\n// del -> 删除第 pos 个数的序顺 \n\nnamespace BIT{\n    ll sumn[MAXN];\n    int lowbit(int x){\n        return x & (-x);\n    }\n    void add(int x,int d){\n        while(x <= n) sumn[x] += d,x += lowbit(x);\n    }\n    ll query(int x){\n        ll ans = 0;\n        while(x >= 1) ans += sumn[x],x -= lowbit(x);\n        return ans;\n    }\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        pos[num[i]] = i;\n    }\n    int tmp; \n    for(int i = 1;i<=m;i++){\n        read(tmp);\n        del[pos[tmp]] = i;\n    }\n}\n\nint l,r,tot,tmp[MAXN];\n\ninline bool judge(int x,int y){\n    //判断归并顺序函数 这里因为不重复，可以不写其他维判定\n    return q[x].b < q[y].b;\n}\n\n\nvoid CDQ(int *t,int num){\n    if(num == 1) return;\n    int mid = num/2;\n    CDQ(t,mid),CDQ(t+mid,num-mid);//分治解决问题\n    //进行归并\n    for(l=0,r=mid,tot=0;tot < num;tot++){\n        if((r==num)||(l<mid && judge(t[l],t[r])))//这一行的条件易错\n            q[t[l]].w = 0,tmp[tot] = t[l++];\n        else\n            q[t[r]].w = 1,tmp[tot] = t[r++];\n    }\n    for(int i = 0;i<num;i++) t[i] = tmp[i];\n\n    //统计id(time)比其小 b(pos)比其小 c(val)比其大的数的个数\n    for(int i = 0;i<num;i++)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,1);\n        else ans[q[t[i]].id] += BIT::query(n)-BIT::query(q[t[i]].c);\n    for(int i = 0;i<num;i++)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,-1);\n    //统计id(time)比其小 b(pos)比其大 c(val)比其小的数的个数\n    for(int i = num-1;i>=0;--i)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,1);\n        else ans[q[t[i]].id] += BIT::query(q[t[i]].c-1);\n    for(int i = num-1;i>=0;--i)\n        if(!q[t[i]].w) BIT::add(q[t[i]].c,-1);\n}\n\nvoid solve(){\n    int nowcnt = 0;\n    static int tt[MAXN];\n    for(int i = 1;i<=n;i++){\n        //遍历每个pos \n        if(del[i] == 0) q[i] = Q(1,i,num[i]);\n        else q[i] = Q(m-del[i]+2,i,num[i]);\n    }\n    sort(q+1,q+1+n);\n    for(int i = 1;i<=n;i++)\n        tt[i] = i;\n    CDQ(tt+1,n);\n    // 前缀和统计答案\n    for(int i = 1;i<=m+1;i++)\n        ans[i] += ans[i-1];\n    for(int i = m+1;i>1;--i)\n        print(ans[i]),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「CQOI2011」动态逆序对-CDQ分治","published":1,"updated":"2018-06-07T13:15:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i7001zbljr67jfyb1y","content":"<p>对于序列$A$，它的逆序对数定义为满足$i&lt;j$，且$A_i&gt;A_j$的数对$(i,j)$的个数。给$1$到$n$的一个排列，按照某种顺序依次删除$m$个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3295\" target=\"_blank\" rel=\"noopener\">BZOJ 3295</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P3157\" target=\"_blank\" rel=\"noopener\">Luogu P3157</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>CDQ分治强啊。</p>\n<p>这道题可以用树状数组&amp;主席树做，不过很难写。</p>\n<p>CDQ分治的话，实现难度上比较低一些吧。</p>\n<p>首先，我们转化问题为每次在某个位置添加一个数，并查询能贡献出来的逆序对个数。这个问题和题目是等价的。</p>\n<p>然后我们令这个删除的反着的顺序为$id$，其插入的位置为$b$，插入的值为$c$，我们要求的就是在$id \\in [1,id - 1]$的数中，满足$b_j &lt; b_i,c_j &gt; c_i$或者$b_j &gt; b_i,c_j &lt; c_i$的j有多少个。</p>\n<p>这个问题我们用CDQ归并解决。先按照id排序，然后对b进行归并，完成后正序和倒序各扫一遍，统计贡献，最后作前缀和即可。</p>\n<p>实现有一点点不好写。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Q</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> w;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> id,b,c;</span><br><span class=\"line\">    <span class=\"comment\">// id -&gt; 加入时间 b -&gt; 加入的位置 c -&gt; 这个数的大小</span></span><br><span class=\"line\">    Q(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> z):id(x),b(y),c(z)&#123;&#125;</span><br><span class=\"line\">    Q()&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (Q w)<span class=\"keyword\">const</span>&#123;<span class=\"comment\">//用于排序</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id!=w.id) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> id &lt; w.id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b!=w.b)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b &lt; w.b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c &lt; w.c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;q[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[MAXN],pos[MAXN],del[MAXN];</span><br><span class=\"line\">ll ans[MAXN];</span><br><span class=\"line\"><span class=\"comment\">// num -&gt; 原数组</span></span><br><span class=\"line\"><span class=\"comment\">// pos -&gt; 值对应的位置</span></span><br><span class=\"line\"><span class=\"comment\">// del -&gt; 删除第 pos 个数的序顺 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> BIT&#123;</span><br><span class=\"line\">    ll sumn[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &amp; (-x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &lt;= n) sumn[x] += d,x += lowbit(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt;= <span class=\"number\">1</span>) ans += sumn[x],x -= lowbit(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">        pos[num[i]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(tmp);</span><br><span class=\"line\">        del[pos[tmp]] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> l,r,tot,tmp[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断归并顺序函数 这里因为不重复，可以不写其他维判定</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> q[x].b &lt; q[y].b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CDQ</span><span class=\"params\">(<span class=\"keyword\">int</span> *t,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num == <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = num/<span class=\"number\">2</span>;</span><br><span class=\"line\">    CDQ(t,mid),CDQ(t+mid,num-mid);<span class=\"comment\">//分治解决问题</span></span><br><span class=\"line\">    <span class=\"comment\">//进行归并</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(l=<span class=\"number\">0</span>,r=mid,tot=<span class=\"number\">0</span>;tot &lt; num;tot++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((r==num)||(l&lt;mid &amp;&amp; judge(t[l],t[r])))<span class=\"comment\">//这一行的条件易错</span></span><br><span class=\"line\">            q[t[l]].w = <span class=\"number\">0</span>,tmp[tot] = t[l++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            q[t[r]].w = <span class=\"number\">1</span>,tmp[tot] = t[r++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;num;i++) t[i] = tmp[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//统计id(time)比其小 b(pos)比其小 c(val)比其大的数的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;num;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q[t[i]].w) BIT::add(q[t[i]].c,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> ans[q[t[i]].id] += BIT::query(n)-BIT::query(q[t[i]].c);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;num;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q[t[i]].w) BIT::add(q[t[i]].c,<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//统计id(time)比其小 b(pos)比其大 c(val)比其小的数的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q[t[i]].w) BIT::add(q[t[i]].c,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> ans[q[t[i]].id] += BIT::query(q[t[i]].c<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = num<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!q[t[i]].w) BIT::add(q[t[i]].c,<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nowcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> tt[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//遍历每个pos </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(del[i] == <span class=\"number\">0</span>) q[i] = Q(<span class=\"number\">1</span>,i,num[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> q[i] = Q(m-del[i]+<span class=\"number\">2</span>,i,num[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(q+<span class=\"number\">1</span>,q+<span class=\"number\">1</span>+n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        tt[i] = i;</span><br><span class=\"line\">    CDQ(tt+<span class=\"number\">1</span>,n);</span><br><span class=\"line\">    <span class=\"comment\">// 前缀和统计答案</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m+<span class=\"number\">1</span>;i++)</span><br><span class=\"line\">        ans[i] += ans[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = m+<span class=\"number\">1</span>;i&gt;<span class=\"number\">1</span>;--i)</span><br><span class=\"line\">        print(ans[i]),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>对于序列$A$，它的逆序对数定义为满足$i&lt;j$，且$A_i&gt;A_j$的数对$(i,j)$的个数。给$1$到$n$的一个排列，按照某种顺序依次删除$m$个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3295\" target=\"_blank\" rel=\"noopener\">BZOJ 3295</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P3157\" target=\"_blank\" rel=\"noopener\">Luogu P3157</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>CDQ分治强啊。</p>\n<p>这道题可以用树状数组&amp;主席树做，不过很难写。</p>\n<p>CDQ分治的话，实现难度上比较低一些吧。</p>\n<p>首先，我们转化问题为每次在某个位置添加一个数，并查询能贡献出来的逆序对个数。这个问题和题目是等价的。</p>\n<p>然后我们令这个删除的反着的顺序为$id$，其插入的位置为$b$，插入的值为$c$，我们要求的就是在$id \\in [1,id - 1]$的数中，满足$b_j &lt; b_i,c_j &gt; c_i$或者$b_j &gt; b_i,c_j &lt; c_i$的j有多少个。</p>\n<p>这个问题我们用CDQ归并解决。先按照id排序，然后对b进行归并，完成后正序和倒序各扫一遍，统计贡献，最后作前缀和即可。</p>\n<p>实现有一点点不好写。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�19-->\n\n</div></div>"},{"title":"「CQOI2012」交换棋子-费用流","urlname":"CQOI2012-chess","date":"2018-04-25T15:29:56.000Z","visible":null,"_content":"\n有一个$n$行$m$列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第$i$行第$j$列的格子只能参与$m_{i,j}$次交换。\n\n输出仅一行，为最小交换总次数。如果无解，输出$-1$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3159](https://www.luogu.org/problemnew/show/P3159)\n\n[BZOJ 2886](https://www.lydsy.com/JudgeOnline/problem.php?id=2668)\n\n## 题解\n\n比较难以实现的是对交换次数的限制。注意到如果一个点是起点或者终点，那么它的交换次数应当是奇数，其余的都是偶数，而且是经过这个点的棋子数目的两倍。所以我们可以按照如下方法建图：\n\n对于棋盘上的每个点，我们把它拆成三个点：$A_{i,j},B_{i,j},C_{i,j}$。\n\n对于一个既是起点也是终点的点或者既不是起点也不是终点的点，我们从$A_{i,j}$向$C_{i,j}$和$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j}}{2} \\rfloor$，费用为$0$的边。\n\n对于一个只是起点的点，我们从起点$S$向$C_{i,j}$连一条容量为$1$，费用为$0$的边。从$A_{i,j}$向$C_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} \\rfloor$，费用为0的边。从$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} +1 \\rfloor$，费用为$0$的边。\n\n对于一个只是终点的点，我们反过来就可以了。\n\n还需要从$C_{i,j}$向$B_{i,j-1},B_{i-1,j+1}...$，也就是周围的八个点连一条容量是$+\\infty$,费用是$1$的边。\n\n显然这样可以保证个点的交换次数不超过$m_{i,j}$。然后我们求出起点$S$到终点$T$最小费用最大流，如果满流有解，不满流就无解。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 5000,MAXM = 500000;\n\nstruct Edge{\n    int from,to;\n    int cap,flow;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t;\nint fir[MAXN],ecnt = 2,maxf = 0;\nint dis[MAXN],instack[MAXN],pree[MAXN];\nint b[25][25],e[25][25],num[25][25];\nqueue<int> q;\n\nint tr(int a,int b){\n    if(a == 0 || b == 0 || a>n||b>m)\n        return -1;\n    return (a-1)*m+b;\n}\n\nvoid addedge(int a,int b,int c,int d){\n    if(a <= 0 || b <= 0 || c == 0) return;\n    edge[ecnt] = (Edge){a,b,c,0,d,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]};\n    fir[b] = ecnt++;    \n}\n\nbool spfa(){\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    while(!q.empty()) q.pop();\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(int &sumf,int &sumc){\n    int nown = t,limit = 0x3f3f3f3f,nowe;\n    while(nown!=s){\n        nowe = pree[nown];\n        limit = min(limit,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown!=s){\n        nowe = pree[nown];\n        edge[nowe].flow += limit,edge[nowe^1].flow -= limit;\n        nown = edge[nowe].from;\n    }\n    sumf += limit,sumc += limit * dis[t];\n}\n\n\nvoid init(){\n    scanf(\"%d %d\",&n,&m);s = 1,t = 2;\n    char tmp[50];\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            b[i][j] = tmp[j-1]^48;\n    }\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            e[i][j] = tmp[j-1]^48;\n    }\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            num[i][j] = tmp[j-1]^48;\n    }\n}\n\nvoid build(){\n    int bb = 0,ee = 0;\n    for(int i = 1;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            int tmp = tr(i,j);\n            if(b[i][j] && !e[i][j]){\n                num[i][j]-=1;\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2+1,0);\n                addedge(s,3*tmp+3,1,0);\n                maxf = max(maxf,++bb);\n            }\n            else if(e[i][j] && !b[i][j]){\n                num[i][j]-=1;\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2+1,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0);\n                addedge(3*tmp+3,t,1,0);\n                maxf = max(maxf,++ee);\n            }\n            else{\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0); \n            } \n            addedge(3*tmp+2,3*tr(i-1,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j+1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i-1,j+1)+1,100000,1);        \n            addedge(3*tmp+2,3*tr(i,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i,j+1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i-1,j)+1,100000,1);\n        }\n    }\n}\n\nvoid solve(){\n    int f = 0,c = 0;\n    while(spfa())\n        argument(f,c);\n    if(f!=maxf)\n        printf(\"-1\");\n    else\n        printf(\"%d\\n\",c);\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}","source":"_posts/「CQOI2012」交换棋子-费用流.md","raw":"---\ntitle: 「CQOI2012」交换棋子-费用流\nurlname: CQOI2012-chess\ndate: 2018-04-25 23:29:56\ntags:\n- 题解\n- 图论\n- 费用流\ncategories: OI\nvisible:\n---\n\n有一个$n$行$m$列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第$i$行第$j$列的格子只能参与$m_{i,j}$次交换。\n\n输出仅一行，为最小交换总次数。如果无解，输出$-1$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3159](https://www.luogu.org/problemnew/show/P3159)\n\n[BZOJ 2886](https://www.lydsy.com/JudgeOnline/problem.php?id=2668)\n\n## 题解\n\n比较难以实现的是对交换次数的限制。注意到如果一个点是起点或者终点，那么它的交换次数应当是奇数，其余的都是偶数，而且是经过这个点的棋子数目的两倍。所以我们可以按照如下方法建图：\n\n对于棋盘上的每个点，我们把它拆成三个点：$A_{i,j},B_{i,j},C_{i,j}$。\n\n对于一个既是起点也是终点的点或者既不是起点也不是终点的点，我们从$A_{i,j}$向$C_{i,j}$和$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j}}{2} \\rfloor$，费用为$0$的边。\n\n对于一个只是起点的点，我们从起点$S$向$C_{i,j}$连一条容量为$1$，费用为$0$的边。从$A_{i,j}$向$C_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} \\rfloor$，费用为0的边。从$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} +1 \\rfloor$，费用为$0$的边。\n\n对于一个只是终点的点，我们反过来就可以了。\n\n还需要从$C_{i,j}$向$B_{i,j-1},B_{i-1,j+1}...$，也就是周围的八个点连一条容量是$+\\infty$,费用是$1$的边。\n\n显然这样可以保证个点的交换次数不超过$m_{i,j}$。然后我们求出起点$S$到终点$T$最小费用最大流，如果满流有解，不满流就无解。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 5000,MAXM = 500000;\n\nstruct Edge{\n    int from,to;\n    int cap,flow;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t;\nint fir[MAXN],ecnt = 2,maxf = 0;\nint dis[MAXN],instack[MAXN],pree[MAXN];\nint b[25][25],e[25][25],num[25][25];\nqueue<int> q;\n\nint tr(int a,int b){\n    if(a == 0 || b == 0 || a>n||b>m)\n        return -1;\n    return (a-1)*m+b;\n}\n\nvoid addedge(int a,int b,int c,int d){\n    if(a <= 0 || b <= 0 || c == 0) return;\n    edge[ecnt] = (Edge){a,b,c,0,d,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]};\n    fir[b] = ecnt++;    \n}\n\nbool spfa(){\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    while(!q.empty()) q.pop();\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(int &sumf,int &sumc){\n    int nown = t,limit = 0x3f3f3f3f,nowe;\n    while(nown!=s){\n        nowe = pree[nown];\n        limit = min(limit,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown!=s){\n        nowe = pree[nown];\n        edge[nowe].flow += limit,edge[nowe^1].flow -= limit;\n        nown = edge[nowe].from;\n    }\n    sumf += limit,sumc += limit * dis[t];\n}\n\n\nvoid init(){\n    scanf(\"%d %d\",&n,&m);s = 1,t = 2;\n    char tmp[50];\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            b[i][j] = tmp[j-1]^48;\n    }\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            e[i][j] = tmp[j-1]^48;\n    }\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",tmp);\n        for(int j = 1;j<=m;j++)\n            num[i][j] = tmp[j-1]^48;\n    }\n}\n\nvoid build(){\n    int bb = 0,ee = 0;\n    for(int i = 1;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            int tmp = tr(i,j);\n            if(b[i][j] && !e[i][j]){\n                num[i][j]-=1;\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2+1,0);\n                addedge(s,3*tmp+3,1,0);\n                maxf = max(maxf,++bb);\n            }\n            else if(e[i][j] && !b[i][j]){\n                num[i][j]-=1;\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2+1,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0);\n                addedge(3*tmp+3,t,1,0);\n                maxf = max(maxf,++ee);\n            }\n            else{\n                addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0);\n                addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0); \n            } \n            addedge(3*tmp+2,3*tr(i-1,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j+1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i-1,j+1)+1,100000,1);        \n            addedge(3*tmp+2,3*tr(i,j-1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i,j+1)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i+1,j)+1,100000,1);\n            addedge(3*tmp+2,3*tr(i-1,j)+1,100000,1);\n        }\n    }\n}\n\nvoid solve(){\n    int f = 0,c = 0;\n    while(spfa())\n        argument(f,c);\n    if(f!=maxf)\n        printf(\"-1\");\n    else\n        printf(\"%d\\n\",c);\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}","slug":"「CQOI2012」交换棋子-费用流","published":1,"updated":"2018-05-05T14:50:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3i90021bljrv3yuqq9u","content":"<p>有一个$n$行$m$列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第$i$行第$j$列的格子只能参与$m_{i,j}$次交换。</p>\n<p>输出仅一行，为最小交换总次数。如果无解，输出$-1$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3159\" target=\"_blank\" rel=\"noopener\">Luogu P3159</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2668\" target=\"_blank\" rel=\"noopener\">BZOJ 2886</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较难以实现的是对交换次数的限制。注意到如果一个点是起点或者终点，那么它的交换次数应当是奇数，其余的都是偶数，而且是经过这个点的棋子数目的两倍。所以我们可以按照如下方法建图：</p>\n<p>对于棋盘上的每个点，我们把它拆成三个点：$A_{i,j},B_{i,j},C_{i,j}$。</p>\n<p>对于一个既是起点也是终点的点或者既不是起点也不是终点的点，我们从$A_{i,j}$向$C_{i,j}$和$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j}}{2} \\rfloor$，费用为$0$的边。</p>\n<p>对于一个只是起点的点，我们从起点$S$向$C_{i,j}$连一条容量为$1$，费用为$0$的边。从$A_{i,j}$向$C_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} \\rfloor$，费用为0的边。从$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} +1 \\rfloor$，费用为$0$的边。</p>\n<p>对于一个只是终点的点，我们反过来就可以了。</p>\n<p>还需要从$C_{i,j}$向$B_{i,j-1},B_{i-1,j+1}…$，也就是周围的八个点连一条容量是$+\\infty$,费用是$1$的边。</p>\n<p>显然这样可以保证个点的交换次数不超过$m_{i,j}$。然后我们求出起点$S$到终点$T$最小费用最大流，如果满流有解，不满流就无解。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">5000</span>,MAXM = <span class=\"number\">500000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap,flow;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost,nex;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN],ecnt = <span class=\"number\">2</span>,maxf = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[MAXN],instack[MAXN],pree[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> b[<span class=\"number\">25</span>][<span class=\"number\">25</span>],e[<span class=\"number\">25</span>][<span class=\"number\">25</span>],num[<span class=\"number\">25</span>][<span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">tr</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == <span class=\"number\">0</span> || b == <span class=\"number\">0</span> || a&gt;n||b&gt;m)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a<span class=\"number\">-1</span>)*m+b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &lt;= <span class=\"number\">0</span> || b &lt;= <span class=\"number\">0</span> || c == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;a,b,c,<span class=\"number\">0</span>,d,fir[a]&#125;;</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;b,a,<span class=\"number\">0</span>,<span class=\"number\">0</span>,-d,fir[b]&#125;;</span><br><span class=\"line\">    fir[b] = ecnt++;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(instack,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(instack));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) q.pop();</span><br><span class=\"line\">    dis[s] = <span class=\"number\">0</span>;q.push(s);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        instack[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">            Edge e = edge[nowe];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[e.to] &gt; dis[nown] + e.cost &amp;&amp; e.cap &gt; e.flow)&#123;</span><br><span class=\"line\">                dis[e.to] = dis[nown] + e.cost;</span><br><span class=\"line\">                pree[e.to] = nowe;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instack[e.to] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                    instack[e.to] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t] &lt; <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">argument</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;sumf,<span class=\"keyword\">int</span> &amp;sumc)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nown = t,limit = <span class=\"number\">0x3f3f3f3f</span>,nowe;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        limit = min(limit,edge[nowe].cap - edge[nowe].flow);</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nown = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        edge[nowe].flow += limit,edge[nowe^<span class=\"number\">1</span>].flow -= limit;</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sumf += limit,sumc += limit * dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;n,&amp;m);s = <span class=\"number\">1</span>,t = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> tmp[<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,tmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            b[i][j] = tmp[j<span class=\"number\">-1</span>]^<span class=\"number\">48</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,tmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            e[i][j] = tmp[j<span class=\"number\">-1</span>]^<span class=\"number\">48</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,tmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            num[i][j] = tmp[j<span class=\"number\">-1</span>]^<span class=\"number\">48</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bb = <span class=\"number\">0</span>,ee = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = tr(i,j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b[i][j] &amp;&amp; !e[i][j])&#123;</span><br><span class=\"line\">                num[i][j]-=<span class=\"number\">1</span>;</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">1</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,num[i][j]/<span class=\"number\">2</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,num[i][j]/<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                addedge(s,<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                maxf = max(maxf,++bb);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e[i][j] &amp;&amp; !b[i][j])&#123;</span><br><span class=\"line\">                num[i][j]-=<span class=\"number\">1</span>;</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">1</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,num[i][j]/<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,num[i][j]/<span class=\"number\">2</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,t,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                maxf = max(maxf,++ee);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">1</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,num[i][j]/<span class=\"number\">2</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">                addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">3</span>,<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,num[i][j]/<span class=\"number\">2</span>,<span class=\"number\">0</span>); </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i<span class=\"number\">-1</span>,j<span class=\"number\">-1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i+<span class=\"number\">1</span>,j<span class=\"number\">-1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i<span class=\"number\">-1</span>,j+<span class=\"number\">1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);        </span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i,j<span class=\"number\">-1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i,j+<span class=\"number\">1</span>)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i+<span class=\"number\">1</span>,j)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">            addedge(<span class=\"number\">3</span>*tmp+<span class=\"number\">2</span>,<span class=\"number\">3</span>*tr(i<span class=\"number\">-1</span>,j)+<span class=\"number\">1</span>,<span class=\"number\">100000</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f = <span class=\"number\">0</span>,c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(spfa())</span><br><span class=\"line\">        argument(f,c);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f!=maxf)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>有一个$n$行$m$列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第$i$行第$j$列的格子只能参与$m_{i,j}$次交换。</p>\n<p>输出仅一行，为最小交换总次数。如果无解，输出$-1$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3159\" target=\"_blank\" rel=\"noopener\">Luogu P3159</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2668\" target=\"_blank\" rel=\"noopener\">BZOJ 2886</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较难以实现的是对交换次数的限制。注意到如果一个点是起点或者终点，那么它的交换次数应当是奇数，其余的都是偶数，而且是经过这个点的棋子数目的两倍。所以我们可以按照如下方法建图：</p>\n<p>对于棋盘上的每个点，我们把它拆成三个点：$A_{i,j},B_{i,j},C_{i,j}$。</p>\n<p>对于一个既是起点也是终点的点或者既不是起点也不是终点的点，我们从$A_{i,j}$向$C_{i,j}$和$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j}}{2} \\rfloor$，费用为$0$的边。</p>\n<p>对于一个只是起点的点，我们从起点$S$向$C_{i,j}$连一条容量为$1$，费用为$0$的边。从$A_{i,j}$向$C_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} \\rfloor$，费用为0的边。从$C_{i,j}$向$B_{i,j}$连一条容量是$\\lfloor \\frac {m_{i,j} \\, -1}{2} +1 \\rfloor$，费用为$0$的边。</p>\n<p>对于一个只是终点的点，我们反过来就可以了。</p>\n<p>还需要从$C_{i,j}$向$B_{i,j-1},B_{i-1,j+1}…$，也就是周围的八个点连一条容量是$+\\infty$,费用是$1$的边。</p>\n<p>显然这样可以保证个点的交换次数不超过$m_{i,j}$。然后我们求出起点$S$到终点$T$最小费用最大流，如果满流有解，不满流就无解。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�20-->\n\n</div></div>"},{"title":"「CQOI2014」排序机械臂-Splay","urlname":"cqoi2014-sort","date":"2018-02-02T07:12:44.000Z","visible":null,"_content":"\n维护一个序列，第$i$次操作时寻找第i小的数的所在位置$Pi$,并将$(P\\_{i-1},P\\_{i}]$的\b区间翻转。\n\n如果有相同的数，必须保证排序后它们的相对位置关系与初始时相同。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3165](https://www.luogu.org/problemnew/show/P3165)\n\n## 题解\n\n这道题的大意是区间\b寻找，区间翻转，所以我们\b可以用\bSplay来做，维护一个$size$值和区间翻转的$rev$标记。{% spoiler 虽然我前几天还说再也不用Splay了（逃。 %}\n\n注意到每次操作都会使第$i$个数排序完成，所以我们每次的$P\\_{i}$事实上就是数组下标的$i-1$。\n- - - \n对于区间的寻找，我们注意到可以在开始的时候就记录下来\b第$i$小的数的位置，也就是把他们的指针存在一个\b数组\b里面。\n\n![\b看不到的话假装有图吧](explanation.png)\n\n然后在查询的时候，先把第$i-1$大的节点splay到根；找到第$i$小的数对应的节点指针，寻找其在排序二叉树中的后继节点（图中红色节点），然后把\b后继splay到根的右子树。\n\n但注意在实际查找中，\b因为寻找后继会破坏根结点，所以要先找到后继节点，然后再完成上述操作。\n\n然后\b关于位置，我们可以看出，根节点左边（包括根结点），也就是图中的绿色部分应当有$i-1$个数，而其他在$i$左边（包括$i$）的数应该就是图中的蓝色部分，所以只要将蓝色部分的$size$加上一个$i-1$就是每一次操作的结果\n- - - \n翻转就是常规的区间翻转，打标记pushdown什么的。\n- - - \n为了方便满足一些\b\b它的要求，\b我还事先做了\b离散化的处理。（其实并没有什么\b用\n\n另外还有就是我写的时候还因为少`push_down`了几次被\b坑了\b一下。不过最后一次过评测还是蛮开心的。\n\n## 代码\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct wupin{\n    int id,h;\n}w[100100];\n\nstruct splay_t{\n    struct node_t{\n        int val,size;\n        bool rev;\n        node_t *p,*son[2],**root,**null;\n        inline bool get_p(){return p->son[1] == this;}\n        inline void init(node_t **root,node_t **null){this->null = null,this->root = root;}\n        inline int lsize(){return son[0]->size;} inline int rsize(){return son[1]->size;}\n        inline void update(){size = lsize()+rsize()+1;}\n        inline void link(node_t *dst,int tmp){\n            dst->son[tmp] = this;\n            this->p = dst;\n        }\n        inline void push_down(){\n            if(this == *null) return;\n            if(rev){\n                swap(son[0],son[1]);\n                son[0]->rev^=1,son[1]->rev^=1;\n                rev = 0;\n            }\n        }\n        inline void rotate(){\n            p->push_down(),push_down();\n            node_t *rp = p;bool re = get_p();\n            link(rp->p,rp->get_p());\n            son[1-re]->link(rp,re);\n            rp->link(this,1-re);\n            rp->update(),update();\n            if(p == *null) *root = this;\n        }\n        inline node_t* splay(node_t *tar = NULL){\n            if(tar == NULL) tar = *null;\n            p->push_down(),push_down();\n            while(p!=tar){\n                if(p->p == tar)\n                    rotate();\n                else if(p->get_p() == get_p())\n                    p->rotate(),rotate();\n                else\n                    rotate(),rotate();\n            }\n            return this;\n        }\n        inline node_t *upper(){\n            splay();\n            node_t *r = son[1];\n            while(true){\n                r->push_down();\n                if(r->son[0] == *null) break;\n                r = r->son[0];\n            }\n            return r;\n        }\n    };\n    int cnt;\n    node_t pool[110000],*to[110000],*null,*root;\n    splay_t(){\n        cnt = 0;\n        null = newnode();\n        null->size = 0;\n    }\n    node_t *newnode(int val = 0){\n        node_t *r = &pool[cnt++];\n        r->init(&root,&null);\n        r->val = val,r->size = 1,r->rev = 0;\n        r->p = r->son[0] = r->son[1] = null;\n        return r;\n    }\n    node_t* build(wupin *a,int l,int r){\n        if(l>r) return null;\n        int mid = (l+r)>>1;\n        node_t *ret = newnode(a[mid].h);\n        to[a[mid].h] = ret;\n        build(a,l,mid-1)->link(ret,0);\n        build(a,mid+1,r)->link(ret,1);\n        ret->update();\n        return ret;\n    }\n};\n\nsplay_t s;\n\nint n;\n\nbool cmp1(wupin a,wupin b){return a.id<b.id;}\nbool cmp2(wupin a,wupin b){\n    if(a.h!=b.h) return a.h<b.h;\n    else         return a.id<b.id;\n}\n\nvoid find(){\n    for(int i = 1;i<=n;i++){\n        //找到应操作节点的后继\n        splay_t::node_t *rbound = s.to[i]->upper();\n        //把前面归位好的最后一个节点旋到根节点\n        s.to[i-1]->splay();\n        //把后继旋转到根节点的右儿子\n        rbound->splay(s.to[i-1]);\n        //打印位置\n        printf(\"%d \",i + rbound->lsize()-1);\n        //添加lazy标记\n        rbound->son[0]->rev^=1;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%d\",&w[i].h);\n        w[i].id = i;\n    }\n    //预处理\n    sort(w+1,w+n+1,cmp2);\n    for(int i = 1;i<=n;i++)\n        w[i].h = i;\n    sort(w+1,w+n+1,cmp1);\n    w[0].h = 0;\n    w[n+1].h = n+1;\n    //正式操作\n    s.root = s.build(w,0,n+1);\n    find();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「CQOI2014」排序机械臂-Splay.md","raw":"---\ntitle: 「CQOI2014」排序机械臂-Splay\nurlname: cqoi2014-sort\ndate: 2018-02-02 15:12:44\ntags:\n- 数据结构\n- 平衡树\n- Splay\n- 题解\ncategories: OI\nvisible:\n---\n\n维护一个序列，第$i$次操作时寻找第i小的数的所在位置$Pi$,并将$(P\\_{i-1},P\\_{i}]$的\b区间翻转。\n\n如果有相同的数，必须保证排序后它们的相对位置关系与初始时相同。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3165](https://www.luogu.org/problemnew/show/P3165)\n\n## 题解\n\n这道题的大意是区间\b寻找，区间翻转，所以我们\b可以用\bSplay来做，维护一个$size$值和区间翻转的$rev$标记。{% spoiler 虽然我前几天还说再也不用Splay了（逃。 %}\n\n注意到每次操作都会使第$i$个数排序完成，所以我们每次的$P\\_{i}$事实上就是数组下标的$i-1$。\n- - - \n对于区间的寻找，我们注意到可以在开始的时候就记录下来\b第$i$小的数的位置，也就是把他们的指针存在一个\b数组\b里面。\n\n![\b看不到的话假装有图吧](explanation.png)\n\n然后在查询的时候，先把第$i-1$大的节点splay到根；找到第$i$小的数对应的节点指针，寻找其在排序二叉树中的后继节点（图中红色节点），然后把\b后继splay到根的右子树。\n\n但注意在实际查找中，\b因为寻找后继会破坏根结点，所以要先找到后继节点，然后再完成上述操作。\n\n然后\b关于位置，我们可以看出，根节点左边（包括根结点），也就是图中的绿色部分应当有$i-1$个数，而其他在$i$左边（包括$i$）的数应该就是图中的蓝色部分，所以只要将蓝色部分的$size$加上一个$i-1$就是每一次操作的结果\n- - - \n翻转就是常规的区间翻转，打标记pushdown什么的。\n- - - \n为了方便满足一些\b\b它的要求，\b我还事先做了\b离散化的处理。（其实并没有什么\b用\n\n另外还有就是我写的时候还因为少`push_down`了几次被\b坑了\b一下。不过最后一次过评测还是蛮开心的。\n\n## 代码\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct wupin{\n    int id,h;\n}w[100100];\n\nstruct splay_t{\n    struct node_t{\n        int val,size;\n        bool rev;\n        node_t *p,*son[2],**root,**null;\n        inline bool get_p(){return p->son[1] == this;}\n        inline void init(node_t **root,node_t **null){this->null = null,this->root = root;}\n        inline int lsize(){return son[0]->size;} inline int rsize(){return son[1]->size;}\n        inline void update(){size = lsize()+rsize()+1;}\n        inline void link(node_t *dst,int tmp){\n            dst->son[tmp] = this;\n            this->p = dst;\n        }\n        inline void push_down(){\n            if(this == *null) return;\n            if(rev){\n                swap(son[0],son[1]);\n                son[0]->rev^=1,son[1]->rev^=1;\n                rev = 0;\n            }\n        }\n        inline void rotate(){\n            p->push_down(),push_down();\n            node_t *rp = p;bool re = get_p();\n            link(rp->p,rp->get_p());\n            son[1-re]->link(rp,re);\n            rp->link(this,1-re);\n            rp->update(),update();\n            if(p == *null) *root = this;\n        }\n        inline node_t* splay(node_t *tar = NULL){\n            if(tar == NULL) tar = *null;\n            p->push_down(),push_down();\n            while(p!=tar){\n                if(p->p == tar)\n                    rotate();\n                else if(p->get_p() == get_p())\n                    p->rotate(),rotate();\n                else\n                    rotate(),rotate();\n            }\n            return this;\n        }\n        inline node_t *upper(){\n            splay();\n            node_t *r = son[1];\n            while(true){\n                r->push_down();\n                if(r->son[0] == *null) break;\n                r = r->son[0];\n            }\n            return r;\n        }\n    };\n    int cnt;\n    node_t pool[110000],*to[110000],*null,*root;\n    splay_t(){\n        cnt = 0;\n        null = newnode();\n        null->size = 0;\n    }\n    node_t *newnode(int val = 0){\n        node_t *r = &pool[cnt++];\n        r->init(&root,&null);\n        r->val = val,r->size = 1,r->rev = 0;\n        r->p = r->son[0] = r->son[1] = null;\n        return r;\n    }\n    node_t* build(wupin *a,int l,int r){\n        if(l>r) return null;\n        int mid = (l+r)>>1;\n        node_t *ret = newnode(a[mid].h);\n        to[a[mid].h] = ret;\n        build(a,l,mid-1)->link(ret,0);\n        build(a,mid+1,r)->link(ret,1);\n        ret->update();\n        return ret;\n    }\n};\n\nsplay_t s;\n\nint n;\n\nbool cmp1(wupin a,wupin b){return a.id<b.id;}\nbool cmp2(wupin a,wupin b){\n    if(a.h!=b.h) return a.h<b.h;\n    else         return a.id<b.id;\n}\n\nvoid find(){\n    for(int i = 1;i<=n;i++){\n        //找到应操作节点的后继\n        splay_t::node_t *rbound = s.to[i]->upper();\n        //把前面归位好的最后一个节点旋到根节点\n        s.to[i-1]->splay();\n        //把后继旋转到根节点的右儿子\n        rbound->splay(s.to[i-1]);\n        //打印位置\n        printf(\"%d \",i + rbound->lsize()-1);\n        //添加lazy标记\n        rbound->son[0]->rev^=1;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%d\",&w[i].h);\n        w[i].id = i;\n    }\n    //预处理\n    sort(w+1,w+n+1,cmp2);\n    for(int i = 1;i<=n;i++)\n        w[i].h = i;\n    sort(w+1,w+n+1,cmp1);\n    w[0].h = 0;\n    w[n+1].h = n+1;\n    //正式操作\n    s.root = s.build(w,0,n+1);\n    find();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「CQOI2014」排序机械臂-Splay","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ia0024bljrd71nqh4d","content":"<p>&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#xFF0C;&#x7B2C;$i$&#x6B21;&#x64CD;&#x4F5C;&#x65F6;&#x5BFB;&#x627E;&#x7B2C;i&#x5C0F;&#x7684;&#x6570;&#x7684;&#x6240;&#x5728;&#x4F4D;&#x7F6E;$Pi$,&#x5E76;&#x5C06;$(P_{i-1},P_{i}]$&#x7684;\b&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#x3002;</p>\n<p>&#x5982;&#x679C;&#x6709;&#x76F8;&#x540C;&#x7684;&#x6570;&#xFF0C;&#x5FC5;&#x987B;&#x4FDD;&#x8BC1;&#x6392;&#x5E8F;&#x540E;&#x5B83;&#x4EEC;&#x7684;&#x76F8;&#x5BF9;&#x4F4D;&#x7F6E;&#x5173;&#x7CFB;&#x4E0E;&#x521D;&#x59CB;&#x65F6;&#x76F8;&#x540C;&#x3002;</p>\n<a id=\"more\"></a>\n<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3165\" target=\"_blank\" rel=\"noopener\">Luogu P3165</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x7684;&#x5927;&#x610F;&#x662F;&#x533A;&#x95F4;\b&#x5BFB;&#x627E;&#xFF0C;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;\b&#x53EF;&#x4EE5;&#x7528;\bSplay&#x6765;&#x505A;&#xFF0C;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;$size$&#x503C;&#x548C;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#x7684;$rev$&#x6807;&#x8BB0;&#x3002;<span class=\"spoiler\">&#x867D;&#x7136;&#x6211;&#x524D;&#x51E0;&#x5929;&#x8FD8;&#x8BF4;&#x518D;&#x4E5F;&#x4E0D;&#x7528;Splay&#x4E86;&#xFF08;&#x9003;&#x3002;\n</span></p>\n<p>&#x6CE8;&#x610F;&#x5230;&#x6BCF;&#x6B21;&#x64CD;&#x4F5C;&#x90FD;&#x4F1A;&#x4F7F;&#x7B2C;$i$&#x4E2A;&#x6570;&#x6392;&#x5E8F;&#x5B8C;&#x6210;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x6BCF;&#x6B21;&#x7684;$P_{i}$&#x4E8B;&#x5B9E;&#x4E0A;&#x5C31;&#x662F;&#x6570;&#x7EC4;&#x4E0B;&#x6807;&#x7684;$i-1$&#x3002;</p>\n<hr>\n<p>&#x5BF9;&#x4E8E;&#x533A;&#x95F4;&#x7684;&#x5BFB;&#x627E;&#xFF0C;&#x6211;&#x4EEC;&#x6CE8;&#x610F;&#x5230;&#x53EF;&#x4EE5;&#x5728;&#x5F00;&#x59CB;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x8BB0;&#x5F55;&#x4E0B;&#x6765;\b&#x7B2C;$i$&#x5C0F;&#x7684;&#x6570;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x628A;&#x4ED6;&#x4EEC;&#x7684;&#x6307;&#x9488;&#x5B58;&#x5728;&#x4E00;&#x4E2A;\b&#x6570;&#x7EC4;\b&#x91CC;&#x9762;&#x3002;</p>\n<p><img src=\"explanation.png\" alt=\"\b&#x770B;&#x4E0D;&#x5230;&#x7684;&#x8BDD;&#x5047;&#x88C5;&#x6709;&#x56FE;&#x5427;\"></p>\n<p>&#x7136;&#x540E;&#x5728;&#x67E5;&#x8BE2;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5148;&#x628A;&#x7B2C;$i-1$&#x5927;&#x7684;&#x8282;&#x70B9;splay&#x5230;&#x6839;&#xFF1B;&#x627E;&#x5230;&#x7B2C;$i$&#x5C0F;&#x7684;&#x6570;&#x5BF9;&#x5E94;&#x7684;&#x8282;&#x70B9;&#x6307;&#x9488;&#xFF0C;&#x5BFB;&#x627E;&#x5176;&#x5728;&#x6392;&#x5E8F;&#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#xFF08;&#x56FE;&#x4E2D;&#x7EA2;&#x8272;&#x8282;&#x70B9;&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x628A;\b&#x540E;&#x7EE7;splay&#x5230;&#x6839;&#x7684;&#x53F3;&#x5B50;&#x6811;&#x3002;</p>\n<p>&#x4F46;&#x6CE8;&#x610F;&#x5728;&#x5B9E;&#x9645;&#x67E5;&#x627E;&#x4E2D;&#xFF0C;\b&#x56E0;&#x4E3A;&#x5BFB;&#x627E;&#x540E;&#x7EE7;&#x4F1A;&#x7834;&#x574F;&#x6839;&#x7ED3;&#x70B9;&#xFF0C;&#x6240;&#x4EE5;&#x8981;&#x5148;&#x627E;&#x5230;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#x3002;</p>\n<p>&#x7136;&#x540E;\b&#x5173;&#x4E8E;&#x4F4D;&#x7F6E;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x6839;&#x8282;&#x70B9;&#x5DE6;&#x8FB9;&#xFF08;&#x5305;&#x62EC;&#x6839;&#x7ED3;&#x70B9;&#xFF09;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x56FE;&#x4E2D;&#x7684;&#x7EFF;&#x8272;&#x90E8;&#x5206;&#x5E94;&#x5F53;&#x6709;$i-1$&#x4E2A;&#x6570;&#xFF0C;&#x800C;&#x5176;&#x4ED6;&#x5728;$i$&#x5DE6;&#x8FB9;&#xFF08;&#x5305;&#x62EC;$i$&#xFF09;&#x7684;&#x6570;&#x5E94;&#x8BE5;&#x5C31;&#x662F;&#x56FE;&#x4E2D;&#x7684;&#x84DD;&#x8272;&#x90E8;&#x5206;&#xFF0C;&#x6240;&#x4EE5;&#x53EA;&#x8981;&#x5C06;&#x84DD;&#x8272;&#x90E8;&#x5206;&#x7684;$size$&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;$i-1$&#x5C31;&#x662F;&#x6BCF;&#x4E00;&#x6B21;&#x64CD;&#x4F5C;&#x7684;&#x7ED3;&#x679C;</p>\n<hr>\n<p>&#x7FFB;&#x8F6C;&#x5C31;&#x662F;&#x5E38;&#x89C4;&#x7684;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#xFF0C;&#x6253;&#x6807;&#x8BB0;pushdown&#x4EC0;&#x4E48;&#x7684;&#x3002;</p>\n<hr>\n<p>&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x6EE1;&#x8DB3;&#x4E00;&#x4E9B;\b\b&#x5B83;&#x7684;&#x8981;&#x6C42;&#xFF0C;\b&#x6211;&#x8FD8;&#x4E8B;&#x5148;&#x505A;&#x4E86;\b&#x79BB;&#x6563;&#x5316;&#x7684;&#x5904;&#x7406;&#x3002;&#xFF08;&#x5176;&#x5B9E;&#x5E76;&#x6CA1;&#x6709;&#x4EC0;&#x4E48;\b&#x7528;</p>\n<p>&#x53E6;&#x5916;&#x8FD8;&#x6709;&#x5C31;&#x662F;&#x6211;&#x5199;&#x7684;&#x65F6;&#x5019;&#x8FD8;&#x56E0;&#x4E3A;&#x5C11;<code>push_down</code>&#x4E86;&#x51E0;&#x6B21;&#x88AB;\b&#x5751;&#x4E86;\b&#x4E00;&#x4E0B;&#x3002;&#x4E0D;&#x8FC7;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x8FC7;&#x8BC4;&#x6D4B;&#x8FD8;&#x662F;&#x86EE;&#x5F00;&#x5FC3;&#x7684;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wupin</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id,h;</span><br><span class=\"line\">&#125;w[<span class=\"number\">100100</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">splay_t</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> val,size;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> rev;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *p,*son[<span class=\"number\">2</span>],**root,**null;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">get_p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> p-&gt;son[<span class=\"number\">1</span>] == <span class=\"keyword\">this</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">node_t</span> **root,<span class=\"keyword\">node_t</span> **null)</span></span>&#123;<span class=\"keyword\">this</span>-&gt;null = null,<span class=\"keyword\">this</span>-&gt;root = root;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lsize</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]-&gt;size;&#125; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">rsize</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]-&gt;size;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;size = lsize()+rsize()+<span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *dst,<span class=\"keyword\">int</span> tmp)</span></span>&#123;</span><br><span class=\"line\">            dst-&gt;son[tmp] = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;p = dst;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rev)&#123;</span><br><span class=\"line\">                swap(son[<span class=\"number\">0</span>],son[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                son[<span class=\"number\">0</span>]-&gt;rev^=<span class=\"number\">1</span>,son[<span class=\"number\">1</span>]-&gt;rev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">                rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            p-&gt;push_down(),push_down();</span><br><span class=\"line\">            <span class=\"keyword\">node_t</span> *rp = p;<span class=\"keyword\">bool</span> re = get_p();</span><br><span class=\"line\">            link(rp-&gt;p,rp-&gt;get_p());</span><br><span class=\"line\">            son[<span class=\"number\">1</span>-re]-&gt;link(rp,re);</span><br><span class=\"line\">            rp-&gt;link(<span class=\"keyword\">this</span>,<span class=\"number\">1</span>-re);</span><br><span class=\"line\">            rp-&gt;update(),update();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p == *null) *root = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> node_t* <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *tar = <span class=\"literal\">NULL</span>)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tar == <span class=\"literal\">NULL</span>) tar = *null;</span><br><span class=\"line\">            p-&gt;push_down(),push_down();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p!=tar)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;p == tar)</span><br><span class=\"line\">                    rotate();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(p-&gt;get_p() == get_p())</span><br><span class=\"line\">                    p-&gt;rotate(),rotate();</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    rotate(),rotate();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> node_t *<span class=\"title\">upper</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            splay();</span><br><span class=\"line\">            <span class=\"keyword\">node_t</span> *r = son[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                r-&gt;push_down();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>] == *null) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                r = r-&gt;son[<span class=\"number\">0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[<span class=\"number\">110000</span>],*to[<span class=\"number\">110000</span>],*null,*root;</span><br><span class=\"line\">    <span class=\"keyword\">splay_t</span>()&#123;</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        null = newnode();</span><br><span class=\"line\">        null-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *newnode(<span class=\"keyword\">int</span> val = <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *r = &amp;pool[cnt++];</span><br><span class=\"line\">        r-&gt;init(&amp;root,&amp;null);</span><br><span class=\"line\">        r-&gt;val = val,r-&gt;size = <span class=\"number\">1</span>,r-&gt;rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        r-&gt;p = r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span>* build(wupin *a,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;r) <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *ret = newnode(a[mid].h);</span><br><span class=\"line\">        to[a[mid].h] = ret;</span><br><span class=\"line\">        build(a,l,mid<span class=\"number\">-1</span>)-&gt;link(ret,<span class=\"number\">0</span>);</span><br><span class=\"line\">        build(a,mid+<span class=\"number\">1</span>,r)-&gt;link(ret,<span class=\"number\">1</span>);</span><br><span class=\"line\">        ret-&gt;update();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">splay_t</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(wupin a,wupin b)</span></span>&#123;<span class=\"keyword\">return</span> a.id&lt;b.id;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(wupin a,wupin b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.h!=b.h) <span class=\"keyword\">return</span> a.h&lt;b.h;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>         <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到应操作节点的后继</span></span><br><span class=\"line\">        <span class=\"keyword\">splay_t</span>::<span class=\"keyword\">node_t</span> *rbound = s.to[i]-&gt;upper();</span><br><span class=\"line\">        <span class=\"comment\">//把前面归位好的最后一个节点旋到根节点</span></span><br><span class=\"line\">        s.to[i<span class=\"number\">-1</span>]-&gt;splay();</span><br><span class=\"line\">        <span class=\"comment\">//把后继旋转到根节点的右儿子</span></span><br><span class=\"line\">        rbound-&gt;splay(s.to[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">        <span class=\"comment\">//打印位置</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>,i + rbound-&gt;lsize()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//添加lazy标记</span></span><br><span class=\"line\">        rbound-&gt;son[<span class=\"number\">0</span>]-&gt;rev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;w[i].h);</span><br><span class=\"line\">        w[i].id = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//预处理</span></span><br><span class=\"line\">    sort(w+<span class=\"number\">1</span>,w+n+<span class=\"number\">1</span>,cmp2);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        w[i].h = i;</span><br><span class=\"line\">    sort(w+<span class=\"number\">1</span>,w+n+<span class=\"number\">1</span>,cmp1);</span><br><span class=\"line\">    w[<span class=\"number\">0</span>].h = <span class=\"number\">0</span>;</span><br><span class=\"line\">    w[n+<span class=\"number\">1</span>].h = n+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//正式操作</span></span><br><span class=\"line\">    s.root = s.build(w,<span class=\"number\">0</span>,n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    find();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x5E8F;&#x5217;&#xFF0C;&#x7B2C;$i$&#x6B21;&#x64CD;&#x4F5C;&#x65F6;&#x5BFB;&#x627E;&#x7B2C;i&#x5C0F;&#x7684;&#x6570;&#x7684;&#x6240;&#x5728;&#x4F4D;&#x7F6E;$Pi$,&#x5E76;&#x5C06;$(P_{i-1},P_{i}]$&#x7684;\b&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#x3002;</p>\n<p>&#x5982;&#x679C;&#x6709;&#x76F8;&#x540C;&#x7684;&#x6570;&#xFF0C;&#x5FC5;&#x987B;&#x4FDD;&#x8BC1;&#x6392;&#x5E8F;&#x540E;&#x5B83;&#x4EEC;&#x7684;&#x76F8;&#x5BF9;&#x4F4D;&#x7F6E;&#x5173;&#x7CFB;&#x4E0E;&#x521D;&#x59CB;&#x65F6;&#x76F8;&#x540C;&#x3002;</p>","more":"<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3165\" target=\"_blank\" rel=\"noopener\">Luogu P3165</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x7684;&#x5927;&#x610F;&#x662F;&#x533A;&#x95F4;\b&#x5BFB;&#x627E;&#xFF0C;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;\b&#x53EF;&#x4EE5;&#x7528;\bSplay&#x6765;&#x505A;&#xFF0C;&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;$size$&#x503C;&#x548C;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#x7684;$rev$&#x6807;&#x8BB0;&#x3002;<span class=\"spoiler\">&#x867D;&#x7136;&#x6211;&#x524D;&#x51E0;&#x5929;&#x8FD8;&#x8BF4;&#x518D;&#x4E5F;&#x4E0D;&#x7528;Splay&#x4E86;&#xFF08;&#x9003;&#x3002;\n</span></p>\n<p>&#x6CE8;&#x610F;&#x5230;&#x6BCF;&#x6B21;&#x64CD;&#x4F5C;&#x90FD;&#x4F1A;&#x4F7F;&#x7B2C;$i$&#x4E2A;&#x6570;&#x6392;&#x5E8F;&#x5B8C;&#x6210;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x6BCF;&#x6B21;&#x7684;$P_{i}$&#x4E8B;&#x5B9E;&#x4E0A;&#x5C31;&#x662F;&#x6570;&#x7EC4;&#x4E0B;&#x6807;&#x7684;$i-1$&#x3002;</p>\n<hr>\n<p>&#x5BF9;&#x4E8E;&#x533A;&#x95F4;&#x7684;&#x5BFB;&#x627E;&#xFF0C;&#x6211;&#x4EEC;&#x6CE8;&#x610F;&#x5230;&#x53EF;&#x4EE5;&#x5728;&#x5F00;&#x59CB;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x8BB0;&#x5F55;&#x4E0B;&#x6765;\b&#x7B2C;$i$&#x5C0F;&#x7684;&#x6570;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x628A;&#x4ED6;&#x4EEC;&#x7684;&#x6307;&#x9488;&#x5B58;&#x5728;&#x4E00;&#x4E2A;\b&#x6570;&#x7EC4;\b&#x91CC;&#x9762;&#x3002;</p>\n<p><img src=\"explanation.png\" alt=\"\b&#x770B;&#x4E0D;&#x5230;&#x7684;&#x8BDD;&#x5047;&#x88C5;&#x6709;&#x56FE;&#x5427;\"></p>\n<p>&#x7136;&#x540E;&#x5728;&#x67E5;&#x8BE2;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5148;&#x628A;&#x7B2C;$i-1$&#x5927;&#x7684;&#x8282;&#x70B9;splay&#x5230;&#x6839;&#xFF1B;&#x627E;&#x5230;&#x7B2C;$i$&#x5C0F;&#x7684;&#x6570;&#x5BF9;&#x5E94;&#x7684;&#x8282;&#x70B9;&#x6307;&#x9488;&#xFF0C;&#x5BFB;&#x627E;&#x5176;&#x5728;&#x6392;&#x5E8F;&#x4E8C;&#x53C9;&#x6811;&#x4E2D;&#x7684;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#xFF08;&#x56FE;&#x4E2D;&#x7EA2;&#x8272;&#x8282;&#x70B9;&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x628A;\b&#x540E;&#x7EE7;splay&#x5230;&#x6839;&#x7684;&#x53F3;&#x5B50;&#x6811;&#x3002;</p>\n<p>&#x4F46;&#x6CE8;&#x610F;&#x5728;&#x5B9E;&#x9645;&#x67E5;&#x627E;&#x4E2D;&#xFF0C;\b&#x56E0;&#x4E3A;&#x5BFB;&#x627E;&#x540E;&#x7EE7;&#x4F1A;&#x7834;&#x574F;&#x6839;&#x7ED3;&#x70B9;&#xFF0C;&#x6240;&#x4EE5;&#x8981;&#x5148;&#x627E;&#x5230;&#x540E;&#x7EE7;&#x8282;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#x3002;</p>\n<p>&#x7136;&#x540E;\b&#x5173;&#x4E8E;&#x4F4D;&#x7F6E;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x6839;&#x8282;&#x70B9;&#x5DE6;&#x8FB9;&#xFF08;&#x5305;&#x62EC;&#x6839;&#x7ED3;&#x70B9;&#xFF09;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x56FE;&#x4E2D;&#x7684;&#x7EFF;&#x8272;&#x90E8;&#x5206;&#x5E94;&#x5F53;&#x6709;$i-1$&#x4E2A;&#x6570;&#xFF0C;&#x800C;&#x5176;&#x4ED6;&#x5728;$i$&#x5DE6;&#x8FB9;&#xFF08;&#x5305;&#x62EC;$i$&#xFF09;&#x7684;&#x6570;&#x5E94;&#x8BE5;&#x5C31;&#x662F;&#x56FE;&#x4E2D;&#x7684;&#x84DD;&#x8272;&#x90E8;&#x5206;&#xFF0C;&#x6240;&#x4EE5;&#x53EA;&#x8981;&#x5C06;&#x84DD;&#x8272;&#x90E8;&#x5206;&#x7684;$size$&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;$i-1$&#x5C31;&#x662F;&#x6BCF;&#x4E00;&#x6B21;&#x64CD;&#x4F5C;&#x7684;&#x7ED3;&#x679C;</p>\n<hr>\n<p>&#x7FFB;&#x8F6C;&#x5C31;&#x662F;&#x5E38;&#x89C4;&#x7684;&#x533A;&#x95F4;&#x7FFB;&#x8F6C;&#xFF0C;&#x6253;&#x6807;&#x8BB0;pushdown&#x4EC0;&#x4E48;&#x7684;&#x3002;</p>\n<hr>\n<p>&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x6EE1;&#x8DB3;&#x4E00;&#x4E9B;\b\b&#x5B83;&#x7684;&#x8981;&#x6C42;&#xFF0C;\b&#x6211;&#x8FD8;&#x4E8B;&#x5148;&#x505A;&#x4E86;\b&#x79BB;&#x6563;&#x5316;&#x7684;&#x5904;&#x7406;&#x3002;&#xFF08;&#x5176;&#x5B9E;&#x5E76;&#x6CA1;&#x6709;&#x4EC0;&#x4E48;\b&#x7528;</p>\n<p>&#x53E6;&#x5916;&#x8FD8;&#x6709;&#x5C31;&#x662F;&#x6211;&#x5199;&#x7684;&#x65F6;&#x5019;&#x8FD8;&#x56E0;&#x4E3A;&#x5C11;<code>push_down</code>&#x4E86;&#x51E0;&#x6B21;&#x88AB;\b&#x5751;&#x4E86;\b&#x4E00;&#x4E0B;&#x3002;&#x4E0D;&#x8FC7;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x8FC7;&#x8BC4;&#x6D4B;&#x8FD8;&#x662F;&#x86EE;&#x5F00;&#x5FC3;&#x7684;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�21-->\n\n</div></div>"},{"title":"「CQOI2015」任务查询系统-可持久化线段树","urlname":"CQOI2015-mission","date":"2018-05-16T13:16:32.000Z","visible":null,"_content":"\n超级计算机中的任务用三元组$(S_i,E_i,P_i)$描述，$(S_i,E_i,P_i)$表示任务运行区间为$[S_i,E_i]$,其优先级为$P_i$。\n\n给出$n$个任务。随后给出$m$个询问，第$X_i$秒正在运行的任务中，优先级最小的$K_i$个任务的优先级之和是多少。特别的，如果$K_i$大于第$X_i$秒正在运行的任务总数，则直接回答第$X_i$秒正在运行的任务优先级之和。\n\n强制在线。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3128](https://www.luogu.org/problemnew/show/P3168)\n\n## 题解\n\n注意到这个问题主要就是区间的权值修改，以及单点的求和（求值），我们可以采用差分的办法。\n\n\b首先对任务离线后分成$(S_i,P_i,1)$，$(E_i+1,P_i,-1)$两个修改，排序后\b扫一遍进行修改。\n\n查询第$X_i$秒的时候，我们注意到我们\b每个时间所对应的线段树\b其实就是\b差分的前缀和，所以我们直接在第$X_i$个线段树上求前$K_i$个数的和就好了。注意在叶子结点需要分类讨论，看\b叶子结点有没有取全。\n\n数据范围很大（？），需要离散化，这里用了map。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cctype>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 200000;\n\nmap<int,int> S;int last[MAXN];\n\nnamespace prSegTree{\n    int val[MAXN*50],ls[MAXN*50],rs[MAXN*50];\n    ll sum[MAXN*50];int cnt = 0;\n    #define mid ((l+r)>>1)\n    void maintain(int nown,int l,int r){\n        val[nown] = val[ls[nown]] + val[rs[nown]];\n        sum[nown] = sum[ls[nown]] + sum[rs[nown]];\n    }\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];\n        val[nown]=val[pre]+d,sum[nown]=sum[pre]+1ll * d * last[pos];\n        if(l == r) return;\n        else{\n            if(pos <= mid) insert(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    ll query(int nown,int l,int r,int k){\n        if(l == r){\n            if(k>=val[nown]) return sum[nown];\n            else return k * last[l];\n        }\n        else{\n            int sumn = val[ls[nown]];\n            if(k <= sumn)\n                return query(ls[nown],l,mid,k);   \n            else if(sumn + 1 <= k)\n                return sum[ls[nown]] + query(rs[nown],mid+1,r,k-sumn);\n        }\n    }\n}\n\n\nint n,m,totn,maxt,rt[MAXN];\nvector<int> qq[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    maxt = n;\n    for(int i = 1;i<=n;i++){\n        read(a),read(b),read(c);\n        qq[a].push_back(c);\n        qq[b+1].push_back(-c);\n        maxt = max(maxt,b+1);\n        S[c] = 0;\n    }\n    for(auto it = S.begin();it!=S.end();it++){\n        it->second = ++totn;\n        last[totn] = it->first;\n    }\n    for(int i = 1;i<=maxt;i++){\n        rt[i] = rt[i-1];\n        for(int j = 0;j<qq[i].size();j++){\n            prSegTree::insert(rt[i],rt[i],1,totn,(S[abs(qq[i][j])]),qq[i][j] > 0? 1 : -1);\n        }\n    }\n}\n\nvoid solve(){\n    ll last = 1,ans;\n    int x,k,a,b,c;\n    for(int i = 1;i<=m;i++){\n        read(x),read(a),read(b),read(c);\n        k = 1+(a*last+b)%c;\n        ans = prSegTree::query(rt[x],1,totn,k);\n        printf(\"%lld\\n\",ans);\n        last = ans;\n    }\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「CQOI2015」任务查询系统-可持久化线段树.md","raw":"---\ntitle: 「CQOI2015」任务查询系统-可持久化线段树\nurlname: CQOI2015-mission\ndate: 2018-05-16 21:16:32\ntags:\n- 题解\n- 可持久化线段树\n- 差分\n- 数据结构\ncategories: OI\nvisible:\n---\n\n超级计算机中的任务用三元组$(S_i,E_i,P_i)$描述，$(S_i,E_i,P_i)$表示任务运行区间为$[S_i,E_i]$,其优先级为$P_i$。\n\n给出$n$个任务。随后给出$m$个询问，第$X_i$秒正在运行的任务中，优先级最小的$K_i$个任务的优先级之和是多少。特别的，如果$K_i$大于第$X_i$秒正在运行的任务总数，则直接回答第$X_i$秒正在运行的任务优先级之和。\n\n强制在线。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3128](https://www.luogu.org/problemnew/show/P3168)\n\n## 题解\n\n注意到这个问题主要就是区间的权值修改，以及单点的求和（求值），我们可以采用差分的办法。\n\n\b首先对任务离线后分成$(S_i,P_i,1)$，$(E_i+1,P_i,-1)$两个修改，排序后\b扫一遍进行修改。\n\n查询第$X_i$秒的时候，我们注意到我们\b每个时间所对应的线段树\b其实就是\b差分的前缀和，所以我们直接在第$X_i$个线段树上求前$K_i$个数的和就好了。注意在叶子结点需要分类讨论，看\b叶子结点有没有取全。\n\n数据范围很大（？），需要离散化，这里用了map。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cctype>\n#include <vector>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 200000;\n\nmap<int,int> S;int last[MAXN];\n\nnamespace prSegTree{\n    int val[MAXN*50],ls[MAXN*50],rs[MAXN*50];\n    ll sum[MAXN*50];int cnt = 0;\n    #define mid ((l+r)>>1)\n    void maintain(int nown,int l,int r){\n        val[nown] = val[ls[nown]] + val[rs[nown]];\n        sum[nown] = sum[ls[nown]] + sum[rs[nown]];\n    }\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];\n        val[nown]=val[pre]+d,sum[nown]=sum[pre]+1ll * d * last[pos];\n        if(l == r) return;\n        else{\n            if(pos <= mid) insert(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    ll query(int nown,int l,int r,int k){\n        if(l == r){\n            if(k>=val[nown]) return sum[nown];\n            else return k * last[l];\n        }\n        else{\n            int sumn = val[ls[nown]];\n            if(k <= sumn)\n                return query(ls[nown],l,mid,k);   \n            else if(sumn + 1 <= k)\n                return sum[ls[nown]] + query(rs[nown],mid+1,r,k-sumn);\n        }\n    }\n}\n\n\nint n,m,totn,maxt,rt[MAXN];\nvector<int> qq[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    maxt = n;\n    for(int i = 1;i<=n;i++){\n        read(a),read(b),read(c);\n        qq[a].push_back(c);\n        qq[b+1].push_back(-c);\n        maxt = max(maxt,b+1);\n        S[c] = 0;\n    }\n    for(auto it = S.begin();it!=S.end();it++){\n        it->second = ++totn;\n        last[totn] = it->first;\n    }\n    for(int i = 1;i<=maxt;i++){\n        rt[i] = rt[i-1];\n        for(int j = 0;j<qq[i].size();j++){\n            prSegTree::insert(rt[i],rt[i],1,totn,(S[abs(qq[i][j])]),qq[i][j] > 0? 1 : -1);\n        }\n    }\n}\n\nvoid solve(){\n    ll last = 1,ans;\n    int x,k,a,b,c;\n    for(int i = 1;i<=m;i++){\n        read(x),read(a),read(b),read(c);\n        k = 1+(a*last+b)%c;\n        ans = prSegTree::query(rt[x],1,totn,k);\n        printf(\"%lld\\n\",ans);\n        last = ans;\n    }\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「CQOI2015」任务查询系统-可持久化线段树","published":1,"updated":"2018-05-16T13:36:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ic0027bljrrs1jbjar","content":"<p>超级计算机中的任务用三元组$(S_i,E_i,P_i)$描述，$(S_i,E_i,P_i)$表示任务运行区间为$[S_i,E_i]$,其优先级为$P_i$。</p>\n<p>给出$n$个任务。随后给出$m$个询问，第$X_i$秒正在运行的任务中，优先级最小的$K_i$个任务的优先级之和是多少。特别的，如果$K_i$大于第$X_i$秒正在运行的任务总数，则直接回答第$X_i$秒正在运行的任务优先级之和。</p>\n<p>强制在线。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3168\" target=\"_blank\" rel=\"noopener\">Luogu P3128</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>注意到这个问题主要就是区间的权值修改，以及单点的求和（求值），我们可以采用差分的办法。</p>\n<p>\b首先对任务离线后分成$(S_i,P_i,1)$，$(E_i+1,P_i,-1)$两个修改，排序后\b扫一遍进行修改。</p>\n<p>查询第$X_i$秒的时候，我们注意到我们\b每个时间所对应的线段树\b其实就是\b差分的前缀和，所以我们直接在第$X_i$个线段树上求前$K_i$个数的和就好了。注意在叶子结点需要分类讨论，看\b叶子结点有没有取全。</p>\n<p>数据范围很大（？），需要离散化，这里用了map。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">200000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; S;<span class=\"keyword\">int</span> last[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> prSegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val[MAXN*<span class=\"number\">50</span>],ls[MAXN*<span class=\"number\">50</span>],rs[MAXN*<span class=\"number\">50</span>];</span><br><span class=\"line\">    ll sum[MAXN*<span class=\"number\">50</span>];<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        val[nown] = val[ls[nown]] + val[rs[nown]];</span><br><span class=\"line\">        sum[nown] = sum[ls[nown]] + sum[rs[nown]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];</span><br><span class=\"line\">        val[nown]=val[pre]+d,sum[nown]=sum[pre]+<span class=\"number\">1l</span>l * d * last[pos];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos &lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= pos) insert(rs[nown],rs[pre],mid+<span class=\"number\">1</span>,r,pos,d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k&gt;=val[nown]) <span class=\"keyword\">return</span> sum[nown];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> k * last[l];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sumn = val[ls[nown]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k &lt;= sumn)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> query(ls[nown],l,mid,k);   </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sumn + <span class=\"number\">1</span> &lt;= k)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum[ls[nown]] + query(rs[nown],mid+<span class=\"number\">1</span>,r,k-sumn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,totn,maxt,rt[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; qq[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    maxt = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        qq[a].push_back(c);</span><br><span class=\"line\">        qq[b+<span class=\"number\">1</span>].push_back(-c);</span><br><span class=\"line\">        maxt = max(maxt,b+<span class=\"number\">1</span>);</span><br><span class=\"line\">        S[c] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = S.begin();it!=S.end();it++)&#123;</span><br><span class=\"line\">        it-&gt;second = ++totn;</span><br><span class=\"line\">        last[totn] = it-&gt;first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=maxt;i++)&#123;</span><br><span class=\"line\">        rt[i] = rt[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;qq[i].size();j++)&#123;</span><br><span class=\"line\">            prSegTree::insert(rt[i],rt[i],<span class=\"number\">1</span>,totn,(S[<span class=\"built_in\">abs</span>(qq[i][j])]),qq[i][j] &gt; <span class=\"number\">0</span>? <span class=\"number\">1</span> : <span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll last = <span class=\"number\">1</span>,ans;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,k,a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(x),read(a),read(b),read(c);</span><br><span class=\"line\">        k = <span class=\"number\">1</span>+(a*last+b)%c;</span><br><span class=\"line\">        ans = prSegTree::query(rt[x],<span class=\"number\">1</span>,totn,k);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">        last = ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>超级计算机中的任务用三元组$(S_i,E_i,P_i)$描述，$(S_i,E_i,P_i)$表示任务运行区间为$[S_i,E_i]$,其优先级为$P_i$。</p>\n<p>给出$n$个任务。随后给出$m$个询问，第$X_i$秒正在运行的任务中，优先级最小的$K_i$个任务的优先级之和是多少。特别的，如果$K_i$大于第$X_i$秒正在运行的任务总数，则直接回答第$X_i$秒正在运行的任务优先级之和。</p>\n<p>强制在线。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3168\" target=\"_blank\" rel=\"noopener\">Luogu P3128</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>注意到这个问题主要就是区间的权值修改，以及单点的求和（求值），我们可以采用差分的办法。</p>\n<p>\b首先对任务离线后分成$(S_i,P_i,1)$，$(E_i+1,P_i,-1)$两个修改，排序后\b扫一遍进行修改。</p>\n<p>查询第$X_i$秒的时候，我们注意到我们\b每个时间所对应的线段树\b其实就是\b差分的前缀和，所以我们直接在第$X_i$个线段树上求前$K_i$个数的和就好了。注意在叶子结点需要分类讨论，看\b叶子结点有没有取全。</p>\n<p>数据范围很大（？），需要离散化，这里用了map。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�22-->\n\n</div></div>"},{"title":"「CQOI2016」手机号码-数位dp","urlname":"CQOI2016-phone","date":"2018-06-19T13:59:36.000Z","visible":null,"_content":"\n手机号码是一个有 $11$ 位且不含前导 $0$ 的数。满足条件手机号码的必须**同时**满足：号码中出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$ 。\n\n给定两个数 $L$ 和 $R$ ，统计出 $[L,R]$区间内所有满足条件的手机号码的个数。 $L$ 和 $R$ 都是符合定义的手机号码。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4124](https://www.luogu.org/problemnew/show/P4124)\n\n## 题解\n\n这个题用数位dp其实也可以递推。\n\n定义一个状态$dp[i][j][num][is8][is4]$，其中$i$代表需要考虑的是后$i$位；$j$表示倒数第$i+1$位是数码$j$；$num$表示目前的连号是几个（$num = 1,2$），若这个为$3$则代表已经出现了连着三位相同的数字；最后两维分别表示有没有出现$8$和有没有出现$4$。状态储存的值就是符合条件的数的个数。\n\n边界情况就是在 $i == 0$ 的时候。只有 `num == 3` 且 `is8 && is4 == 0` 时，边界才能得 $1$ ；否则就得 $0$ 。\n\n其次转移就好了。枚举下一个数位从 $0$ 到 $9$ ，然后根据新的数位计算出 $num$ ， $is8$ ， $is4$ 等信息，转移就可以了。这里的 $num$ 如果已经为 $3$ ，就算与上一位相同，我们也不再往上加了；如果不是3的话才往上加。\n\n注意在计算状态的时候，要把所有 `is8 && is4 == 1` 的情况全都置作$0$。\n\n- - -\n\n计算答案的话，就按照普通数位dp的统计方式去统计就可以了：把每一位都拆下来，在每一位都取到所有比这一位小的数，最后再加上最后一个数的情况。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\nusing namespace std;\n#define ll long long \n\nconst int MAXN = 12;\n\nll x,y;\nll dp[MAXN][MAXN][4][2][2];\n//dp[i][j][num][is8][is4];\n//后i位，上一个数字是j，连续出现了num个数，有没有出现8，有没有出现4\n\nvoid init(){\n    scanf(\"%lld %lld\",&x,&y);\n}\n\nvoid solve(){\n    for(int i = 0;i<=11;i++)\n    for(int j = 0;j<=9;j++)\n    for(int num = 1;num<=3;num++)\n    for(int is8 = 0;is8<=1;is8++)\n        for(int is4 = 0;is4<=1;is4++){\n            ll &t = dp[i][j][num][is8][is4];\n            if(i == 0)\n                t = (num==3?1:0);// 边界的判定\n            else for(int w = 0;w<=9;w++){\n                t += dp[i-1][w][num==3?3:w==j?num+1:1][is8||(w==8)][is4||(w==4)];\n            if(is8 && is4)\n                t = 0;\n        }\n    }\n}\n\nll cal(ll x){\n    if (x < 1e10) return 0;\n    int d[20],cnt = 0;\n    while(t) d[++cnt] = x%10,x/=10;\n    d[cnt+1] = 0;\n    ll ans = 0;int num = 0,is8 = 0,is4 = 0;\n    for(int i = cnt;i>=1;--i){\n        for(int j = 0;j<d[i];j++)\n            ans += dp[i-1][j][num==3?3:d[i+1]==j?num+1:1][(j==8)||is8][(j==4)||is4];\n        // 该位小于限定数\n\t\tnum = (num == 3?3:d[i]==d[i+1]?num+1:1);\n        is8 |= d[i] == 8;\n        is4 |= d[i] == 4;\n    }\n    ans -= dp[10][0][1][0][0];//减去存在前缀0的情况\n    ans += dp[0][d[1]][num][is8][is4];\n    return ans;\n}\n\nvoid getans(){\n    ll ans = cal(y)-cal(x-1);\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    getans();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「CQOI2016」手机号码-数位dp.md","raw":"---\ntitle: 「CQOI2016」手机号码-数位dp\nurlname: CQOI2016-phone\ndate: 2018-06-19 21:59:36\ntags:\n- 题解\n- 数位dp\n- 动态规划\ncategories: OI\nvisible:\n---\n\n手机号码是一个有 $11$ 位且不含前导 $0$ 的数。满足条件手机号码的必须**同时**满足：号码中出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$ 。\n\n给定两个数 $L$ 和 $R$ ，统计出 $[L,R]$区间内所有满足条件的手机号码的个数。 $L$ 和 $R$ 都是符合定义的手机号码。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4124](https://www.luogu.org/problemnew/show/P4124)\n\n## 题解\n\n这个题用数位dp其实也可以递推。\n\n定义一个状态$dp[i][j][num][is8][is4]$，其中$i$代表需要考虑的是后$i$位；$j$表示倒数第$i+1$位是数码$j$；$num$表示目前的连号是几个（$num = 1,2$），若这个为$3$则代表已经出现了连着三位相同的数字；最后两维分别表示有没有出现$8$和有没有出现$4$。状态储存的值就是符合条件的数的个数。\n\n边界情况就是在 $i == 0$ 的时候。只有 `num == 3` 且 `is8 && is4 == 0` 时，边界才能得 $1$ ；否则就得 $0$ 。\n\n其次转移就好了。枚举下一个数位从 $0$ 到 $9$ ，然后根据新的数位计算出 $num$ ， $is8$ ， $is4$ 等信息，转移就可以了。这里的 $num$ 如果已经为 $3$ ，就算与上一位相同，我们也不再往上加了；如果不是3的话才往上加。\n\n注意在计算状态的时候，要把所有 `is8 && is4 == 1` 的情况全都置作$0$。\n\n- - -\n\n计算答案的话，就按照普通数位dp的统计方式去统计就可以了：把每一位都拆下来，在每一位都取到所有比这一位小的数，最后再加上最后一个数的情况。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\nusing namespace std;\n#define ll long long \n\nconst int MAXN = 12;\n\nll x,y;\nll dp[MAXN][MAXN][4][2][2];\n//dp[i][j][num][is8][is4];\n//后i位，上一个数字是j，连续出现了num个数，有没有出现8，有没有出现4\n\nvoid init(){\n    scanf(\"%lld %lld\",&x,&y);\n}\n\nvoid solve(){\n    for(int i = 0;i<=11;i++)\n    for(int j = 0;j<=9;j++)\n    for(int num = 1;num<=3;num++)\n    for(int is8 = 0;is8<=1;is8++)\n        for(int is4 = 0;is4<=1;is4++){\n            ll &t = dp[i][j][num][is8][is4];\n            if(i == 0)\n                t = (num==3?1:0);// 边界的判定\n            else for(int w = 0;w<=9;w++){\n                t += dp[i-1][w][num==3?3:w==j?num+1:1][is8||(w==8)][is4||(w==4)];\n            if(is8 && is4)\n                t = 0;\n        }\n    }\n}\n\nll cal(ll x){\n    if (x < 1e10) return 0;\n    int d[20],cnt = 0;\n    while(t) d[++cnt] = x%10,x/=10;\n    d[cnt+1] = 0;\n    ll ans = 0;int num = 0,is8 = 0,is4 = 0;\n    for(int i = cnt;i>=1;--i){\n        for(int j = 0;j<d[i];j++)\n            ans += dp[i-1][j][num==3?3:d[i+1]==j?num+1:1][(j==8)||is8][(j==4)||is4];\n        // 该位小于限定数\n\t\tnum = (num == 3?3:d[i]==d[i+1]?num+1:1);\n        is8 |= d[i] == 8;\n        is4 |= d[i] == 4;\n    }\n    ans -= dp[10][0][1][0][0];//减去存在前缀0的情况\n    ans += dp[0][d[1]][num][is8][is4];\n    return ans;\n}\n\nvoid getans(){\n    ll ans = cal(y)-cal(x-1);\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    getans();\n    return 0;\n}\n```\n{% endfold %}","slug":"「CQOI2016」手机号码-数位dp","published":1,"updated":"2018-06-19T15:03:44.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ie002abljrfiipcorj","content":"<p>手机号码是一个有 $11$ 位且不含前导 $0$ 的数。满足条件手机号码的必须<strong>同时</strong>满足：号码中出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$ 。</p>\n<p>给定两个数 $L$ 和 $R$ ，统计出 $[L,R]$区间内所有满足条件的手机号码的个数。 $L$ 和 $R$ 都是符合定义的手机号码。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4124\" target=\"_blank\" rel=\"noopener\">Luogu P4124</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这个题用数位dp其实也可以递推。</p>\n<p>定义一个状态$dp[i][j][num][is8][is4]$，其中$i$代表需要考虑的是后$i$位；$j$表示倒数第$i+1$位是数码$j$；$num$表示目前的连号是几个（$num = 1,2$），若这个为$3$则代表已经出现了连着三位相同的数字；最后两维分别表示有没有出现$8$和有没有出现$4$。状态储存的值就是符合条件的数的个数。</p>\n<p>边界情况就是在 $i == 0$ 的时候。只有 <code>num == 3</code> 且 <code>is8 &amp;&amp; is4 == 0</code> 时，边界才能得 $1$ ；否则就得 $0$ 。</p>\n<p>其次转移就好了。枚举下一个数位从 $0$ 到 $9$ ，然后根据新的数位计算出 $num$ ， $is8$ ， $is4$ 等信息，转移就可以了。这里的 $num$ 如果已经为 $3$ ，就算与上一位相同，我们也不再往上加了；如果不是3的话才往上加。</p>\n<p>注意在计算状态的时候，要把所有 <code>is8 &amp;&amp; is4 == 1</code> 的情况全都置作$0$。</p>\n<hr>\n<p>计算答案的话，就按照普通数位dp的统计方式去统计就可以了：把每一位都拆下来，在每一位都取到所有比这一位小的数，最后再加上最后一个数的情况。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">12</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ll x,y;</span><br><span class=\"line\">ll dp[MAXN][MAXN][<span class=\"number\">4</span>][<span class=\"number\">2</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">//dp[i][j][num][is8][is4];</span></span><br><span class=\"line\"><span class=\"comment\">//后i位，上一个数字是j，连续出现了num个数，有没有出现8，有没有出现4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>,&amp;x,&amp;y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=<span class=\"number\">11</span>;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;=<span class=\"number\">9</span>;j++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num = <span class=\"number\">1</span>;num&lt;=<span class=\"number\">3</span>;num++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> is8 = <span class=\"number\">0</span>;is8&lt;=<span class=\"number\">1</span>;is8++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> is4 = <span class=\"number\">0</span>;is4&lt;=<span class=\"number\">1</span>;is4++)&#123;</span><br><span class=\"line\">            ll &amp;t = dp[i][j][num][is8][is4];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>)</span><br><span class=\"line\">                t = (num==<span class=\"number\">3</span>?<span class=\"number\">1</span>:<span class=\"number\">0</span>);<span class=\"comment\">// 边界的判定</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> w = <span class=\"number\">0</span>;w&lt;=<span class=\"number\">9</span>;w++)&#123;</span><br><span class=\"line\">                t += dp[i<span class=\"number\">-1</span>][w][num==<span class=\"number\">3</span>?<span class=\"number\">3</span>:w==j?num+<span class=\"number\">1</span>:<span class=\"number\">1</span>][is8||(w==<span class=\"number\">8</span>)][is4||(w==<span class=\"number\">4</span>)];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(is8 &amp;&amp; is4)</span><br><span class=\"line\">                t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">cal</span><span class=\"params\">(ll x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">1e10</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d[<span class=\"number\">20</span>],cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t) d[++cnt] = x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    d[cnt+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>,is8 = <span class=\"number\">0</span>,is4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = cnt;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;d[i];j++)</span><br><span class=\"line\">            ans += dp[i<span class=\"number\">-1</span>][j][num==<span class=\"number\">3</span>?<span class=\"number\">3</span>:d[i+<span class=\"number\">1</span>]==j?num+<span class=\"number\">1</span>:<span class=\"number\">1</span>][(j==<span class=\"number\">8</span>)||is8][(j==<span class=\"number\">4</span>)||is4];</span><br><span class=\"line\">        <span class=\"comment\">// 该位小于限定数</span></span><br><span class=\"line\">\t\tnum = (num == <span class=\"number\">3</span>?<span class=\"number\">3</span>:d[i]==d[i+<span class=\"number\">1</span>]?num+<span class=\"number\">1</span>:<span class=\"number\">1</span>);</span><br><span class=\"line\">        is8 |= d[i] == <span class=\"number\">8</span>;</span><br><span class=\"line\">        is4 |= d[i] == <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans -= dp[<span class=\"number\">10</span>][<span class=\"number\">0</span>][<span class=\"number\">1</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>];<span class=\"comment\">//减去存在前缀0的情况</span></span><br><span class=\"line\">    ans += dp[<span class=\"number\">0</span>][d[<span class=\"number\">1</span>]][num][is8][is4];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getans</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll ans = cal(y)-cal(x<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    getans();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>手机号码是一个有 $11$ 位且不含前导 $0$ 的数。满足条件手机号码的必须<strong>同时</strong>满足：号码中出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$ 。</p>\n<p>给定两个数 $L$ 和 $R$ ，统计出 $[L,R]$区间内所有满足条件的手机号码的个数。 $L$ 和 $R$ 都是符合定义的手机号码。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4124\" target=\"_blank\" rel=\"noopener\">Luogu P4124</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这个题用数位dp其实也可以递推。</p>\n<p>定义一个状态$dp[i][j][num][is8][is4]$，其中$i$代表需要考虑的是后$i$位；$j$表示倒数第$i+1$位是数码$j$；$num$表示目前的连号是几个（$num = 1,2$），若这个为$3$则代表已经出现了连着三位相同的数字；最后两维分别表示有没有出现$8$和有没有出现$4$。状态储存的值就是符合条件的数的个数。</p>\n<p>边界情况就是在 $i == 0$ 的时候。只有 <code>num == 3</code> 且 <code>is8 &amp;&amp; is4 == 0</code> 时，边界才能得 $1$ ；否则就得 $0$ 。</p>\n<p>其次转移就好了。枚举下一个数位从 $0$ 到 $9$ ，然后根据新的数位计算出 $num$ ， $is8$ ， $is4$ 等信息，转移就可以了。这里的 $num$ 如果已经为 $3$ ，就算与上一位相同，我们也不再往上加了；如果不是3的话才往上加。</p>\n<p>注意在计算状态的时候，要把所有 <code>is8 &amp;&amp; is4 == 1</code> 的情况全都置作$0$。</p>\n<hr>\n<p>计算答案的话，就按照普通数位dp的统计方式去统计就可以了：把每一位都拆下来，在每一位都取到所有比这一位小的数，最后再加上最后一个数的情况。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�23-->\n\n</div></div>"},{"title":"「HAOI2007」理想的正方形-单调队列","urlname":"HAOI2007-square","date":"2018-05-18T10:52:06.000Z","visible":null,"_content":"\n有一个$a \\times b$的整数组成的矩阵，现请你从中找出一个$n\\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小，输出这个最小的差值。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2216](https://www.luogu.org/problemnew/show/P2216)\n\n## 题解\n\n单调队列的一道有趣的题。\n\n事实上我们可以发现，需要找出的区域是正方形，而且大小固定，所以我们可以想到用单调队列来解决这个问题。\n\n但这个问题是二维的，怎么把单调队列转化成二维的呢？\n\n可以这么考虑。用$a$个单调队列维护 **每一行**在$[j-n+1,j]$的位置中的最大值和最小值。\n\n每次我们计算正方形的最大值或最小值的时候，对于这$a$个单调队列中的最大值或者最小值，我们新开一个单调队列，其中维护在$a$个单调队列中$[i-n+1,i]$这个范围里的最大值或者最小值。然后就可以用最大值减去最小值，并尝试更新答案。\n\n可以证明，复杂度是$O(n^2)$的。\n\n实在偷懒，单调队列用了$deque$，不开`O2`极慢。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <algorithm>\n#define pp pair<int,int>\nusing namespace std;\n\nconst int MAXN = 1100;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nint n,m,k;\nint num[MAXN][MAXN];\n\ndeque<pp> max1[MAXN],min1[MAXN];\ndeque<pp> max2,min2;\n\nvoid init(){\n    read(n),read(m),read(k);\n    for(int i = 1;i<=n;i++)\n        for(int j = 1;j<=m;j++)\n            read(num[i][j]);\n}\n\n\nvoid solve(){\n    int ans = 0x3f3f3f3f;\n    static int minn[MAXN],maxn[MAXN];\n    int tmin,tmax;\n    for(int i = 1;i<=n;i++){\n        //printf(\"i %d:\\n\",i);\n        for(int j = 1;j<=m;j++){\n            //max\n            while(!max1[j].empty()&&max1[j].begin()->second < num[i][j])\n                max1[j].pop_front();\n            max1[j].emplace_front(i,num[i][j]);\n            while(!max1[j].empty()&&max1[j].rbegin()->first <= i-k)\n                max1[j].pop_back();\n            tmax = max1[j].rbegin()->second;\n            maxn[j] = tmax;\n            //min\n            while(!min1[j].empty()&&min1[j].begin()->second > num[i][j])\n                min1[j].pop_front();\n            min1[j].emplace_front(i,num[i][j]);\n            while(!min1[j].empty()&&min1[j].rbegin()->first <= i-k)\n                min1[j].pop_back();\n            tmin = min1[j].rbegin()->second;\n            minn[j] = tmin;\n        }\n        max2.clear(),min2.clear();\n        for(int j = 1;j<=m;j++){\n            //max\n            while(!max2.empty()&&max2.begin()->second < maxn[j])\n                max2.pop_front();\n            max2.emplace_front(j,maxn[j]);\n            while(!max2.empty()&&max2.rbegin()->first <= j-k)\n                max2.pop_back();\n            tmax = max2.rbegin()->second;\n            //min\n            while(!min2.empty()&&min2.begin()->second > minn[j])\n                min2.pop_front();\n            min2.emplace_front(j,minn[j]);\n            while(!min2.empty()&&min2.rbegin()->first <= j-k)\n                min2.pop_back();\n            tmin = min2.rbegin()->second;\n            if(i>=k && j>=k)//保证解合法\n                ans = min(tmax-tmin,ans);\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「HAOI2007」理想的正方形-单调队列.md","raw":"---\ntitle: 「HAOI2007」理想的正方形-单调队列\nurlname: HAOI2007-square\ndate: 2018-05-18 18:52:06\ntags:\n- 题解\n- 单调队列\n- 数据结构\ncategories: OI\nvisible:\n---\n\n有一个$a \\times b$的整数组成的矩阵，现请你从中找出一个$n\\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小，输出这个最小的差值。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2216](https://www.luogu.org/problemnew/show/P2216)\n\n## 题解\n\n单调队列的一道有趣的题。\n\n事实上我们可以发现，需要找出的区域是正方形，而且大小固定，所以我们可以想到用单调队列来解决这个问题。\n\n但这个问题是二维的，怎么把单调队列转化成二维的呢？\n\n可以这么考虑。用$a$个单调队列维护 **每一行**在$[j-n+1,j]$的位置中的最大值和最小值。\n\n每次我们计算正方形的最大值或最小值的时候，对于这$a$个单调队列中的最大值或者最小值，我们新开一个单调队列，其中维护在$a$个单调队列中$[i-n+1,i]$这个范围里的最大值或者最小值。然后就可以用最大值减去最小值，并尝试更新答案。\n\n可以证明，复杂度是$O(n^2)$的。\n\n实在偷懒，单调队列用了$deque$，不开`O2`极慢。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <algorithm>\n#define pp pair<int,int>\nusing namespace std;\n\nconst int MAXN = 1100;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nint n,m,k;\nint num[MAXN][MAXN];\n\ndeque<pp> max1[MAXN],min1[MAXN];\ndeque<pp> max2,min2;\n\nvoid init(){\n    read(n),read(m),read(k);\n    for(int i = 1;i<=n;i++)\n        for(int j = 1;j<=m;j++)\n            read(num[i][j]);\n}\n\n\nvoid solve(){\n    int ans = 0x3f3f3f3f;\n    static int minn[MAXN],maxn[MAXN];\n    int tmin,tmax;\n    for(int i = 1;i<=n;i++){\n        //printf(\"i %d:\\n\",i);\n        for(int j = 1;j<=m;j++){\n            //max\n            while(!max1[j].empty()&&max1[j].begin()->second < num[i][j])\n                max1[j].pop_front();\n            max1[j].emplace_front(i,num[i][j]);\n            while(!max1[j].empty()&&max1[j].rbegin()->first <= i-k)\n                max1[j].pop_back();\n            tmax = max1[j].rbegin()->second;\n            maxn[j] = tmax;\n            //min\n            while(!min1[j].empty()&&min1[j].begin()->second > num[i][j])\n                min1[j].pop_front();\n            min1[j].emplace_front(i,num[i][j]);\n            while(!min1[j].empty()&&min1[j].rbegin()->first <= i-k)\n                min1[j].pop_back();\n            tmin = min1[j].rbegin()->second;\n            minn[j] = tmin;\n        }\n        max2.clear(),min2.clear();\n        for(int j = 1;j<=m;j++){\n            //max\n            while(!max2.empty()&&max2.begin()->second < maxn[j])\n                max2.pop_front();\n            max2.emplace_front(j,maxn[j]);\n            while(!max2.empty()&&max2.rbegin()->first <= j-k)\n                max2.pop_back();\n            tmax = max2.rbegin()->second;\n            //min\n            while(!min2.empty()&&min2.begin()->second > minn[j])\n                min2.pop_front();\n            min2.emplace_front(j,minn[j]);\n            while(!min2.empty()&&min2.rbegin()->first <= j-k)\n                min2.pop_back();\n            tmin = min2.rbegin()->second;\n            if(i>=k && j>=k)//保证解合法\n                ans = min(tmax-tmin,ans);\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","slug":"「HAOI2007」理想的正方形-单调队列","published":1,"updated":"2018-05-18T11:53:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ih002ebljrp96agzak","content":"<p>有一个$a \\times b$的整数组成的矩阵，现请你从中找出一个$n\\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小，输出这个最小的差值。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2216\" target=\"_blank\" rel=\"noopener\">Luogu P2216</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>单调队列的一道有趣的题。</p>\n<p>事实上我们可以发现，需要找出的区域是正方形，而且大小固定，所以我们可以想到用单调队列来解决这个问题。</p>\n<p>但这个问题是二维的，怎么把单调队列转化成二维的呢？</p>\n<p>可以这么考虑。用$a$个单调队列维护 <strong>每一行</strong>在$[j-n+1,j]$的位置中的最大值和最小值。</p>\n<p>每次我们计算正方形的最大值或最小值的时候，对于这$a$个单调队列中的最大值或者最小值，我们新开一个单调队列，其中维护在$a$个单调队列中$[i-n+1,i]$这个范围里的最大值或者最小值。然后就可以用最大值减去最小值，并尝试更新答案。</p>\n<p>可以证明，复杂度是$O(n^2)$的。</p>\n<p>实在偷懒，单调队列用了$deque$，不开<code>O2</code>极慢。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pp pair<span class=\"meta-string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[MAXN][MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">deque</span>&lt;pp&gt; max1[MAXN],min1[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">deque</span>&lt;pp&gt; max2,min2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m),read(k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)</span><br><span class=\"line\">            read(num[i][j]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> minn[MAXN],maxn[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmin,tmax;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//printf(\"i %d:\\n\",i);</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//max</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!max1[j].empty()&amp;&amp;max1[j].begin()-&gt;second &lt; num[i][j])</span><br><span class=\"line\">                max1[j].pop_front();</span><br><span class=\"line\">            max1[j].emplace_front(i,num[i][j]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!max1[j].empty()&amp;&amp;max1[j].rbegin()-&gt;first &lt;= i-k)</span><br><span class=\"line\">                max1[j].pop_back();</span><br><span class=\"line\">            tmax = max1[j].rbegin()-&gt;second;</span><br><span class=\"line\">            maxn[j] = tmax;</span><br><span class=\"line\">            <span class=\"comment\">//min</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!min1[j].empty()&amp;&amp;min1[j].begin()-&gt;second &gt; num[i][j])</span><br><span class=\"line\">                min1[j].pop_front();</span><br><span class=\"line\">            min1[j].emplace_front(i,num[i][j]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!min1[j].empty()&amp;&amp;min1[j].rbegin()-&gt;first &lt;= i-k)</span><br><span class=\"line\">                min1[j].pop_back();</span><br><span class=\"line\">            tmin = min1[j].rbegin()-&gt;second;</span><br><span class=\"line\">            minn[j] = tmin;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        max2.clear(),min2.clear();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//max</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!max2.empty()&amp;&amp;max2.begin()-&gt;second &lt; maxn[j])</span><br><span class=\"line\">                max2.pop_front();</span><br><span class=\"line\">            max2.emplace_front(j,maxn[j]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!max2.empty()&amp;&amp;max2.rbegin()-&gt;first &lt;= j-k)</span><br><span class=\"line\">                max2.pop_back();</span><br><span class=\"line\">            tmax = max2.rbegin()-&gt;second;</span><br><span class=\"line\">            <span class=\"comment\">//min</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!min2.empty()&amp;&amp;min2.begin()-&gt;second &gt; minn[j])</span><br><span class=\"line\">                min2.pop_front();</span><br><span class=\"line\">            min2.emplace_front(j,minn[j]);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!min2.empty()&amp;&amp;min2.rbegin()-&gt;first &lt;= j-k)</span><br><span class=\"line\">                min2.pop_back();</span><br><span class=\"line\">            tmin = min2.rbegin()-&gt;second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;=k &amp;&amp; j&gt;=k)<span class=\"comment\">//保证解合法</span></span><br><span class=\"line\">                ans = min(tmax-tmin,ans);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>有一个$a \\times b$的整数组成的矩阵，现请你从中找出一个$n\\times n$的正方形区域，使得该区域所有数中的最大值和最小值的差最小，输出这个最小的差值。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2216\" target=\"_blank\" rel=\"noopener\">Luogu P2216</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>单调队列的一道有趣的题。</p>\n<p>事实上我们可以发现，需要找出的区域是正方形，而且大小固定，所以我们可以想到用单调队列来解决这个问题。</p>\n<p>但这个问题是二维的，怎么把单调队列转化成二维的呢？</p>\n<p>可以这么考虑。用$a$个单调队列维护 <strong>每一行</strong>在$[j-n+1,j]$的位置中的最大值和最小值。</p>\n<p>每次我们计算正方形的最大值或最小值的时候，对于这$a$个单调队列中的最大值或者最小值，我们新开一个单调队列，其中维护在$a$个单调队列中$[i-n+1,i]$这个范围里的最大值或者最小值。然后就可以用最大值减去最小值，并尝试更新答案。</p>\n<p>可以证明，复杂度是$O(n^2)$的。</p>\n<p>实在偷懒，单调队列用了$deque$，不开<code>O2</code>极慢。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�24-->\n\n</div></div>"},{"title":"「HAOI2009」毛毛虫-树形dp","urlname":"HAOI2009-worm","date":"2018-06-06T11:08:55.000Z","visible":null,"_content":"\n对于一棵树，我们可以将某条链和与该链相连的边抽出来，称其为一个“毛毛虫”。求在这个树中点数最多的毛毛虫的点数。\n\n$n < 300000$\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3174](https://www.luogu.org/problemnew/show/P3174)\n\n\n## 题解\n\n很简单的一道$dp$题（感觉这个东西像一个$faKe$的$dp$）...\n\n随便找一个根，记录$in[x]$为$x$节点的度，令$d[x]$为从$x$节点向下最长的毛毛虫的边数（含$x$连向其他儿子及其连向父节点的边）。\n\n状态转移方程：\n\n$d[x] = \\max(d[v]) + in[x]$\n\n统计答案的时候，在$dfs$过程中，我们记录其子树里面的最大的两个$d$，最后更新$ans = max(ans,d + d' + in[x])$。\n\n最后给ans+1。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 310000;\n\nvector<int> edge[MAXN];\nint n,m,d[MAXN],in[MAXN],ans = 0;\n\nvoid dfs(int nown,int fa){\n    //d[nown] -> 从nown往下走的最大毛毛虫\n    int maxa = 0,maxb = -0x3f3f3f3f;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa) continue;\n        dfs(v,nown);\n        d[nown] = max(d[nown],d[v]);\n        if(d[v] >= maxa)\n            maxb = maxa,maxa = d[v];\n        else if(d[v] >= maxb)\n            maxb = d[v];\n    }\n    ans = max(ans,maxa+maxb+in[nown]);\n    d[nown] += in[nown]-1;\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n        in[a]++;in[b]++;\n    }\n}\n\n\nvoid solve(){\n    dfs(1,0);\n    printf(\"%d\\n\",ans+1);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「HAOI2009」毛毛虫-树形dp.md","raw":"---\ntitle: 「HAOI2009」毛毛虫-树形dp\nurlname: HAOI2009-worm\ndate: 2018-06-06 19:08:55\ntags:\n- 题解\n- 树形dp\n- 动态规划\ncategories: OI\nvisible:\n---\n\n对于一棵树，我们可以将某条链和与该链相连的边抽出来，称其为一个“毛毛虫”。求在这个树中点数最多的毛毛虫的点数。\n\n$n < 300000$\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3174](https://www.luogu.org/problemnew/show/P3174)\n\n\n## 题解\n\n很简单的一道$dp$题（感觉这个东西像一个$faKe$的$dp$）...\n\n随便找一个根，记录$in[x]$为$x$节点的度，令$d[x]$为从$x$节点向下最长的毛毛虫的边数（含$x$连向其他儿子及其连向父节点的边）。\n\n状态转移方程：\n\n$d[x] = \\max(d[v]) + in[x]$\n\n统计答案的时候，在$dfs$过程中，我们记录其子树里面的最大的两个$d$，最后更新$ans = max(ans,d + d' + in[x])$。\n\n最后给ans+1。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 310000;\n\nvector<int> edge[MAXN];\nint n,m,d[MAXN],in[MAXN],ans = 0;\n\nvoid dfs(int nown,int fa){\n    //d[nown] -> 从nown往下走的最大毛毛虫\n    int maxa = 0,maxb = -0x3f3f3f3f;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa) continue;\n        dfs(v,nown);\n        d[nown] = max(d[nown],d[v]);\n        if(d[v] >= maxa)\n            maxb = maxa,maxa = d[v];\n        else if(d[v] >= maxb)\n            maxb = d[v];\n    }\n    ans = max(ans,maxa+maxb+in[nown]);\n    d[nown] += in[nown]-1;\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n        in[a]++;in[b]++;\n    }\n}\n\n\nvoid solve(){\n    dfs(1,0);\n    printf(\"%d\\n\",ans+1);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","slug":"「HAOI2009」毛毛虫-树形dp","published":1,"updated":"2018-06-07T15:02:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3il002hbljrn2fwn8nx","content":"<p>对于一棵树，我们可以将某条链和与该链相连的边抽出来，称其为一个“毛毛虫”。求在这个树中点数最多的毛毛虫的点数。</p>\n<p>$n &lt; 300000$</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3174\" target=\"_blank\" rel=\"noopener\">Luogu P3174</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很简单的一道$dp$题（感觉这个东西像一个$faKe$的$dp$）…</p>\n<p>随便找一个根，记录$in[x]$为$x$节点的度，令$d[x]$为从$x$节点向下最长的毛毛虫的边数（含$x$连向其他儿子及其连向父节点的边）。</p>\n<p>状态转移方程：</p>\n<p>$d[x] = \\max(d[v]) + in[x]$</p>\n<p>统计答案的时候，在$dfs$过程中，我们记录其子树里面的最大的两个$d$，最后更新$ans = max(ans,d + d’ + in[x])$。</p>\n<p>最后给ans+1。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">310000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,d[MAXN],in[MAXN],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//d[nown] -&gt; 从nown往下走的最大毛毛虫</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxa = <span class=\"number\">0</span>,maxb = <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs(v,nown);</span><br><span class=\"line\">        d[nown] = max(d[nown],d[v]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(d[v] &gt;= maxa)</span><br><span class=\"line\">            maxb = maxa,maxa = d[v];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(d[v] &gt;= maxb)</span><br><span class=\"line\">            maxb = d[v];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = max(ans,maxa+maxb+in[nown]);</span><br><span class=\"line\">    d[nown] += in[nown]<span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        edge[a].push_back(b);</span><br><span class=\"line\">        edge[b].push_back(a);</span><br><span class=\"line\">        in[a]++;in[b]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans+<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>对于一棵树，我们可以将某条链和与该链相连的边抽出来，称其为一个“毛毛虫”。求在这个树中点数最多的毛毛虫的点数。</p>\n<p>$n &lt; 300000$</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3174\" target=\"_blank\" rel=\"noopener\">Luogu P3174</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很简单的一道$dp$题（感觉这个东西像一个$faKe$的$dp$）…</p>\n<p>随便找一个根，记录$in[x]$为$x$节点的度，令$d[x]$为从$x$节点向下最长的毛毛虫的边数（含$x$连向其他儿子及其连向父节点的边）。</p>\n<p>状态转移方程：</p>\n<p>$d[x] = \\max(d[v]) + in[x]$</p>\n<p>统计答案的时候，在$dfs$过程中，我们记录其子树里面的最大的两个$d$，最后更新$ans = max(ans,d + d’ + in[x])$。</p>\n<p>最后给ans+1。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�25-->\n\n</div></div>"},{"title":"「HNOI2009」梦幻布丁-set-启发式合并","urlname":"HNOI2009-pudding","date":"2018-05-21T12:08:18.000Z","visible":null,"_content":"\n$n$个布丁摆成一行，每个布丁最开始都有一个颜色$c_i$，进行$m$次操作。\n\n操作格式：\n\n+ `1 c d`表示将所有的$c$颜色替换为$d$\n\n+ `2`代表查询当前布丁序列一共有多少段颜色。例如颜色分别为$1,2,2,1$的四个布丁一共有3段颜色。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3201](https://www.luogu.org/problemnew/show/P3201)\n\n## 题解\n\n这题非常有趣。开始想倒是像以前做过的{% post_link [SDOI2011]染色 「SDOI2011」染色-树链剖分+线段树 %} ，不过仔细想想这个东西很难用线段树进行维护。\n\n~~由于这道题放在平衡树的专题里~~，我们思考一下这个东西能不能用平衡树维护。\n\n重点需要解决的问题是如何合并两种颜色（因为颜色段肯定是单调递减的）。我们可以想到使用平衡树的启发式合并。合并的时候更新答案的情况只有当前这个位置的$pos-1$或者$pos+1$的位置有相同颜色的位置的时候，我们都需要对答案减去1。\n\n启发式合并可以让复杂度降低一个$log$，最后时间复杂度就是$O(n \\log^2{n})$。最坏情况就是每次合并的区间大小都相等的情况，合并起来的次数$O(n \\log {n})$。\n\n有$O(n \\log{n})$的奇怪做法，具体我也就不会了。\n\n具体实现上，可以维护一个数组记录当前某个数对应的`set`位置，就可以减去一些不必要消耗。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 1100000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nint n,m,ans = 0;\nint num[MAXN],re[MAXN];\nset<int> S[MAXN];\n\nvoid update(int last,int now){\n    for(set<int>::iterator it = S[last].begin();it!=S[last].end();it++){\n        if(num[(*it)-1] == (now)) \n            ans--;\n        if(num[(*it)+1] == (now))\n            ans--;\n        S[now].insert(*it);\n    }\n    for(set<int>::iterator it = S[last].begin();it!=S[last].end();it++)\n        num[*it] = now;\n    S[last].clear();\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        if(num[i]!=num[i-1]) ans++;\n        S[num[i]].insert(i);\n        re[num[i]] = num[i];\n    }\n}\n\nvoid solve(){\n    int op,a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);\n        if(op == 1){\n            read(a),read(b);\n            if(a == b) continue;//很重要！\n            if(S[re[a]].size() > S[re[b]].size()) swap(re[a],re[b]);\n            update(re[a],re[b]);\n        }\n        else if(op == 2){\n            print(ans),print('\\n');\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「HNOI2009」梦幻布丁-set-启发式合并.md","raw":"---\ntitle: 「HNOI2009」梦幻布丁-set-启发式合并\nurlname: HNOI2009-pudding\ndate: 2018-05-21 20:08:18\ntags:\n- 题解\n- 启发式合并\n- set\n- 平衡树\ncategories: OI\nvisible:\n---\n\n$n$个布丁摆成一行，每个布丁最开始都有一个颜色$c_i$，进行$m$次操作。\n\n操作格式：\n\n+ `1 c d`表示将所有的$c$颜色替换为$d$\n\n+ `2`代表查询当前布丁序列一共有多少段颜色。例如颜色分别为$1,2,2,1$的四个布丁一共有3段颜色。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3201](https://www.luogu.org/problemnew/show/P3201)\n\n## 题解\n\n这题非常有趣。开始想倒是像以前做过的{% post_link [SDOI2011]染色 「SDOI2011」染色-树链剖分+线段树 %} ，不过仔细想想这个东西很难用线段树进行维护。\n\n~~由于这道题放在平衡树的专题里~~，我们思考一下这个东西能不能用平衡树维护。\n\n重点需要解决的问题是如何合并两种颜色（因为颜色段肯定是单调递减的）。我们可以想到使用平衡树的启发式合并。合并的时候更新答案的情况只有当前这个位置的$pos-1$或者$pos+1$的位置有相同颜色的位置的时候，我们都需要对答案减去1。\n\n启发式合并可以让复杂度降低一个$log$，最后时间复杂度就是$O(n \\log^2{n})$。最坏情况就是每次合并的区间大小都相等的情况，合并起来的次数$O(n \\log {n})$。\n\n有$O(n \\log{n})$的奇怪做法，具体我也就不会了。\n\n具体实现上，可以维护一个数组记录当前某个数对应的`set`位置，就可以减去一些不必要消耗。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 1100000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nint n,m,ans = 0;\nint num[MAXN],re[MAXN];\nset<int> S[MAXN];\n\nvoid update(int last,int now){\n    for(set<int>::iterator it = S[last].begin();it!=S[last].end();it++){\n        if(num[(*it)-1] == (now)) \n            ans--;\n        if(num[(*it)+1] == (now))\n            ans--;\n        S[now].insert(*it);\n    }\n    for(set<int>::iterator it = S[last].begin();it!=S[last].end();it++)\n        num[*it] = now;\n    S[last].clear();\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        if(num[i]!=num[i-1]) ans++;\n        S[num[i]].insert(i);\n        re[num[i]] = num[i];\n    }\n}\n\nvoid solve(){\n    int op,a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);\n        if(op == 1){\n            read(a),read(b);\n            if(a == b) continue;//很重要！\n            if(S[re[a]].size() > S[re[b]].size()) swap(re[a],re[b]);\n            update(re[a],re[b]);\n        }\n        else if(op == 2){\n            print(ans),print('\\n');\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「HNOI2009」梦幻布丁-set-启发式合并","published":1,"updated":"2018-05-21T13:10:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3io002lbljr1aa4m6gl","content":"<p>$n$个布丁摆成一行，每个布丁最开始都有一个颜色$c_i$，进行$m$次操作。</p>\n<p>操作格式：</p>\n<ul>\n<li><p><code>1 c d</code>表示将所有的$c$颜色替换为$d$</p>\n</li>\n<li><p><code>2</code>代表查询当前布丁序列一共有多少段颜色。例如颜色分别为$1,2,2,1$的四个布丁一共有3段颜色。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3201\" target=\"_blank\" rel=\"noopener\">Luogu P3201</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题非常有趣。开始想倒是像以前做过的 ，不过仔细想想这个东西很难用线段树进行维护。</p>\n<p><del>由于这道题放在平衡树的专题里</del>，我们思考一下这个东西能不能用平衡树维护。</p>\n<p>重点需要解决的问题是如何合并两种颜色（因为颜色段肯定是单调递减的）。我们可以想到使用平衡树的启发式合并。合并的时候更新答案的情况只有当前这个位置的$pos-1$或者$pos+1$的位置有相同颜色的位置的时候，我们都需要对答案减去1。</p>\n<p>启发式合并可以让复杂度降低一个$log$，最后时间复杂度就是$O(n \\log^2{n})$。最坏情况就是每次合并的区间大小都相等的情况，合并起来的次数$O(n \\log {n})$。</p>\n<p>有$O(n \\log{n})$的奇怪做法，具体我也就不会了。</p>\n<p>具体实现上，可以维护一个数组记录当前某个数对应的<code>set</code>位置，就可以减去一些不必要消耗。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[MAXN],re[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt; S[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = S[last].begin();it!=S[last].end();it++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[(*it)<span class=\"number\">-1</span>] == (now)) </span><br><span class=\"line\">            ans--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[(*it)+<span class=\"number\">1</span>] == (now))</span><br><span class=\"line\">            ans--;</span><br><span class=\"line\">        S[now].insert(*it);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">set</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator it = S[last].begin();it!=S[last].end();it++)</span><br><span class=\"line\">        num[*it] = now;</span><br><span class=\"line\">    S[last].clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[i]!=num[i<span class=\"number\">-1</span>]) ans++;</span><br><span class=\"line\">        S[num[i]].insert(i);</span><br><span class=\"line\">        re[num[i]] = num[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> op,a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            read(a),read(b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a == b) <span class=\"keyword\">continue</span>;<span class=\"comment\">//很重要！</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(S[re[a]].size() &gt; S[re[b]].size()) swap(re[a],re[b]);</span><br><span class=\"line\">            update(re[a],re[b]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            print(ans),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>$n$个布丁摆成一行，每个布丁最开始都有一个颜色$c_i$，进行$m$次操作。</p>\n<p>操作格式：</p>\n<ul>\n<li><p><code>1 c d</code>表示将所有的$c$颜色替换为$d$</p>\n</li>\n<li><p><code>2</code>代表查询当前布丁序列一共有多少段颜色。例如颜色分别为$1,2,2,1$的四个布丁一共有3段颜色。</p>\n</li>\n</ul>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3201\" target=\"_blank\" rel=\"noopener\">Luogu P3201</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题非常有趣。开始想倒是像以前做过的 ，不过仔细想想这个东西很难用线段树进行维护。</p>\n<p><del>由于这道题放在平衡树的专题里</del>，我们思考一下这个东西能不能用平衡树维护。</p>\n<p>重点需要解决的问题是如何合并两种颜色（因为颜色段肯定是单调递减的）。我们可以想到使用平衡树的启发式合并。合并的时候更新答案的情况只有当前这个位置的$pos-1$或者$pos+1$的位置有相同颜色的位置的时候，我们都需要对答案减去1。</p>\n<p>启发式合并可以让复杂度降低一个$log$，最后时间复杂度就是$O(n \\log^2{n})$。最坏情况就是每次合并的区间大小都相等的情况，合并起来的次数$O(n \\log {n})$。</p>\n<p>有$O(n \\log{n})$的奇怪做法，具体我也就不会了。</p>\n<p>具体实现上，可以维护一个数组记录当前某个数对应的<code>set</code>位置，就可以减去一些不必要消耗。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�26-->\n\n</div></div>"},{"title":"「HNOI2010」弹飞绵羊-动态树","urlname":"HNOI2010-bounce","date":"2018-05-18T10:52:39.000Z","visible":null,"_content":"\n游戏一开始，`Lostmonkey`在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$K_i$，当绵羊达到第$i$个装置时，它会往后弹$K_i$步，达到第$i+K_i$个装置，若不存在第$i+K_i$个装置，则绵羊被弹飞。\n\n存在两种操作：\n\n+ 查询在第$i$个装置起步是，再经多少次会被弹飞。\n\n+ 修改第$i$个装置的弹力系数为$K'$。\n\n保证任何时候，任何装置弹力系数均为正整数。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3203](https://www.luogu.org/problemnew/show/P3203)\n\n[BZOJ 2002](https://www.lydsy.com/JudgeOnline/problem.php?id=2002)\n\n## 题解\n\n`Link_Cut_Tree`比较好想的一道题。\n\n我们注意到，这n个装置的弹力系数可以抽象成一颗树，即连接第$i$和第$i+K_i$个节点的边，并且弹力系数的正整数的性质使其不存在环。\n\n对于弹出去的装置，我们都用一个$n+1$号点来代替。每次在`Link_Cut_Tree`上查询$i$到$i+K_i$的距离，即为答案。修改的时候，我们先断掉与原来的$i+K_i$的边，再连上到$i+K'$的边，更新弹力系数数组即可。\n\n注意这里的装置编号是$0\\to n-1$的，所以可以统一进行$+1$处理。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 510000;\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nstruct Link_Cat_Tree{\n    int sum[MAXN];\n    int f[MAXN],c[MAXN][2];\n    bool rev[MAXN];\n    void push_up(int x){\n        sum[x] = sum[c[x][0]] + sum[c[x][1]] + 1;\n    }\n    void reverse(int x){\n        if(!x) return;\n        swap(c[x][0],c[x][1]);\n        rev[x] ^= 1;\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]);\n            reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    bool noroot(int x){\n        return (c[f[x]][0] == x) || (c[f[x]][1] == x);\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1]==y] = x;\n        c[x][1-t] = y,c[y][t] = w; \n        if(w) f[w] = y;\n        f[y] = x;f[x] = z;\n        push_up(y),push_up(x); \n    }\n    void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y)){\n                if((c[y][1]==x)^(c[z][1]==y)) rotate(x);\n                else rotate(y);\n            }rotate(x);\n        }\n    }\n    void access(int x){\n        for(int y = 0;x;x = f[y=x]){\n            splay(x);c[x][1] = y;\n            push_up(x);\n        }\n    }\n    void makeroot(int x){\n        access(x),splay(x),reverse(x);\n    }\n    int find(int x){\n        access(x),splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    void link(int x,int y){\n        makeroot(x);\n        if(find(y)!=x)\n            f[x] = y;\n    }\n    void cat(int x,int y){\n        makeroot(x);//find == splay\n        if(find(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0,push_up(y);\n    }\n    int query(int u,int v){\n        makeroot(v);\n        //if(find(v)!=find(u)) return -1;\n        access(u);splay(u);\n        return sum[u];\n    }\n    void print(int n){\n        for(int i = 1;i<=n;i++){\n            printf(\"%d: sum:%d f:%d c:%d %d r:%d\\n\",i,sum[i],f[i],c[i][0],c[i][1],int(rev[i]));\n        }\n    }\n};\n\n\nint n,m,num[MAXN];\nLink_Cat_Tree T;\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    for(int i = 1;i<=n;i++)\n        T.link(i,min(i+num[i],n+1));\n}\nvoid solve(){\n    read(m);\n    int op,a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);read(a);++a;\n        if(op == 1)\n            print(T.query(a,n+1)-1),print('\\n');\n        else if(op == 2){\n            read(b);\n            T.cat(a,min(a+num[a],n+1));\n            T.link(a,min(a+b,n+1));\n            num[a] = b;\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「HNOI2010」弹飞绵羊-动态树.md","raw":"---\ntitle: 「HNOI2010」弹飞绵羊-动态树\nurlname: HNOI2010-bounce\ndate: 2018-05-18 18:52:39\ntags:\n- 题解\n- 动态树\n- 数据结构\n- 树形结构\ncategories: OI\nvisible:\n---\n\n游戏一开始，`Lostmonkey`在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$K_i$，当绵羊达到第$i$个装置时，它会往后弹$K_i$步，达到第$i+K_i$个装置，若不存在第$i+K_i$个装置，则绵羊被弹飞。\n\n存在两种操作：\n\n+ 查询在第$i$个装置起步是，再经多少次会被弹飞。\n\n+ 修改第$i$个装置的弹力系数为$K'$。\n\n保证任何时候，任何装置弹力系数均为正整数。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3203](https://www.luogu.org/problemnew/show/P3203)\n\n[BZOJ 2002](https://www.lydsy.com/JudgeOnline/problem.php?id=2002)\n\n## 题解\n\n`Link_Cut_Tree`比较好想的一道题。\n\n我们注意到，这n个装置的弹力系数可以抽象成一颗树，即连接第$i$和第$i+K_i$个节点的边，并且弹力系数的正整数的性质使其不存在环。\n\n对于弹出去的装置，我们都用一个$n+1$号点来代替。每次在`Link_Cut_Tree`上查询$i$到$i+K_i$的距离，即为答案。修改的时候，我们先断掉与原来的$i+K_i$的边，再连上到$i+K'$的边，更新弹力系数数组即可。\n\n注意这里的装置编号是$0\\to n-1$的，所以可以统一进行$+1$处理。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 510000;\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nstruct Link_Cat_Tree{\n    int sum[MAXN];\n    int f[MAXN],c[MAXN][2];\n    bool rev[MAXN];\n    void push_up(int x){\n        sum[x] = sum[c[x][0]] + sum[c[x][1]] + 1;\n    }\n    void reverse(int x){\n        if(!x) return;\n        swap(c[x][0],c[x][1]);\n        rev[x] ^= 1;\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]);\n            reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    bool noroot(int x){\n        return (c[f[x]][0] == x) || (c[f[x]][1] == x);\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1]==y] = x;\n        c[x][1-t] = y,c[y][t] = w; \n        if(w) f[w] = y;\n        f[y] = x;f[x] = z;\n        push_up(y),push_up(x); \n    }\n    void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y)){\n                if((c[y][1]==x)^(c[z][1]==y)) rotate(x);\n                else rotate(y);\n            }rotate(x);\n        }\n    }\n    void access(int x){\n        for(int y = 0;x;x = f[y=x]){\n            splay(x);c[x][1] = y;\n            push_up(x);\n        }\n    }\n    void makeroot(int x){\n        access(x),splay(x),reverse(x);\n    }\n    int find(int x){\n        access(x),splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    void link(int x,int y){\n        makeroot(x);\n        if(find(y)!=x)\n            f[x] = y;\n    }\n    void cat(int x,int y){\n        makeroot(x);//find == splay\n        if(find(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0,push_up(y);\n    }\n    int query(int u,int v){\n        makeroot(v);\n        //if(find(v)!=find(u)) return -1;\n        access(u);splay(u);\n        return sum[u];\n    }\n    void print(int n){\n        for(int i = 1;i<=n;i++){\n            printf(\"%d: sum:%d f:%d c:%d %d r:%d\\n\",i,sum[i],f[i],c[i][0],c[i][1],int(rev[i]));\n        }\n    }\n};\n\n\nint n,m,num[MAXN];\nLink_Cat_Tree T;\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    for(int i = 1;i<=n;i++)\n        T.link(i,min(i+num[i],n+1));\n}\nvoid solve(){\n    read(m);\n    int op,a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);read(a);++a;\n        if(op == 1)\n            print(T.query(a,n+1)-1),print('\\n');\n        else if(op == 2){\n            read(b);\n            T.cat(a,min(a+num[a],n+1));\n            T.link(a,min(a+b,n+1));\n            num[a] = b;\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「HNOI2010」弹飞绵羊-动态树","published":1,"updated":"2018-05-18T11:11:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ip002nbljrvs2lwhkm","content":"<p>游戏一开始，<code>Lostmonkey</code>在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$K_i$，当绵羊达到第$i$个装置时，它会往后弹$K_i$步，达到第$i+K_i$个装置，若不存在第$i+K_i$个装置，则绵羊被弹飞。</p>\n<p>存在两种操作：</p>\n<ul>\n<li><p>查询在第$i$个装置起步是，再经多少次会被弹飞。</p>\n</li>\n<li><p>修改第$i$个装置的弹力系数为$K’$。</p>\n</li>\n</ul>\n<p>保证任何时候，任何装置弹力系数均为正整数。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3203\" target=\"_blank\" rel=\"noopener\">Luogu P3203</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2002\" target=\"_blank\" rel=\"noopener\">BZOJ 2002</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><code>Link_Cut_Tree</code>比较好想的一道题。</p>\n<p>我们注意到，这n个装置的弹力系数可以抽象成一颗树，即连接第$i$和第$i+K_i$个节点的边，并且弹力系数的正整数的性质使其不存在环。</p>\n<p>对于弹出去的装置，我们都用一个$n+1$号点来代替。每次在<code>Link_Cut_Tree</code>上查询$i$到$i+K_i$的距离，即为答案。修改的时候，我们先断掉与原来的$i+K_i$的边，再连上到$i+K’$的边，更新弹力系数数组即可。</p>\n<p>注意这里的装置编号是$0\\to n-1$的，所以可以统一进行$+1$处理。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">510000</span>;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Link_Cat_Tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[MAXN],c[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        sum[x] = sum[c[x][<span class=\"number\">0</span>]] + sum[c[x][<span class=\"number\">1</span>]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(c[x][<span class=\"number\">0</span>],c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        rev[x] ^= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev[x])&#123;</span><br><span class=\"line\">            reverse(c[x][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            reverse(c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            rev[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">noroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (c[f[x]][<span class=\"number\">0</span>] == x) || (c[f[x]][<span class=\"number\">1</span>] == x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_all</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(x)) push_all(f[x]);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = f[x],z = f[y],t = (c[y][<span class=\"number\">1</span>] == x),w = c[x][<span class=\"number\">1</span>-t];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(y)) c[z][c[z][<span class=\"number\">1</span>]==y] = x;</span><br><span class=\"line\">        c[x][<span class=\"number\">1</span>-t] = y,c[y][t] = w; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w) f[w] = y;</span><br><span class=\"line\">        f[y] = x;f[x] = z;</span><br><span class=\"line\">        push_up(y),push_up(x); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        push_all(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(noroot(x))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = f[x],z = f[y];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(noroot(y))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((c[y][<span class=\"number\">1</span>]==x)^(c[z][<span class=\"number\">1</span>]==y)) rotate(x);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> rotate(y);</span><br><span class=\"line\">            &#125;rotate(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;x;x = f[y=x])&#123;</span><br><span class=\"line\">            splay(x);c[x][<span class=\"number\">1</span>] = y;</span><br><span class=\"line\">            push_up(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x),splay(x),reverse(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x),splay(x);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c[x][<span class=\"number\">0</span>])</span><br><span class=\"line\">            x = c[x][<span class=\"number\">0</span>],push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(find(y)!=x)</span><br><span class=\"line\">            f[x] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cat</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);<span class=\"comment\">//find == splay</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(find(y) == x &amp;&amp; f[x] == y &amp;&amp; !c[x][<span class=\"number\">1</span>])</span><br><span class=\"line\">            f[x] = c[y][<span class=\"number\">0</span>] = <span class=\"number\">0</span>,push_up(y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        makeroot(v);</span><br><span class=\"line\">        <span class=\"comment\">//if(find(v)!=find(u)) return -1;</span></span><br><span class=\"line\">        access(u);splay(u);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum[u];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d: sum:%d f:%d c:%d %d r:%d\\n\"</span>,i,sum[i],f[i],c[i][<span class=\"number\">0</span>],c[i][<span class=\"number\">1</span>],<span class=\"keyword\">int</span>(rev[i]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,num[MAXN];</span><br><span class=\"line\">Link_Cat_Tree T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        T.link(i,min(i+num[i],n+<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> op,a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op);read(a);++a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op == <span class=\"number\">1</span>)</span><br><span class=\"line\">            print(T.query(a,n+<span class=\"number\">1</span>)<span class=\"number\">-1</span>),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            read(b);</span><br><span class=\"line\">            T.cat(a,min(a+num[a],n+<span class=\"number\">1</span>));</span><br><span class=\"line\">            T.link(a,min(a+b,n+<span class=\"number\">1</span>));</span><br><span class=\"line\">            num[a] = b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>游戏一开始，<code>Lostmonkey</code>在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$K_i$，当绵羊达到第$i$个装置时，它会往后弹$K_i$步，达到第$i+K_i$个装置，若不存在第$i+K_i$个装置，则绵羊被弹飞。</p>\n<p>存在两种操作：</p>\n<ul>\n<li><p>查询在第$i$个装置起步是，再经多少次会被弹飞。</p>\n</li>\n<li><p>修改第$i$个装置的弹力系数为$K’$。</p>\n</li>\n</ul>\n<p>保证任何时候，任何装置弹力系数均为正整数。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3203\" target=\"_blank\" rel=\"noopener\">Luogu P3203</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2002\" target=\"_blank\" rel=\"noopener\">BZOJ 2002</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><code>Link_Cut_Tree</code>比较好想的一道题。</p>\n<p>我们注意到，这n个装置的弹力系数可以抽象成一颗树，即连接第$i$和第$i+K_i$个节点的边，并且弹力系数的正整数的性质使其不存在环。</p>\n<p>对于弹出去的装置，我们都用一个$n+1$号点来代替。每次在<code>Link_Cut_Tree</code>上查询$i$到$i+K_i$的距离，即为答案。修改的时候，我们先断掉与原来的$i+K_i$的边，再连上到$i+K’$的边，更新弹力系数数组即可。</p>\n<p>注意这里的装置编号是$0\\to n-1$的，所以可以统一进行$+1$处理。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�27-->\n\n</div></div>"},{"title":"「JSOI2016」最佳团体-树上背包+0/1分数规划","urlname":"JSOI2016-team","date":"2018-06-18T01:34:03.000Z","visible":null,"_content":"\n`JSOI` 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，`JYY` 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 `JYY` 自己看上的。\n\n为了保证团队的和谐，`JYY` 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，`JYY` 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。`JYY` 希望招募 $K$ 个候选人（`JYY` 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 `JYY` 选择的候选人的总战斗值与总招募费用的比值最大。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4322](https://www.luogu.org/problemnew/show/P4322)\n\n## 代码\n\n这题看着很高端...事实上就是一个0/1分数规划+树形dp...\n\n0/1分数规划的过程，就是二分选择一个答案$ans$，然后去验证能不能取到若干个$P_i - ans \\times S_i$大于0。\n\n能不能取到这个大于$0$的东西，用$O(n^2)$的树形dp验证一下就好了。\n\n我这个代码好像有点锅，不开O2就RE...懒得找了...就这样吧...\n\n这里的初始化也要注意一下，还有就是循环的边界，因为这里父节点必须取，第一层循环就不能到$0$...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n\nconst int MAXN = 3000;\nconst double eps = 1e-4;\nint n,m;\ndouble s[MAXN],p[MAXN];\nint siz[MAXN];\ndouble dp[MAXN][MAXN];\nvector<int> edge[MAXN];\n\ndouble k;\n\ndouble tmp[MAXN];\n\nvoid dfs(int x){\n    for(int j = 0;j < MAXN;j++)\n        dp[x][j] = -1e9;\n    siz[x] = 1;dp[x][0] = 0;dp[x][1] = p[x] - k*s[x];\n    for(int i = 0;i<edge[x].size();i++){\n        int v = edge[x][i];\n        dfs(v);\n        for(int j = 0;j<=siz[x] + siz[v];j++)\n            tmp[j] = -1e9;\n        for(int j = 0;j<=siz[x];j++)\n            tmp[j] = dp[x][j];\n        for(int j = siz[x];j >= 1;--j)\n            for(int w = siz[v];w >= 0;--w)\n                if(j+w <= m)\n                    tmp[j+w] = max(tmp[j+w],dp[x][j] + dp[v][w]);\n        memcpy(dp[x],tmp,sizeof(double)*(siz[x] + siz[v]+1));\n        siz[x] += siz[v];\n    }\n}\n\nbool check(double num){\n    k = num;\n    dfs(0);\n    return dp[0][m] > -eps;\n}\n\nint main(){\n    scanf(\"%d %d\",&m,&n);m++;\n    int f;\n    for(int i = 1;i<=n;i++){\n        scanf(\"%lf %lf %d\",&s[i],&p[i],&f);\n        edge[f].push_back(i);\n    }\n    double l = 0,r = 10000;\n    while(r - l > eps){\n        double mid = (l+r)/2;\n        if(check(mid))\n            l = mid;\n        else\n            r = mid;\n    }\n    printf(\"%.3lf\\n\",l);\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「JSOI2016」最佳团体-树上背包-0-1分数规划.md","raw":"---\ntitle: 「JSOI2016」最佳团体-树上背包+0/1分数规划\nurlname: JSOI2016-team\ndate: 2018-06-18 09:34:03\ntags:\n- 题解\n- 0/1分数规划\n- 树形结构\n- 树形dp\ncategories: OI\nvisible:\n---\n\n`JSOI` 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，`JYY` 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 `JYY` 自己看上的。\n\n为了保证团队的和谐，`JYY` 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，`JYY` 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。`JYY` 希望招募 $K$ 个候选人（`JYY` 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 `JYY` 选择的候选人的总战斗值与总招募费用的比值最大。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4322](https://www.luogu.org/problemnew/show/P4322)\n\n## 代码\n\n这题看着很高端...事实上就是一个0/1分数规划+树形dp...\n\n0/1分数规划的过程，就是二分选择一个答案$ans$，然后去验证能不能取到若干个$P_i - ans \\times S_i$大于0。\n\n能不能取到这个大于$0$的东西，用$O(n^2)$的树形dp验证一下就好了。\n\n我这个代码好像有点锅，不开O2就RE...懒得找了...就这样吧...\n\n这里的初始化也要注意一下，还有就是循环的边界，因为这里父节点必须取，第一层循环就不能到$0$...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n\nconst int MAXN = 3000;\nconst double eps = 1e-4;\nint n,m;\ndouble s[MAXN],p[MAXN];\nint siz[MAXN];\ndouble dp[MAXN][MAXN];\nvector<int> edge[MAXN];\n\ndouble k;\n\ndouble tmp[MAXN];\n\nvoid dfs(int x){\n    for(int j = 0;j < MAXN;j++)\n        dp[x][j] = -1e9;\n    siz[x] = 1;dp[x][0] = 0;dp[x][1] = p[x] - k*s[x];\n    for(int i = 0;i<edge[x].size();i++){\n        int v = edge[x][i];\n        dfs(v);\n        for(int j = 0;j<=siz[x] + siz[v];j++)\n            tmp[j] = -1e9;\n        for(int j = 0;j<=siz[x];j++)\n            tmp[j] = dp[x][j];\n        for(int j = siz[x];j >= 1;--j)\n            for(int w = siz[v];w >= 0;--w)\n                if(j+w <= m)\n                    tmp[j+w] = max(tmp[j+w],dp[x][j] + dp[v][w]);\n        memcpy(dp[x],tmp,sizeof(double)*(siz[x] + siz[v]+1));\n        siz[x] += siz[v];\n    }\n}\n\nbool check(double num){\n    k = num;\n    dfs(0);\n    return dp[0][m] > -eps;\n}\n\nint main(){\n    scanf(\"%d %d\",&m,&n);m++;\n    int f;\n    for(int i = 1;i<=n;i++){\n        scanf(\"%lf %lf %d\",&s[i],&p[i],&f);\n        edge[f].push_back(i);\n    }\n    double l = 0,r = 10000;\n    while(r - l > eps){\n        double mid = (l+r)/2;\n        if(check(mid))\n            l = mid;\n        else\n            r = mid;\n    }\n    printf(\"%.3lf\\n\",l);\n    return 0;\n}\n```\n{% endfold %}","slug":"「JSOI2016」最佳团体-树上背包-0-1分数规划","published":1,"updated":"2018-06-18T03:58:59.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3is002qbljrfjdtneni","content":"<p><code>JSOI</code> 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，<code>JYY</code> 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 <code>JYY</code> 自己看上的。</p>\n<p>为了保证团队的和谐，<code>JYY</code> 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，<code>JYY</code> 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。<code>JYY</code> 希望招募 $K$ 个候选人（<code>JYY</code> 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 <code>JYY</code> 选择的候选人的总战斗值与总招募费用的比值最大。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4322\" target=\"_blank\" rel=\"noopener\">Luogu P4322</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>这题看着很高端…事实上就是一个0/1分数规划+树形dp…</p>\n<p>0/1分数规划的过程，就是二分选择一个答案$ans$，然后去验证能不能取到若干个$P_i - ans \\times S_i$大于0。</p>\n<p>能不能取到这个大于$0$的东西，用$O(n^2)$的树形dp验证一下就好了。</p>\n<p>我这个代码好像有点锅，不开O2就RE…懒得找了…就这样吧…</p>\n<p>这里的初始化也要注意一下，还有就是循环的边界，因为这里父节点必须取，第一层循环就不能到$0$…</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">3000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> eps = <span class=\"number\">1e-4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">double</span> s[MAXN],p[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> siz[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">double</span> dp[MAXN][MAXN];</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> tmp[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; MAXN;j++)</span><br><span class=\"line\">        dp[x][j] = <span class=\"number\">-1e9</span>;</span><br><span class=\"line\">    siz[x] = <span class=\"number\">1</span>;dp[x][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;dp[x][<span class=\"number\">1</span>] = p[x] - k*s[x];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[x].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[x][i];</span><br><span class=\"line\">        dfs(v);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;=siz[x] + siz[v];j++)</span><br><span class=\"line\">            tmp[j] = <span class=\"number\">-1e9</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;=siz[x];j++)</span><br><span class=\"line\">            tmp[j] = dp[x][j];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = siz[x];j &gt;= <span class=\"number\">1</span>;--j)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> w = siz[v];w &gt;= <span class=\"number\">0</span>;--w)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j+w &lt;= m)</span><br><span class=\"line\">                    tmp[j+w] = max(tmp[j+w],dp[x][j] + dp[v][w]);</span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(dp[x],tmp,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">double</span>)*(siz[x] + siz[v]+<span class=\"number\">1</span>));</span><br><span class=\"line\">        siz[x] += siz[v];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></span>&#123;</span><br><span class=\"line\">    k = num;</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][m] &gt; -eps;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;m,&amp;n);m++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf %lf %d\"</span>,&amp;s[i],&amp;p[i],&amp;f);</span><br><span class=\"line\">        edge[f].push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l = <span class=\"number\">0</span>,r = <span class=\"number\">10000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r - l &gt; eps)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(check(mid))</span><br><span class=\"line\">            l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%.3lf\\n\"</span>,l);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p><code>JSOI</code> 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，<code>JYY</code> 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 <code>JYY</code> 自己看上的。</p>\n<p>为了保证团队的和谐，<code>JYY</code> 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，<code>JYY</code> 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。<code>JYY</code> 希望招募 $K$ 个候选人（<code>JYY</code> 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 <code>JYY</code> 选择的候选人的总战斗值与总招募费用的比值最大。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4322\" target=\"_blank\" rel=\"noopener\">Luogu P4322</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>这题看着很高端…事实上就是一个0/1分数规划+树形dp…</p>\n<p>0/1分数规划的过程，就是二分选择一个答案$ans$，然后去验证能不能取到若干个$P_i - ans \\times S_i$大于0。</p>\n<p>能不能取到这个大于$0$的东西，用$O(n^2)$的树形dp验证一下就好了。</p>\n<p>我这个代码好像有点锅，不开O2就RE…懒得找了…就这样吧…</p>\n<p>这里的初始化也要注意一下，还有就是循环的边界，因为这里父节点必须取，第一层循环就不能到$0$…</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�28-->\n\n</div></div>"},{"title":"「LNOI2014」LCA-树链剖分-差分","urlname":"lnoi2014-lca","date":"2018-06-02T13:23:25.000Z","visible":null,"_content":"\n给出一个$n$个节点的有根树。有$q$次询问，每次询问给出$l,r,z$，求$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4211](https://www.luogu.org/problemnew/show/P4211)\n\n## 题解\n\n神仙题...真是不知道考场上有没有人能够想到。\n\n给出这样一个结论：\n\n> 节点$x$和$y$的$lca$到根节点的距离等于在$x$到根节点的路径上且$y$到根节点的路径上的节点个数。\n\n所以如果我们将$[l,r]$中的点到根节点的路径上所有的节点的值分别加$1$，这个时候$z$到根节点的路径上的权值和就是查询$(l,r,z)$的答案。\n\n- - -\n\n而且我们注意到这个问题满足区间可减性：\n\n即设$sum(l,r) = \\sum_{l\\leq i\\leq r}{dep[LCA(i,z)]}$，有$sum(l,r) = sum(1,r)-sum(1,l-1)$。\n\n因此，我们将询问$(l,r,z)$分离成$(l-1,z)$和$(r,z)$。\n\n我们用$(t_i,pos_i)$代表询问。按照$t_i$为第一关键字进行排序离线之后查询。每次查询的时候，使得$1~t_i$的所有节点都已经把往根节点的路径上都做了修改，那么我们只需要查询一个$(1,pos_i)$的路径上的节点的权值和即可。\n\n这个东西如果用树链剖分+线段树，复杂度是$O(n \\log^{2}{n})$，如果用`LCT`，复杂度是$O(n\\log n)$。\n\n其实我感觉这道题完全可以出到$200000$，然后给$O(n \\log^{2}{n})$五六十分部分分。\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\nconst int MAXN = 210000,mod = 201314;\n\nint n,m;\n\nvector<int> edge[MAXN];\nint dep[MAXN],son[MAXN],top[MAXN],siz[MAXN],fa[MAXN],id[MAXN],cnt = 0;\n\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1;dep[nown] = depth;\n    fa[nown] = f;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == f) continue;\n        dfs1(v,nown,depth+1);\n        siz[nown] += siz[v];\n        if(siz[v] > siz[son[nown]]) son[nown] = v;\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    top[nown] = topf;\n    id[nown] = ++cnt;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa[nown] || v == son[nown])\n            continue;\n        dfs2(v,v);\n    }\n}\n\nnamespace SegTree{\n    int sumn[MAXN],addn[MAXN];\n    #define lson (nown<<1)\n    #define rson ((nown<<1)|1)\n    #define mid ((l+r)>>1)\n    void push_up(int nown){\n        sumn[nown] = sumn[lson] + sumn[rson];\n        sumn[nown] %= mod;\n    }\n    void add(int nown,int l,int r,int d){\n        sumn[nown] += d*(r-l+1);\n        addn[nown] += d;\n        sumn[nown] %= mod,addn[nown] %= mod;\n    }\n    void push_down(int nown,int l,int r){\n        if(addn[nown]){\n            add(lson,l,mid,addn[nown]);\n            add(rson,mid+1,r,addn[nown]);\n            addn[nown] = 0;\n        }\n    }\n    void add(int nown,int l,int r,int ql,int qr,int d){\n        if(ql <= l && r <= qr){\n            add(nown,l,r,d);\n        }\n        else{\n            push_down(nown,l,r);\n            if(ql <= mid) add(lson,l,mid,ql,qr,d);\n            if(mid+1 <= qr) add(rson,mid+1,r,ql,qr,d);\n            push_up(nown);\n        }\n    }\n    int query(int nown,int l,int r,int ql,int qr){\n        if(ql <= l && r <= qr) \n            return sumn[nown];\n        else{\n            push_down(nown,l,r);\n            int ans = 0;\n            if(ql <= mid) ans += query(lson,l,mid,ql,qr);\n            if(mid + 1 <= qr) ans += query(rson,mid+1,r,ql,qr);\n            ans %= mod;\n            return ans;\n        }\n    }\n    void build(int nown,int l,int r){\n        ;\n    }\n}\n\nstruct Q{\n    int ti,pos,id;\n    Q(int t,int p,int i):ti(t),pos(p),id(i){;}\n    bool operator<(Q a) const{\n        return ti < a.ti;\n    }\n};\n\nvector<Q> q;\n\nint ans[MAXN<<2],qa[MAXN][2];\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    for(int i = 2;i<=n;i++){\n        read(a);\n        edge[i].push_back(a+1);\n        edge[a+1].push_back(i);\n    }\n    int tot;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b),read(c);\n        q.push_back(Q(a,c+1,++tot));\n        qa[i][0] = tot;\n        q.push_back(Q(b+1,c+1,++tot));\n        qa[i][1] = tot;\n    }\n}\n\nvoid w_add(int u,int v,int d = 1){\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        SegTree::add(1,1,n,id[top[u]],id[u],d);\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    SegTree::add(1,1,n,id[u],id[v],d);\n}\n\nint w_query(int u,int v){\n    int ans = 0;\n    while(top[u] != top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans += SegTree::query(1,1,n,id[top[u]],id[u]);\n        u = fa[top[u]]; ans %= mod;\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans += SegTree::query(1,1,n,id[u],id[v]);\n    ans %= mod;\n    return ans;\n}\n\nvoid solve(){\n    sort(q.begin(),q.end());\n    dfs1(1,0,1);\n    dfs2(1,1);\n    int nowt = 0;\n    for(int i = 0;i < q.size();i++){\n        while(q[i].ti > nowt) w_add(1,++nowt);\n        ans[q[i].id] = w_query(1,q[i].pos);\n    }\n    for(int i = 1;i<=m;i++)\n        print((ans[qa[i][1]]-ans[qa[i][0]]+mod+mod+mod)%mod),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n","source":"_posts/「LNOI2014」LCA-树链剖分-差分.md","raw":"---\ntitle: 「LNOI2014」LCA-树链剖分-差分\nurlname: lnoi2014-lca\ndate: 2018-06-02 21:23:25\ntags:\ncategories:\nvisible:\n---\n\n给出一个$n$个节点的有根树。有$q$次询问，每次询问给出$l,r,z$，求$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4211](https://www.luogu.org/problemnew/show/P4211)\n\n## 题解\n\n神仙题...真是不知道考场上有没有人能够想到。\n\n给出这样一个结论：\n\n> 节点$x$和$y$的$lca$到根节点的距离等于在$x$到根节点的路径上且$y$到根节点的路径上的节点个数。\n\n所以如果我们将$[l,r]$中的点到根节点的路径上所有的节点的值分别加$1$，这个时候$z$到根节点的路径上的权值和就是查询$(l,r,z)$的答案。\n\n- - -\n\n而且我们注意到这个问题满足区间可减性：\n\n即设$sum(l,r) = \\sum_{l\\leq i\\leq r}{dep[LCA(i,z)]}$，有$sum(l,r) = sum(1,r)-sum(1,l-1)$。\n\n因此，我们将询问$(l,r,z)$分离成$(l-1,z)$和$(r,z)$。\n\n我们用$(t_i,pos_i)$代表询问。按照$t_i$为第一关键字进行排序离线之后查询。每次查询的时候，使得$1~t_i$的所有节点都已经把往根节点的路径上都做了修改，那么我们只需要查询一个$(1,pos_i)$的路径上的节点的权值和即可。\n\n这个东西如果用树链剖分+线段树，复杂度是$O(n \\log^{2}{n})$，如果用`LCT`，复杂度是$O(n\\log n)$。\n\n其实我感觉这道题完全可以出到$200000$，然后给$O(n \\log^{2}{n})$五六十分部分分。\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\nconst int MAXN = 210000,mod = 201314;\n\nint n,m;\n\nvector<int> edge[MAXN];\nint dep[MAXN],son[MAXN],top[MAXN],siz[MAXN],fa[MAXN],id[MAXN],cnt = 0;\n\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1;dep[nown] = depth;\n    fa[nown] = f;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == f) continue;\n        dfs1(v,nown,depth+1);\n        siz[nown] += siz[v];\n        if(siz[v] > siz[son[nown]]) son[nown] = v;\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    top[nown] = topf;\n    id[nown] = ++cnt;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa[nown] || v == son[nown])\n            continue;\n        dfs2(v,v);\n    }\n}\n\nnamespace SegTree{\n    int sumn[MAXN],addn[MAXN];\n    #define lson (nown<<1)\n    #define rson ((nown<<1)|1)\n    #define mid ((l+r)>>1)\n    void push_up(int nown){\n        sumn[nown] = sumn[lson] + sumn[rson];\n        sumn[nown] %= mod;\n    }\n    void add(int nown,int l,int r,int d){\n        sumn[nown] += d*(r-l+1);\n        addn[nown] += d;\n        sumn[nown] %= mod,addn[nown] %= mod;\n    }\n    void push_down(int nown,int l,int r){\n        if(addn[nown]){\n            add(lson,l,mid,addn[nown]);\n            add(rson,mid+1,r,addn[nown]);\n            addn[nown] = 0;\n        }\n    }\n    void add(int nown,int l,int r,int ql,int qr,int d){\n        if(ql <= l && r <= qr){\n            add(nown,l,r,d);\n        }\n        else{\n            push_down(nown,l,r);\n            if(ql <= mid) add(lson,l,mid,ql,qr,d);\n            if(mid+1 <= qr) add(rson,mid+1,r,ql,qr,d);\n            push_up(nown);\n        }\n    }\n    int query(int nown,int l,int r,int ql,int qr){\n        if(ql <= l && r <= qr) \n            return sumn[nown];\n        else{\n            push_down(nown,l,r);\n            int ans = 0;\n            if(ql <= mid) ans += query(lson,l,mid,ql,qr);\n            if(mid + 1 <= qr) ans += query(rson,mid+1,r,ql,qr);\n            ans %= mod;\n            return ans;\n        }\n    }\n    void build(int nown,int l,int r){\n        ;\n    }\n}\n\nstruct Q{\n    int ti,pos,id;\n    Q(int t,int p,int i):ti(t),pos(p),id(i){;}\n    bool operator<(Q a) const{\n        return ti < a.ti;\n    }\n};\n\nvector<Q> q;\n\nint ans[MAXN<<2],qa[MAXN][2];\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    for(int i = 2;i<=n;i++){\n        read(a);\n        edge[i].push_back(a+1);\n        edge[a+1].push_back(i);\n    }\n    int tot;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b),read(c);\n        q.push_back(Q(a,c+1,++tot));\n        qa[i][0] = tot;\n        q.push_back(Q(b+1,c+1,++tot));\n        qa[i][1] = tot;\n    }\n}\n\nvoid w_add(int u,int v,int d = 1){\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        SegTree::add(1,1,n,id[top[u]],id[u],d);\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    SegTree::add(1,1,n,id[u],id[v],d);\n}\n\nint w_query(int u,int v){\n    int ans = 0;\n    while(top[u] != top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans += SegTree::query(1,1,n,id[top[u]],id[u]);\n        u = fa[top[u]]; ans %= mod;\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans += SegTree::query(1,1,n,id[u],id[v]);\n    ans %= mod;\n    return ans;\n}\n\nvoid solve(){\n    sort(q.begin(),q.end());\n    dfs1(1,0,1);\n    dfs2(1,1);\n    int nowt = 0;\n    for(int i = 0;i < q.size();i++){\n        while(q[i].ti > nowt) w_add(1,++nowt);\n        ans[q[i].id] = w_query(1,q[i].pos);\n    }\n    for(int i = 1;i<=m;i++)\n        print((ans[qa[i][1]]-ans[qa[i][0]]+mod+mod+mod)%mod),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n","slug":"「LNOI2014」LCA-树链剖分-差分","published":1,"updated":"2018-06-02T15:41:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3iw002sbljrolwmtsog","content":"<p>给出一个$n$个节点的有根树。有$q$次询问，每次询问给出$l,r,z$，求$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4211\" target=\"_blank\" rel=\"noopener\">Luogu P4211</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>神仙题…真是不知道考场上有没有人能够想到。</p>\n<p>给出这样一个结论：</p>\n<blockquote>\n<p>节点$x$和$y$的$lca$到根节点的距离等于在$x$到根节点的路径上且$y$到根节点的路径上的节点个数。</p>\n</blockquote>\n<p>所以如果我们将$[l,r]$中的点到根节点的路径上所有的节点的值分别加$1$，这个时候$z$到根节点的路径上的权值和就是查询$(l,r,z)$的答案。</p>\n<hr>\n<p>而且我们注意到这个问题满足区间可减性：</p>\n<p>即设$sum(l,r) = \\sum_{l\\leq i\\leq r}{dep[LCA(i,z)]}$，有$sum(l,r) = sum(1,r)-sum(1,l-1)$。</p>\n<p>因此，我们将询问$(l,r,z)$分离成$(l-1,z)$和$(r,z)$。</p>\n<p>我们用$(t_i,pos_i)$代表询问。按照$t_i$为第一关键字进行排序离线之后查询。每次查询的时候，使得$1~t_i$的所有节点都已经把往根节点的路径上都做了修改，那么我们只需要查询一个$(1,pos_i)$的路径上的节点的权值和即可。</p>\n<p>这个东西如果用树链剖分+线段树，复杂度是$O(n \\log^{2}{n})$，如果用<code>LCT</code>，复杂度是$O(n\\log n)$。</p>\n<p>其实我感觉这道题完全可以出到$200000$，然后给$O(n \\log^{2}{n})$五六十分部分分。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">210000</span>,mod = <span class=\"number\">201314</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dep[MAXN],son[MAXN],top[MAXN],siz[MAXN],fa[MAXN],id[MAXN],cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>;dep[nown] = depth;</span><br><span class=\"line\">    fa[nown] = f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(v,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        siz[nown] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; siz[son[nown]]) son[nown] = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    top[nown] = topf;</span><br><span class=\"line\">    id[nown] = ++cnt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!son[nown]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == fa[nown] || v == son[nown])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(v,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> SegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sumn[MAXN],addn[MAXN];</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson (nown&lt;&lt;1)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson ((nown&lt;&lt;1)|1)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">        sumn[nown] = sumn[lson] + sumn[rson];</span><br><span class=\"line\">        sumn[nown] %= mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        sumn[nown] += d*(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">        addn[nown] += d;</span><br><span class=\"line\">        sumn[nown] %= mod,addn[nown] %= mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(addn[nown])&#123;</span><br><span class=\"line\">            add(lson,l,mid,addn[nown]);</span><br><span class=\"line\">            add(rson,mid+<span class=\"number\">1</span>,r,addn[nown]);</span><br><span class=\"line\">            addn[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)&#123;</span><br><span class=\"line\">            add(nown,l,r,d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            push_down(nown,l,r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql &lt;= mid) add(lson,l,mid,ql,qr,d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= qr) add(rson,mid+<span class=\"number\">1</span>,r,ql,qr,d);</span><br><span class=\"line\">            push_up(nown);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> sumn[nown];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            push_down(nown,l,r);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql &lt;= mid) ans += query(lson,l,mid,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid + <span class=\"number\">1</span> &lt;= qr) ans += query(rson,mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">            ans %= mod;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Q</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ti,pos,id;</span><br><span class=\"line\">    Q(<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> p,<span class=\"keyword\">int</span> i):ti(t),pos(p),id(i)&#123;;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(Q a) <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ti &lt; a.ti;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Q&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[MAXN&lt;&lt;<span class=\"number\">2</span>],qa[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(a);</span><br><span class=\"line\">        edge[i].push_back(a+<span class=\"number\">1</span>);</span><br><span class=\"line\">        edge[a+<span class=\"number\">1</span>].push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        q.push_back(Q(a,c+<span class=\"number\">1</span>,++tot));</span><br><span class=\"line\">        qa[i][<span class=\"number\">0</span>] = tot;</span><br><span class=\"line\">        q.push_back(Q(b+<span class=\"number\">1</span>,c+<span class=\"number\">1</span>,++tot));</span><br><span class=\"line\">        qa[i][<span class=\"number\">1</span>] = tot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">w_add</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> d = <span class=\"number\">1</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[u]!=top[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[u]] &lt; dep[top[v]]) swap(u,v);</span><br><span class=\"line\">        SegTree::add(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[u]],id[u],d);</span><br><span class=\"line\">        u = fa[top[u]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class=\"line\">    SegTree::add(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[u],id[v],d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">w_query</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[u] != top[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[u]] &lt; dep[top[v]]) swap(u,v);</span><br><span class=\"line\">        ans += SegTree::query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[u]],id[u]);</span><br><span class=\"line\">        u = fa[top[u]]; ans %= mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class=\"line\">    ans += SegTree::query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[u],id[v]);</span><br><span class=\"line\">    ans %= mod;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(q.begin(),q.end());</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nowt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; q.size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(q[i].ti &gt; nowt) w_add(<span class=\"number\">1</span>,++nowt);</span><br><span class=\"line\">        ans[q[i].id] = w_query(<span class=\"number\">1</span>,q[i].pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        print((ans[qa[i][<span class=\"number\">1</span>]]-ans[qa[i][<span class=\"number\">0</span>]]+mod+mod+mod)%mod),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>给出一个$n$个节点的有根树。有$q$次询问，每次询问给出$l,r,z$，求$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4211\" target=\"_blank\" rel=\"noopener\">Luogu P4211</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>神仙题…真是不知道考场上有没有人能够想到。</p>\n<p>给出这样一个结论：</p>\n<blockquote>\n<p>节点$x$和$y$的$lca$到根节点的距离等于在$x$到根节点的路径上且$y$到根节点的路径上的节点个数。</p>\n</blockquote>\n<p>所以如果我们将$[l,r]$中的点到根节点的路径上所有的节点的值分别加$1$，这个时候$z$到根节点的路径上的权值和就是查询$(l,r,z)$的答案。</p>\n<hr>\n<p>而且我们注意到这个问题满足区间可减性：</p>\n<p>即设$sum(l,r) = \\sum_{l\\leq i\\leq r}{dep[LCA(i,z)]}$，有$sum(l,r) = sum(1,r)-sum(1,l-1)$。</p>\n<p>因此，我们将询问$(l,r,z)$分离成$(l-1,z)$和$(r,z)$。</p>\n<p>我们用$(t_i,pos_i)$代表询问。按照$t_i$为第一关键字进行排序离线之后查询。每次查询的时候，使得$1~t_i$的所有节点都已经把往根节点的路径上都做了修改，那么我们只需要查询一个$(1,pos_i)$的路径上的节点的权值和即可。</p>\n<p>这个东西如果用树链剖分+线段树，复杂度是$O(n \\log^{2}{n})$，如果用<code>LCT</code>，复杂度是$O(n\\log n)$。</p>\n<p>其实我感觉这道题完全可以出到$200000$，然后给$O(n \\log^{2}{n})$五六十分部分分。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><!--�29-->"},{"title":"「Luogu1043」数字游戏-dp","date":"2017-12-23T05:15:19.000Z","visible":null,"urlname":"luogu-1043","_content":"\n在你面前有一圈整数（一共$n$个），你要按顺序将其分为$m$个部分，各部分内的数字相加，相加所得的$m$个结果对10取模后再相乘，最终得到一个数$k$。游戏的要求是使你所得的$k$最大或者最小。\n<!-- more -->\n\n例如，对于下面这圈数字（$n$=4，$m$=2）：\n\n![](description.png)\n\n要求最小值时，$((2-1) mod 10)×((4+3) mod 10)=1×7=7$，要求最大值时，为$((2+4+3) mod 10)×(-1 mod 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。\n\n丁丁请你编写程序帮他赢得这个游戏。\n\n## 链接\n\n[Luogu P1043](https://www.luogu.org/problemnew/show/P1043)\n\n## 题解\n很水的一道$dp$题目。只要知道断环为链剩下的也都不难。题解洛谷没给过，现在也找不到了，只有代码还剩了下来。代码里面也有注释，凑活看看也可以。\n\nupdate: 这是我写的第一篇题解啦！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nlong long num[150],dp_1[150],dp_2[150];//_1放最大值,_2放最小值\n\nint n,m;\n\ninline int mod(long long nnn){//mod函数\n    int w = int(floor(double(nnn)/10));\n    return nnn - w*10;\n}\n\nint main(){\n    scanf(\"%d %d\",&n,&m);\n    for(int i = 1;i<=n;i++){//断环为链的准备\n        scanf(\"%lld\",&(num[i]));\n        num[i+n] = num[i];\n    }\n    for(int i = 1;i<=2*n;i++)//前缀和的处理\n        num[i] = num[i-1]+num[i];\n    //正经dp\n    long long maxn = -1,minn = 0x3f3f3f3f;\n    for(int s = 1;s<=n;s++){//枚举起点\n        memset(dp_1,0,sizeof(dp_1));//清零dp数组\n        memset(dp_2,0,sizeof(dp_2));\n        for(int j = 0;j<m;j++){//板子由少到多\n            for(int i = s;i<=s+n;i++){//上一个插板子的地方\n                if(j == 0){//j==0的时候的处理，其实也可以叫初始化\n                    dp_1[i] = dp_2[i] = mod(num[s+n]-num[i]);\n                    continue;\n                }\n                long long maxtmp = -1,mintmp = 0x3f3f3f3f;//对所有可能下一状态的遍历，并取最大或最小值\n                for(int x = i+1;x<=s+n-j-1;x++){\n                    maxtmp = max(maxtmp,dp_1[x]*mod(num[x]-num[i]));\n                    mintmp = min(mintmp,dp_2[x]*mod(num[x]-num[i]));\n                }\n                dp_1[i] = maxtmp;//取最大最小值\n                dp_2[i] = mintmp;\n            }\n        }\n        maxn = max(dp_1[s],maxn);//对于起点不同的最大最小值进行更新\n        minn = min(dp_2[s],minn);\n    }\n    printf(\"%lld\\n%lld\\n\",minn,maxn);\n    return 0;\n}\n```\n{% endfold %}\n\n","source":"_posts/「Luogu1043」数字游戏-dp.md","raw":"---\ntitle: 「Luogu1043」数字游戏-dp\ndate: 2017-12-23 13:15:19\ntags:\n- 动态规划\n- 题解\ncategories: OI\nvisible:\nurlname: luogu-1043\n---\n\n在你面前有一圈整数（一共$n$个），你要按顺序将其分为$m$个部分，各部分内的数字相加，相加所得的$m$个结果对10取模后再相乘，最终得到一个数$k$。游戏的要求是使你所得的$k$最大或者最小。\n<!-- more -->\n\n例如，对于下面这圈数字（$n$=4，$m$=2）：\n\n![](description.png)\n\n要求最小值时，$((2-1) mod 10)×((4+3) mod 10)=1×7=7$，要求最大值时，为$((2+4+3) mod 10)×(-1 mod 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。\n\n丁丁请你编写程序帮他赢得这个游戏。\n\n## 链接\n\n[Luogu P1043](https://www.luogu.org/problemnew/show/P1043)\n\n## 题解\n很水的一道$dp$题目。只要知道断环为链剩下的也都不难。题解洛谷没给过，现在也找不到了，只有代码还剩了下来。代码里面也有注释，凑活看看也可以。\n\nupdate: 这是我写的第一篇题解啦！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nlong long num[150],dp_1[150],dp_2[150];//_1放最大值,_2放最小值\n\nint n,m;\n\ninline int mod(long long nnn){//mod函数\n    int w = int(floor(double(nnn)/10));\n    return nnn - w*10;\n}\n\nint main(){\n    scanf(\"%d %d\",&n,&m);\n    for(int i = 1;i<=n;i++){//断环为链的准备\n        scanf(\"%lld\",&(num[i]));\n        num[i+n] = num[i];\n    }\n    for(int i = 1;i<=2*n;i++)//前缀和的处理\n        num[i] = num[i-1]+num[i];\n    //正经dp\n    long long maxn = -1,minn = 0x3f3f3f3f;\n    for(int s = 1;s<=n;s++){//枚举起点\n        memset(dp_1,0,sizeof(dp_1));//清零dp数组\n        memset(dp_2,0,sizeof(dp_2));\n        for(int j = 0;j<m;j++){//板子由少到多\n            for(int i = s;i<=s+n;i++){//上一个插板子的地方\n                if(j == 0){//j==0的时候的处理，其实也可以叫初始化\n                    dp_1[i] = dp_2[i] = mod(num[s+n]-num[i]);\n                    continue;\n                }\n                long long maxtmp = -1,mintmp = 0x3f3f3f3f;//对所有可能下一状态的遍历，并取最大或最小值\n                for(int x = i+1;x<=s+n-j-1;x++){\n                    maxtmp = max(maxtmp,dp_1[x]*mod(num[x]-num[i]));\n                    mintmp = min(mintmp,dp_2[x]*mod(num[x]-num[i]));\n                }\n                dp_1[i] = maxtmp;//取最大最小值\n                dp_2[i] = mintmp;\n            }\n        }\n        maxn = max(dp_1[s],maxn);//对于起点不同的最大最小值进行更新\n        minn = min(dp_2[s],minn);\n    }\n    printf(\"%lld\\n%lld\\n\",minn,maxn);\n    return 0;\n}\n```\n{% endfold %}\n\n","slug":"「Luogu1043」数字游戏-dp","published":1,"updated":"2018-04-26T03:04:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ix002vbljrbhruzuvs","content":"<p>在你面前有一圈整数（一共$n$个），你要按顺序将其分为$m$个部分，各部分内的数字相加，相加所得的$m$个结果对10取模后再相乘，最终得到一个数$k$。游戏的要求是使你所得的$k$最大或者最小。<br><a id=\"more\"></a></p>\n<p>例如，对于下面这圈数字（$n$=4，$m$=2）：</p>\n<p><img src=\"description.png\" alt=\"\"></p>\n<p>要求最小值时，$((2-1) mod 10)×((4+3) mod 10)=1×7=7$，要求最大值时，为$((2+4+3) mod 10)×(-1 mod 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。</p>\n<p>丁丁请你编写程序帮他赢得这个游戏。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1043\" target=\"_blank\" rel=\"noopener\">Luogu P1043</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很水的一道$dp$题目。只要知道断环为链剩下的也都不难。题解洛谷没给过，现在也找不到了，只有代码还剩了下来。代码里面也有注释，凑活看看也可以。</p>\n<p>update: 这是我写的第一篇题解啦！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num[<span class=\"number\">150</span>],dp_1[<span class=\"number\">150</span>],dp_2[<span class=\"number\">150</span>];<span class=\"comment\">//_1放最大值,_2放最小值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">mod</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> nnn)</span></span>&#123;<span class=\"comment\">//mod函数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = <span class=\"keyword\">int</span>(<span class=\"built_in\">floor</span>(<span class=\"keyword\">double</span>(nnn)/<span class=\"number\">10</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nnn - w*<span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;<span class=\"comment\">//断环为链的准备</span></span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;(num[i]));</span><br><span class=\"line\">        num[i+n] = num[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n;i++)<span class=\"comment\">//前缀和的处理</span></span><br><span class=\"line\">        num[i] = num[i<span class=\"number\">-1</span>]+num[i];</span><br><span class=\"line\">    <span class=\"comment\">//正经dp</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> maxn = <span class=\"number\">-1</span>,minn = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> s = <span class=\"number\">1</span>;s&lt;=n;s++)&#123;<span class=\"comment\">//枚举起点</span></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp_1,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dp_1));<span class=\"comment\">//清零dp数组</span></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(dp_2,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dp_2));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;j++)&#123;<span class=\"comment\">//板子由少到多</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s;i&lt;=s+n;i++)&#123;<span class=\"comment\">//上一个插板子的地方</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//j==0的时候的处理，其实也可以叫初始化</span></span><br><span class=\"line\">                    dp_1[i] = dp_2[i] = mod(num[s+n]-num[i]);</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> maxtmp = <span class=\"number\">-1</span>,mintmp = <span class=\"number\">0x3f3f3f3f</span>;<span class=\"comment\">//对所有可能下一状态的遍历，并取最大或最小值</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> x = i+<span class=\"number\">1</span>;x&lt;=s+n-j<span class=\"number\">-1</span>;x++)&#123;</span><br><span class=\"line\">                    maxtmp = max(maxtmp,dp_1[x]*mod(num[x]-num[i]));</span><br><span class=\"line\">                    mintmp = min(mintmp,dp_2[x]*mod(num[x]-num[i]));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp_1[i] = maxtmp;<span class=\"comment\">//取最大最小值</span></span><br><span class=\"line\">                dp_2[i] = mintmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maxn = max(dp_1[s],maxn);<span class=\"comment\">//对于起点不同的最大最小值进行更新</span></span><br><span class=\"line\">        minn = min(dp_2[s],minn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n%lld\\n\"</span>,minn,maxn);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>在你面前有一圈整数（一共$n$个），你要按顺序将其分为$m$个部分，各部分内的数字相加，相加所得的$m$个结果对10取模后再相乘，最终得到一个数$k$。游戏的要求是使你所得的$k$最大或者最小。<br>","more":"</p>\n<p>例如，对于下面这圈数字（$n$=4，$m$=2）：</p>\n<p><img src=\"description.png\" alt=\"\"></p>\n<p>要求最小值时，$((2-1) mod 10)×((4+3) mod 10)=1×7=7$，要求最大值时，为$((2+4+3) mod 10)×(-1 mod 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。</p>\n<p>丁丁请你编写程序帮他赢得这个游戏。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1043\" target=\"_blank\" rel=\"noopener\">Luogu P1043</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很水的一道$dp$题目。只要知道断环为链剩下的也都不难。题解洛谷没给过，现在也找不到了，只有代码还剩了下来。代码里面也有注释，凑活看看也可以。</p>\n<p>update: 这是我写的第一篇题解啦！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�30-->\n\n</div></div>"},{"title":"「Luogu2617」Dynamic Rankings-树状数组-可持久化线段树","urlname":"luogu2617-Dynamic-Rankings","date":"2018-05-12T10:05:36.000Z","visible":null,"_content":"\n给定一个含有$n$个数的序列$\\{a_n\\}$，回答询问或执行操作：\n\n+ `Q i j k` （$1\\leq i\\leq j\\leq n, 1\\leq k\\leq j-i+1$）表示询问$a[i],a[i+1]......a[j]$中第$k$小的数。\n\n+ `C i t` ($1 \\leq i \\leq n,0\\leq t \\leq 10^{9}$)表示把$a[i]$改变成为$t$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2617](https://www.luogu.org/problemnew/show/P2617)\n\n先在这里粗略的讲一讲。\n\n与普通主席树不同，令第$i$个位置的线段树维护$(i-lowbit(i),\\; i\\,]$这个区间的权值线段树，而不是$[1,\\;i\\,]$。\n\n这个时候，我们注意到，对于每一个修改，只会影响到$O(\\log{n})$个线段树。我们直接按树状数组的规则去修改，直接在原节点上建立一颗新树进行更改即可。\n\n而每次查询，也只会需要到$O(\\log{n})$个线段树，也就是两个树状数组前缀和相减，就可以得到指定区间的权值线段树。我们可以按照树状数组的方式先将权值线段树中要加上的节点和要减去的节点全部存到一个数组里，然后就可以按照不带修改区间$k$大差不多的样子去查询了。\n\n这里时空复杂度应该都是$O(n \\log^{2}{n})$。\n\n需要离散化。这里用了`map`。这里有一个地方易错。离散化出来的数可能比`n`要大，所以需要另记一个`totn`在树状数组查询修改和各种地方作为值域使用。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 50000;\n\nint n,m,totn = 0;\nint rt[MAXN],num[MAXN];\n\nint lowbit(int x){return x & (-x);}\n\nnamespace prSegTree{\n    int val[MAXN*50],ls[MAXN*50],rs[MAXN*50];\n    int cnt = 0;int ll[MAXN],rr[MAXN],totx,toty;\n    #define mid ((l+r) >> 1)\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;val[nown] = val[pre] + d;\n        ls[nown] = ls[pre],rs[nown] = rs[pre];\n        if(l == r) return;\n        else{\n            if(pos <= mid)\n                insert(ls[nown],ls[pre],l,mid,pos,d);\n            else if(pos >= mid+1)\n                insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    void update(int pos,int v,int d){\n        for(int i = pos;i<=totn;i += lowbit(i))\n            insert(rt[i],rt[i],1,totn,v,d);\n    }\n    void add(int l,int r){\n        totx = toty = 0;\n        for(int i = l-1;i;i-=lowbit(i))\n            ll[++totx] = rt[i];\n        for(int i = r;i;i-=lowbit(i))\n            rr[++toty] = rt[i];\n    }\n    int find_kth(int l,int r,int k){\n        int sum = 0;\n        if(l == r){\n            return l;\n        }\n        else{\n            for(int i = 1;i<=totx;i++) sum -= val[ls[ll[i]]];\n            for(int i = 1;i<=toty;i++) sum += val[ls[rr[i]]];   \n            if(k <= sum){\n                for(int i = 1;i<=totx;i++)  ll[i] = ls[ll[i]];\n                for(int i = 1;i<=toty;i++)  rr[i] = ls[rr[i]];\n                return find_kth(l,mid,k);\n            }\n            else{\n                for(int i = 1;i<=totx;i++)  ll[i] = rs[ll[i]];\n                for(int i = 1;i<=toty;i++)  rr[i] = rs[rr[i]];\n                return find_kth(mid+1,r,k-sum);\n            } \n        }  \n    }\n    int query(int l,int r,int k){\n        add(l,r);\n        return find_kth(1,totn,k);\n    }\n}\n \nmap<int,int> S;int last[MAXN];\n\nint op[MAXN],ql[MAXN],qr[MAXN],v[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]),S[num[i]] = 0;\n    char t[23];\n    for(int i = 1;i<=m;i++){\n        read(t);read(ql[i]),read(qr[i]);\n        if(t[0] == 'Q') op[i] = 1,read(v[i]);\n        else S[qr[i]] = 0;\n    }\n    for(auto it = S.begin();it != S.end();it++)\n        it->second = ++totn,last[totn] = it->first;\n    for(int i = 1;i<=n;i++)\n        prSegTree::update(i,S[num[i]],1);\n}\n\nvoid solve(){\n    for(int i = 1;i<=m;i++){\n        if(op[i] == 0)\n            prSegTree::update(ql[i],S[num[ql[i]]],-1),\n            prSegTree::update(ql[i],S[qr[i]],1),num[ql[i]] = qr[i]; \n        else\n            print(last[prSegTree::query(ql[i],qr[i],v[i])]),print('\\n');\n    }\n}\n\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「Luogu2617」Dynamic-Rankings-树状数组-可持久化线段树.md","raw":"---\ntitle: 「Luogu2617」Dynamic Rankings-树状数组-可持久化线段树\nurlname: luogu2617-Dynamic-Rankings\ndate: 2018-05-12 18:05:36\ntags:\ncategories:\nvisible:\n---\n\n给定一个含有$n$个数的序列$\\{a_n\\}$，回答询问或执行操作：\n\n+ `Q i j k` （$1\\leq i\\leq j\\leq n, 1\\leq k\\leq j-i+1$）表示询问$a[i],a[i+1]......a[j]$中第$k$小的数。\n\n+ `C i t` ($1 \\leq i \\leq n,0\\leq t \\leq 10^{9}$)表示把$a[i]$改变成为$t$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2617](https://www.luogu.org/problemnew/show/P2617)\n\n先在这里粗略的讲一讲。\n\n与普通主席树不同，令第$i$个位置的线段树维护$(i-lowbit(i),\\; i\\,]$这个区间的权值线段树，而不是$[1,\\;i\\,]$。\n\n这个时候，我们注意到，对于每一个修改，只会影响到$O(\\log{n})$个线段树。我们直接按树状数组的规则去修改，直接在原节点上建立一颗新树进行更改即可。\n\n而每次查询，也只会需要到$O(\\log{n})$个线段树，也就是两个树状数组前缀和相减，就可以得到指定区间的权值线段树。我们可以按照树状数组的方式先将权值线段树中要加上的节点和要减去的节点全部存到一个数组里，然后就可以按照不带修改区间$k$大差不多的样子去查询了。\n\n这里时空复杂度应该都是$O(n \\log^{2}{n})$。\n\n需要离散化。这里用了`map`。这里有一个地方易错。离散化出来的数可能比`n`要大，所以需要另记一个`totn`在树状数组查询修改和各种地方作为值域使用。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 50000;\n\nint n,m,totn = 0;\nint rt[MAXN],num[MAXN];\n\nint lowbit(int x){return x & (-x);}\n\nnamespace prSegTree{\n    int val[MAXN*50],ls[MAXN*50],rs[MAXN*50];\n    int cnt = 0;int ll[MAXN],rr[MAXN],totx,toty;\n    #define mid ((l+r) >> 1)\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;val[nown] = val[pre] + d;\n        ls[nown] = ls[pre],rs[nown] = rs[pre];\n        if(l == r) return;\n        else{\n            if(pos <= mid)\n                insert(ls[nown],ls[pre],l,mid,pos,d);\n            else if(pos >= mid+1)\n                insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    void update(int pos,int v,int d){\n        for(int i = pos;i<=totn;i += lowbit(i))\n            insert(rt[i],rt[i],1,totn,v,d);\n    }\n    void add(int l,int r){\n        totx = toty = 0;\n        for(int i = l-1;i;i-=lowbit(i))\n            ll[++totx] = rt[i];\n        for(int i = r;i;i-=lowbit(i))\n            rr[++toty] = rt[i];\n    }\n    int find_kth(int l,int r,int k){\n        int sum = 0;\n        if(l == r){\n            return l;\n        }\n        else{\n            for(int i = 1;i<=totx;i++) sum -= val[ls[ll[i]]];\n            for(int i = 1;i<=toty;i++) sum += val[ls[rr[i]]];   \n            if(k <= sum){\n                for(int i = 1;i<=totx;i++)  ll[i] = ls[ll[i]];\n                for(int i = 1;i<=toty;i++)  rr[i] = ls[rr[i]];\n                return find_kth(l,mid,k);\n            }\n            else{\n                for(int i = 1;i<=totx;i++)  ll[i] = rs[ll[i]];\n                for(int i = 1;i<=toty;i++)  rr[i] = rs[rr[i]];\n                return find_kth(mid+1,r,k-sum);\n            } \n        }  \n    }\n    int query(int l,int r,int k){\n        add(l,r);\n        return find_kth(1,totn,k);\n    }\n}\n \nmap<int,int> S;int last[MAXN];\n\nint op[MAXN],ql[MAXN],qr[MAXN],v[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]),S[num[i]] = 0;\n    char t[23];\n    for(int i = 1;i<=m;i++){\n        read(t);read(ql[i]),read(qr[i]);\n        if(t[0] == 'Q') op[i] = 1,read(v[i]);\n        else S[qr[i]] = 0;\n    }\n    for(auto it = S.begin();it != S.end();it++)\n        it->second = ++totn,last[totn] = it->first;\n    for(int i = 1;i<=n;i++)\n        prSegTree::update(i,S[num[i]],1);\n}\n\nvoid solve(){\n    for(int i = 1;i<=m;i++){\n        if(op[i] == 0)\n            prSegTree::update(ql[i],S[num[ql[i]]],-1),\n            prSegTree::update(ql[i],S[qr[i]],1),num[ql[i]] = qr[i]; \n        else\n            print(last[prSegTree::query(ql[i],qr[i],v[i])]),print('\\n');\n    }\n}\n\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「Luogu2617」Dynamic-Rankings-树状数组-可持久化线段树","published":1,"updated":"2018-05-12T12:49:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3j0002xbljrf3pap6c1","content":"<p>给定一个含有$n$个数的序列${a_n}$，回答询问或执行操作：</p>\n<ul>\n<li><p><code>Q i j k</code> （$1\\leq i\\leq j\\leq n, 1\\leq k\\leq j-i+1$）表示询问$a[i],a[i+1]……a[j]$中第$k$小的数。</p>\n</li>\n<li><p><code>C i t</code> ($1 \\leq i \\leq n,0\\leq t \\leq 10^{9}$)表示把$a[i]$改变成为$t$。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2617\" target=\"_blank\" rel=\"noopener\">Luogu P2617</a></p>\n<p>先在这里粗略的讲一讲。</p>\n<p>与普通主席树不同，令第$i$个位置的线段树维护$(i-lowbit(i),\\; i\\,]$这个区间的权值线段树，而不是$[1,\\;i\\,]$。</p>\n<p>这个时候，我们注意到，对于每一个修改，只会影响到$O(\\log{n})$个线段树。我们直接按树状数组的规则去修改，直接在原节点上建立一颗新树进行更改即可。</p>\n<p>而每次查询，也只会需要到$O(\\log{n})$个线段树，也就是两个树状数组前缀和相减，就可以得到指定区间的权值线段树。我们可以按照树状数组的方式先将权值线段树中要加上的节点和要减去的节点全部存到一个数组里，然后就可以按照不带修改区间$k$大差不多的样子去查询了。</p>\n<p>这里时空复杂度应该都是$O(n \\log^{2}{n})$。</p>\n<p>需要离散化。这里用了<code>map</code>。这里有一个地方易错。离散化出来的数可能比<code>n</code>要大，所以需要另记一个<code>totn</code>在树状数组查询修改和各种地方作为值域使用。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">50000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,totn = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rt[MAXN],num[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;<span class=\"keyword\">return</span> x &amp; (-x);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> prSegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val[MAXN*<span class=\"number\">50</span>],ls[MAXN*<span class=\"number\">50</span>],rs[MAXN*<span class=\"number\">50</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;<span class=\"keyword\">int</span> ll[MAXN],rr[MAXN],totx,toty;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r) &gt;&gt; 1)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        nown = ++cnt;val[nown] = val[pre] + d;</span><br><span class=\"line\">        ls[nown] = ls[pre],rs[nown] = rs[pre];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">                insert(ls[nown],ls[pre],l,mid,pos,d);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pos &gt;= mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">                insert(rs[nown],rs[pre],mid+<span class=\"number\">1</span>,r,pos,d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = pos;i&lt;=totn;i += lowbit(i))</span><br><span class=\"line\">            insert(rt[i],rt[i],<span class=\"number\">1</span>,totn,v,d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        totx = toty = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = l<span class=\"number\">-1</span>;i;i-=lowbit(i))</span><br><span class=\"line\">            ll[++totx] = rt[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = r;i;i-=lowbit(i))</span><br><span class=\"line\">            rr[++toty] = rt[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find_kth</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=totx;i++) sum -= val[ls[ll[i]]];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=toty;i++) sum += val[ls[rr[i]]];   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k &lt;= sum)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=totx;i++)  ll[i] = ls[ll[i]];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=toty;i++)  rr[i] = ls[rr[i]];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> find_kth(l,mid,k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=totx;i++)  ll[i] = rs[ll[i]];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=toty;i++)  rr[i] = rs[rr[i]];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> find_kth(mid+<span class=\"number\">1</span>,r,k-sum);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        add(l,r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find_kth(<span class=\"number\">1</span>,totn,k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; S;<span class=\"keyword\">int</span> last[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> op[MAXN],ql[MAXN],qr[MAXN],v[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]),S[num[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> t[<span class=\"number\">23</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(t);read(ql[i]),read(qr[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>) op[i] = <span class=\"number\">1</span>,read(v[i]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> S[qr[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = S.begin();it != S.end();it++)</span><br><span class=\"line\">        it-&gt;second = ++totn,last[totn] = it-&gt;first;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        prSegTree::update(i,S[num[i]],<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            prSegTree::update(ql[i],S[num[ql[i]]],<span class=\"number\">-1</span>),</span><br><span class=\"line\">            prSegTree::update(ql[i],S[qr[i]],<span class=\"number\">1</span>),num[ql[i]] = qr[i]; </span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            print(last[prSegTree::query(ql[i],qr[i],v[i])]),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>给定一个含有$n$个数的序列${a_n}$，回答询问或执行操作：</p>\n<ul>\n<li><p><code>Q i j k</code> （$1\\leq i\\leq j\\leq n, 1\\leq k\\leq j-i+1$）表示询问$a[i],a[i+1]……a[j]$中第$k$小的数。</p>\n</li>\n<li><p><code>C i t</code> ($1 \\leq i \\leq n,0\\leq t \\leq 10^{9}$)表示把$a[i]$改变成为$t$。</p>\n</li>\n</ul>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2617\" target=\"_blank\" rel=\"noopener\">Luogu P2617</a></p>\n<p>先在这里粗略的讲一讲。</p>\n<p>与普通主席树不同，令第$i$个位置的线段树维护$(i-lowbit(i),\\; i\\,]$这个区间的权值线段树，而不是$[1,\\;i\\,]$。</p>\n<p>这个时候，我们注意到，对于每一个修改，只会影响到$O(\\log{n})$个线段树。我们直接按树状数组的规则去修改，直接在原节点上建立一颗新树进行更改即可。</p>\n<p>而每次查询，也只会需要到$O(\\log{n})$个线段树，也就是两个树状数组前缀和相减，就可以得到指定区间的权值线段树。我们可以按照树状数组的方式先将权值线段树中要加上的节点和要减去的节点全部存到一个数组里，然后就可以按照不带修改区间$k$大差不多的样子去查询了。</p>\n<p>这里时空复杂度应该都是$O(n \\log^{2}{n})$。</p>\n<p>需要离散化。这里用了<code>map</code>。这里有一个地方易错。离散化出来的数可能比<code>n</code>要大，所以需要另记一个<code>totn</code>在树状数组查询修改和各种地方作为值域使用。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�31-->\n\n</div></div>"},{"title":"「Luogu3765」总统选举-平衡树-线段树","urlname":"luogu-3765","date":"2018-04-25T15:30:25.000Z","visible":null,"_content":"\n\n秋之国共有$n$个人，分别编号为$1,2,...,n$，一开始每个人都投了一票，范围$[1,n]$，表示支持对应编号的人当总统。共有$m$次预选，每次选取编号$[l_i,r_i]$内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜，如果没有人获胜，则由小$C$钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有$k_i$个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人，没有候选人的话输出$-1$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3765](https://www.luogu.org/problemnew/show/P3765)\n\n## 题解\n\n非常有趣的一道题。\n\nBZOJ的2456可以启发到这道题。\n\n那道题是：\n\n> 给你一个$n$个数的数列，其中某个数出现了超过$\\frac {n}{2}$次即为绝对众数，请你找出那个数。\n\n做法则是:\n\n> 如果众数出现了超过$\\frac {n}{2}$次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。*(摘自[Menci's Blog](https://oi.men.ci/bzoj-2456))*\n\n这件事是可以用线段树维护的。\n\n所以可以用线段树维护这个信息，就可以在$O(\\log {n})$的时间里查询到某个区间可能的区间绝对众数。可以证明，如果区间有绝对众数，那么这个数一定就是。但是也可以发现，这个数不一定就是绝对众数，所以我们需要检验。\n\n这个时候我们建立$n$棵平衡树，共用一个$pool$。我们可以直接用数组中的节点编号来代表它的$val$。检验的时候，找到待查询数字的根节点，然后查询在$[l,r]$区间内有多少个数，也就是$getrank(r+1) - getrank(l)$。然后就可以检验出给定的数是不是给定的区间的绝对众数了。\n\n修改投票也很简单，线段树直接修改然后一路维护就好，平衡树的话就在旧树里删掉，新树里加上就可以了。\n\n时间复杂度大概是\n\n$$O((n+\\sum_{i = 1}^{n} {k_i}) \\log {n})$$\n\n可以过掉本题。\n\n> 妙啊！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\nconst int MAXN = 550000;\nint n,m,num[MAXN];\n\n//平衡树\nnamespace Treap{\nint nowcnt = 0;\nint p[MAXN],son[MAXN][2];\nint siz[MAXN];\nint root[MAXN];\nvoid update(int x){\n    siz[x] = siz[son[x][0]] + siz[son[x][1]] + 1;\n}\nvoid rotate(int &x,int t){\n    int y = son[x][t];\n    son[x][t] = son[y][1-t];\n    son[y][1-t] = x;\n    update(x),update(y);\n    x = y;\n}\nvoid insert(int &x,int v){\n    if(!x){\n        x = v,p[x] = rand();\n    }\n    else{\n        int t = v > x;\n        insert(son[x][t],v);\n        if(p[son[x][t]] < p[x])\n            rotate(x,t);\n    }\n    update(x);\n}\nvoid erase(int &x,int v){\n    if(x == v){\n        if(!son[x][0] && !son[x][1]){\n            x = 0;return;\n        }\n        int t = p[son[x][0]] > p[son[x][1]];\n        rotate(x,t);\n        erase(x,v);\n    }\n    else{\n        erase(son[x][v > x],v);\n    }\n    update(x);\n}\nint grank(int r,int v){\n    int x = r,ans = 0;\n    while(x){\n        if(v < x)\n            x = son[x][0];\n        else if(v == x)\n            ans += siz[son[x][0]],x = 0;\n        else\n            ans += siz[son[x][0]]+1,x = son[x][1]; \n    }\n    return ans;\n}\nvoid __print(int x,int dep){\n    if(dep == 0)\n        printf(\"%d:-------------------\\n\",x);\n    if(x == 0) return;\n    __print(son[x][0],dep+1);\n    for(int i = 0;i<dep;i++) putchar(' ');\n    printf(\"v:%d p:%d siz:%d son:%d %d\\n\",x,p[x],siz[x],son[x][0],son[x][1]);\n    __print(son[x][1],dep+1);\n    if(dep == 0)\n        printf(\"---------------------\\n\");\n}\nbool check(int num,int l,int r){\n    return 2*(grank(root[num],r+1)-grank(root[num],l)) > r-l+1;\n}\nvoid update(int pos,int last,int now){\n    erase(root[last],pos);\n    insert(root[now],pos);\n}\nvoid init(int *a){\n    p[0] = 2147483647;\n    for(int i = 1;i<=n;i++)\n        insert(root[a[i]],i);\n}\n}\n\n//线段树\nnamespace seg_tree{\n#define lson (nown<<1)\n#define rson ((nown<<1)|1)\n#define mid ((l+r)>>1)\n#define pp pair<int,int>\n#define fr first\n#define sc second\npp tree[MAXN<<2];\npp merge(pp a,pp b){\n    pp ans;\n    if(a.fr == b.fr)\n        ans.fr = a.fr,ans.sc = a.sc + b.sc;\n    else{\n        ans.fr = a.sc > b.sc?a.fr:b.fr;\n        ans.sc = a.sc - b.sc;\n        if(ans.sc < 0) ans.sc *= -1;\n    }\n    return ans;\n}\nvoid update(int nown){\n    tree[nown] = merge(tree[lson],tree[rson]);\n}\nvoid build(int nown,int l,int r,int *a){\n    if(l == r){\n        tree[nown] = make_pair(a[l],1);\n        return;\n    }\n    build(lson,l,mid,a);\n    build(rson,mid+1,r,a);\n    update(nown);\n}\npp query(int nown,int l,int r,int ql,int qr){\n    if(ql <= l && r <= qr)\n        return tree[nown];\n    else{\n        pp ans;\n        if(ql <= mid && mid+1 <= qr)\n            ans = merge(query(lson,l,mid,ql,qr),query(rson,mid+1,r,ql,qr));              \n        else if(ql <= mid)\n            ans = query(lson,l,mid,ql,qr);\n        else if(mid+1 <= qr)\n            ans = query(rson,mid+1,r,ql,qr);\n        return ans;\n    }\n}\nvoid update(int nown,int l,int r,int pos,int val){\n    if(l == r)\n        tree[nown] = make_pair(val,1);\n    else{\n        if(pos<=mid)\n            update(lson,l,mid,pos,val);\n        if(pos>=mid+1)\n            update(rson,mid+1,r,pos,val);\n        update(nown);\n    }\n}\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    seg_tree::build(1,1,n,num);\n    Treap::init(num);\n}\n\nvoid solve(){\n    int l,r,s,k,t,win;\n    for(int i = 1;i<=m;i++){\n        read(l),read(r),read(s),read(k);\n        win = seg_tree::query(1,1,n,l,r).first;\n        win = Treap::check(win,l,r)? win:s;\n        for(int i = 1;i<=k;i++){\n            read(t);\n            Treap::update(t,num[t],win);\n            seg_tree::update(1,1,n,t,win);\n            num[t] = win;\n        }\n        print(win),print('\\n');\n    }\n    win = seg_tree::query(1,1,n,1,n).first;\n    win = Treap::check(win,1,n)?win:-1;\n    print(win),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","source":"_posts/「Luogu3765」总统选举-平衡树-线段树.md","raw":"---\ntitle: 「Luogu3765」总统选举-平衡树-线段树\nurlname: luogu-3765\ndate: 2018-04-25 23:30:25\ntags:\n- 题解\n- 数据结构\n- 平衡树\n- 线段树\ncategories: OI\nvisible:\n---\n\n\n秋之国共有$n$个人，分别编号为$1,2,...,n$，一开始每个人都投了一票，范围$[1,n]$，表示支持对应编号的人当总统。共有$m$次预选，每次选取编号$[l_i,r_i]$内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜，如果没有人获胜，则由小$C$钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有$k_i$个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人，没有候选人的话输出$-1$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3765](https://www.luogu.org/problemnew/show/P3765)\n\n## 题解\n\n非常有趣的一道题。\n\nBZOJ的2456可以启发到这道题。\n\n那道题是：\n\n> 给你一个$n$个数的数列，其中某个数出现了超过$\\frac {n}{2}$次即为绝对众数，请你找出那个数。\n\n做法则是:\n\n> 如果众数出现了超过$\\frac {n}{2}$次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。*(摘自[Menci's Blog](https://oi.men.ci/bzoj-2456))*\n\n这件事是可以用线段树维护的。\n\n所以可以用线段树维护这个信息，就可以在$O(\\log {n})$的时间里查询到某个区间可能的区间绝对众数。可以证明，如果区间有绝对众数，那么这个数一定就是。但是也可以发现，这个数不一定就是绝对众数，所以我们需要检验。\n\n这个时候我们建立$n$棵平衡树，共用一个$pool$。我们可以直接用数组中的节点编号来代表它的$val$。检验的时候，找到待查询数字的根节点，然后查询在$[l,r]$区间内有多少个数，也就是$getrank(r+1) - getrank(l)$。然后就可以检验出给定的数是不是给定的区间的绝对众数了。\n\n修改投票也很简单，线段树直接修改然后一路维护就好，平衡树的话就在旧树里删掉，新树里加上就可以了。\n\n时间复杂度大概是\n\n$$O((n+\\sum_{i = 1}^{n} {k_i}) \\log {n})$$\n\n可以过掉本题。\n\n> 妙啊！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\nconst int MAXN = 550000;\nint n,m,num[MAXN];\n\n//平衡树\nnamespace Treap{\nint nowcnt = 0;\nint p[MAXN],son[MAXN][2];\nint siz[MAXN];\nint root[MAXN];\nvoid update(int x){\n    siz[x] = siz[son[x][0]] + siz[son[x][1]] + 1;\n}\nvoid rotate(int &x,int t){\n    int y = son[x][t];\n    son[x][t] = son[y][1-t];\n    son[y][1-t] = x;\n    update(x),update(y);\n    x = y;\n}\nvoid insert(int &x,int v){\n    if(!x){\n        x = v,p[x] = rand();\n    }\n    else{\n        int t = v > x;\n        insert(son[x][t],v);\n        if(p[son[x][t]] < p[x])\n            rotate(x,t);\n    }\n    update(x);\n}\nvoid erase(int &x,int v){\n    if(x == v){\n        if(!son[x][0] && !son[x][1]){\n            x = 0;return;\n        }\n        int t = p[son[x][0]] > p[son[x][1]];\n        rotate(x,t);\n        erase(x,v);\n    }\n    else{\n        erase(son[x][v > x],v);\n    }\n    update(x);\n}\nint grank(int r,int v){\n    int x = r,ans = 0;\n    while(x){\n        if(v < x)\n            x = son[x][0];\n        else if(v == x)\n            ans += siz[son[x][0]],x = 0;\n        else\n            ans += siz[son[x][0]]+1,x = son[x][1]; \n    }\n    return ans;\n}\nvoid __print(int x,int dep){\n    if(dep == 0)\n        printf(\"%d:-------------------\\n\",x);\n    if(x == 0) return;\n    __print(son[x][0],dep+1);\n    for(int i = 0;i<dep;i++) putchar(' ');\n    printf(\"v:%d p:%d siz:%d son:%d %d\\n\",x,p[x],siz[x],son[x][0],son[x][1]);\n    __print(son[x][1],dep+1);\n    if(dep == 0)\n        printf(\"---------------------\\n\");\n}\nbool check(int num,int l,int r){\n    return 2*(grank(root[num],r+1)-grank(root[num],l)) > r-l+1;\n}\nvoid update(int pos,int last,int now){\n    erase(root[last],pos);\n    insert(root[now],pos);\n}\nvoid init(int *a){\n    p[0] = 2147483647;\n    for(int i = 1;i<=n;i++)\n        insert(root[a[i]],i);\n}\n}\n\n//线段树\nnamespace seg_tree{\n#define lson (nown<<1)\n#define rson ((nown<<1)|1)\n#define mid ((l+r)>>1)\n#define pp pair<int,int>\n#define fr first\n#define sc second\npp tree[MAXN<<2];\npp merge(pp a,pp b){\n    pp ans;\n    if(a.fr == b.fr)\n        ans.fr = a.fr,ans.sc = a.sc + b.sc;\n    else{\n        ans.fr = a.sc > b.sc?a.fr:b.fr;\n        ans.sc = a.sc - b.sc;\n        if(ans.sc < 0) ans.sc *= -1;\n    }\n    return ans;\n}\nvoid update(int nown){\n    tree[nown] = merge(tree[lson],tree[rson]);\n}\nvoid build(int nown,int l,int r,int *a){\n    if(l == r){\n        tree[nown] = make_pair(a[l],1);\n        return;\n    }\n    build(lson,l,mid,a);\n    build(rson,mid+1,r,a);\n    update(nown);\n}\npp query(int nown,int l,int r,int ql,int qr){\n    if(ql <= l && r <= qr)\n        return tree[nown];\n    else{\n        pp ans;\n        if(ql <= mid && mid+1 <= qr)\n            ans = merge(query(lson,l,mid,ql,qr),query(rson,mid+1,r,ql,qr));              \n        else if(ql <= mid)\n            ans = query(lson,l,mid,ql,qr);\n        else if(mid+1 <= qr)\n            ans = query(rson,mid+1,r,ql,qr);\n        return ans;\n    }\n}\nvoid update(int nown,int l,int r,int pos,int val){\n    if(l == r)\n        tree[nown] = make_pair(val,1);\n    else{\n        if(pos<=mid)\n            update(lson,l,mid,pos,val);\n        if(pos>=mid+1)\n            update(rson,mid+1,r,pos,val);\n        update(nown);\n    }\n}\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    seg_tree::build(1,1,n,num);\n    Treap::init(num);\n}\n\nvoid solve(){\n    int l,r,s,k,t,win;\n    for(int i = 1;i<=m;i++){\n        read(l),read(r),read(s),read(k);\n        win = seg_tree::query(1,1,n,l,r).first;\n        win = Treap::check(win,l,r)? win:s;\n        for(int i = 1;i<=k;i++){\n            read(t);\n            Treap::update(t,num[t],win);\n            seg_tree::update(1,1,n,t,win);\n            num[t] = win;\n        }\n        print(win),print('\\n');\n    }\n    win = seg_tree::query(1,1,n,1,n).first;\n    win = Treap::check(win,1,n)?win:-1;\n    print(win),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","slug":"「Luogu3765」总统选举-平衡树-线段树","published":1,"updated":"2018-05-05T14:49:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3j40030bljrrwu4as6j","content":"<p>秋之国共有$n$个人，分别编号为$1,2,…,n$，一开始每个人都投了一票，范围$[1,n]$，表示支持对应编号的人当总统。共有$m$次预选，每次选取编号$[l_i,r_i]$内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜，如果没有人获胜，则由小$C$钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有$k_i$个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人，没有候选人的话输出$-1$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3765\" target=\"_blank\" rel=\"noopener\">Luogu P3765</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>非常有趣的一道题。</p>\n<p>BZOJ的2456可以启发到这道题。</p>\n<p>那道题是：</p>\n<blockquote>\n<p>给你一个$n$个数的数列，其中某个数出现了超过$\\frac {n}{2}$次即为绝对众数，请你找出那个数。</p>\n</blockquote>\n<p>做法则是:</p>\n<blockquote>\n<p>如果众数出现了超过$\\frac {n}{2}$次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。<em>(摘自<a href=\"https://oi.men.ci/bzoj-2456\" target=\"_blank\" rel=\"noopener\">Menci’s Blog</a>)</em></p>\n</blockquote>\n<p>这件事是可以用线段树维护的。</p>\n<p>所以可以用线段树维护这个信息，就可以在$O(\\log {n})$的时间里查询到某个区间可能的区间绝对众数。可以证明，如果区间有绝对众数，那么这个数一定就是。但是也可以发现，这个数不一定就是绝对众数，所以我们需要检验。</p>\n<p>这个时候我们建立$n$棵平衡树，共用一个$pool$。我们可以直接用数组中的节点编号来代表它的$val$。检验的时候，找到待查询数字的根节点，然后查询在$[l,r]$区间内有多少个数，也就是$getrank(r+1) - getrank(l)$。然后就可以检验出给定的数是不是给定的区间的绝对众数了。</p>\n<p>修改投票也很简单，线段树直接修改然后一路维护就好，平衡树的话就在旧树里删掉，新树里加上就可以了。</p>\n<p>时间复杂度大概是</p>\n<p>$$O((n+\\sum_{i = 1}^{n} {k_i}) \\log {n})$$</p>\n<p>可以过掉本题。</p>\n<blockquote>\n<p>妙啊！</p>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">550000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,num[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//平衡树</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Treap&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nowcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[MAXN],son[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> siz[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> root[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    siz[x] = siz[son[x][<span class=\"number\">0</span>]] + siz[son[x][<span class=\"number\">1</span>]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x,<span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y = son[x][t];</span><br><span class=\"line\">    son[x][t] = son[y][<span class=\"number\">1</span>-t];</span><br><span class=\"line\">    son[y][<span class=\"number\">1</span>-t] = x;</span><br><span class=\"line\">    update(x),update(y);</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!x)&#123;</span><br><span class=\"line\">        x = v,p[x] = rand();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = v &gt; x;</span><br><span class=\"line\">        insert(son[x][t],v);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p[son[x][t]] &lt; p[x])</span><br><span class=\"line\">            rotate(x,t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!son[x][<span class=\"number\">0</span>] &amp;&amp; !son[x][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            x = <span class=\"number\">0</span>;<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = p[son[x][<span class=\"number\">0</span>]] &gt; p[son[x][<span class=\"number\">1</span>]];</span><br><span class=\"line\">        rotate(x,t);</span><br><span class=\"line\">        erase(x,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        erase(son[x][v &gt; x],v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    update(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">grank</span><span class=\"params\">(<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = r,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v &lt; x)</span><br><span class=\"line\">            x = son[x][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(v == x)</span><br><span class=\"line\">            ans += siz[son[x][<span class=\"number\">0</span>]],x = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ans += siz[son[x][<span class=\"number\">0</span>]]+<span class=\"number\">1</span>,x = son[x][<span class=\"number\">1</span>]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> __print(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> dep)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d:-------------------\\n\"</span>,x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    __print(son[x][<span class=\"number\">0</span>],dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;dep;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"v:%d p:%d siz:%d son:%d %d\\n\"</span>,x,p[x],siz[x],son[x][<span class=\"number\">0</span>],son[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">    __print(son[x][<span class=\"number\">1</span>],dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"---------------------\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span> num,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>*(grank(root[num],r+<span class=\"number\">1</span>)-grank(root[num],l)) &gt; r-l+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> last,<span class=\"keyword\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">    erase(root[last],pos);</span><br><span class=\"line\">    insert(root[now],pos);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> *a)</span></span>&#123;</span><br><span class=\"line\">    p[<span class=\"number\">0</span>] = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        insert(root[a[i]],i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> seg_tree&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson (nown&lt;&lt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson ((nown&lt;&lt;1)|1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pp pair<span class=\"meta-string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> fr first</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> sc second</span></span><br><span class=\"line\">pp tree[MAXN&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\">pp <span class=\"title\">merge</span><span class=\"params\">(pp a,pp b)</span></span>&#123;</span><br><span class=\"line\">    pp ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.fr == b.fr)</span><br><span class=\"line\">        ans.fr = a.fr,ans.sc = a.sc + b.sc;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        ans.fr = a.sc &gt; b.sc?a.fr:b.fr;</span><br><span class=\"line\">        ans.sc = a.sc - b.sc;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans.sc &lt; <span class=\"number\">0</span>) ans.sc *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    tree[nown] = merge(tree[lson],tree[rson]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> *a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        tree[nown] = make_pair(a[l],<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    build(lson,l,mid,a);</span><br><span class=\"line\">    build(rson,mid+<span class=\"number\">1</span>,r,a);</span><br><span class=\"line\">    update(nown);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">pp <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tree[nown];</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        pp ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql &lt;= mid &amp;&amp; mid+<span class=\"number\">1</span> &lt;= qr)</span><br><span class=\"line\">            ans = merge(query(lson,l,mid,ql,qr),query(rson,mid+<span class=\"number\">1</span>,r,ql,qr));              </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ql &lt;= mid)</span><br><span class=\"line\">            ans = query(lson,l,mid,ql,qr);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= qr)</span><br><span class=\"line\">            ans = query(rson,mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">        tree[nown] = make_pair(val,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos&lt;=mid)</span><br><span class=\"line\">            update(lson,l,mid,pos,val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos&gt;=mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">            update(rson,mid+<span class=\"number\">1</span>,r,pos,val);</span><br><span class=\"line\">        update(nown);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">    seg_tree::build(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,num);</span><br><span class=\"line\">    Treap::init(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l,r,s,k,t,win;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(l),read(r),read(s),read(k);</span><br><span class=\"line\">        win = seg_tree::query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r).first;</span><br><span class=\"line\">        win = Treap::check(win,l,r)? win:s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">            read(t);</span><br><span class=\"line\">            Treap::update(t,num[t],win);</span><br><span class=\"line\">            seg_tree::update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,t,win);</span><br><span class=\"line\">            num[t] = win;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        print(win),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    win = seg_tree::query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,n).first;</span><br><span class=\"line\">    win = Treap::check(win,<span class=\"number\">1</span>,n)?win:<span class=\"number\">-1</span>;</span><br><span class=\"line\">    print(win),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>秋之国共有$n$个人，分别编号为$1,2,…,n$，一开始每个人都投了一票，范围$[1,n]$，表示支持对应编号的人当总统。共有$m$次预选，每次选取编号$[l_i,r_i]$内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜，如果没有人获胜，则由小$C$钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有$k_i$个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人，没有候选人的话输出$-1$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3765\" target=\"_blank\" rel=\"noopener\">Luogu P3765</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>非常有趣的一道题。</p>\n<p>BZOJ的2456可以启发到这道题。</p>\n<p>那道题是：</p>\n<blockquote>\n<p>给你一个$n$个数的数列，其中某个数出现了超过$\\frac {n}{2}$次即为绝对众数，请你找出那个数。</p>\n</blockquote>\n<p>做法则是:</p>\n<blockquote>\n<p>如果众数出现了超过$\\frac {n}{2}$次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。<em>(摘自<a href=\"https://oi.men.ci/bzoj-2456\" target=\"_blank\" rel=\"noopener\">Menci’s Blog</a>)</em></p>\n</blockquote>\n<p>这件事是可以用线段树维护的。</p>\n<p>所以可以用线段树维护这个信息，就可以在$O(\\log {n})$的时间里查询到某个区间可能的区间绝对众数。可以证明，如果区间有绝对众数，那么这个数一定就是。但是也可以发现，这个数不一定就是绝对众数，所以我们需要检验。</p>\n<p>这个时候我们建立$n$棵平衡树，共用一个$pool$。我们可以直接用数组中的节点编号来代表它的$val$。检验的时候，找到待查询数字的根节点，然后查询在$[l,r]$区间内有多少个数，也就是$getrank(r+1) - getrank(l)$。然后就可以检验出给定的数是不是给定的区间的绝对众数了。</p>\n<p>修改投票也很简单，线段树直接修改然后一路维护就好，平衡树的话就在旧树里删掉，新树里加上就可以了。</p>\n<p>时间复杂度大概是</p>\n<p>$$O((n+\\sum_{i = 1}^{n} {k_i}) \\log {n})$$</p>\n<p>可以过掉本题。</p>\n<blockquote>\n<p>妙啊！</p>\n</blockquote>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�32-->\n\n</div></div>"},{"title":"「NOI2002」银河英雄传说-并查集","urlname":"noi2002-hero","date":"2018-02-11T08:27:45.000Z","visible":null,"_content":"\n初始时，第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$。\n\n有两种指令：\n\n合并指令为$M\\ i\\ j$，含义为将第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第$j$号战舰所在的战舰队列的尾部。\n\n询问指令为$C\\ i\\ j$。该指令意思询问第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1196](https://www.luogu.org/problemnew/show/P1196)\n\n## 题解\n\n一道并查集的题目。\n\n因为快速的寻找两个战舰是否在同一列里面，我们可以使用并查集数据结构。但注意到题目还要询问两个战舰之间的距离，我们需要额外维护一些信息，所以我们需要用加权的并查集。\n\n说的加权，事实上就是在每一个节点上额外维护一些信息。在这里，我们在节点上额外维护到父节点的距离，在根节点处维护这个集合的大小。\n\n在寻找某个节点的时候，我们仍然可以进行路径压缩。只需要先对父节点递归完成后，把权值加上父节点的权值，然后就可以直接连到根上。\n\n合并操作也差不多。为了使合并操作简单，我们需要保证父节点一定在子节点前面。这样，我们找到的根节点就是每个队列的最前方的节点。然后可以将后面接上的节点的父亲指向前面的节点，距离设为前面的集合的大小，就可以维护了。\n\n查询距离的时候，只需要把两个节点到根的距离算出来，作差取绝对值，然后再减去1即可。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define MAXN 30010\nusing namespace std;\n\nint f[MAXN],d[MAXN],s[MAXN],t;\n// f 维护父亲节点，d 维护于父亲节点的距离，s 在根节点处维护集合的元素数\n\nint find(int x){\n    if(f[x] == x){\n        return x;\n    }\n    else{\n        int w = find(f[x]);\n        d[x] += d[f[x]];\n        f[x] = w;\n        return w;\n    }\n}\n\nvoid un(int x,int y){\n    int b = find(y),e = find(x);\n    if(b == e){\n        return;\n    }\n    else{\n        d[e] = s[b],d[b] = 0;\n        s[b] = s[b] + s[e],s[e] = 0;\n        f[e] = b;\n        return;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&t);\n    for(int i = 1;i<MAXN;i++){\n        f[i] = i,d[i] = 0,s[i] = 1;\n    }\n    for(int i = 1;i<=t;i++){\n        char op[20];int a,b;\n        scanf(\"%s\",op);\n        scanf(\"%d %d\",&a,&b);\n        if(op[0] == 'M'){\n            un(a,b);\n        }\n        else{\n            int a1 = find(a),b1 = find(b);\n            if(a1!=b1){\n                printf(\"-1\\n\");\n            }\n            else{\n                printf(\"%d\\n\",abs(d[a]-d[b])-1);\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n{% endfold %}","source":"_posts/「NOI2002」银河英雄传说-并查集.md","raw":"---\ntitle: 「NOI2002」银河英雄传说-并查集\nurlname: noi2002-hero\ndate: 2018-02-11 16:27:45\ntags:\n- 题解\n- 数据结构\n- 并查集\ncategories: OI\nvisible:\n---\n\n初始时，第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$。\n\n有两种指令：\n\n合并指令为$M\\ i\\ j$，含义为将第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第$j$号战舰所在的战舰队列的尾部。\n\n询问指令为$C\\ i\\ j$。该指令意思询问第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1196](https://www.luogu.org/problemnew/show/P1196)\n\n## 题解\n\n一道并查集的题目。\n\n因为快速的寻找两个战舰是否在同一列里面，我们可以使用并查集数据结构。但注意到题目还要询问两个战舰之间的距离，我们需要额外维护一些信息，所以我们需要用加权的并查集。\n\n说的加权，事实上就是在每一个节点上额外维护一些信息。在这里，我们在节点上额外维护到父节点的距离，在根节点处维护这个集合的大小。\n\n在寻找某个节点的时候，我们仍然可以进行路径压缩。只需要先对父节点递归完成后，把权值加上父节点的权值，然后就可以直接连到根上。\n\n合并操作也差不多。为了使合并操作简单，我们需要保证父节点一定在子节点前面。这样，我们找到的根节点就是每个队列的最前方的节点。然后可以将后面接上的节点的父亲指向前面的节点，距离设为前面的集合的大小，就可以维护了。\n\n查询距离的时候，只需要把两个节点到根的距离算出来，作差取绝对值，然后再减去1即可。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define MAXN 30010\nusing namespace std;\n\nint f[MAXN],d[MAXN],s[MAXN],t;\n// f 维护父亲节点，d 维护于父亲节点的距离，s 在根节点处维护集合的元素数\n\nint find(int x){\n    if(f[x] == x){\n        return x;\n    }\n    else{\n        int w = find(f[x]);\n        d[x] += d[f[x]];\n        f[x] = w;\n        return w;\n    }\n}\n\nvoid un(int x,int y){\n    int b = find(y),e = find(x);\n    if(b == e){\n        return;\n    }\n    else{\n        d[e] = s[b],d[b] = 0;\n        s[b] = s[b] + s[e],s[e] = 0;\n        f[e] = b;\n        return;\n    }\n}\n\nint main(){\n    scanf(\"%d\",&t);\n    for(int i = 1;i<MAXN;i++){\n        f[i] = i,d[i] = 0,s[i] = 1;\n    }\n    for(int i = 1;i<=t;i++){\n        char op[20];int a,b;\n        scanf(\"%s\",op);\n        scanf(\"%d %d\",&a,&b);\n        if(op[0] == 'M'){\n            un(a,b);\n        }\n        else{\n            int a1 = find(a),b1 = find(b);\n            if(a1!=b1){\n                printf(\"-1\\n\");\n            }\n            else{\n                printf(\"%d\\n\",abs(d[a]-d[b])-1);\n            }\n        }\n    }\n    return 0;\n}\n\n```\n\n{% endfold %}","slug":"「NOI2002」银河英雄传说-并查集","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3j80033bljro9qe6bw9","content":"<p>初始时，第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$。</p>\n<p>有两种指令：</p>\n<p>合并指令为$M\\ i\\ j$，含义为将第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第$j$号战舰所在的战舰队列的尾部。</p>\n<p>询问指令为$C\\ i\\ j$。该指令意思询问第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1196\" target=\"_blank\" rel=\"noopener\">Luogu P1196</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道并查集的题目。</p>\n<p>因为快速的寻找两个战舰是否在同一列里面，我们可以使用并查集数据结构。但注意到题目还要询问两个战舰之间的距离，我们需要额外维护一些信息，所以我们需要用加权的并查集。</p>\n<p>说的加权，事实上就是在每一个节点上额外维护一些信息。在这里，我们在节点上额外维护到父节点的距离，在根节点处维护这个集合的大小。</p>\n<p>在寻找某个节点的时候，我们仍然可以进行路径压缩。只需要先对父节点递归完成后，把权值加上父节点的权值，然后就可以直接连到根上。</p>\n<p>合并操作也差不多。为了使合并操作简单，我们需要保证父节点一定在子节点前面。这样，我们找到的根节点就是每个队列的最前方的节点。然后可以将后面接上的节点的父亲指向前面的节点，距离设为前面的集合的大小，就可以维护了。</p>\n<p>查询距离的时候，只需要把两个节点到根的距离算出来，作差取绝对值，然后再减去1即可。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 30010</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAXN],d[MAXN],s[MAXN],t;</span><br><span class=\"line\"><span class=\"comment\">// f 维护父亲节点，d 维护于父亲节点的距离，s 在根节点处维护集合的元素数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[x] == x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> w = find(f[x]);</span><br><span class=\"line\">        d[x] += d[f[x]];</span><br><span class=\"line\">        f[x] = w;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">un</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = find(y),e = find(x);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b == e)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        d[e] = s[b],d[b] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        s[b] = s[b] + s[e],s[e] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        f[e] = b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class=\"line\">        f[i] = i,d[i] = <span class=\"number\">0</span>,s[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=t;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,op);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'M'</span>)&#123;</span><br><span class=\"line\">            un(a,b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a1 = find(a),b1 = find(b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a1!=b1)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"-1\\n\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,<span class=\"built_in\">abs</span>(d[a]-d[b])<span class=\"number\">-1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>初始时，第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$。</p>\n<p>有两种指令：</p>\n<p>合并指令为$M\\ i\\ j$，含义为将第$i$号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第$j$号战舰所在的战舰队列的尾部。</p>\n<p>询问指令为$C\\ i\\ j$。该指令意思询问第$i$号战舰与第$j$号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1196\" target=\"_blank\" rel=\"noopener\">Luogu P1196</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道并查集的题目。</p>\n<p>因为快速的寻找两个战舰是否在同一列里面，我们可以使用并查集数据结构。但注意到题目还要询问两个战舰之间的距离，我们需要额外维护一些信息，所以我们需要用加权的并查集。</p>\n<p>说的加权，事实上就是在每一个节点上额外维护一些信息。在这里，我们在节点上额外维护到父节点的距离，在根节点处维护这个集合的大小。</p>\n<p>在寻找某个节点的时候，我们仍然可以进行路径压缩。只需要先对父节点递归完成后，把权值加上父节点的权值，然后就可以直接连到根上。</p>\n<p>合并操作也差不多。为了使合并操作简单，我们需要保证父节点一定在子节点前面。这样，我们找到的根节点就是每个队列的最前方的节点。然后可以将后面接上的节点的父亲指向前面的节点，距离设为前面的集合的大小，就可以维护了。</p>\n<p>查询距离的时候，只需要把两个节点到根的距离算出来，作差取绝对值，然后再减去1即可。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�33-->\n\n</div></div>"},{"title":"「NOI2004」郁闷的出纳员-Splay","date":"2018-01-31T13:05:48.000Z","visible":null,"urlname":"noi2004-cashier","_content":"\n维护一个数列。\n现有四种命令，新加入一个数$k$，把每个数加上$k$，把每个数减去$k$，查询第$k$大的数。如果数列中的任意数小于$min$，将它立即删除。并在最后输出总共删去的数的个数$res$。\n\n如果新加入的数k的初值小于$min$，它将不会被加入数列。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1486](https://www.luogu.org/problemnew/show/P1486)\n\n## 题解\n\n这是一道经典的平衡树的题，被我用来练手Splay。\n\n{% spoiler 写完这道题之后我就觉得，我再也不会想用Splay了。debug了一天，简直浑身难受。以后尽量写旋转&非旋Treap吧。%}\n\n构建一颗Splay树。需要记录目前已经全体加过或者减过的数，也就是一个相对值。换算来说就是`树外-相对值=树内，树内+相对值=树外`。后面也就不再太多特殊说明。需要添加两个虚的最大和最小节点，也会导致排名计算的一些变化。\n\n+ 插入操作\n\n先判断是否满足插入条件，即此数是否大于$min$，然后减去相对后正常插入，`splay`至根节点。\n\n+ 加上一个数\n\n直接更改全局相对值，由于不会出现删数，不会有其他操作。\n\n+ 减去一个数\n\n首先更改全局相对值，再把小于$min$的数删除，简单的来说就是吧第一个大于等于$min$的数`splay`到根上，然后删除左子树，补上左边的最小节点。\n\n如果正好存在值为$min$的节点，就将它直接`splay`到根，完成上述操作；如果不存在，就插入一个值为$min-1$的节点，寻找它的后继，并`splay`到根，完成上述操作。这时统计$res$需要减去我们刚刚加上的节点。\n\n+ 查询第k大\n\n直接查，然后`splay`到根。只需要注意我们的数列是从小到大排列的。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#define MAX 0x3f3f3f3f\nusing namespace std;\n\ninline int qr(){\n    int f = 1,s = 0;char ch = getchar();\n    while(ch<'0'||ch>'9'){\n        if(ch == '-') f = -1;\n        ch = getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        s = (s<<3)+(s<<1)+ch-48;\n        ch = getchar();\n    }\n    return f*s;\n}\n\nstruct splay_t{\n    struct node_t{\n        int val,size,cnt;\n        node_t *son[2],*p;node_t **null,**root;\n        //与父亲关系\n        inline bool get_p(){return p->son[1] == this;}\n        //双向连接\n        inline void link(node_t *dst,bool re){p = dst;dst->son[re] = this;}\n        //更新size值\n        inline void update(){size = son[0]->size + son[1]->size + cnt;}\n        //初始化**root和**null\n        inline void init(node_t **null,node_t **root){this->null = null,this->root = root;}\n        //获取左右节点的大小\n        inline int lsize(){return son[0]->size;}int rsize(){return son[1]->size;}\n        //寻找节点前驱或者后继\n        node_t *uporlow(int tmp){//0前驱，1后继\n            splay();\n            node_t *t = son[tmp];\n            while(t->son[1-tmp] != *null)\n                t = t->son[1-tmp]; \n            return t;\n        }\n        //旋转\n        void rotate(){\n            bool re = get_p();node_t *rp = p;\n            link(rp->p,rp->get_p());\n            son[1-re]->link(rp,re);\n            rp->link(this,1-re);\n            rp->update();update();\n            if(p == *null) *root = this; \n        }\n        //splay操作\n        node_t* splay(node_t *tar = NULL){\n            if(this == *null) return this;\n            if(tar == NULL) tar = *null;\n            while(p!=tar){\n                if(p->p == tar) rotate();\n                else{\n                    if(p->get_p()==get_p()) p->rotate(),rotate();\n                    else rotate(),rotate();\n                }\n            }\n            return this;\n        }\n    };\n    int treecnt;\n    node_t pool[300000];\n    node_t *null,*root,*lb,*rb;//lb是左边的虚拟节点，rb同理\n    //初始化\n    splay_t(){\n        treecnt = 0;\n        newnode(null);root = null;\n        null->size = 0,null->val = 0;\n        lb = insert(-MAX);rb = insert(MAX);\n    }\n    //新建节点\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[treecnt++];\n        r->val = val;\n        r->son[0] = r->son[1] = r->p = null;\n        r->cnt = r->size = 1;\n        r->init(&null,&root);\n    }\n    //寻找给定rank的数字\n    node_t* find_Kth(int rank){\n        node_t *t = root;\n        while(t!=null){\n            if(rank<t->lsize())\n                t = t->son[0];\n            else if((rank-=t->lsize())<t->cnt)\n                return t->splay();\n            else\n                rank-=t->cnt,t = t->son[1];\n        }\n        return null;\n    }\n    //按值寻找\n    node_t *find_by_val(int val){\n        node_t *t = root;\n        while(t!=null){\n            if(val<t->val)\n                t = t->son[0];\n            else if(val==t->val)\n                return t->splay();\n            else\n                t = t->son[1];\n        }\n        return null;\n    }\n    //插入给定值的节点\n    node_t* insert(int val){\n        node_t **tar = &root,*parent = null;\n        while(*tar!=null){\n            (*tar)->size++;\n            if((*tar)->val == val){\n                (*tar)->cnt++;return *tar;\n            }\n            else{\n                parent = *tar;tar = &(*tar)->son[(*tar)->val<val];\n            }\n        }\n        newnode(*tar,val);\n        (*tar)->link(parent,parent->val < val);\n        return (*tar)->splay();\n    }\n    //调试用 打印树\n    void print(node_t *r = NULL,int depth = 0){\n        if(r == NULL) r = root;\n        if(r == null) return;\n        else{\n            print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');\n            printf(\"v:%d,size:%d,cnt:%d,son:%d %d,depth:%03d\\n\",r->val,r->size,r->cnt,r->son[0]!=null,r->son[1]!=null,depth);\n            print(r->son[1],depth+1);\n        }\n    }\n};\n\nsplay_t x;int n,minn,res = 0,nowadd = 0;\n\n//插入一个数\ninline void insert(int val){if(val>=minn) x.insert(val-nowadd);}//注意要减去nowadd \n//统一加工资\ninline void add(int val){nowadd+=val;}\n//统一减公司顺便裁人\ninline void decrease(int val){\n    nowadd-=val;\n    splay_t::node_t *r = x.find_by_val(minn-nowadd);//注意要减去nowadd \n    if(r!=x.null)\n        r->splay(),res+=(x.root->lsize()-1);\n    else\n        x.insert(minn-nowadd-1)->uporlow(1)->splay(),res+=(x.root->lsize()-2);\n    x.lb->link(x.root,0);x.lb->son[1] = x.null;\n    x.root->update();\n}\n//查找工资排名K位的员工的工资\ninline int ask(int rank){\n    if(rank > x.root->size - 2) return -1;\n    return x.find_Kth(x.root->size-rank-1)->val + nowadd;//注意要加上nowadd\n}\n\nint main(){\n    n = qr();minn = qr();\n    for(int i = 0;i<n;i++){\n        char op[20];int k;\n        scanf(\"%s\",op);k = qr();\n        if(op[0] == 'A')      add(k);\n        else if(op[0] == 'S') decrease(k);\n        else if(op[0] == 'I') insert(k);\n        else if(op[0] == 'F') printf(\"%d\\n\",ask(k));\n        else if(op[0] == 'P') x.print();\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「NOI2004」郁闷的出纳员-Splay.md","raw":"---\ntitle: 「NOI2004」郁闷的出纳员-Splay\ndate: 2018-01-31 21:05:48\ntags:\n- 题解\n- 数据结构\n- 平衡树\n- Splay\ncategories: OI\nvisible:\nurlname: noi2004-cashier\n---\n\n维护一个数列。\n现有四种命令，新加入一个数$k$，把每个数加上$k$，把每个数减去$k$，查询第$k$大的数。如果数列中的任意数小于$min$，将它立即删除。并在最后输出总共删去的数的个数$res$。\n\n如果新加入的数k的初值小于$min$，它将不会被加入数列。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1486](https://www.luogu.org/problemnew/show/P1486)\n\n## 题解\n\n这是一道经典的平衡树的题，被我用来练手Splay。\n\n{% spoiler 写完这道题之后我就觉得，我再也不会想用Splay了。debug了一天，简直浑身难受。以后尽量写旋转&非旋Treap吧。%}\n\n构建一颗Splay树。需要记录目前已经全体加过或者减过的数，也就是一个相对值。换算来说就是`树外-相对值=树内，树内+相对值=树外`。后面也就不再太多特殊说明。需要添加两个虚的最大和最小节点，也会导致排名计算的一些变化。\n\n+ 插入操作\n\n先判断是否满足插入条件，即此数是否大于$min$，然后减去相对后正常插入，`splay`至根节点。\n\n+ 加上一个数\n\n直接更改全局相对值，由于不会出现删数，不会有其他操作。\n\n+ 减去一个数\n\n首先更改全局相对值，再把小于$min$的数删除，简单的来说就是吧第一个大于等于$min$的数`splay`到根上，然后删除左子树，补上左边的最小节点。\n\n如果正好存在值为$min$的节点，就将它直接`splay`到根，完成上述操作；如果不存在，就插入一个值为$min-1$的节点，寻找它的后继，并`splay`到根，完成上述操作。这时统计$res$需要减去我们刚刚加上的节点。\n\n+ 查询第k大\n\n直接查，然后`splay`到根。只需要注意我们的数列是从小到大排列的。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#define MAX 0x3f3f3f3f\nusing namespace std;\n\ninline int qr(){\n    int f = 1,s = 0;char ch = getchar();\n    while(ch<'0'||ch>'9'){\n        if(ch == '-') f = -1;\n        ch = getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        s = (s<<3)+(s<<1)+ch-48;\n        ch = getchar();\n    }\n    return f*s;\n}\n\nstruct splay_t{\n    struct node_t{\n        int val,size,cnt;\n        node_t *son[2],*p;node_t **null,**root;\n        //与父亲关系\n        inline bool get_p(){return p->son[1] == this;}\n        //双向连接\n        inline void link(node_t *dst,bool re){p = dst;dst->son[re] = this;}\n        //更新size值\n        inline void update(){size = son[0]->size + son[1]->size + cnt;}\n        //初始化**root和**null\n        inline void init(node_t **null,node_t **root){this->null = null,this->root = root;}\n        //获取左右节点的大小\n        inline int lsize(){return son[0]->size;}int rsize(){return son[1]->size;}\n        //寻找节点前驱或者后继\n        node_t *uporlow(int tmp){//0前驱，1后继\n            splay();\n            node_t *t = son[tmp];\n            while(t->son[1-tmp] != *null)\n                t = t->son[1-tmp]; \n            return t;\n        }\n        //旋转\n        void rotate(){\n            bool re = get_p();node_t *rp = p;\n            link(rp->p,rp->get_p());\n            son[1-re]->link(rp,re);\n            rp->link(this,1-re);\n            rp->update();update();\n            if(p == *null) *root = this; \n        }\n        //splay操作\n        node_t* splay(node_t *tar = NULL){\n            if(this == *null) return this;\n            if(tar == NULL) tar = *null;\n            while(p!=tar){\n                if(p->p == tar) rotate();\n                else{\n                    if(p->get_p()==get_p()) p->rotate(),rotate();\n                    else rotate(),rotate();\n                }\n            }\n            return this;\n        }\n    };\n    int treecnt;\n    node_t pool[300000];\n    node_t *null,*root,*lb,*rb;//lb是左边的虚拟节点，rb同理\n    //初始化\n    splay_t(){\n        treecnt = 0;\n        newnode(null);root = null;\n        null->size = 0,null->val = 0;\n        lb = insert(-MAX);rb = insert(MAX);\n    }\n    //新建节点\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[treecnt++];\n        r->val = val;\n        r->son[0] = r->son[1] = r->p = null;\n        r->cnt = r->size = 1;\n        r->init(&null,&root);\n    }\n    //寻找给定rank的数字\n    node_t* find_Kth(int rank){\n        node_t *t = root;\n        while(t!=null){\n            if(rank<t->lsize())\n                t = t->son[0];\n            else if((rank-=t->lsize())<t->cnt)\n                return t->splay();\n            else\n                rank-=t->cnt,t = t->son[1];\n        }\n        return null;\n    }\n    //按值寻找\n    node_t *find_by_val(int val){\n        node_t *t = root;\n        while(t!=null){\n            if(val<t->val)\n                t = t->son[0];\n            else if(val==t->val)\n                return t->splay();\n            else\n                t = t->son[1];\n        }\n        return null;\n    }\n    //插入给定值的节点\n    node_t* insert(int val){\n        node_t **tar = &root,*parent = null;\n        while(*tar!=null){\n            (*tar)->size++;\n            if((*tar)->val == val){\n                (*tar)->cnt++;return *tar;\n            }\n            else{\n                parent = *tar;tar = &(*tar)->son[(*tar)->val<val];\n            }\n        }\n        newnode(*tar,val);\n        (*tar)->link(parent,parent->val < val);\n        return (*tar)->splay();\n    }\n    //调试用 打印树\n    void print(node_t *r = NULL,int depth = 0){\n        if(r == NULL) r = root;\n        if(r == null) return;\n        else{\n            print(r->son[0],depth+1);\n            for(int i = 0;i<depth;i++) putchar(' ');\n            printf(\"v:%d,size:%d,cnt:%d,son:%d %d,depth:%03d\\n\",r->val,r->size,r->cnt,r->son[0]!=null,r->son[1]!=null,depth);\n            print(r->son[1],depth+1);\n        }\n    }\n};\n\nsplay_t x;int n,minn,res = 0,nowadd = 0;\n\n//插入一个数\ninline void insert(int val){if(val>=minn) x.insert(val-nowadd);}//注意要减去nowadd \n//统一加工资\ninline void add(int val){nowadd+=val;}\n//统一减公司顺便裁人\ninline void decrease(int val){\n    nowadd-=val;\n    splay_t::node_t *r = x.find_by_val(minn-nowadd);//注意要减去nowadd \n    if(r!=x.null)\n        r->splay(),res+=(x.root->lsize()-1);\n    else\n        x.insert(minn-nowadd-1)->uporlow(1)->splay(),res+=(x.root->lsize()-2);\n    x.lb->link(x.root,0);x.lb->son[1] = x.null;\n    x.root->update();\n}\n//查找工资排名K位的员工的工资\ninline int ask(int rank){\n    if(rank > x.root->size - 2) return -1;\n    return x.find_Kth(x.root->size-rank-1)->val + nowadd;//注意要加上nowadd\n}\n\nint main(){\n    n = qr();minn = qr();\n    for(int i = 0;i<n;i++){\n        char op[20];int k;\n        scanf(\"%s\",op);k = qr();\n        if(op[0] == 'A')      add(k);\n        else if(op[0] == 'S') decrease(k);\n        else if(op[0] == 'I') insert(k);\n        else if(op[0] == 'F') printf(\"%d\\n\",ask(k));\n        else if(op[0] == 'P') x.print();\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「NOI2004」郁闷的出纳员-Splay","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jc0037bljrf3j6iknd","content":"<p>&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x6570;&#x5217;&#x3002;<br>&#x73B0;&#x6709;&#x56DB;&#x79CD;&#x547D;&#x4EE4;&#xFF0C;&#x65B0;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x6570;$k$&#xFF0C;&#x628A;&#x6BCF;&#x4E2A;&#x6570;&#x52A0;&#x4E0A;$k$&#xFF0C;&#x628A;&#x6BCF;&#x4E2A;&#x6570;&#x51CF;&#x53BB;$k$&#xFF0C;&#x67E5;&#x8BE2;&#x7B2C;$k$&#x5927;&#x7684;&#x6570;&#x3002;&#x5982;&#x679C;&#x6570;&#x5217;&#x4E2D;&#x7684;&#x4EFB;&#x610F;&#x6570;&#x5C0F;&#x4E8E;$min$&#xFF0C;&#x5C06;&#x5B83;&#x7ACB;&#x5373;&#x5220;&#x9664;&#x3002;&#x5E76;&#x5728;&#x6700;&#x540E;&#x8F93;&#x51FA;&#x603B;&#x5171;&#x5220;&#x53BB;&#x7684;&#x6570;&#x7684;&#x4E2A;&#x6570;$res$&#x3002;</p>\n<p>&#x5982;&#x679C;&#x65B0;&#x52A0;&#x5165;&#x7684;&#x6570;k&#x7684;&#x521D;&#x503C;&#x5C0F;&#x4E8E;$min$&#xFF0C;&#x5B83;&#x5C06;&#x4E0D;&#x4F1A;&#x88AB;&#x52A0;&#x5165;&#x6570;&#x5217;&#x3002;</p>\n<a id=\"more\"></a>\n<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1486\" target=\"_blank\" rel=\"noopener\">Luogu P1486</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x662F;&#x4E00;&#x9053;&#x7ECF;&#x5178;&#x7684;&#x5E73;&#x8861;&#x6811;&#x7684;&#x9898;&#xFF0C;&#x88AB;&#x6211;&#x7528;&#x6765;&#x7EC3;&#x624B;Splay&#x3002;</p>\n<span class=\"spoiler\">&#x5199;&#x5B8C;&#x8FD9;&#x9053;&#x9898;&#x4E4B;&#x540E;&#x6211;&#x5C31;&#x89C9;&#x5F97;&#xFF0C;&#x6211;&#x518D;&#x4E5F;&#x4E0D;&#x4F1A;&#x60F3;&#x7528;Splay&#x4E86;&#x3002;debug&#x4E86;&#x4E00;&#x5929;&#xFF0C;&#x7B80;&#x76F4;&#x6D51;&#x8EAB;&#x96BE;&#x53D7;&#x3002;&#x4EE5;&#x540E;&#x5C3D;&#x91CF;&#x5199;&#x65CB;&#x8F6C;&amp;&#x975E;&#x65CB;Treap&#x5427;&#x3002;\n</span>\n<p>&#x6784;&#x5EFA;&#x4E00;&#x9897;Splay&#x6811;&#x3002;&#x9700;&#x8981;&#x8BB0;&#x5F55;&#x76EE;&#x524D;&#x5DF2;&#x7ECF;&#x5168;&#x4F53;&#x52A0;&#x8FC7;&#x6216;&#x8005;&#x51CF;&#x8FC7;&#x7684;&#x6570;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x76F8;&#x5BF9;&#x503C;&#x3002;&#x6362;&#x7B97;&#x6765;&#x8BF4;&#x5C31;&#x662F;<code>&#x6811;&#x5916;-&#x76F8;&#x5BF9;&#x503C;=&#x6811;&#x5185;&#xFF0C;&#x6811;&#x5185;+&#x76F8;&#x5BF9;&#x503C;=&#x6811;&#x5916;</code>&#x3002;&#x540E;&#x9762;&#x4E5F;&#x5C31;&#x4E0D;&#x518D;&#x592A;&#x591A;&#x7279;&#x6B8A;&#x8BF4;&#x660E;&#x3002;&#x9700;&#x8981;&#x6DFB;&#x52A0;&#x4E24;&#x4E2A;&#x865A;&#x7684;&#x6700;&#x5927;&#x548C;&#x6700;&#x5C0F;&#x8282;&#x70B9;&#xFF0C;&#x4E5F;&#x4F1A;&#x5BFC;&#x81F4;&#x6392;&#x540D;&#x8BA1;&#x7B97;&#x7684;&#x4E00;&#x4E9B;&#x53D8;&#x5316;&#x3002;</p>\n<ul>\n<li>&#x63D2;&#x5165;&#x64CD;&#x4F5C;</li>\n</ul>\n<p>&#x5148;&#x5224;&#x65AD;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x63D2;&#x5165;&#x6761;&#x4EF6;&#xFF0C;&#x5373;&#x6B64;&#x6570;&#x662F;&#x5426;&#x5927;&#x4E8E;$min$&#xFF0C;&#x7136;&#x540E;&#x51CF;&#x53BB;&#x76F8;&#x5BF9;&#x540E;&#x6B63;&#x5E38;&#x63D2;&#x5165;&#xFF0C;<code>splay</code>&#x81F3;&#x6839;&#x8282;&#x70B9;&#x3002;</p>\n<ul>\n<li>&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;&#x6570;</li>\n</ul>\n<p>&#x76F4;&#x63A5;&#x66F4;&#x6539;&#x5168;&#x5C40;&#x76F8;&#x5BF9;&#x503C;&#xFF0C;&#x7531;&#x4E8E;&#x4E0D;&#x4F1A;&#x51FA;&#x73B0;&#x5220;&#x6570;&#xFF0C;&#x4E0D;&#x4F1A;&#x6709;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;&#x3002;</p>\n<ul>\n<li>&#x51CF;&#x53BB;&#x4E00;&#x4E2A;&#x6570;</li>\n</ul>\n<p>&#x9996;&#x5148;&#x66F4;&#x6539;&#x5168;&#x5C40;&#x76F8;&#x5BF9;&#x503C;&#xFF0C;&#x518D;&#x628A;&#x5C0F;&#x4E8E;$min$&#x7684;&#x6570;&#x5220;&#x9664;&#xFF0C;&#x7B80;&#x5355;&#x7684;&#x6765;&#x8BF4;&#x5C31;&#x662F;&#x5427;&#x7B2C;&#x4E00;&#x4E2A;&#x5927;&#x4E8E;&#x7B49;&#x4E8E;$min$&#x7684;&#x6570;<code>splay</code>&#x5230;&#x6839;&#x4E0A;&#xFF0C;&#x7136;&#x540E;&#x5220;&#x9664;&#x5DE6;&#x5B50;&#x6811;&#xFF0C;&#x8865;&#x4E0A;&#x5DE6;&#x8FB9;&#x7684;&#x6700;&#x5C0F;&#x8282;&#x70B9;&#x3002;</p>\n<p>&#x5982;&#x679C;&#x6B63;&#x597D;&#x5B58;&#x5728;&#x503C;&#x4E3A;$min$&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x5C31;&#x5C06;&#x5B83;&#x76F4;&#x63A5;<code>splay</code>&#x5230;&#x6839;&#xFF0C;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#xFF1B;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x5C31;&#x63D2;&#x5165;&#x4E00;&#x4E2A;&#x503C;&#x4E3A;$min-1$&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x5BFB;&#x627E;&#x5B83;&#x7684;&#x540E;&#x7EE7;&#xFF0C;&#x5E76;<code>splay</code>&#x5230;&#x6839;&#xFF0C;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#x3002;&#x8FD9;&#x65F6;&#x7EDF;&#x8BA1;$res$&#x9700;&#x8981;&#x51CF;&#x53BB;&#x6211;&#x4EEC;&#x521A;&#x521A;&#x52A0;&#x4E0A;&#x7684;&#x8282;&#x70B9;&#x3002;</p>\n<ul>\n<li>&#x67E5;&#x8BE2;&#x7B2C;k&#x5927;</li>\n</ul>\n<p>&#x76F4;&#x63A5;&#x67E5;&#xFF0C;&#x7136;&#x540E;<code>splay</code>&#x5230;&#x6839;&#x3002;&#x53EA;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x6211;&#x4EEC;&#x7684;&#x6570;&#x5217;&#x662F;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5217;&#x7684;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 0x3f3f3f3f</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">qr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f = <span class=\"number\">1</span>,s = <span class=\"number\">0</span>;<span class=\"keyword\">char</span> ch = getchar();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">'0'</span>||ch&gt;<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch == <span class=\"string\">'-'</span>) f = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">'0'</span>&amp;&amp;ch&lt;=<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">        s = (s&lt;&lt;<span class=\"number\">3</span>)+(s&lt;&lt;<span class=\"number\">1</span>)+ch<span class=\"number\">-48</span>;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f*s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">splay_t</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> val,size,cnt;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>],*p;<span class=\"keyword\">node_t</span> **null,**root;</span><br><span class=\"line\">        <span class=\"comment\">//与父亲关系</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">get_p</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> p-&gt;son[<span class=\"number\">1</span>] == <span class=\"keyword\">this</span>;&#125;</span><br><span class=\"line\">        <span class=\"comment\">//双向连接</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *dst,<span class=\"keyword\">bool</span> re)</span></span>&#123;p = dst;dst-&gt;son[re] = <span class=\"keyword\">this</span>;&#125;</span><br><span class=\"line\">        <span class=\"comment\">//更新size值</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;size = son[<span class=\"number\">0</span>]-&gt;size + son[<span class=\"number\">1</span>]-&gt;size + cnt;&#125;</span><br><span class=\"line\">        <span class=\"comment\">//初始化**root和**null</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">node_t</span> **null,<span class=\"keyword\">node_t</span> **root)</span></span>&#123;<span class=\"keyword\">this</span>-&gt;null = null,<span class=\"keyword\">this</span>-&gt;root = root;&#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取左右节点的大小</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lsize</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> son[<span class=\"number\">0</span>]-&gt;size;&#125;<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">rsize</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> son[<span class=\"number\">1</span>]-&gt;size;&#125;</span><br><span class=\"line\">        <span class=\"comment\">//寻找节点前驱或者后继</span></span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *uporlow(<span class=\"keyword\">int</span> tmp)&#123;<span class=\"comment\">//0前驱，1后继</span></span><br><span class=\"line\">            splay();</span><br><span class=\"line\">            <span class=\"keyword\">node_t</span> *t = son[tmp];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(t-&gt;son[<span class=\"number\">1</span>-tmp] != *null)</span><br><span class=\"line\">                t = t-&gt;son[<span class=\"number\">1</span>-tmp]; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//旋转</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">bool</span> re = get_p();<span class=\"keyword\">node_t</span> *rp = p;</span><br><span class=\"line\">            link(rp-&gt;p,rp-&gt;get_p());</span><br><span class=\"line\">            son[<span class=\"number\">1</span>-re]-&gt;link(rp,re);</span><br><span class=\"line\">            rp-&gt;link(<span class=\"keyword\">this</span>,<span class=\"number\">1</span>-re);</span><br><span class=\"line\">            rp-&gt;update();update();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p == *null) *root = <span class=\"keyword\">this</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//splay操作</span></span><br><span class=\"line\">        <span class=\"keyword\">node_t</span>* splay(<span class=\"keyword\">node_t</span> *tar = <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tar == <span class=\"literal\">NULL</span>) tar = *null;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(p!=tar)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p-&gt;p == tar) rotate();</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(p-&gt;get_p()==get_p()) p-&gt;rotate(),rotate();</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> rotate(),rotate();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> treecnt;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[<span class=\"number\">300000</span>];</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *null,*root,*lb,*rb;<span class=\"comment\">//lb是左边的虚拟节点，rb同理</span></span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">splay_t</span>()&#123;</span><br><span class=\"line\">        treecnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        newnode(null);root = null;</span><br><span class=\"line\">        null-&gt;size = <span class=\"number\">0</span>,null-&gt;val = <span class=\"number\">0</span>;</span><br><span class=\"line\">        lb = insert(-MAX);rb = insert(MAX);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//新建节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> val = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        r = &amp;pool[treecnt++];</span><br><span class=\"line\">        r-&gt;val = val;</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = r-&gt;p = null;</span><br><span class=\"line\">        r-&gt;cnt = r-&gt;size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;init(&amp;null,&amp;root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//寻找给定rank的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span>* find_Kth(<span class=\"keyword\">int</span> rank)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *t = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t!=null)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(rank&lt;t-&gt;lsize())</span><br><span class=\"line\">                t = t-&gt;son[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((rank-=t-&gt;lsize())&lt;t-&gt;cnt)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t-&gt;splay();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                rank-=t-&gt;cnt,t = t-&gt;son[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//按值寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *find_by_val(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *t = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(t!=null)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val&lt;t-&gt;val)</span><br><span class=\"line\">                t = t-&gt;son[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(val==t-&gt;val)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t-&gt;splay();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                t = t-&gt;son[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//插入给定值的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span>* insert(<span class=\"keyword\">int</span> val)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> **tar = &amp;root,*parent = null;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*tar!=null)&#123;</span><br><span class=\"line\">            (*tar)-&gt;size++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((*tar)-&gt;val == val)&#123;</span><br><span class=\"line\">                (*tar)-&gt;cnt++;<span class=\"keyword\">return</span> *tar;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                parent = *tar;tar = &amp;(*tar)-&gt;son[(*tar)-&gt;val&lt;val];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newnode(*tar,val);</span><br><span class=\"line\">        (*tar)-&gt;link(parent,parent-&gt;val &lt; val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (*tar)-&gt;splay();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//调试用 打印树</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r = <span class=\"literal\">NULL</span>,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == <span class=\"literal\">NULL</span>) r = root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            print(r-&gt;son[<span class=\"number\">0</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;depth;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"v:%d,size:%d,cnt:%d,son:%d %d,depth:%03d\\n\"</span>,r-&gt;val,r-&gt;size,r-&gt;cnt,r-&gt;son[<span class=\"number\">0</span>]!=null,r-&gt;son[<span class=\"number\">1</span>]!=null,depth);</span><br><span class=\"line\">            print(r-&gt;son[<span class=\"number\">1</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">splay_t</span> x;<span class=\"keyword\">int</span> n,minn,res = <span class=\"number\">0</span>,nowadd = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//插入一个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span>&#123;<span class=\"keyword\">if</span>(val&gt;=minn) x.insert(val-nowadd);&#125;<span class=\"comment\">//注意要减去nowadd </span></span><br><span class=\"line\"><span class=\"comment\">//统一加工资</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span>&#123;nowadd+=val;&#125;</span><br><span class=\"line\"><span class=\"comment\">//统一减公司顺便裁人</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">decrease</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    nowadd-=val;</span><br><span class=\"line\">    <span class=\"keyword\">splay_t</span>::<span class=\"keyword\">node_t</span> *r = x.find_by_val(minn-nowadd);<span class=\"comment\">//注意要减去nowadd </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r!=x.null)</span><br><span class=\"line\">        r-&gt;splay(),res+=(x.root-&gt;lsize()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        x.insert(minn-nowadd<span class=\"number\">-1</span>)-&gt;uporlow(<span class=\"number\">1</span>)-&gt;splay(),res+=(x.root-&gt;lsize()<span class=\"number\">-2</span>);</span><br><span class=\"line\">    x.lb-&gt;link(x.root,<span class=\"number\">0</span>);x.lb-&gt;son[<span class=\"number\">1</span>] = x.null;</span><br><span class=\"line\">    x.root-&gt;update();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查找工资排名K位的员工的工资</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">ask</span><span class=\"params\">(<span class=\"keyword\">int</span> rank)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rank &gt; x.root-&gt;size - <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.find_Kth(x.root-&gt;size-rank<span class=\"number\">-1</span>)-&gt;val + nowadd;<span class=\"comment\">//注意要加上nowadd</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    n = qr();minn = qr();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> k;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,op);k = qr();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'A'</span>)      add(k);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'S'</span>) decrease(k);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>) insert(k);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'F'</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ask(k));</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'P'</span>) x.print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>&#x7EF4;&#x62A4;&#x4E00;&#x4E2A;&#x6570;&#x5217;&#x3002;<br>&#x73B0;&#x6709;&#x56DB;&#x79CD;&#x547D;&#x4EE4;&#xFF0C;&#x65B0;&#x52A0;&#x5165;&#x4E00;&#x4E2A;&#x6570;$k$&#xFF0C;&#x628A;&#x6BCF;&#x4E2A;&#x6570;&#x52A0;&#x4E0A;$k$&#xFF0C;&#x628A;&#x6BCF;&#x4E2A;&#x6570;&#x51CF;&#x53BB;$k$&#xFF0C;&#x67E5;&#x8BE2;&#x7B2C;$k$&#x5927;&#x7684;&#x6570;&#x3002;&#x5982;&#x679C;&#x6570;&#x5217;&#x4E2D;&#x7684;&#x4EFB;&#x610F;&#x6570;&#x5C0F;&#x4E8E;$min$&#xFF0C;&#x5C06;&#x5B83;&#x7ACB;&#x5373;&#x5220;&#x9664;&#x3002;&#x5E76;&#x5728;&#x6700;&#x540E;&#x8F93;&#x51FA;&#x603B;&#x5171;&#x5220;&#x53BB;&#x7684;&#x6570;&#x7684;&#x4E2A;&#x6570;$res$&#x3002;</p>\n<p>&#x5982;&#x679C;&#x65B0;&#x52A0;&#x5165;&#x7684;&#x6570;k&#x7684;&#x521D;&#x503C;&#x5C0F;&#x4E8E;$min$&#xFF0C;&#x5B83;&#x5C06;&#x4E0D;&#x4F1A;&#x88AB;&#x52A0;&#x5165;&#x6570;&#x5217;&#x3002;</p>","more":"<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1486\" target=\"_blank\" rel=\"noopener\">Luogu P1486</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x662F;&#x4E00;&#x9053;&#x7ECF;&#x5178;&#x7684;&#x5E73;&#x8861;&#x6811;&#x7684;&#x9898;&#xFF0C;&#x88AB;&#x6211;&#x7528;&#x6765;&#x7EC3;&#x624B;Splay&#x3002;</p>\n<span class=\"spoiler\">&#x5199;&#x5B8C;&#x8FD9;&#x9053;&#x9898;&#x4E4B;&#x540E;&#x6211;&#x5C31;&#x89C9;&#x5F97;&#xFF0C;&#x6211;&#x518D;&#x4E5F;&#x4E0D;&#x4F1A;&#x60F3;&#x7528;Splay&#x4E86;&#x3002;debug&#x4E86;&#x4E00;&#x5929;&#xFF0C;&#x7B80;&#x76F4;&#x6D51;&#x8EAB;&#x96BE;&#x53D7;&#x3002;&#x4EE5;&#x540E;&#x5C3D;&#x91CF;&#x5199;&#x65CB;&#x8F6C;&amp;&#x975E;&#x65CB;Treap&#x5427;&#x3002;\n</span>\n<p>&#x6784;&#x5EFA;&#x4E00;&#x9897;Splay&#x6811;&#x3002;&#x9700;&#x8981;&#x8BB0;&#x5F55;&#x76EE;&#x524D;&#x5DF2;&#x7ECF;&#x5168;&#x4F53;&#x52A0;&#x8FC7;&#x6216;&#x8005;&#x51CF;&#x8FC7;&#x7684;&#x6570;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x76F8;&#x5BF9;&#x503C;&#x3002;&#x6362;&#x7B97;&#x6765;&#x8BF4;&#x5C31;&#x662F;<code>&#x6811;&#x5916;-&#x76F8;&#x5BF9;&#x503C;=&#x6811;&#x5185;&#xFF0C;&#x6811;&#x5185;+&#x76F8;&#x5BF9;&#x503C;=&#x6811;&#x5916;</code>&#x3002;&#x540E;&#x9762;&#x4E5F;&#x5C31;&#x4E0D;&#x518D;&#x592A;&#x591A;&#x7279;&#x6B8A;&#x8BF4;&#x660E;&#x3002;&#x9700;&#x8981;&#x6DFB;&#x52A0;&#x4E24;&#x4E2A;&#x865A;&#x7684;&#x6700;&#x5927;&#x548C;&#x6700;&#x5C0F;&#x8282;&#x70B9;&#xFF0C;&#x4E5F;&#x4F1A;&#x5BFC;&#x81F4;&#x6392;&#x540D;&#x8BA1;&#x7B97;&#x7684;&#x4E00;&#x4E9B;&#x53D8;&#x5316;&#x3002;</p>\n<ul>\n<li>&#x63D2;&#x5165;&#x64CD;&#x4F5C;</li>\n</ul>\n<p>&#x5148;&#x5224;&#x65AD;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x63D2;&#x5165;&#x6761;&#x4EF6;&#xFF0C;&#x5373;&#x6B64;&#x6570;&#x662F;&#x5426;&#x5927;&#x4E8E;$min$&#xFF0C;&#x7136;&#x540E;&#x51CF;&#x53BB;&#x76F8;&#x5BF9;&#x540E;&#x6B63;&#x5E38;&#x63D2;&#x5165;&#xFF0C;<code>splay</code>&#x81F3;&#x6839;&#x8282;&#x70B9;&#x3002;</p>\n<ul>\n<li>&#x52A0;&#x4E0A;&#x4E00;&#x4E2A;&#x6570;</li>\n</ul>\n<p>&#x76F4;&#x63A5;&#x66F4;&#x6539;&#x5168;&#x5C40;&#x76F8;&#x5BF9;&#x503C;&#xFF0C;&#x7531;&#x4E8E;&#x4E0D;&#x4F1A;&#x51FA;&#x73B0;&#x5220;&#x6570;&#xFF0C;&#x4E0D;&#x4F1A;&#x6709;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;&#x3002;</p>\n<ul>\n<li>&#x51CF;&#x53BB;&#x4E00;&#x4E2A;&#x6570;</li>\n</ul>\n<p>&#x9996;&#x5148;&#x66F4;&#x6539;&#x5168;&#x5C40;&#x76F8;&#x5BF9;&#x503C;&#xFF0C;&#x518D;&#x628A;&#x5C0F;&#x4E8E;$min$&#x7684;&#x6570;&#x5220;&#x9664;&#xFF0C;&#x7B80;&#x5355;&#x7684;&#x6765;&#x8BF4;&#x5C31;&#x662F;&#x5427;&#x7B2C;&#x4E00;&#x4E2A;&#x5927;&#x4E8E;&#x7B49;&#x4E8E;$min$&#x7684;&#x6570;<code>splay</code>&#x5230;&#x6839;&#x4E0A;&#xFF0C;&#x7136;&#x540E;&#x5220;&#x9664;&#x5DE6;&#x5B50;&#x6811;&#xFF0C;&#x8865;&#x4E0A;&#x5DE6;&#x8FB9;&#x7684;&#x6700;&#x5C0F;&#x8282;&#x70B9;&#x3002;</p>\n<p>&#x5982;&#x679C;&#x6B63;&#x597D;&#x5B58;&#x5728;&#x503C;&#x4E3A;$min$&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x5C31;&#x5C06;&#x5B83;&#x76F4;&#x63A5;<code>splay</code>&#x5230;&#x6839;&#xFF0C;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#xFF1B;&#x5982;&#x679C;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x5C31;&#x63D2;&#x5165;&#x4E00;&#x4E2A;&#x503C;&#x4E3A;$min-1$&#x7684;&#x8282;&#x70B9;&#xFF0C;&#x5BFB;&#x627E;&#x5B83;&#x7684;&#x540E;&#x7EE7;&#xFF0C;&#x5E76;<code>splay</code>&#x5230;&#x6839;&#xFF0C;&#x5B8C;&#x6210;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#x3002;&#x8FD9;&#x65F6;&#x7EDF;&#x8BA1;$res$&#x9700;&#x8981;&#x51CF;&#x53BB;&#x6211;&#x4EEC;&#x521A;&#x521A;&#x52A0;&#x4E0A;&#x7684;&#x8282;&#x70B9;&#x3002;</p>\n<ul>\n<li>&#x67E5;&#x8BE2;&#x7B2C;k&#x5927;</li>\n</ul>\n<p>&#x76F4;&#x63A5;&#x67E5;&#xFF0C;&#x7136;&#x540E;<code>splay</code>&#x5230;&#x6839;&#x3002;&#x53EA;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x6211;&#x4EEC;&#x7684;&#x6570;&#x5217;&#x662F;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5217;&#x7684;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�34-->\n\n</div></div>"},{"title":"「NOI2005」维护数列-非旋Treap","urlname":"noi2005-sequence","date":"2018-02-17T13:48:01.000Z","visible":null,"_content":"\n维护一个数列，给定初始的$n$个数字。\n现有六种命令，在第$pos$个数后插入$tot$个数，翻转从第$pos$个数开始的$tot$个数，删除从第$pos$个数开始的$tot$个数，查询从第$pos$个数开始的$tot$个数的和，设定从第$pos$个数开始的$tot$个数设定为$c$，查询整个数列中和最大的连续子区间的大小。\n\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2042](https://www.luogu.org/problemnew/show/P2042)\n\n## 题解\n\n这是一道经典的平衡树的题，被我用来练手非旋$Treap$。\n\n因为我太弱了，所以写的很痛苦。\n\n关于合并和分裂的主要思想参见{% post_link 非旋Treap学习笔记 学习笔记 %}。\n\n- - -\n对于节点，要维护：\n\n树的大小，树的权值和，树从左端点开始的最大连续和，树从右端点开始的最大连续和，和树的最大连续子区间和。\n\n- - -\n主要操作：\n\n+ $pushdown$\n\n往下$push$，修改两个子节点并打上标记。\n\n+ $pushup$\n\n更新所有信息，维护三个$max$信息的方式有些特殊，但仔细想想应当能想到。\n\n这里我被坑了。这个与线段树的区间最大查询有点不太一样，根节点也有代表的数，这个需要记住。\n\n- - -\n\n+ 建树\n\n构建笛卡尔树。详见{% post_link 非旋Treap学习笔记 学习笔记 %}。\n\n+ 最大查询连续和\n\n直接输出根节点维护的最大连续子区间的值即可。\n\n+ 插入\n\n把即将插入的$tot$个数按照上文的介绍方法建树。\n\n把原来的数按照$size$裂成两棵树，分别按顺序合起来就可以了。\n\n- - -\n\n接下来的操作都需要裂成三棵树，左边的有$pos-1$个树，中间有$tot$个数。\n\n+ 删除\n\n直接删除中间子树，左右合并。因为内存不够（$64MB$），需要垃圾回收。\n\n+ 求和\n\n输出中间子树的和，再把三个子树顺次合并起来。\n\n+ 翻转\n\n翻转中间子树并打标记，再把三个子树顺次合并起来。\n\n+ 设定\n\n对中间子树完成设定并打标记，再将三个子树顺次合并起来。\n\n- - -\n\n还有一点就是垃圾回收。简略来说就是把删除的节点暴力的扔到一个栈里面，然后能用就用，不能有就再新开内存池。\n\n其他也没有什么重要的。多$pushdown pushup$几次，然后这些操作都是要注意边界，也就是`null`时候的条件的。$pushup$的合并公式也需要好好斟酌。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 510000;\n\nconst int MAX = 2147483647;\n\nint k,n;\n\nstruct node_t{\n    int val,p;\n    int lmax,rmax,maxn,sumn,tag;\n    int size;\n    bool rev,is_tag;\n    node_t *son[2],**null;\n    void pushdown(){\n        if(this == *null) return;\n        if(is_tag){\n            son[0]->cover(tag),son[1]->cover(tag);\n            is_tag = tag = 0;\n        }\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    void pushup(){\n        if(this == *null) return;\n        if(son[0] == *null && son[1] == *null){\n            size = 1;sumn = lmax = rmax = maxn = val;\n            return;\n        }\n        size = son[0]->size + son[1]->size + 1;\n        sumn = son[0]->sumn + son[1]->sumn + val;\n        lmax = max(son[0]->lmax,son[0]->sumn + val + max(0,son[1]->lmax));\n        rmax = max(son[1]->rmax,son[1]->sumn + val + max(0,son[0]->rmax));\n        maxn = max(0,son[0]->rmax) + val + max(0,son[1]->lmax);\n        maxn = max(maxn,max(son[0]->maxn,son[1]->maxn));\n    }\n    void cover(int v){\n        if(this == *null) return;\n        val = v;sumn = size * v;\n        lmax = rmax = maxn = max(v,sumn);\n        is_tag = 1;tag = v;\n    }\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        swap(lmax,rmax);\n        rev^=1;\n    }\n};\n\n\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN],*garbage[MAXN];\n    node_t *root,*null;\n    int cnt,tot;\n    void newnode(node_t *&r,int val = 0){\n        if(tot == 0) r = &pool[cnt++];\n        else         r = garbage[--tot];//垃圾回收\n        r->val = val;r->size = 1;\n        r->lmax = r->rmax = r->maxn = r->sumn = val;\n        r->son[0] = r->son[1] = null;\n        r->is_tag = r->rev = 0;\n        r->null = &null;\n        r->p = rand();\n    }\n    fhqtreap(){\n        tot = 0;cnt = 0;\n        srand(time(NULL));\n        newnode(null,-MAX);\n        null->p = MAX;\n        root = null;\n        null -> sumn = null->size = 0;\n    }\n    void cycle(node_t *r){\n        if(r == null) return;\n        garbage[tot++] = r;\n        cycle(r->son[0]);\n        cycle(r->son[1]);\n    }\n    void read_tree(int n){\n        for(int i = 1;i<=n;i++){\n            int t;scanf(\"%d\",&t);\n            newnode(tmp[i],t);\n        }\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);\n        stack[0]->p = -MAX;\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;\n            stack[nowp+1]->son[0] = pre;\n            top = nowp+2;\n        }\n        while(top) stack[--top]->pushup();\n        return stack[0]->son[1];\n    }\n    void split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n        if(r == null){\n            ls = null;rs = null;return;\n        }\n        r->pushdown();\n        if(r->son[0]->size + 1 <= lsize){\n            ls = r;\n            split(r->son[1],lsize-r->son[0]->size-1,ls->son[1],rs);\n        }\n        else{\n            rs = r;\n            split(r->son[0],lsize,ls,rs->son[0]);\n        }\n        ls->pushup();rs->pushup();\n    }\n    node_t *merge(node_t *ls,node_t *rs){\n        if(ls == null) return rs;\n        if(rs == null) return ls;\n        if(ls->p < rs->p){\n            ls->pushdown();\n            ls->son[1] = merge(ls->son[1],rs);\n            ls->pushup();\n            return ls;\n        }\n        else{\n            rs->pushdown();\n            rs->son[0] = merge(ls,rs->son[0]);\n            rs->pushup();\n            return rs;\n        }\n    }\n    void insert(int rank,int n){\n        if(n == 0) return;\n        node_t *ls,*rs,*newn,*ret;\n        split(root,rank,ls,rs);\n        newn = build(n);\n        root = merge(merge(ls,newn),rs);\n    }\n    void split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n        node_t *m1;\n        split(root,ls,l,m1);\n        split(m1,ms,m,r);\n    }\n    void erase(int lb,int ms){\n        if(ms == 0) return;\n        node_t *l,*m,*r,*ret;\n        split(lb-1,ms,l,m,r);\n        cycle(m);\n        root = merge(l,r);\n    }\n    int get_sum(int lb,int ms){\n        if(ms == 0) return 0;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        int ans = m->sumn;\n        root = merge(l,merge(m,r));\n        return ans;\n    }\n    int max_sum(){\n        return root->maxn;\n    }\n    void reverse(int lb,int ms){\n        if(ms == 0) return;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        m->reverse();       \n        root = merge(l,merge(m,r));\n    }\n    void make_same(int lb,int ms,int c){\n        if(ms == 0) return;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        m->cover(c);\n        root = merge(l,merge(m,r));\n    }\n};\n\nfhqtreap w;\n\nvoid init(){\n    scanf(\"%d %d\",&n,&k);\n    w.root = w.build(n);\n}\n\nvoid solve(){\n    for(int i = 1;i<=k;i++){\n        char op[50];int a,b,c;\n        scanf(\"%s\",op);\n        if(op[0] == 'M'&&op[2] == 'X')\n            printf(\"%d\\n\",w.max_sum());\n        else{\n            scanf(\"%d %d\",&a,&b);\n            if(op[0] == 'I')\n                w.insert(a,b);\n            else if(op[0] == 'D')\n                w.erase(a,b);\n            else if(op[0] == 'G'){\n                printf(\"%d\\n\",w.get_sum(a,b));\n            }\n            else if(op[0] == 'M'){\n                scanf(\"%d\",&c);\n                w.make_same(a,b,c);\n            }\n            else if(op[0] == 'R'){\n                w.reverse(a,b);\n            }\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「NOI2005」维护数列-非旋Treap.md","raw":"---\ntitle: 「NOI2005」维护数列-非旋Treap\nurlname: noi2005-sequence\ndate: 2018-02-17 21:48:01\ntags:\n- 题解\n- Treap\n- 平衡树\n- 数据结构\ncategories: OI\nvisible:\n---\n\n维护一个数列，给定初始的$n$个数字。\n现有六种命令，在第$pos$个数后插入$tot$个数，翻转从第$pos$个数开始的$tot$个数，删除从第$pos$个数开始的$tot$个数，查询从第$pos$个数开始的$tot$个数的和，设定从第$pos$个数开始的$tot$个数设定为$c$，查询整个数列中和最大的连续子区间的大小。\n\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2042](https://www.luogu.org/problemnew/show/P2042)\n\n## 题解\n\n这是一道经典的平衡树的题，被我用来练手非旋$Treap$。\n\n因为我太弱了，所以写的很痛苦。\n\n关于合并和分裂的主要思想参见{% post_link 非旋Treap学习笔记 学习笔记 %}。\n\n- - -\n对于节点，要维护：\n\n树的大小，树的权值和，树从左端点开始的最大连续和，树从右端点开始的最大连续和，和树的最大连续子区间和。\n\n- - -\n主要操作：\n\n+ $pushdown$\n\n往下$push$，修改两个子节点并打上标记。\n\n+ $pushup$\n\n更新所有信息，维护三个$max$信息的方式有些特殊，但仔细想想应当能想到。\n\n这里我被坑了。这个与线段树的区间最大查询有点不太一样，根节点也有代表的数，这个需要记住。\n\n- - -\n\n+ 建树\n\n构建笛卡尔树。详见{% post_link 非旋Treap学习笔记 学习笔记 %}。\n\n+ 最大查询连续和\n\n直接输出根节点维护的最大连续子区间的值即可。\n\n+ 插入\n\n把即将插入的$tot$个数按照上文的介绍方法建树。\n\n把原来的数按照$size$裂成两棵树，分别按顺序合起来就可以了。\n\n- - -\n\n接下来的操作都需要裂成三棵树，左边的有$pos-1$个树，中间有$tot$个数。\n\n+ 删除\n\n直接删除中间子树，左右合并。因为内存不够（$64MB$），需要垃圾回收。\n\n+ 求和\n\n输出中间子树的和，再把三个子树顺次合并起来。\n\n+ 翻转\n\n翻转中间子树并打标记，再把三个子树顺次合并起来。\n\n+ 设定\n\n对中间子树完成设定并打标记，再将三个子树顺次合并起来。\n\n- - -\n\n还有一点就是垃圾回收。简略来说就是把删除的节点暴力的扔到一个栈里面，然后能用就用，不能有就再新开内存池。\n\n其他也没有什么重要的。多$pushdown pushup$几次，然后这些操作都是要注意边界，也就是`null`时候的条件的。$pushup$的合并公式也需要好好斟酌。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 510000;\n\nconst int MAX = 2147483647;\n\nint k,n;\n\nstruct node_t{\n    int val,p;\n    int lmax,rmax,maxn,sumn,tag;\n    int size;\n    bool rev,is_tag;\n    node_t *son[2],**null;\n    void pushdown(){\n        if(this == *null) return;\n        if(is_tag){\n            son[0]->cover(tag),son[1]->cover(tag);\n            is_tag = tag = 0;\n        }\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    void pushup(){\n        if(this == *null) return;\n        if(son[0] == *null && son[1] == *null){\n            size = 1;sumn = lmax = rmax = maxn = val;\n            return;\n        }\n        size = son[0]->size + son[1]->size + 1;\n        sumn = son[0]->sumn + son[1]->sumn + val;\n        lmax = max(son[0]->lmax,son[0]->sumn + val + max(0,son[1]->lmax));\n        rmax = max(son[1]->rmax,son[1]->sumn + val + max(0,son[0]->rmax));\n        maxn = max(0,son[0]->rmax) + val + max(0,son[1]->lmax);\n        maxn = max(maxn,max(son[0]->maxn,son[1]->maxn));\n    }\n    void cover(int v){\n        if(this == *null) return;\n        val = v;sumn = size * v;\n        lmax = rmax = maxn = max(v,sumn);\n        is_tag = 1;tag = v;\n    }\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        swap(lmax,rmax);\n        rev^=1;\n    }\n};\n\n\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN],*garbage[MAXN];\n    node_t *root,*null;\n    int cnt,tot;\n    void newnode(node_t *&r,int val = 0){\n        if(tot == 0) r = &pool[cnt++];\n        else         r = garbage[--tot];//垃圾回收\n        r->val = val;r->size = 1;\n        r->lmax = r->rmax = r->maxn = r->sumn = val;\n        r->son[0] = r->son[1] = null;\n        r->is_tag = r->rev = 0;\n        r->null = &null;\n        r->p = rand();\n    }\n    fhqtreap(){\n        tot = 0;cnt = 0;\n        srand(time(NULL));\n        newnode(null,-MAX);\n        null->p = MAX;\n        root = null;\n        null -> sumn = null->size = 0;\n    }\n    void cycle(node_t *r){\n        if(r == null) return;\n        garbage[tot++] = r;\n        cycle(r->son[0]);\n        cycle(r->son[1]);\n    }\n    void read_tree(int n){\n        for(int i = 1;i<=n;i++){\n            int t;scanf(\"%d\",&t);\n            newnode(tmp[i],t);\n        }\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);\n        stack[0]->p = -MAX;\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;\n            stack[nowp+1]->son[0] = pre;\n            top = nowp+2;\n        }\n        while(top) stack[--top]->pushup();\n        return stack[0]->son[1];\n    }\n    void split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n        if(r == null){\n            ls = null;rs = null;return;\n        }\n        r->pushdown();\n        if(r->son[0]->size + 1 <= lsize){\n            ls = r;\n            split(r->son[1],lsize-r->son[0]->size-1,ls->son[1],rs);\n        }\n        else{\n            rs = r;\n            split(r->son[0],lsize,ls,rs->son[0]);\n        }\n        ls->pushup();rs->pushup();\n    }\n    node_t *merge(node_t *ls,node_t *rs){\n        if(ls == null) return rs;\n        if(rs == null) return ls;\n        if(ls->p < rs->p){\n            ls->pushdown();\n            ls->son[1] = merge(ls->son[1],rs);\n            ls->pushup();\n            return ls;\n        }\n        else{\n            rs->pushdown();\n            rs->son[0] = merge(ls,rs->son[0]);\n            rs->pushup();\n            return rs;\n        }\n    }\n    void insert(int rank,int n){\n        if(n == 0) return;\n        node_t *ls,*rs,*newn,*ret;\n        split(root,rank,ls,rs);\n        newn = build(n);\n        root = merge(merge(ls,newn),rs);\n    }\n    void split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n        node_t *m1;\n        split(root,ls,l,m1);\n        split(m1,ms,m,r);\n    }\n    void erase(int lb,int ms){\n        if(ms == 0) return;\n        node_t *l,*m,*r,*ret;\n        split(lb-1,ms,l,m,r);\n        cycle(m);\n        root = merge(l,r);\n    }\n    int get_sum(int lb,int ms){\n        if(ms == 0) return 0;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        int ans = m->sumn;\n        root = merge(l,merge(m,r));\n        return ans;\n    }\n    int max_sum(){\n        return root->maxn;\n    }\n    void reverse(int lb,int ms){\n        if(ms == 0) return;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        m->reverse();       \n        root = merge(l,merge(m,r));\n    }\n    void make_same(int lb,int ms,int c){\n        if(ms == 0) return;\n        node_t *l,*m,*r;\n        split(lb-1,ms,l,m,r);\n        m->cover(c);\n        root = merge(l,merge(m,r));\n    }\n};\n\nfhqtreap w;\n\nvoid init(){\n    scanf(\"%d %d\",&n,&k);\n    w.root = w.build(n);\n}\n\nvoid solve(){\n    for(int i = 1;i<=k;i++){\n        char op[50];int a,b,c;\n        scanf(\"%s\",op);\n        if(op[0] == 'M'&&op[2] == 'X')\n            printf(\"%d\\n\",w.max_sum());\n        else{\n            scanf(\"%d %d\",&a,&b);\n            if(op[0] == 'I')\n                w.insert(a,b);\n            else if(op[0] == 'D')\n                w.erase(a,b);\n            else if(op[0] == 'G'){\n                printf(\"%d\\n\",w.get_sum(a,b));\n            }\n            else if(op[0] == 'M'){\n                scanf(\"%d\",&c);\n                w.make_same(a,b,c);\n            }\n            else if(op[0] == 'R'){\n                w.reverse(a,b);\n            }\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「NOI2005」维护数列-非旋Treap","published":1,"updated":"2018-06-02T02:32:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jf003abljrq69r7hja","content":"<p>维护一个数列，给定初始的$n$个数字。<br>现有六种命令，在第$pos$个数后插入$tot$个数，翻转从第$pos$个数开始的$tot$个数，删除从第$pos$个数开始的$tot$个数，查询从第$pos$个数开始的$tot$个数的和，设定从第$pos$个数开始的$tot$个数设定为$c$，查询整个数列中和最大的连续子区间的大小。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2042\" target=\"_blank\" rel=\"noopener\">Luogu P2042</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这是一道经典的平衡树的题，被我用来练手非旋$Treap$。</p>\n<p>因为我太弱了，所以写的很痛苦。</p>\n<p>关于合并和分裂的主要思想参见<a href=\"/20180217-nonerotatingtreap-notes/\" title=\"学习笔记\">学习笔记</a>。</p>\n<hr>\n<p>对于节点，要维护：</p>\n<p>树的大小，树的权值和，树从左端点开始的最大连续和，树从右端点开始的最大连续和，和树的最大连续子区间和。</p>\n<hr>\n<p>主要操作：</p>\n<ul>\n<li>$pushdown$</li>\n</ul>\n<p>往下$push$，修改两个子节点并打上标记。</p>\n<ul>\n<li>$pushup$</li>\n</ul>\n<p>更新所有信息，维护三个$max$信息的方式有些特殊，但仔细想想应当能想到。</p>\n<p>这里我被坑了。这个与线段树的区间最大查询有点不太一样，根节点也有代表的数，这个需要记住。</p>\n<hr>\n<ul>\n<li>建树</li>\n</ul>\n<p>构建笛卡尔树。详见<a href=\"/20180217-nonerotatingtreap-notes/\" title=\"学习笔记\">学习笔记</a>。</p>\n<ul>\n<li>最大查询连续和</li>\n</ul>\n<p>直接输出根节点维护的最大连续子区间的值即可。</p>\n<ul>\n<li>插入</li>\n</ul>\n<p>把即将插入的$tot$个数按照上文的介绍方法建树。</p>\n<p>把原来的数按照$size$裂成两棵树，分别按顺序合起来就可以了。</p>\n<hr>\n<p>接下来的操作都需要裂成三棵树，左边的有$pos-1$个树，中间有$tot$个数。</p>\n<ul>\n<li>删除</li>\n</ul>\n<p>直接删除中间子树，左右合并。因为内存不够（$64MB$），需要垃圾回收。</p>\n<ul>\n<li>求和</li>\n</ul>\n<p>输出中间子树的和，再把三个子树顺次合并起来。</p>\n<ul>\n<li>翻转</li>\n</ul>\n<p>翻转中间子树并打标记，再把三个子树顺次合并起来。</p>\n<ul>\n<li>设定</li>\n</ul>\n<p>对中间子树完成设定并打标记，再将三个子树顺次合并起来。</p>\n<hr>\n<p>还有一点就是垃圾回收。简略来说就是把删除的节点暴力的扔到一个栈里面，然后能用就用，不能有就再新开内存池。</p>\n<p>其他也没有什么重要的。多$pushdown pushup$几次，然后这些操作都是要注意边界，也就是<code>null</code>时候的条件的。$pushup$的合并公式也需要好好斟酌。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">510000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> k,n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val,p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lmax,rmax,maxn,sumn,tag;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev,is_tag;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>],**null;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(is_tag)&#123;</span><br><span class=\"line\">            son[<span class=\"number\">0</span>]-&gt;cover(tag),son[<span class=\"number\">1</span>]-&gt;cover(tag);</span><br><span class=\"line\">            is_tag = tag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev) &#123;</span><br><span class=\"line\">            son[<span class=\"number\">0</span>]-&gt;reverse(),son[<span class=\"number\">1</span>]-&gt;reverse();</span><br><span class=\"line\">            rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(son[<span class=\"number\">0</span>] == *null &amp;&amp; son[<span class=\"number\">1</span>] == *null)&#123;</span><br><span class=\"line\">            size = <span class=\"number\">1</span>;sumn = lmax = rmax = maxn = val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = son[<span class=\"number\">0</span>]-&gt;size + son[<span class=\"number\">1</span>]-&gt;size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        sumn = son[<span class=\"number\">0</span>]-&gt;sumn + son[<span class=\"number\">1</span>]-&gt;sumn + val;</span><br><span class=\"line\">        lmax = max(son[<span class=\"number\">0</span>]-&gt;lmax,son[<span class=\"number\">0</span>]-&gt;sumn + val + max(<span class=\"number\">0</span>,son[<span class=\"number\">1</span>]-&gt;lmax));</span><br><span class=\"line\">        rmax = max(son[<span class=\"number\">1</span>]-&gt;rmax,son[<span class=\"number\">1</span>]-&gt;sumn + val + max(<span class=\"number\">0</span>,son[<span class=\"number\">0</span>]-&gt;rmax));</span><br><span class=\"line\">        maxn = max(<span class=\"number\">0</span>,son[<span class=\"number\">0</span>]-&gt;rmax) + val + max(<span class=\"number\">0</span>,son[<span class=\"number\">1</span>]-&gt;lmax);</span><br><span class=\"line\">        maxn = max(maxn,max(son[<span class=\"number\">0</span>]-&gt;maxn,son[<span class=\"number\">1</span>]-&gt;maxn));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cover</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        val = v;sumn = size * v;</span><br><span class=\"line\">        lmax = rmax = maxn = max(v,sumn);</span><br><span class=\"line\">        is_tag = <span class=\"number\">1</span>;tag = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(son[<span class=\"number\">0</span>],son[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        swap(lmax,rmax);</span><br><span class=\"line\">        rev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fhqtreap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[MAXN],*tmp[MAXN],*<span class=\"built_in\">stack</span>[MAXN],*garbage[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *root,*null;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt,tot;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> val = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tot == <span class=\"number\">0</span>) r = &amp;pool[cnt++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>         r = garbage[--tot];<span class=\"comment\">//垃圾回收</span></span><br><span class=\"line\">        r-&gt;val = val;r-&gt;size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;lmax = r-&gt;rmax = r-&gt;maxn = r-&gt;sumn = val;</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">        r-&gt;is_tag = r-&gt;rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        r-&gt;null = &amp;null;</span><br><span class=\"line\">        r-&gt;p = rand();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fhqtreap()&#123;</span><br><span class=\"line\">        tot = <span class=\"number\">0</span>;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">        newnode(null,-MAX);</span><br><span class=\"line\">        null-&gt;p = MAX;</span><br><span class=\"line\">        root = null;</span><br><span class=\"line\">        null -&gt; sumn = null-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cycle</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        garbage[tot++] = r;</span><br><span class=\"line\">        cycle(r-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        cycle(r-&gt;son[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;t);</span><br><span class=\"line\">            newnode(tmp[i],t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *build(<span class=\"keyword\">int</span> n)&#123;</span><br><span class=\"line\">        read_tree(n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top = <span class=\"number\">1</span>;</span><br><span class=\"line\">        newnode(<span class=\"built_in\">stack</span>[<span class=\"number\">0</span>],-MAX);</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;p = -MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowp = top - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">node_t</span> *r = tmp[i],*pre = null;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"built_in\">stack</span>[nowp]-&gt;p &gt; r -&gt; p)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[nowp]-&gt;pushup();</span><br><span class=\"line\">                pre = <span class=\"built_in\">stack</span>[nowp];</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[nowp] = null;</span><br><span class=\"line\">                nowp--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>] = <span class=\"built_in\">stack</span>[nowp]-&gt;son[<span class=\"number\">1</span>] = r;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>]-&gt;son[<span class=\"number\">0</span>] = pre;</span><br><span class=\"line\">            top = nowp+<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top) <span class=\"built_in\">stack</span>[--top]-&gt;pushup();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;son[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> lsize,<span class=\"keyword\">node_t</span> *&amp;ls,<span class=\"keyword\">node_t</span> *&amp;rs)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null)&#123;</span><br><span class=\"line\">            ls = null;rs = null;<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r-&gt;pushdown();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>]-&gt;size + <span class=\"number\">1</span> &lt;= lsize)&#123;</span><br><span class=\"line\">            ls = r;</span><br><span class=\"line\">            split(r-&gt;son[<span class=\"number\">1</span>],lsize-r-&gt;son[<span class=\"number\">0</span>]-&gt;size<span class=\"number\">-1</span>,ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            rs = r;</span><br><span class=\"line\">            split(r-&gt;son[<span class=\"number\">0</span>],lsize,ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ls-&gt;pushup();rs-&gt;pushup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *merge(<span class=\"keyword\">node_t</span> *ls,<span class=\"keyword\">node_t</span> *rs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ls == null) <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rs == null) <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ls-&gt;p &lt; rs-&gt;p)&#123;</span><br><span class=\"line\">            ls-&gt;pushdown();</span><br><span class=\"line\">            ls-&gt;son[<span class=\"number\">1</span>] = merge(ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">            ls-&gt;pushup();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            rs-&gt;pushdown();</span><br><span class=\"line\">            rs-&gt;son[<span class=\"number\">0</span>] = merge(ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            rs-&gt;pushup();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> rank,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *ls,*rs,*newn,*ret;</span><br><span class=\"line\">        split(root,rank,ls,rs);</span><br><span class=\"line\">        newn = build(n);</span><br><span class=\"line\">        root = merge(merge(ls,newn),rs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> ls,<span class=\"keyword\">int</span> ms,<span class=\"keyword\">node_t</span> *&amp;l,<span class=\"keyword\">node_t</span> *&amp;m,<span class=\"keyword\">node_t</span> *&amp;r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *m1;</span><br><span class=\"line\">        split(root,ls,l,m1);</span><br><span class=\"line\">        split(m1,ms,m,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> ms)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ms == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *l,*m,*r,*ret;</span><br><span class=\"line\">        split(lb<span class=\"number\">-1</span>,ms,l,m,r);</span><br><span class=\"line\">        cycle(m);</span><br><span class=\"line\">        root = merge(l,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">get_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> ms)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ms == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *l,*m,*r;</span><br><span class=\"line\">        split(lb<span class=\"number\">-1</span>,ms,l,m,r);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = m-&gt;sumn;</span><br><span class=\"line\">        root = merge(l,merge(m,r));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">max_sum</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root-&gt;maxn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> ms)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ms == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *l,*m,*r;</span><br><span class=\"line\">        split(lb<span class=\"number\">-1</span>,ms,l,m,r);</span><br><span class=\"line\">        m-&gt;reverse();       </span><br><span class=\"line\">        root = merge(l,merge(m,r));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make_same</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> ms,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ms == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *l,*m,*r;</span><br><span class=\"line\">        split(lb<span class=\"number\">-1</span>,ms,l,m,r);</span><br><span class=\"line\">        m-&gt;cover(c);</span><br><span class=\"line\">        root = merge(l,merge(m,r));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fhqtreap w;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    w.root = w.build(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> op[<span class=\"number\">50</span>];<span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,op);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'M'</span>&amp;&amp;op[<span class=\"number\">2</span>] == <span class=\"string\">'X'</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.max_sum());</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'I'</span>)</span><br><span class=\"line\">                w.insert(a,b);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>)</span><br><span class=\"line\">                w.erase(a,b);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'G'</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,w.get_sum(a,b));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'M'</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;c);</span><br><span class=\"line\">                w.make_same(a,b,c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">                w.reverse(a,b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>维护一个数列，给定初始的$n$个数字。<br>现有六种命令，在第$pos$个数后插入$tot$个数，翻转从第$pos$个数开始的$tot$个数，删除从第$pos$个数开始的$tot$个数，查询从第$pos$个数开始的$tot$个数的和，设定从第$pos$个数开始的$tot$个数设定为$c$，查询整个数列中和最大的连续子区间的大小。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2042\" target=\"_blank\" rel=\"noopener\">Luogu P2042</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这是一道经典的平衡树的题，被我用来练手非旋$Treap$。</p>\n<p>因为我太弱了，所以写的很痛苦。</p>\n<p>关于合并和分裂的主要思想参见<a href=\"/20180217-nonerotatingtreap-notes/\" title=\"学习笔记\">学习笔记</a>。</p>\n<hr>\n<p>对于节点，要维护：</p>\n<p>树的大小，树的权值和，树从左端点开始的最大连续和，树从右端点开始的最大连续和，和树的最大连续子区间和。</p>\n<hr>\n<p>主要操作：</p>\n<ul>\n<li>$pushdown$</li>\n</ul>\n<p>往下$push$，修改两个子节点并打上标记。</p>\n<ul>\n<li>$pushup$</li>\n</ul>\n<p>更新所有信息，维护三个$max$信息的方式有些特殊，但仔细想想应当能想到。</p>\n<p>这里我被坑了。这个与线段树的区间最大查询有点不太一样，根节点也有代表的数，这个需要记住。</p>\n<hr>\n<ul>\n<li>建树</li>\n</ul>\n<p>构建笛卡尔树。详见<a href=\"/20180217-nonerotatingtreap-notes/\" title=\"学习笔记\">学习笔记</a>。</p>\n<ul>\n<li>最大查询连续和</li>\n</ul>\n<p>直接输出根节点维护的最大连续子区间的值即可。</p>\n<ul>\n<li>插入</li>\n</ul>\n<p>把即将插入的$tot$个数按照上文的介绍方法建树。</p>\n<p>把原来的数按照$size$裂成两棵树，分别按顺序合起来就可以了。</p>\n<hr>\n<p>接下来的操作都需要裂成三棵树，左边的有$pos-1$个树，中间有$tot$个数。</p>\n<ul>\n<li>删除</li>\n</ul>\n<p>直接删除中间子树，左右合并。因为内存不够（$64MB$），需要垃圾回收。</p>\n<ul>\n<li>求和</li>\n</ul>\n<p>输出中间子树的和，再把三个子树顺次合并起来。</p>\n<ul>\n<li>翻转</li>\n</ul>\n<p>翻转中间子树并打标记，再把三个子树顺次合并起来。</p>\n<ul>\n<li>设定</li>\n</ul>\n<p>对中间子树完成设定并打标记，再将三个子树顺次合并起来。</p>\n<hr>\n<p>还有一点就是垃圾回收。简略来说就是把删除的节点暴力的扔到一个栈里面，然后能用就用，不能有就再新开内存池。</p>\n<p>其他也没有什么重要的。多$pushdown pushup$几次，然后这些操作都是要注意边界，也就是<code>null</code>时候的条件的。$pushup$的合并公式也需要好好斟酌。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�35-->\n\n</div></div>"},{"title":"「NOI2009」二叉查找树-区间dp","urlname":"NOI2009-binary","date":"2018-04-28T12:21:18.000Z","visible":null,"_content":"\n给定$n$个结点的数据值$V_i$，权值$P_i$，访问频度$T_i(T_i \\geq 0)$。对于$\\forall i,j \\in V$且$i \\neq j$，有$V_i \\neq V_j, P_i \\neq P_j$。\n\n现令这n个点组成一颗二叉树，且满足$\\forall \\, i \\in V$，若$p$为$i$的左子节点，$q$为$i$的右子节点，则$V_p < V_i < V_q$且$P_i < P_p,\\; P_i < P_q$。可以证明，这样的二叉树是唯一的。点\u001c$i$在树中的深度$D_i$定义为它到根的距离加$1$。定义结点$i$的访问代价$E_i = T_i \\times D_i$。可以修改每个点的权值为任意实数，其代价均为给定的正整数$K$，但需保证任两点权值仍互不相同。\n\n现求上文所述二叉树中，其 $\\sum^n _{i = 1}{E_i} + \\sum K$的最小值。\n<!-- more -->\n原文描述：\n\n{% fold %}\n- - -\n已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。\n\n另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。\n\n已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。\n\n一个结点在树中的深度定义为它到树根的距离加1。因此树的根结点的深度为1。\n\n每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。\n\n现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出K的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？\n- - -\n{% endfold %}\n\n## 链接\n\n[Luogu P1864](https://www.luogu.org/problemnew/show/P1864)\n\n[BZOJ 1564](https://www.lydsy.com/JudgeOnline/problem.php?id=1564)\n\n## 题解\n比较简单的区间dp。\n\n首先对点的权值离散化，然后按照点的数据值排序。注意到点的顺序是确定的，所以如果给定区间$[l,r]$以及其根节点能取到的最大的权值$p$，就可以确定这个最小值。这个问题还满足局部最优解，所以搞一搞$dp$就可以了。定义$w(i,j)= \\sum_{k = i}^j {T_i}$。转移方程如下：\n\n$$\nm(l,r,p) = 0\\; (l \\geq r),\n$$\n\n$$\n\\min_{k = l}^r{(\\, m(l,k-1,p)+m(k+1,r,p)+ K), \\;\nm(l,k-1,P_k)+m(k+1,r,P_k))+w(i,j) \\; \\;(l < r)}\n$$\n\n\n## 代码\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define pp node\nusing namespace std;\n\nconst int MAXN = 80;\nint n,K;\nint sum[MAXN],num[MAXN];\nint dp[MAXN][MAXN][MAXN];\nstruct node{\n    int fr,sc,tr;\n    bool operator < (const node a)const{\n        return fr < a.fr;\n    }\n};\n\nvoid init(){\n    scanf(\"%d %d\",&n,&K);\n    pp tmp[MAXN];int t[MAXN];\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&tmp[i].fr);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%d\",&tmp[i].sc);\n        t[i] = tmp[i].sc;\n    }\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&tmp[i].tr);\n    sort(tmp+1,tmp+n+1),sort(t+1,t+n+1);\n    for(int i = 1;i<=n;i++){\n        num[i] = lower_bound(t+1,t+n+1,tmp[i].sc)-t;\n        sum[i] = sum[i-1]+tmp[i].tr;\n    }\n}\n\nvoid solve(){\n    int tmp;\n    for(int w = 1;w<=n;w++){\n        for(int l = 1,r = w;r<=n;l++,r++){\n            for(int p = 0;p<=n;p++){\n                dp[l][r][p] = 0x3f3f3f3f;\n                for(int k = l;k<=r;k++){\n                    tmp = min(dp[l][k-1][p] + dp[k+1][r][p] + K,\n                    num[k] > p? dp[l][k-1][num[k]] + dp[k+1][r][num[k]]: 0x3f3f3f3f);\n                    dp[l][r][p] = min(dp[l][r][p],tmp);\n                }\n                dp[l][r][p] += sum[r] - sum[l-1];\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[1][n][0]);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「NOI2009」二叉查找树-区间dp.md","raw":"---\ntitle: 「NOI2009」二叉查找树-区间dp\nurlname: NOI2009-binary\ndate: 2018-04-28 20:21:18\ntags:\n- 题解\n- 动态规划\n- 平衡树\ncategories: OI\nvisible:\n---\n\n给定$n$个结点的数据值$V_i$，权值$P_i$，访问频度$T_i(T_i \\geq 0)$。对于$\\forall i,j \\in V$且$i \\neq j$，有$V_i \\neq V_j, P_i \\neq P_j$。\n\n现令这n个点组成一颗二叉树，且满足$\\forall \\, i \\in V$，若$p$为$i$的左子节点，$q$为$i$的右子节点，则$V_p < V_i < V_q$且$P_i < P_p,\\; P_i < P_q$。可以证明，这样的二叉树是唯一的。点\u001c$i$在树中的深度$D_i$定义为它到根的距离加$1$。定义结点$i$的访问代价$E_i = T_i \\times D_i$。可以修改每个点的权值为任意实数，其代价均为给定的正整数$K$，但需保证任两点权值仍互不相同。\n\n现求上文所述二叉树中，其 $\\sum^n _{i = 1}{E_i} + \\sum K$的最小值。\n<!-- more -->\n原文描述：\n\n{% fold %}\n- - -\n已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。\n\n另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。\n\n已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。\n\n一个结点在树中的深度定义为它到树根的距离加1。因此树的根结点的深度为1。\n\n每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。\n\n现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出K的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？\n- - -\n{% endfold %}\n\n## 链接\n\n[Luogu P1864](https://www.luogu.org/problemnew/show/P1864)\n\n[BZOJ 1564](https://www.lydsy.com/JudgeOnline/problem.php?id=1564)\n\n## 题解\n比较简单的区间dp。\n\n首先对点的权值离散化，然后按照点的数据值排序。注意到点的顺序是确定的，所以如果给定区间$[l,r]$以及其根节点能取到的最大的权值$p$，就可以确定这个最小值。这个问题还满足局部最优解，所以搞一搞$dp$就可以了。定义$w(i,j)= \\sum_{k = i}^j {T_i}$。转移方程如下：\n\n$$\nm(l,r,p) = 0\\; (l \\geq r),\n$$\n\n$$\n\\min_{k = l}^r{(\\, m(l,k-1,p)+m(k+1,r,p)+ K), \\;\nm(l,k-1,P_k)+m(k+1,r,P_k))+w(i,j) \\; \\;(l < r)}\n$$\n\n\n## 代码\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define pp node\nusing namespace std;\n\nconst int MAXN = 80;\nint n,K;\nint sum[MAXN],num[MAXN];\nint dp[MAXN][MAXN][MAXN];\nstruct node{\n    int fr,sc,tr;\n    bool operator < (const node a)const{\n        return fr < a.fr;\n    }\n};\n\nvoid init(){\n    scanf(\"%d %d\",&n,&K);\n    pp tmp[MAXN];int t[MAXN];\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&tmp[i].fr);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%d\",&tmp[i].sc);\n        t[i] = tmp[i].sc;\n    }\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&tmp[i].tr);\n    sort(tmp+1,tmp+n+1),sort(t+1,t+n+1);\n    for(int i = 1;i<=n;i++){\n        num[i] = lower_bound(t+1,t+n+1,tmp[i].sc)-t;\n        sum[i] = sum[i-1]+tmp[i].tr;\n    }\n}\n\nvoid solve(){\n    int tmp;\n    for(int w = 1;w<=n;w++){\n        for(int l = 1,r = w;r<=n;l++,r++){\n            for(int p = 0;p<=n;p++){\n                dp[l][r][p] = 0x3f3f3f3f;\n                for(int k = l;k<=r;k++){\n                    tmp = min(dp[l][k-1][p] + dp[k+1][r][p] + K,\n                    num[k] > p? dp[l][k-1][num[k]] + dp[k+1][r][num[k]]: 0x3f3f3f3f);\n                    dp[l][r][p] = min(dp[l][r][p],tmp);\n                }\n                dp[l][r][p] += sum[r] - sum[l-1];\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[1][n][0]);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「NOI2009」二叉查找树-区间dp","published":1,"updated":"2018-05-05T14:48:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jh003dbljrkgcqpuo7","content":"<p>给定$n$个结点的数据值$V_i$，权值$P_i$，访问频度$T_i(T_i \\geq 0)$。对于$\\forall i,j \\in V$且$i \\neq j$，有$V_i \\neq V_j, P_i \\neq P_j$。</p>\n<p>现令这n个点组成一颗二叉树，且满足$\\forall \\, i \\in V$，若$p$为$i$的左子节点，$q$为$i$的右子节点，则$V_p &lt; V_i &lt; V_q$且$P_i &lt; P_p,\\; P_i &lt; P_q$。可以证明，这样的二叉树是唯一的。点\u001c$i$在树中的深度$D_i$定义为它到根的距离加$1$。定义结点$i$的访问代价$E_i = T_i \\times D_i$。可以修改每个点的权值为任意实数，其代价均为给定的正整数$K$，但需保证任两点权值仍互不相同。</p>\n<p>现求上文所述二叉树中，其 $\\sum^n _{i = 1}{E_i} + \\sum K$的最小值。<br><a id=\"more\"></a><br>原文描述：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<hr>\n<p>已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。</p>\n<p>另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。</p>\n<p>已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。</p>\n<p>一个结点在树中的深度定义为它到树根的距离加1。因此树的根结点的深度为1。</p>\n<p>每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。</p>\n<p>现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出K的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？</p>\n<hr>\n\n</div></div>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1864\" target=\"_blank\" rel=\"noopener\">Luogu P1864</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1564\" target=\"_blank\" rel=\"noopener\">BZOJ 1564</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较简单的区间dp。</p>\n<p>首先对点的权值离散化，然后按照点的数据值排序。注意到点的顺序是确定的，所以如果给定区间$[l,r]$以及其根节点能取到的最大的权值$p$，就可以确定这个最小值。这个问题还满足局部最优解，所以搞一搞$dp$就可以了。定义$w(i,j)= \\sum_{k = i}^j {T_i}$。转移方程如下：</p>\n<p>$$<br>m(l,r,p) = 0\\; (l \\geq r),<br>$$</p>\n<p>$$<br>\\min_{k = l}^r{(\\, m(l,k-1,p)+m(k+1,r,p)+ K), \\;<br>m(l,k-1,P_k)+m(k+1,r,P_k))+w(i,j) \\; \\;(l &lt; r)}<br>$$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pp node</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">80</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,K;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[MAXN],num[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[MAXN][MAXN][MAXN];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> fr,sc,tr;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fr &lt; a.fr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;n,&amp;K);</span><br><span class=\"line\">    pp tmp[MAXN];<span class=\"keyword\">int</span> t[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;tmp[i].fr);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;tmp[i].sc);</span><br><span class=\"line\">        t[i] = tmp[i].sc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;tmp[i].tr);</span><br><span class=\"line\">    sort(tmp+<span class=\"number\">1</span>,tmp+n+<span class=\"number\">1</span>),sort(t+<span class=\"number\">1</span>,t+n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        num[i] = lower_bound(t+<span class=\"number\">1</span>,t+n+<span class=\"number\">1</span>,tmp[i].sc)-t;</span><br><span class=\"line\">        sum[i] = sum[i<span class=\"number\">-1</span>]+tmp[i].tr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> w = <span class=\"number\">1</span>;w&lt;=n;w++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,r = w;r&lt;=n;l++,r++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>;p&lt;=n;p++)&#123;</span><br><span class=\"line\">                dp[l][r][p] = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = l;k&lt;=r;k++)&#123;</span><br><span class=\"line\">                    tmp = min(dp[l][k<span class=\"number\">-1</span>][p] + dp[k+<span class=\"number\">1</span>][r][p] + K,</span><br><span class=\"line\">                    num[k] &gt; p? dp[l][k<span class=\"number\">-1</span>][num[k]] + dp[k+<span class=\"number\">1</span>][r][num[k]]: <span class=\"number\">0x3f3f3f3f</span>);</span><br><span class=\"line\">                    dp[l][r][p] = min(dp[l][r][p],tmp);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[l][r][p] += sum[r] - sum[l<span class=\"number\">-1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,dp[<span class=\"number\">1</span>][n][<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定$n$个结点的数据值$V_i$，权值$P_i$，访问频度$T_i(T_i \\geq 0)$。对于$\\forall i,j \\in V$且$i \\neq j$，有$V_i \\neq V_j, P_i \\neq P_j$。</p>\n<p>现令这n个点组成一颗二叉树，且满足$\\forall \\, i \\in V$，若$p$为$i$的左子节点，$q$为$i$的右子节点，则$V_p &lt; V_i &lt; V_q$且$P_i &lt; P_p,\\; P_i &lt; P_q$。可以证明，这样的二叉树是唯一的。点\u001c$i$在树中的深度$D_i$定义为它到根的距离加$1$。定义结点$i$的访问代价$E_i = T_i \\times D_i$。可以修改每个点的权值为任意实数，其代价均为给定的正整数$K$，但需保证任两点权值仍互不相同。</p>\n<p>现求上文所述二叉树中，其 $\\sum^n _{i = 1}{E_i} + \\sum K$的最小值。<br>","more":"<br>原文描述：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<hr>\n<p>已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。</p>\n<p>另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。</p>\n<p>已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。</p>\n<p>一个结点在树中的深度定义为它到树根的距离加1。因此树的根结点的深度为1。</p>\n<p>每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。</p>\n<p>现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出K的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？</p>\n<hr>\n\n</div></div>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1864\" target=\"_blank\" rel=\"noopener\">Luogu P1864</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1564\" target=\"_blank\" rel=\"noopener\">BZOJ 1564</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较简单的区间dp。</p>\n<p>首先对点的权值离散化，然后按照点的数据值排序。注意到点的顺序是确定的，所以如果给定区间$[l,r]$以及其根节点能取到的最大的权值$p$，就可以确定这个最小值。这个问题还满足局部最优解，所以搞一搞$dp$就可以了。定义$w(i,j)= \\sum_{k = i}^j {T_i}$。转移方程如下：</p>\n<p>$$<br>m(l,r,p) = 0\\; (l \\geq r),<br>$$</p>\n<p>$$<br>\\min_{k = l}^r{(\\, m(l,k-1,p)+m(k+1,r,p)+ K), \\;<br>m(l,k-1,P_k)+m(k+1,r,P_k))+w(i,j) \\; \\;(l &lt; r)}<br>$$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�36-->\n\n</div></div>"},{"title":"「NOI2010」能量采集-简单数学","urlname":"NOI2010-energy","date":"2018-06-18T01:31:46.000Z","visible":null,"_content":"\n给定两个整数$n$,$m$，对于平面上的整点$\\{(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z\\}$。若$(x,y)$与$(0,0)$的连线上有$k$个整点（不包括$(0,0),(n,m)$），则产生的贡献为$2k+1$。求所有满足条件的点的贡献总和。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1447](https://www.luogu.org/problemnew/show/P1447)\n\n## 题解\n\n给出一个结论：**从$(0,0)$到$(n,m)$的线路上，有$gcd(n,m)-1$个整点(不包括$(0,0),(n,m)$)**。想一想很好明白：令t是n,m的公因数$(\\frac {n}{t},\\frac {m}{t})$就相当于步长，$m,n$一定时$t$越大，步长越小，整点就越多。$gcd(n,m)$是$n,m$的最大公因数，所以就是最多整点的个数了。\n\n所以问题转化为：\n求\n\n$$\\sum_{i = 1}^{n} \\sum_{j = 1}^{m}2\\times gcd(n,m)-1$$\n\n的值。\n\n显然高端的数学方法我肯定是不会的。那怎么办呢。\n\n数据范围不允许我们求出对于每一个$n,m$的$gcd$，但是我们可以想办法求出对于每一个$w$，$gcd(i,j) = w$的$(i,j)$对数，然后就可以$O(n)$的加出结果了。\n\n这个东西的话也不太好求...但是我们可以求出以w为约数的树的个数！对于一个$w$，均以$w$为约数的$(i,j)$的个数就是$\\lfloor \\frac{n}{w} \\rfloor \\times \\lfloor \\frac{m}{w} \\rfloor$。\n\n还有一件事情，就是以$w$为最大公因数的数的个数就是以$w$为约数的数的个数减去以$kw(k = 2,3,4...)$为最大公因数的个数。\n\n然后我们就可以开始从上往下的递推了，计算的时候每次往上跳$w$，直到超界，然后都减去就可以了。\n\n根据一些调和级数的东西，$1+\\frac{1}{2}+\\frac{1}{3}...+\\frac{1}{n} \\approx \\ln n$，所以最后的复杂度大约是$O(n \\ln n)$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int MAXN = 110000;\n\nint n,m,w,f[MAXN];\n\nvoid init(){\n    scanf(\"%lld %lld\",&n,&m);\n    w = min(n,m);\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = w;i>=1;--i){\n        f[i] = (n/i) * (m/i);\n        for(int j = 2*i;j<=w;j+=i)\n            f[i] -= f[j];\n        ans += f[i]*(2*i-1);\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nsigned main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「NOI2010」能量采集-简单数学.md","raw":"---\ntitle: 「NOI2010」能量采集-简单数学\nurlname: NOI2010-energy\ndate: 2018-06-18 09:31:46\ntags:\n- 题解\n- 数学\n- 最大公约数\ncategories: \n- OI\nvisible:\n---\n\n给定两个整数$n$,$m$，对于平面上的整点$\\{(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z\\}$。若$(x,y)$与$(0,0)$的连线上有$k$个整点（不包括$(0,0),(n,m)$），则产生的贡献为$2k+1$。求所有满足条件的点的贡献总和。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1447](https://www.luogu.org/problemnew/show/P1447)\n\n## 题解\n\n给出一个结论：**从$(0,0)$到$(n,m)$的线路上，有$gcd(n,m)-1$个整点(不包括$(0,0),(n,m)$)**。想一想很好明白：令t是n,m的公因数$(\\frac {n}{t},\\frac {m}{t})$就相当于步长，$m,n$一定时$t$越大，步长越小，整点就越多。$gcd(n,m)$是$n,m$的最大公因数，所以就是最多整点的个数了。\n\n所以问题转化为：\n求\n\n$$\\sum_{i = 1}^{n} \\sum_{j = 1}^{m}2\\times gcd(n,m)-1$$\n\n的值。\n\n显然高端的数学方法我肯定是不会的。那怎么办呢。\n\n数据范围不允许我们求出对于每一个$n,m$的$gcd$，但是我们可以想办法求出对于每一个$w$，$gcd(i,j) = w$的$(i,j)$对数，然后就可以$O(n)$的加出结果了。\n\n这个东西的话也不太好求...但是我们可以求出以w为约数的树的个数！对于一个$w$，均以$w$为约数的$(i,j)$的个数就是$\\lfloor \\frac{n}{w} \\rfloor \\times \\lfloor \\frac{m}{w} \\rfloor$。\n\n还有一件事情，就是以$w$为最大公因数的数的个数就是以$w$为约数的数的个数减去以$kw(k = 2,3,4...)$为最大公因数的个数。\n\n然后我们就可以开始从上往下的递推了，计算的时候每次往上跳$w$，直到超界，然后都减去就可以了。\n\n根据一些调和级数的东西，$1+\\frac{1}{2}+\\frac{1}{3}...+\\frac{1}{n} \\approx \\ln n$，所以最后的复杂度大约是$O(n \\ln n)$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int MAXN = 110000;\n\nint n,m,w,f[MAXN];\n\nvoid init(){\n    scanf(\"%lld %lld\",&n,&m);\n    w = min(n,m);\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = w;i>=1;--i){\n        f[i] = (n/i) * (m/i);\n        for(int j = 2*i;j<=w;j+=i)\n            f[i] -= f[j];\n        ans += f[i]*(2*i-1);\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nsigned main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","slug":"「NOI2010」能量采集-简单数学","published":1,"updated":"2018-06-18T02:15:36.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jj003gbljrkz0mm4f7","content":"<p>给定两个整数$n$,$m$，对于平面上的整点${(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z}$。若$(x,y)$与$(0,0)$的连线上有$k$个整点（不包括$(0,0),(n,m)$），则产生的贡献为$2k+1$。求所有满足条件的点的贡献总和。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1447\" target=\"_blank\" rel=\"noopener\">Luogu P1447</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>给出一个结论：<strong>从$(0,0)$到$(n,m)$的线路上，有$gcd(n,m)-1$个整点(不包括$(0,0),(n,m)$)</strong>。想一想很好明白：令t是n,m的公因数$(\\frac {n}{t},\\frac {m}{t})$就相当于步长，$m,n$一定时$t$越大，步长越小，整点就越多。$gcd(n,m)$是$n,m$的最大公因数，所以就是最多整点的个数了。</p>\n<p>所以问题转化为：<br>求</p>\n<p>$$\\sum_{i = 1}^{n} \\sum_{j = 1}^{m}2\\times gcd(n,m)-1$$</p>\n<p>的值。</p>\n<p>显然高端的数学方法我肯定是不会的。那怎么办呢。</p>\n<p>数据范围不允许我们求出对于每一个$n,m$的$gcd$，但是我们可以想办法求出对于每一个$w$，$gcd(i,j) = w$的$(i,j)$对数，然后就可以$O(n)$的加出结果了。</p>\n<p>这个东西的话也不太好求…但是我们可以求出以w为约数的树的个数！对于一个$w$，均以$w$为约数的$(i,j)$的个数就是$\\lfloor \\frac{n}{w} \\rfloor \\times \\lfloor \\frac{m}{w} \\rfloor$。</p>\n<p>还有一件事情，就是以$w$为最大公因数的数的个数就是以$w$为约数的数的个数减去以$kw(k = 2,3,4…)$为最大公因数的个数。</p>\n<p>然后我们就可以开始从上往下的递推了，计算的时候每次往上跳$w$，直到超界，然后都减去就可以了。</p>\n<p>根据一些调和级数的东西，$1+\\frac{1}{2}+\\frac{1}{3}…+\\frac{1}{n} \\approx \\ln n$，所以最后的复杂度大约是$O(n \\ln n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,w,f[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    w = min(n,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = w;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">        f[i] = (n/i) * (m/i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>*i;j&lt;=w;j+=i)</span><br><span class=\"line\">            f[i] -= f[j];</span><br><span class=\"line\">        ans += f[i]*(<span class=\"number\">2</span>*i<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>给定两个整数$n$,$m$，对于平面上的整点${(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z}$。若$(x,y)$与$(0,0)$的连线上有$k$个整点（不包括$(0,0),(n,m)$），则产生的贡献为$2k+1$。求所有满足条件的点的贡献总和。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1447\" target=\"_blank\" rel=\"noopener\">Luogu P1447</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>给出一个结论：<strong>从$(0,0)$到$(n,m)$的线路上，有$gcd(n,m)-1$个整点(不包括$(0,0),(n,m)$)</strong>。想一想很好明白：令t是n,m的公因数$(\\frac {n}{t},\\frac {m}{t})$就相当于步长，$m,n$一定时$t$越大，步长越小，整点就越多。$gcd(n,m)$是$n,m$的最大公因数，所以就是最多整点的个数了。</p>\n<p>所以问题转化为：<br>求</p>\n<p>$$\\sum_{i = 1}^{n} \\sum_{j = 1}^{m}2\\times gcd(n,m)-1$$</p>\n<p>的值。</p>\n<p>显然高端的数学方法我肯定是不会的。那怎么办呢。</p>\n<p>数据范围不允许我们求出对于每一个$n,m$的$gcd$，但是我们可以想办法求出对于每一个$w$，$gcd(i,j) = w$的$(i,j)$对数，然后就可以$O(n)$的加出结果了。</p>\n<p>这个东西的话也不太好求…但是我们可以求出以w为约数的树的个数！对于一个$w$，均以$w$为约数的$(i,j)$的个数就是$\\lfloor \\frac{n}{w} \\rfloor \\times \\lfloor \\frac{m}{w} \\rfloor$。</p>\n<p>还有一件事情，就是以$w$为最大公因数的数的个数就是以$w$为约数的数的个数减去以$kw(k = 2,3,4…)$为最大公因数的个数。</p>\n<p>然后我们就可以开始从上往下的递推了，计算的时候每次往上跳$w$，直到超界，然后都减去就可以了。</p>\n<p>根据一些调和级数的东西，$1+\\frac{1}{2}+\\frac{1}{3}…+\\frac{1}{n} \\approx \\ln n$，所以最后的复杂度大约是$O(n \\ln n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�37-->\n\n</div></div>"},{"title":"「NOI2012」美食节-费用流","urlname":"NOI2012-festival","date":"2018-05-03T14:16:33.000Z","visible":null,"_content":"\n美食节共有$n$种不同的菜品，每个同学都点了一份在这$n$中菜品中的菜。总共有$m$个厨师来制作这些菜品。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。第$j$个厨师制作第$i$种菜品的时间记为$t_{i,j}$。每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。总等待时间为所有同学的等待时间之和。\n\n已知共有$n$种菜品，第$i$种菜品需要做$p_i$份，共有$m$个厨师。请计算出最小的总等待时间是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2050](https://www.luogu.org/problemnew/show/P2050)\n\n[BZOJ 2879](https://www.lydsy.com/JudgeOnline/problem.php?id=2879)\n\n## 题解\n\n\b很有趣的题。\b\n\n看起来跟「SCOI2007」修车 很像，然而这道题的数据大大加强了。\n\n这道题主要的方法如下：\n\n对于每一个厨师，构建$\\sum p$个点，分别代表其倒数第一个，...\b，倒数第p\b个制作的\b菜品。对于第i个菜品，由菜品节点向第j个厨师倒数第k个做的菜，连一条\b容量为1，\b费用为t_{i,j} \\times k 的边。可以发现，这条边就代表了\b所有在倒数第k个后面以及倒数第k\b个\b制作菜品中由倒数第k个菜品的制作而产生的等待时间。\b\n\n其他还有从各个\b节点连向汇点，以及源点\b连向各菜品节点，\b\b容量为p_i的边。\n\n\n但是，这个过不了。经过计算，我们发现最多的时候会有近$6000000$条边，\b显然很惨。干写这个算法大概是50-60分的样子吧。\n\n所以我们需要作出一些\b改进，来让这个算法变成`O(能过)`。考虑到最主要的问题是边数太多，\b所以我们应该想办法减少边的数目。\n\n\b这个时候就可以玄学操作了。\n\n考虑到以下的一件事：如果一个厨师倒数第k个需要做的菜还没有做，那么不可能先做倒数第k+1个菜，因为无论做什么菜，倒数第k个做的菜价格总是更低。\n\n所以我们先把每个厨师最后一个制作的菜品加入图中，然后进行一次$spfa$的增广。然后每次增广出来的菜和厨师，我们就加一条同一个厨师后面一个需要做的菜，这样既能保证复杂度比较低，也可以正确增广。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 100000,MAXM = 2000000;\n\nstruct Edge{\n    int from,to;\n    int cap,flow;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t,sum = 0;\nint ff = 0,cc = 0,p[MAXN],ti[1000][1000];\nint fir[MAXN],ecnt = 2;\n\nvoid addedge(int a,int b,int c,int d){\n    edge[ecnt] = (Edge){a,b,c,0,d,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]};\n    fir[b] = ecnt++;\n}\n\nint dis[MAXN],instack[MAXN],pree[MAXN];\nqueue<int> q;\n\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    q.push(s);dis[s] = 0;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(){\n    int nown = t,nowe = 0,limit = 0x3f3f3f3f;\n    while(nown != s){\n        nowe = pree[nown];\n        limit = min(limit,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown != s){\n        nowe = pree[nown];\n        edge[nowe].flow += limit;\n        edge[nowe^1].flow -= limit;\n        nown = edge[nowe].from;\n    }\n    ff += limit,cc += limit * dis[t];\n}\n\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n    \tread(p[i]);\n    \tsum += p[i];\n    }\n    for(int i = 1;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            read(ti[i][j]);\n        }\n    }\n}\n\nvoid solve(){\n    s = m*sum + n + 1,t = m*sum + n + 2;\n    for(int i = 1;i<=n;i++)\n        addedge(s,m*sum + i,p[i],0);\n    for(int j = 1;j<=m;j++){\n        addedge(j,t,1,0);\n        for(int i = 1;i<=n;i++){\t\n            addedge(m*sum + i,j,1,ti[i][j]);\n        }\n    }\n    while(spfa()){\n        argument();\n        int x = edge[pree[t]].from;\n        addedge(x+m,t,1,0);\n        for(int i = 1;i<=n;i++){\n            addedge(m*sum + i,x+m,1,ti[i][(x-1)%m+1]*((x+m-1)/m+1));\n        }\n    }\n    print(cc),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「NOI2012」美食节-费用流.md","raw":"---\ntitle: 「NOI2012」美食节-费用流\nurlname: NOI2012-festival\ndate: 2018-05-03 22:16:33\ntags:\n- 题解\n- 费用流\n- 图论\ncategories: OI\nvisible:\n---\n\n美食节共有$n$种不同的菜品，每个同学都点了一份在这$n$中菜品中的菜。总共有$m$个厨师来制作这些菜品。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。第$j$个厨师制作第$i$种菜品的时间记为$t_{i,j}$。每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。总等待时间为所有同学的等待时间之和。\n\n已知共有$n$种菜品，第$i$种菜品需要做$p_i$份，共有$m$个厨师。请计算出最小的总等待时间是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2050](https://www.luogu.org/problemnew/show/P2050)\n\n[BZOJ 2879](https://www.lydsy.com/JudgeOnline/problem.php?id=2879)\n\n## 题解\n\n\b很有趣的题。\b\n\n看起来跟「SCOI2007」修车 很像，然而这道题的数据大大加强了。\n\n这道题主要的方法如下：\n\n对于每一个厨师，构建$\\sum p$个点，分别代表其倒数第一个，...\b，倒数第p\b个制作的\b菜品。对于第i个菜品，由菜品节点向第j个厨师倒数第k个做的菜，连一条\b容量为1，\b费用为t_{i,j} \\times k 的边。可以发现，这条边就代表了\b所有在倒数第k个后面以及倒数第k\b个\b制作菜品中由倒数第k个菜品的制作而产生的等待时间。\b\n\n其他还有从各个\b节点连向汇点，以及源点\b连向各菜品节点，\b\b容量为p_i的边。\n\n\n但是，这个过不了。经过计算，我们发现最多的时候会有近$6000000$条边，\b显然很惨。干写这个算法大概是50-60分的样子吧。\n\n所以我们需要作出一些\b改进，来让这个算法变成`O(能过)`。考虑到最主要的问题是边数太多，\b所以我们应该想办法减少边的数目。\n\n\b这个时候就可以玄学操作了。\n\n考虑到以下的一件事：如果一个厨师倒数第k个需要做的菜还没有做，那么不可能先做倒数第k+1个菜，因为无论做什么菜，倒数第k个做的菜价格总是更低。\n\n所以我们先把每个厨师最后一个制作的菜品加入图中，然后进行一次$spfa$的增广。然后每次增广出来的菜和厨师，我们就加一条同一个厨师后面一个需要做的菜，这样既能保证复杂度比较低，也可以正确增广。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 100000,MAXM = 2000000;\n\nstruct Edge{\n    int from,to;\n    int cap,flow;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t,sum = 0;\nint ff = 0,cc = 0,p[MAXN],ti[1000][1000];\nint fir[MAXN],ecnt = 2;\n\nvoid addedge(int a,int b,int c,int d){\n    edge[ecnt] = (Edge){a,b,c,0,d,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]};\n    fir[b] = ecnt++;\n}\n\nint dis[MAXN],instack[MAXN],pree[MAXN];\nqueue<int> q;\n\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    q.push(s);dis[s] = 0;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(){\n    int nown = t,nowe = 0,limit = 0x3f3f3f3f;\n    while(nown != s){\n        nowe = pree[nown];\n        limit = min(limit,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown != s){\n        nowe = pree[nown];\n        edge[nowe].flow += limit;\n        edge[nowe^1].flow -= limit;\n        nown = edge[nowe].from;\n    }\n    ff += limit,cc += limit * dis[t];\n}\n\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++){\n    \tread(p[i]);\n    \tsum += p[i];\n    }\n    for(int i = 1;i<=n;i++){\n        for(int j = 1;j<=m;j++){\n            read(ti[i][j]);\n        }\n    }\n}\n\nvoid solve(){\n    s = m*sum + n + 1,t = m*sum + n + 2;\n    for(int i = 1;i<=n;i++)\n        addedge(s,m*sum + i,p[i],0);\n    for(int j = 1;j<=m;j++){\n        addedge(j,t,1,0);\n        for(int i = 1;i<=n;i++){\t\n            addedge(m*sum + i,j,1,ti[i][j]);\n        }\n    }\n    while(spfa()){\n        argument();\n        int x = edge[pree[t]].from;\n        addedge(x+m,t,1,0);\n        for(int i = 1;i<=n;i++){\n            addedge(m*sum + i,x+m,1,ti[i][(x-1)%m+1]*((x+m-1)/m+1));\n        }\n    }\n    print(cc),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「NOI2012」美食节-费用流","published":1,"updated":"2018-05-04T10:31:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jl003ibljrs7oxti4l","content":"<p>美食节共有$n$种不同的菜品，每个同学都点了一份在这$n$中菜品中的菜。总共有$m$个厨师来制作这些菜品。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。第$j$个厨师制作第$i$种菜品的时间记为$t_{i,j}$。每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。总等待时间为所有同学的等待时间之和。</p>\n<p>已知共有$n$种菜品，第$i$种菜品需要做$p_i$份，共有$m$个厨师。请计算出最小的总等待时间是多少。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2050\" target=\"_blank\" rel=\"noopener\">Luogu P2050</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2879\" target=\"_blank\" rel=\"noopener\">BZOJ 2879</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>\b很有趣的题。\b</p>\n<p>看起来跟「SCOI2007」修车 很像，然而这道题的数据大大加强了。</p>\n<p>这道题主要的方法如下：</p>\n<p>对于每一个厨师，构建$\\sum p$个点，分别代表其倒数第一个，…\b，倒数第p\b个制作的\b菜品。对于第i个菜品，由菜品节点向第j个厨师倒数第k个做的菜，连一条\b容量为1，\b费用为t_{i,j} \\times k 的边。可以发现，这条边就代表了\b所有在倒数第k个后面以及倒数第k\b个\b制作菜品中由倒数第k个菜品的制作而产生的等待时间。\b</p>\n<p>其他还有从各个\b节点连向汇点，以及源点\b连向各菜品节点，\b\b容量为p_i的边。</p>\n<p>但是，这个过不了。经过计算，我们发现最多的时候会有近$6000000$条边，\b显然很惨。干写这个算法大概是50-60分的样子吧。</p>\n<p>所以我们需要作出一些\b改进，来让这个算法变成<code>O(能过)</code>。考虑到最主要的问题是边数太多，\b所以我们应该想办法减少边的数目。</p>\n<p>\b这个时候就可以玄学操作了。</p>\n<p>考虑到以下的一件事：如果一个厨师倒数第k个需要做的菜还没有做，那么不可能先做倒数第k+1个菜，因为无论做什么菜，倒数第k个做的菜价格总是更低。</p>\n<p>所以我们先把每个厨师最后一个制作的菜品加入图中，然后进行一次$spfa$的增广。然后每次增广出来的菜和厨师，我们就加一条同一个厨师后面一个需要做的菜，这样既能保证复杂度比较低，也可以正确增广。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">100000</span>,MAXM = <span class=\"number\">2000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cap,flow;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost,nex;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ff = <span class=\"number\">0</span>,cc = <span class=\"number\">0</span>,p[MAXN],ti[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN],ecnt = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;a,b,c,<span class=\"number\">0</span>,d,fir[a]&#125;;</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;b,a,<span class=\"number\">0</span>,<span class=\"number\">0</span>,-d,fir[b]&#125;;</span><br><span class=\"line\">    fir[b] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[MAXN],instack[MAXN],pree[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) q.pop();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(instack,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(instack));</span><br><span class=\"line\">    q.push(s);dis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        instack[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">            Edge e = edge[nowe];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[e.to] &gt; dis[nown] + e.cost &amp;&amp; e.cap &gt; e.flow)&#123;</span><br><span class=\"line\">                dis[e.to] = dis[nown] + e.cost;</span><br><span class=\"line\">                pree[e.to] = nowe;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instack[e.to] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                    instack[e.to] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t] &lt; <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">argument</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nown = t,nowe = <span class=\"number\">0</span>,limit = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown != s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        limit = min(limit,edge[nowe].cap - edge[nowe].flow);</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nown = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown != s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        edge[nowe].flow += limit;</span><br><span class=\"line\">        edge[nowe^<span class=\"number\">1</span>].flow -= limit;</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ff += limit,cc += limit * dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">    \tread(p[i]);</span><br><span class=\"line\">    \tsum += p[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">            read(ti[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    s = m*sum + n + <span class=\"number\">1</span>,t = m*sum + n + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        addedge(s,m*sum + i,p[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">        addedge(j,t,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;\t</span><br><span class=\"line\">            addedge(m*sum + i,j,<span class=\"number\">1</span>,ti[i][j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(spfa())&#123;</span><br><span class=\"line\">        argument();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = edge[pree[t]].from;</span><br><span class=\"line\">        addedge(x+m,t,<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            addedge(m*sum + i,x+m,<span class=\"number\">1</span>,ti[i][(x<span class=\"number\">-1</span>)%m+<span class=\"number\">1</span>]*((x+m<span class=\"number\">-1</span>)/m+<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(cc),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>美食节共有$n$种不同的菜品，每个同学都点了一份在这$n$中菜品中的菜。总共有$m$个厨师来制作这些菜品。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。第$j$个厨师制作第$i$种菜品的时间记为$t_{i,j}$。每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。总等待时间为所有同学的等待时间之和。</p>\n<p>已知共有$n$种菜品，第$i$种菜品需要做$p_i$份，共有$m$个厨师。请计算出最小的总等待时间是多少。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2050\" target=\"_blank\" rel=\"noopener\">Luogu P2050</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2879\" target=\"_blank\" rel=\"noopener\">BZOJ 2879</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>\b很有趣的题。\b</p>\n<p>看起来跟「SCOI2007」修车 很像，然而这道题的数据大大加强了。</p>\n<p>这道题主要的方法如下：</p>\n<p>对于每一个厨师，构建$\\sum p$个点，分别代表其倒数第一个，…\b，倒数第p\b个制作的\b菜品。对于第i个菜品，由菜品节点向第j个厨师倒数第k个做的菜，连一条\b容量为1，\b费用为t_{i,j} \\times k 的边。可以发现，这条边就代表了\b所有在倒数第k个后面以及倒数第k\b个\b制作菜品中由倒数第k个菜品的制作而产生的等待时间。\b</p>\n<p>其他还有从各个\b节点连向汇点，以及源点\b连向各菜品节点，\b\b容量为p_i的边。</p>\n<p>但是，这个过不了。经过计算，我们发现最多的时候会有近$6000000$条边，\b显然很惨。干写这个算法大概是50-60分的样子吧。</p>\n<p>所以我们需要作出一些\b改进，来让这个算法变成<code>O(能过)</code>。考虑到最主要的问题是边数太多，\b所以我们应该想办法减少边的数目。</p>\n<p>\b这个时候就可以玄学操作了。</p>\n<p>考虑到以下的一件事：如果一个厨师倒数第k个需要做的菜还没有做，那么不可能先做倒数第k+1个菜，因为无论做什么菜，倒数第k个做的菜价格总是更低。</p>\n<p>所以我们先把每个厨师最后一个制作的菜品加入图中，然后进行一次$spfa$的增广。然后每次增广出来的菜和厨师，我们就加一条同一个厨师后面一个需要做的菜，这样既能保证复杂度比较低，也可以正确增广。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�38-->\n\n</div></div>"},{"title":"「NOI2014」动物园-KMP","urlname":"noi2014-zoo","date":"2018-04-05T08:55:40.000Z","visible":null,"_content":"\n给定一个字符串$S$，求出$num$数组——对于字符串$S$的前$i$个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作$num[i]$。\n\n特别地，为了避免大量的输出，你不需要输出$num[i]$分别是多少，你只需要输出所有$(num[i]+1)$的乘积，对$10^9+7$取模的结果即可。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2375](https://www.luogu.org/problemnew/show/P2375)\n\n[BZOJ 3670](https://www.lydsy.com/JudgeOnline/problem.php?id=3670)\n\n## 题解\n\n终于开始怼字符串的题了。\n\n这一道题让我们求$num$的个数，其实联系一下`AC`自动机，很容易就想到沿着$nex$数组往回跳。跳的次数就是相同前后缀的个数，这个可以在求$nex$的时候直接预处理出来，记为$cnt$数组。\n\n但题目中有一个限制比较烦人：\n\n> 该后缀与该前缀不重叠\n\n一个简单的想法就是求出$nex$数组，对于每一个$i$，先将$nex$降到$\\frac{i}{2}$以下，然后看这个$nex$还能跳多少次。但是很遗憾，这个`TLE`了，只有$50$分。因为每一次都跳$nex$代价太高，`gg`。\n\n- - -\n\n一个简单的改进就可以过掉这道题。\n\n我们只需要像跳普通的$nex$一样去跳这个地方的$nex$，只需要每次确保其在$\\frac{i}{2}$以下就可以。然后就可以找到$nex$，从而得到$num$。\n\n说长度在$\\frac{i}{2}$以下其实不太严谨，具体看代码吧。\n\n## 代码\n\n+ AC代码：\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 1110000;\n\nint n,p = 1000000007;\nint nex[MAXN],cnt[MAXN];\nchar s[MAXN];\n\nvoid cal(){\n    memset(nex,0,sizeof(nex));\n    memset(cnt,0,sizeof(cnt));\n    nex[0] = 0;\n    int len = strlen(s);\n    int j = 0;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        nex[i] = j;\n        cnt[i] = cnt[nex[i-1]]+1;\n    }\n    ll ans = 1;\n    j = 0;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        while(j>0 && 2*j > i+1)\n            j = nex[j-1];\n        ans *= (cnt[j]+1),ans%=p;\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nvoid solve(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",s);\n        cal();\n    }\n}\n\nint main(){\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n\n\n+ 另附50分代码：\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 1110000;\n\nint n,p = 1000000007;\nint nex[MAXN],cnt[MAXN];\nchar s[MAXN];\n\nvoid cal(){\n    memset(nex,0,sizeof(nex));\n    memset(cnt,0,sizeof(cnt));\n    nex[0] = 0;\n    int j = 0,len = strlen(s);\n    ll ans = 1;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        nex[i] = j;\n        cnt[i] = cnt[nex[i-1]]+1;\n    }\n    for(int i = 1;i<len;i++){\n        j = nex[i];\n        while(j>0 && 2*j > i+1)\n            j = nex[j-1];\n        ans *= (cnt[j]+1),ans%=p;\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nvoid solve(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",s);\n        cal();\n    }\n}\n\nint main(){\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「NOI2014」动物园-KMP.md","raw":"---\ntitle: 「NOI2014」动物园-KMP\nurlname: noi2014-zoo\ndate: 2018-04-05 16:55:40\ntags:\n- 题解\n- 字符串\n- KMP\ncategories: OI\nvisible:\n---\n\n给定一个字符串$S$，求出$num$数组——对于字符串$S$的前$i$个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作$num[i]$。\n\n特别地，为了避免大量的输出，你不需要输出$num[i]$分别是多少，你只需要输出所有$(num[i]+1)$的乘积，对$10^9+7$取模的结果即可。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2375](https://www.luogu.org/problemnew/show/P2375)\n\n[BZOJ 3670](https://www.lydsy.com/JudgeOnline/problem.php?id=3670)\n\n## 题解\n\n终于开始怼字符串的题了。\n\n这一道题让我们求$num$的个数，其实联系一下`AC`自动机，很容易就想到沿着$nex$数组往回跳。跳的次数就是相同前后缀的个数，这个可以在求$nex$的时候直接预处理出来，记为$cnt$数组。\n\n但题目中有一个限制比较烦人：\n\n> 该后缀与该前缀不重叠\n\n一个简单的想法就是求出$nex$数组，对于每一个$i$，先将$nex$降到$\\frac{i}{2}$以下，然后看这个$nex$还能跳多少次。但是很遗憾，这个`TLE`了，只有$50$分。因为每一次都跳$nex$代价太高，`gg`。\n\n- - -\n\n一个简单的改进就可以过掉这道题。\n\n我们只需要像跳普通的$nex$一样去跳这个地方的$nex$，只需要每次确保其在$\\frac{i}{2}$以下就可以。然后就可以找到$nex$，从而得到$num$。\n\n说长度在$\\frac{i}{2}$以下其实不太严谨，具体看代码吧。\n\n## 代码\n\n+ AC代码：\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 1110000;\n\nint n,p = 1000000007;\nint nex[MAXN],cnt[MAXN];\nchar s[MAXN];\n\nvoid cal(){\n    memset(nex,0,sizeof(nex));\n    memset(cnt,0,sizeof(cnt));\n    nex[0] = 0;\n    int len = strlen(s);\n    int j = 0;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        nex[i] = j;\n        cnt[i] = cnt[nex[i-1]]+1;\n    }\n    ll ans = 1;\n    j = 0;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        while(j>0 && 2*j > i+1)\n            j = nex[j-1];\n        ans *= (cnt[j]+1),ans%=p;\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nvoid solve(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",s);\n        cal();\n    }\n}\n\nint main(){\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n\n\n+ 另附50分代码：\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 1110000;\n\nint n,p = 1000000007;\nint nex[MAXN],cnt[MAXN];\nchar s[MAXN];\n\nvoid cal(){\n    memset(nex,0,sizeof(nex));\n    memset(cnt,0,sizeof(cnt));\n    nex[0] = 0;\n    int j = 0,len = strlen(s);\n    ll ans = 1;\n    for(int i = 1;i<len;i++){\n        while(j > 0 && s[i]!=s[j])\n            j = nex[j-1];\n        if(s[i] == s[j]) ++j;\n        nex[i] = j;\n        cnt[i] = cnt[nex[i-1]]+1;\n    }\n    for(int i = 1;i<len;i++){\n        j = nex[i];\n        while(j>0 && 2*j > i+1)\n            j = nex[j-1];\n        ans *= (cnt[j]+1),ans%=p;\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nvoid solve(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++){\n        scanf(\"%s\",s);\n        cal();\n    }\n}\n\nint main(){\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「NOI2014」动物园-KMP","published":1,"updated":"2018-04-05T12:12:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jn003lbljr1d4w6vqc","content":"<p>给定一个字符串$S$，求出$num$数组——对于字符串$S$的前$i$个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作$num[i]$。</p>\n<p>特别地，为了避免大量的输出，你不需要输出$num[i]$分别是多少，你只需要输出所有$(num[i]+1)$的乘积，对$10^9+7$取模的结果即可。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2375\" target=\"_blank\" rel=\"noopener\">Luogu P2375</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3670\" target=\"_blank\" rel=\"noopener\">BZOJ 3670</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>终于开始怼字符串的题了。</p>\n<p>这一道题让我们求$num$的个数，其实联系一下<code>AC</code>自动机，很容易就想到沿着$nex$数组往回跳。跳的次数就是相同前后缀的个数，这个可以在求$nex$的时候直接预处理出来，记为$cnt$数组。</p>\n<p>但题目中有一个限制比较烦人：</p>\n<blockquote>\n<p>该后缀与该前缀不重叠</p>\n</blockquote>\n<p>一个简单的想法就是求出$nex$数组，对于每一个$i$，先将$nex$降到$\\frac{i}{2}$以下，然后看这个$nex$还能跳多少次。但是很遗憾，这个<code>TLE</code>了，只有$50$分。因为每一次都跳$nex$代价太高，<code>gg</code>。</p>\n<hr>\n<p>一个简单的改进就可以过掉这道题。</p>\n<p>我们只需要像跳普通的$nex$一样去跳这个地方的$nex$，只需要每次确保其在$\\frac{i}{2}$以下就可以。然后就可以找到$nex$，从而得到$num$。</p>\n<p>说长度在$\\frac{i}{2}$以下其实不太严谨，具体看代码吧。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><ul>\n<li>AC代码：</li>\n</ul>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,p = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nex[MAXN],cnt[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(nex,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(nex));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(cnt,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(cnt));</span><br><span class=\"line\">    nex[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s[i]!=s[j])</span><br><span class=\"line\">            j = nex[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == s[j]) ++j;</span><br><span class=\"line\">        nex[i] = j;</span><br><span class=\"line\">        cnt[i] = cnt[nex[i<span class=\"number\">-1</span>]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s[i]!=s[j])</span><br><span class=\"line\">            j = nex[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == s[j]) ++j;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&gt;<span class=\"number\">0</span> &amp;&amp; <span class=\"number\">2</span>*j &gt; i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            j = nex[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        ans *= (cnt[j]+<span class=\"number\">1</span>),ans%=p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        cal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<ul>\n<li>另附50分代码：</li>\n</ul>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,p = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nex[MAXN],cnt[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(nex,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(nex));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(cnt,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(cnt));</span><br><span class=\"line\">    nex[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>,len = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    ll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s[i]!=s[j])</span><br><span class=\"line\">            j = nex[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == s[j]) ++j;</span><br><span class=\"line\">        nex[i] = j;</span><br><span class=\"line\">        cnt[i] = cnt[nex[i<span class=\"number\">-1</span>]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        j = nex[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&gt;<span class=\"number\">0</span> &amp;&amp; <span class=\"number\">2</span>*j &gt; i+<span class=\"number\">1</span>)</span><br><span class=\"line\">            j = nex[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">        ans *= (cnt[j]+<span class=\"number\">1</span>),ans%=p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">        cal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定一个字符串$S$，求出$num$数组——对于字符串$S$的前$i$个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作$num[i]$。</p>\n<p>特别地，为了避免大量的输出，你不需要输出$num[i]$分别是多少，你只需要输出所有$(num[i]+1)$的乘积，对$10^9+7$取模的结果即可。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2375\" target=\"_blank\" rel=\"noopener\">Luogu P2375</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3670\" target=\"_blank\" rel=\"noopener\">BZOJ 3670</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>终于开始怼字符串的题了。</p>\n<p>这一道题让我们求$num$的个数，其实联系一下<code>AC</code>自动机，很容易就想到沿着$nex$数组往回跳。跳的次数就是相同前后缀的个数，这个可以在求$nex$的时候直接预处理出来，记为$cnt$数组。</p>\n<p>但题目中有一个限制比较烦人：</p>\n<blockquote>\n<p>该后缀与该前缀不重叠</p>\n</blockquote>\n<p>一个简单的想法就是求出$nex$数组，对于每一个$i$，先将$nex$降到$\\frac{i}{2}$以下，然后看这个$nex$还能跳多少次。但是很遗憾，这个<code>TLE</code>了，只有$50$分。因为每一次都跳$nex$代价太高，<code>gg</code>。</p>\n<hr>\n<p>一个简单的改进就可以过掉这道题。</p>\n<p>我们只需要像跳普通的$nex$一样去跳这个地方的$nex$，只需要每次确保其在$\\frac{i}{2}$以下就可以。然后就可以找到$nex$，从而得到$num$。</p>\n<p>说长度在$\\frac{i}{2}$以下其实不太严谨，具体看代码吧。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><ul>\n<li>AC代码：</li>\n</ul>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�39-->\n\n</div></div>\n<ul>\n<li>另附50分代码：</li>\n</ul>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�40-->\n\n</div></div>"},{"title":"「NOI2014」魔法森林-LCT","urlname":"NOI2014-forest","date":"2018-06-16T03:36:51.000Z","visible":null,"_content":"\n给定一个$n$个点$m$条边的无向图，每条边有两个权值$a_i,b_i$。请你找到一条从$1 \\rightarrow n$ 的道路，令道路上所有边的集合为$S$，使$ans = \\max(a_i)+\\max(b_j),i,j \\in S$最小，求出这个最小值$ans$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2387](https://www.luogu.org/problemnew/show/P2387)\n\n[BZOJ 3669](https://www.lydsy.com/JudgeOnline/problem.php?id=3669)\n\n## 题解\n\n这题告诉我们了一个$LCT$(连猫树)的新用法：动态维护最小生成树。\n\n思考一下：如果我们有一颗生成树，现在再添加进一条边，图里必然会出现一个环。而新的最小生成树就是在这个环里面砍掉最大的那一条边而得到的。\n\n这是非常显然的。\n\n可以发现一个结论，就是给定一个无向图，那么$1 \\rightarrow n$路径上边权最大值最小的这些边一定在其最小生成树里面。这个只要考虑一下$Kruskal$算法的过程就很容易明白。\n\n那么再回来看这个问题。如果这个地方只有一维的限制，那么我们就可以用并查集做。这是一个离线的做法，也就是我们把所有边一股脑的扔进去，拿到一个最小生成树，然后答案就是这两点之间的边权最大值。（其实是并查集直到两个东西联通为止）\n\n但是现在有了$a$这一维的限制，该怎么办呢？考虑一下贪心的做法，我们可以利用$LCT$**动态**维护最小生成树的特点。\n\n考虑对于$a$排序之后，就可以排除掉$a$对这个东西的干扰。然后我们按照$a$从小到大往树里面加边，每次维护最小生成树，答案就可以用$a_{now} + b_{max}$来求得，动态更新即可。\n\n为什么这个东西是正确的呢？如果路径上的$a_{max} < a_{now}$，会不会对答案造成影响？\n\n不会。因为如果$a_{max} < a_{now}$，那么在我们加到$a_{max}$这条边的时候，其所有路径上的边应该已经出现，就可以囊括$a_{max} + b_{max}$这种情况了。而如果后面换用了其他$b$更小的边，显然$a_{max}$会扩大为$a_{now}$，算法的正确性就可以保证了。\n\n$LCT$只能维护点权，所以我们把边换成点，每次$link$或者$cat$的时候连或者猫两下就可以了。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\nconst int MAXN = 151000;\n\nstruct Link_Cat_Tree{\n    int val[MAXN],maxn[MAXN];\n    int c[MAXN][2],f[MAXN];\n    bool rev[MAXN];\n    int getmax(int u,int x,int y){\n        if(val[u] >= val[maxn[x]] && val[u] >= val[maxn[y]])\n            return u;\n        else if(val[maxn[x]] >= val[maxn[y]])\n            return maxn[x];\n        else \n            return maxn[y];\n    }\n    bool noroot(int x){\n        return (c[f[x]][1] == x) || (c[f[x]][0] == x);\n    }\n    void push_up(int x){\n        if(!x) return;\n        maxn[x] = getmax(x,c[x][0],c[x][1]);\n    }\n    void reverse(int x){\n        if(!x) return;\n        swap(c[x][0],c[x][1]);\n        rev[x]^=1;\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]),reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1]==y] = x;\n        c[x][1-t] = y;c[y][t] = w;\n        if(w) f[w] = y;\n        f[y] = x;f[x] = z;\n        push_up(y),push_up(x);\n    }\n    void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y))\n                (c[z][1] == y) ^ (c[y][1] == x) ? rotate(x):rotate(y);\n            rotate(x);\n        }\n    }\n    void access(int x){\n        for(int y = 0;x;x=f[y=x]){\n            splay(x);\n            c[x][1] = y,push_up(x);\n        }\n    }\n    void makeroot(int x){\n        access(x);splay(x);reverse(x);\n    }\n    int findroot(int x){\n        access(x);splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    void link(int x,int y){\n        makeroot(x);\n        if(findroot(y) != x)\n            f[x] = y;\n    }\n    void cat(int x,int y){\n        makeroot(x);\n        if(findroot(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0,push_up(y);\n    }\n    void split(int x,int y){\n        makeroot(x),access(y),splay(y);\n    }\n    int querymax(int x,int y){\n        return split(x,y),maxn[y];\n    }\n}T;\n\n//点1->n 边n+1->n+m\nint n,m;\n\nstruct Edge{\n    int from,to,a,b;\n}edge[MAXN];\n\nbool cmp(Edge x,Edge y){\n    return x.a < y.a;\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b,f,t;\n    for(int i = 1;i<=m;i++){\n        read(f),read(t),read(a),read(b);\n        edge[i] = (Edge){f,t,a,b};\n    }\n}\n\nvoid solve(){\n    int ans = 0x3f3f3f3f;\n    sort(edge + 1,edge+m+1,cmp);\n    for(int i = 1;i<=m;i++)\n        T.val[n+i] = edge[i].b;\n    for(int i = 1;i<=n+m;i++)\n        T.maxn[i] = i;\n    int x = 0,y = 0,a = 0,b = 0;\n    for(int i = 1;i<=m;i++){\n        x = edge[i].from,y = edge[i].to;\n        a = edge[i].a,b = edge[i].b;\n        if(x == y) continue;\n        if(T.findroot(x)!=T.findroot(y))\n            T.link(n+i,x),T.link(n+i,y);\n        else{\n            int t = T.querymax(x,y) - n;\n            if(edge[t].b < b) continue;\n            T.cat(n+t,edge[t].from),T.cat(n+t,edge[t].to);\n            T.link(n+i,x),T.link(n+i,y);\n        }\n        if(T.findroot(1) == T.findroot(n))\n            ans = min(ans,a+edge[T.querymax(1,n)-n].b);\n    }\n    if(ans > 1000000000)\n        print(-1);\n    else\n        print(ans);\n    print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「NOI2014」魔法森林-LCT.md","raw":"---\ntitle: 「NOI2014」魔法森林-LCT\nurlname: NOI2014-forest\ndate: 2018-06-16 11:36:51\ntags:\n- 题解\n- 数据结构\n- 动态树\n- Link Cut Tree(LCT)\ncategories: OI\nvisible:\n---\n\n给定一个$n$个点$m$条边的无向图，每条边有两个权值$a_i,b_i$。请你找到一条从$1 \\rightarrow n$ 的道路，令道路上所有边的集合为$S$，使$ans = \\max(a_i)+\\max(b_j),i,j \\in S$最小，求出这个最小值$ans$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2387](https://www.luogu.org/problemnew/show/P2387)\n\n[BZOJ 3669](https://www.lydsy.com/JudgeOnline/problem.php?id=3669)\n\n## 题解\n\n这题告诉我们了一个$LCT$(连猫树)的新用法：动态维护最小生成树。\n\n思考一下：如果我们有一颗生成树，现在再添加进一条边，图里必然会出现一个环。而新的最小生成树就是在这个环里面砍掉最大的那一条边而得到的。\n\n这是非常显然的。\n\n可以发现一个结论，就是给定一个无向图，那么$1 \\rightarrow n$路径上边权最大值最小的这些边一定在其最小生成树里面。这个只要考虑一下$Kruskal$算法的过程就很容易明白。\n\n那么再回来看这个问题。如果这个地方只有一维的限制，那么我们就可以用并查集做。这是一个离线的做法，也就是我们把所有边一股脑的扔进去，拿到一个最小生成树，然后答案就是这两点之间的边权最大值。（其实是并查集直到两个东西联通为止）\n\n但是现在有了$a$这一维的限制，该怎么办呢？考虑一下贪心的做法，我们可以利用$LCT$**动态**维护最小生成树的特点。\n\n考虑对于$a$排序之后，就可以排除掉$a$对这个东西的干扰。然后我们按照$a$从小到大往树里面加边，每次维护最小生成树，答案就可以用$a_{now} + b_{max}$来求得，动态更新即可。\n\n为什么这个东西是正确的呢？如果路径上的$a_{max} < a_{now}$，会不会对答案造成影响？\n\n不会。因为如果$a_{max} < a_{now}$，那么在我们加到$a_{max}$这条边的时候，其所有路径上的边应该已经出现，就可以囊括$a_{max} + b_{max}$这种情况了。而如果后面换用了其他$b$更小的边，显然$a_{max}$会扩大为$a_{now}$，算法的正确性就可以保证了。\n\n$LCT$只能维护点权，所以我们把边换成点，每次$link$或者$cat$的时候连或者猫两下就可以了。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\nconst int MAXN = 151000;\n\nstruct Link_Cat_Tree{\n    int val[MAXN],maxn[MAXN];\n    int c[MAXN][2],f[MAXN];\n    bool rev[MAXN];\n    int getmax(int u,int x,int y){\n        if(val[u] >= val[maxn[x]] && val[u] >= val[maxn[y]])\n            return u;\n        else if(val[maxn[x]] >= val[maxn[y]])\n            return maxn[x];\n        else \n            return maxn[y];\n    }\n    bool noroot(int x){\n        return (c[f[x]][1] == x) || (c[f[x]][0] == x);\n    }\n    void push_up(int x){\n        if(!x) return;\n        maxn[x] = getmax(x,c[x][0],c[x][1]);\n    }\n    void reverse(int x){\n        if(!x) return;\n        swap(c[x][0],c[x][1]);\n        rev[x]^=1;\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]),reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1]==y] = x;\n        c[x][1-t] = y;c[y][t] = w;\n        if(w) f[w] = y;\n        f[y] = x;f[x] = z;\n        push_up(y),push_up(x);\n    }\n    void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y))\n                (c[z][1] == y) ^ (c[y][1] == x) ? rotate(x):rotate(y);\n            rotate(x);\n        }\n    }\n    void access(int x){\n        for(int y = 0;x;x=f[y=x]){\n            splay(x);\n            c[x][1] = y,push_up(x);\n        }\n    }\n    void makeroot(int x){\n        access(x);splay(x);reverse(x);\n    }\n    int findroot(int x){\n        access(x);splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    void link(int x,int y){\n        makeroot(x);\n        if(findroot(y) != x)\n            f[x] = y;\n    }\n    void cat(int x,int y){\n        makeroot(x);\n        if(findroot(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0,push_up(y);\n    }\n    void split(int x,int y){\n        makeroot(x),access(y),splay(y);\n    }\n    int querymax(int x,int y){\n        return split(x,y),maxn[y];\n    }\n}T;\n\n//点1->n 边n+1->n+m\nint n,m;\n\nstruct Edge{\n    int from,to,a,b;\n}edge[MAXN];\n\nbool cmp(Edge x,Edge y){\n    return x.a < y.a;\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b,f,t;\n    for(int i = 1;i<=m;i++){\n        read(f),read(t),read(a),read(b);\n        edge[i] = (Edge){f,t,a,b};\n    }\n}\n\nvoid solve(){\n    int ans = 0x3f3f3f3f;\n    sort(edge + 1,edge+m+1,cmp);\n    for(int i = 1;i<=m;i++)\n        T.val[n+i] = edge[i].b;\n    for(int i = 1;i<=n+m;i++)\n        T.maxn[i] = i;\n    int x = 0,y = 0,a = 0,b = 0;\n    for(int i = 1;i<=m;i++){\n        x = edge[i].from,y = edge[i].to;\n        a = edge[i].a,b = edge[i].b;\n        if(x == y) continue;\n        if(T.findroot(x)!=T.findroot(y))\n            T.link(n+i,x),T.link(n+i,y);\n        else{\n            int t = T.querymax(x,y) - n;\n            if(edge[t].b < b) continue;\n            T.cat(n+t,edge[t].from),T.cat(n+t,edge[t].to);\n            T.link(n+i,x),T.link(n+i,y);\n        }\n        if(T.findroot(1) == T.findroot(n))\n            ans = min(ans,a+edge[T.querymax(1,n)-n].b);\n    }\n    if(ans > 1000000000)\n        print(-1);\n    else\n        print(ans);\n    print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「NOI2014」魔法森林-LCT","published":1,"updated":"2018-06-18T04:04:16.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jp003obljrm837jh8w","content":"<p>给定一个$n$个点$m$条边的无向图，每条边有两个权值$a_i,b_i$。请你找到一条从$1 \\rightarrow n$ 的道路，令道路上所有边的集合为$S$，使$ans = \\max(a_i)+\\max(b_j),i,j \\in S$最小，求出这个最小值$ans$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2387\" target=\"_blank\" rel=\"noopener\">Luogu P2387</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3669\" target=\"_blank\" rel=\"noopener\">BZOJ 3669</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题告诉我们了一个$LCT$(连猫树)的新用法：动态维护最小生成树。</p>\n<p>思考一下：如果我们有一颗生成树，现在再添加进一条边，图里必然会出现一个环。而新的最小生成树就是在这个环里面砍掉最大的那一条边而得到的。</p>\n<p>这是非常显然的。</p>\n<p>可以发现一个结论，就是给定一个无向图，那么$1 \\rightarrow n$路径上边权最大值最小的这些边一定在其最小生成树里面。这个只要考虑一下$Kruskal$算法的过程就很容易明白。</p>\n<p>那么再回来看这个问题。如果这个地方只有一维的限制，那么我们就可以用并查集做。这是一个离线的做法，也就是我们把所有边一股脑的扔进去，拿到一个最小生成树，然后答案就是这两点之间的边权最大值。（其实是并查集直到两个东西联通为止）</p>\n<p>但是现在有了$a$这一维的限制，该怎么办呢？考虑一下贪心的做法，我们可以利用$LCT$<strong>动态</strong>维护最小生成树的特点。</p>\n<p>考虑对于$a$排序之后，就可以排除掉$a$对这个东西的干扰。然后我们按照$a$从小到大往树里面加边，每次维护最小生成树，答案就可以用$a_{now} + b_{max}$来求得，动态更新即可。</p>\n<p>为什么这个东西是正确的呢？如果路径上的$a_{max} &lt; a_{now}$，会不会对答案造成影响？</p>\n<p>不会。因为如果$a_{max} &lt; a_{now}$，那么在我们加到$a_{max}$这条边的时候，其所有路径上的边应该已经出现，就可以囊括$a_{max} + b_{max}$这种情况了。而如果后面换用了其他$b$更小的边，显然$a_{max}$会扩大为$a_{now}$，算法的正确性就可以保证了。</p>\n<p>$LCT$只能维护点权，所以我们把边换成点，每次$link$或者$cat$的时候连或者猫两下就可以了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">151000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Link_Cat_Tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val[MAXN],maxn[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c[MAXN][<span class=\"number\">2</span>],f[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getmax</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(val[u] &gt;= val[maxn[x]] &amp;&amp; val[u] &gt;= val[maxn[y]])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(val[maxn[x]] &gt;= val[maxn[y]])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxn[x];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxn[y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">noroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (c[f[x]][<span class=\"number\">1</span>] == x) || (c[f[x]][<span class=\"number\">0</span>] == x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        maxn[x] = getmax(x,c[x][<span class=\"number\">0</span>],c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(c[x][<span class=\"number\">0</span>],c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        rev[x]^=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev[x])&#123;</span><br><span class=\"line\">            reverse(c[x][<span class=\"number\">0</span>]),reverse(c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            rev[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_all</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(x)) push_all(f[x]);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = f[x],z = f[y],t = (c[y][<span class=\"number\">1</span>] == x),w = c[x][<span class=\"number\">1</span>-t];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(y)) c[z][c[z][<span class=\"number\">1</span>]==y] = x;</span><br><span class=\"line\">        c[x][<span class=\"number\">1</span>-t] = y;c[y][t] = w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w) f[w] = y;</span><br><span class=\"line\">        f[y] = x;f[x] = z;</span><br><span class=\"line\">        push_up(y),push_up(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        push_all(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(noroot(x))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = f[x],z = f[y];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(noroot(y))</span><br><span class=\"line\">                (c[z][<span class=\"number\">1</span>] == y) ^ (c[y][<span class=\"number\">1</span>] == x) ? rotate(x):rotate(y);</span><br><span class=\"line\">            rotate(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;x;x=f[y=x])&#123;</span><br><span class=\"line\">            splay(x);</span><br><span class=\"line\">            c[x][<span class=\"number\">1</span>] = y,push_up(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x);splay(x);reverse(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x);splay(x);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c[x][<span class=\"number\">0</span>])</span><br><span class=\"line\">            x = c[x][<span class=\"number\">0</span>],push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(findroot(y) != x)</span><br><span class=\"line\">            f[x] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cat</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(findroot(y) == x &amp;&amp; f[x] == y &amp;&amp; !c[x][<span class=\"number\">1</span>])</span><br><span class=\"line\">            f[x] = c[y][<span class=\"number\">0</span>] = <span class=\"number\">0</span>,push_up(y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x),access(y),splay(y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">querymax</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> split(x,y),maxn[y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//点1-&gt;n 边n+1-&gt;n+m</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,a,b;</span><br><span class=\"line\">&#125;edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge x,Edge y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.a &lt; y.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,f,t;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(f),read(t),read(a),read(b);</span><br><span class=\"line\">        edge[i] = (Edge)&#123;f,t,a,b&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    sort(edge + <span class=\"number\">1</span>,edge+m+<span class=\"number\">1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        T.val[n+i] = edge[i].b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n+m;i++)</span><br><span class=\"line\">        T.maxn[i] = i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>,y = <span class=\"number\">0</span>,a = <span class=\"number\">0</span>,b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        x = edge[i].from,y = edge[i].to;</span><br><span class=\"line\">        a = edge[i].a,b = edge[i].b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T.findroot(x)!=T.findroot(y))</span><br><span class=\"line\">            T.link(n+i,x),T.link(n+i,y);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = T.querymax(x,y) - n;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[t].b &lt; b) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            T.cat(n+t,edge[t].from),T.cat(n+t,edge[t].to);</span><br><span class=\"line\">            T.link(n+i,x),T.link(n+i,y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(T.findroot(<span class=\"number\">1</span>) == T.findroot(n))</span><br><span class=\"line\">            ans = min(ans,a+edge[T.querymax(<span class=\"number\">1</span>,n)-n].b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans &gt; <span class=\"number\">1000000000</span>)</span><br><span class=\"line\">        print(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        print(ans);</span><br><span class=\"line\">    print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定一个$n$个点$m$条边的无向图，每条边有两个权值$a_i,b_i$。请你找到一条从$1 \\rightarrow n$ 的道路，令道路上所有边的集合为$S$，使$ans = \\max(a_i)+\\max(b_j),i,j \\in S$最小，求出这个最小值$ans$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2387\" target=\"_blank\" rel=\"noopener\">Luogu P2387</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3669\" target=\"_blank\" rel=\"noopener\">BZOJ 3669</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这题告诉我们了一个$LCT$(连猫树)的新用法：动态维护最小生成树。</p>\n<p>思考一下：如果我们有一颗生成树，现在再添加进一条边，图里必然会出现一个环。而新的最小生成树就是在这个环里面砍掉最大的那一条边而得到的。</p>\n<p>这是非常显然的。</p>\n<p>可以发现一个结论，就是给定一个无向图，那么$1 \\rightarrow n$路径上边权最大值最小的这些边一定在其最小生成树里面。这个只要考虑一下$Kruskal$算法的过程就很容易明白。</p>\n<p>那么再回来看这个问题。如果这个地方只有一维的限制，那么我们就可以用并查集做。这是一个离线的做法，也就是我们把所有边一股脑的扔进去，拿到一个最小生成树，然后答案就是这两点之间的边权最大值。（其实是并查集直到两个东西联通为止）</p>\n<p>但是现在有了$a$这一维的限制，该怎么办呢？考虑一下贪心的做法，我们可以利用$LCT$<strong>动态</strong>维护最小生成树的特点。</p>\n<p>考虑对于$a$排序之后，就可以排除掉$a$对这个东西的干扰。然后我们按照$a$从小到大往树里面加边，每次维护最小生成树，答案就可以用$a_{now} + b_{max}$来求得，动态更新即可。</p>\n<p>为什么这个东西是正确的呢？如果路径上的$a_{max} &lt; a_{now}$，会不会对答案造成影响？</p>\n<p>不会。因为如果$a_{max} &lt; a_{now}$，那么在我们加到$a_{max}$这条边的时候，其所有路径上的边应该已经出现，就可以囊括$a_{max} + b_{max}$这种情况了。而如果后面换用了其他$b$更小的边，显然$a_{max}$会扩大为$a_{now}$，算法的正确性就可以保证了。</p>\n<p>$LCT$只能维护点权，所以我们把边换成点，每次$link$或者$cat$的时候连或者猫两下就可以了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�41-->\n\n</div></div>"},{"title":"「NOI2015」软件包管理器-树链剖分","urlname":"noi2015-manager","date":"2018-04-09T13:07:03.000Z","visible":null,"_content":"\n\n你决定设计你自己的软件包管理器。如果软件包A依赖软件包$B$，那么安装软件包$A$以前，必须先安装软件包$B$。同时，如果想要卸载软件包$B$，则必须卸载软件包$A$。现在你已经获得了所有的软件包之间的依赖关系。除$0$号软件包以外，所有软件包都会依赖一个且仅一个软件包，而$0$号软件包不依赖任何一个软件包。依赖关系不存在环。\n\n现在有一些安装或卸载软件包的操作，需要求出这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包）。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2146](https://www.luogu.org/problemnew/show/P2146)\n\n[BZOJ 4196](https://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n## 题解\n\n可以说应该还是一道比较裸的树链剖分了。\n\n先树链剖分，然后根据编号构建一颗线段树。线段树每个节点维护当前区间已经安装的软件包的个数。需要一个$lazy$标记，为$1$意味着这个区间被全部卸载，为$2$意味着这个区间被全部安装。\n\n对于$install$操作，明显可以看出我们的需求包是从$0$号节点到$x$号节点的链上的所有节点，所以我们先求出在这条路径上的安装的软件包的个数，然后再求出这个路径的节点个数，并对整个路径进行修改，最后相减得到答案。\n\n对于$uninstall$操作，很明显可以看出只要把以x为根节点的子树的节点全都给卸载就可以了。\n所有我们求出在这个子树中的安装个数（注意到一颗子树的$id$应当是连续的），这个就是查询的答案，然后我们将这个子树给卸载掉就可以了。\n\n复杂度大约是$O(n \\; log^2{n})$或者稍小一些吧。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nstruct seg_tree{\n    #define lson (nown<<1)\n    #define rson ((nown<<1)|1)\n    #define mid ((l+r)>>1)\n    static const int MAXN = 110000;\n    int sumn[MAXN<<2],lazy[MAXN<<2];\n    seg_tree(){\n        memset(sumn,0,sizeof(sumn));\n        memset(lazy,0,sizeof(lazy));\n    }\n    //添加标记\n    inline void add_tag(int nown,int l,int r,int t){\n        if(t == 1)\n            sumn[nown] = 0,lazy[nown] = 1;\n        if(t == 2)\n            sumn[nown] = r-l+1,lazy[nown] = 2;\n    }\n    //下传区间标记\n    inline void push_down(int nown,int l,int r){\n        if(l == r) return;\n        if(lazy[nown]){\n            add_tag(lson,l,mid,lazy[nown]);\n            add_tag(rson,mid+1,r,lazy[nown]);\n            lazy[nown] = 0;\n        }\n    }\n    //维护区间和\n    inline void maintain(int nown){\n        sumn[nown] = sumn[lson] + sumn[rson];\n    }\n    //区间更新为安装（tag == 2）或未安装（tag == 2）\n    inline void update(int nown,int l,int r,int ql,int qr,int tag){\n        if(ql <= l && r<=qr)\n            add_tag(nown,l,r,tag);\n        else{\n            push_down(nown,l,r);\n            if(ql <= mid)\n                update(lson,l,mid,ql,qr,tag);\n            if(qr >= mid+1)\n                update(rson,mid+1,r,ql,qr,tag);\n            maintain(nown);\n        }\n    }\n    //区间查询安装的个数\n    inline int query(int nown,int l,int r,int ql,int qr){\n        if(ql <= l && r <= qr)\n            return sumn[nown];\n        else{\n            push_down(nown,l,r);\n            int ans = 0;\n            if(ql<=mid)\n                ans+=query(lson,l,mid,ql,qr);\n            if(qr >= mid+1)\n                ans+=query(rson,mid+1,r,ql,qr);\n            return ans;\n        }\n    }\n}tree;\n//线段树\n\nconst int MAXN = 110000;\nint n,m;\nint cnt = 0;\nint dep[MAXN],id[MAXN],son[MAXN],fa[MAXN],top[MAXN],siz[MAXN];\n\nvector<int> edge[MAXN];\n\n//树链剖分\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f;\n    dep[nown] = depth;\n    int maxsum = -1;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to] > maxsum)\n            son[nown] = to,maxsum = siz[to];\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    id[nown] = ++cnt,top[nown] = topf;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown] || to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//查询x到y的路径上的安装的个数\ninline int query(int x,int y){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]] < dep[top[y]]) swap(x,y);\n        ans+=tree.query(1,1,n,id[top[x]],id[x]);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y]) swap(x,y);\n    ans+=tree.query(1,1,n,id[x],id[y]);\n    return ans;\n}\n\n//将x到y路径上的点标记为安装或者卸载\ninline int update(int x,int y,int t){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]] < dep[top[y]]) swap(x,y);\n        ans+=id[x]-id[top[x]]+1;\n        tree.update(1,1,n,id[top[x]],id[x],t);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y]) swap(x,y);\n    ans+=id[y]-id[x]+1;tree.update(1,1,n,id[x],id[y],t);\n    return ans;\n}\n//安装\ninline int install(int x){\n    int b = query(1,x);\n    int e = update(1,x,2);\n    return e-b;\n}\n//卸载\ninline int uninstall(int x){\n    int b = tree.query(1,1,n,id[x],id[x]+siz[x]-1);\n    tree.update(1,1,n,id[x],id[x]+siz[x]-1,1);\n    return b;\n}\n\ninline void init(){\n    read(n);\n    int tmp;\n    for(int i = 2;i<=n;i++){\n        read(tmp);\n        edge[i].push_back(tmp+1);\n        edge[tmp+1].push_back(i);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n}\n\ninline void solve(){\n    read(m);\n    char op[20];int x;\n    for(int i = 1;i<=m;i++){\n        read(op),read(x);\n        if(op[0] == 'u')\n            print(uninstall(x+1)),print('\\n');\n        else if(op[0] == 'i')\n            print(install(x+1)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","source":"_posts/「NOI2015」软件包管理器-树链剖分.md","raw":"---\ntitle: 「NOI2015」软件包管理器-树链剖分\nurlname: noi2015-manager\ndate: 2018-04-09 21:07:03\ntags:\n- 题解\n- 数据结构\n- 树链剖分\n- 线段树\ncategories: OI\nvisible:\n---\n\n\n你决定设计你自己的软件包管理器。如果软件包A依赖软件包$B$，那么安装软件包$A$以前，必须先安装软件包$B$。同时，如果想要卸载软件包$B$，则必须卸载软件包$A$。现在你已经获得了所有的软件包之间的依赖关系。除$0$号软件包以外，所有软件包都会依赖一个且仅一个软件包，而$0$号软件包不依赖任何一个软件包。依赖关系不存在环。\n\n现在有一些安装或卸载软件包的操作，需要求出这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包）。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2146](https://www.luogu.org/problemnew/show/P2146)\n\n[BZOJ 4196](https://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n## 题解\n\n可以说应该还是一道比较裸的树链剖分了。\n\n先树链剖分，然后根据编号构建一颗线段树。线段树每个节点维护当前区间已经安装的软件包的个数。需要一个$lazy$标记，为$1$意味着这个区间被全部卸载，为$2$意味着这个区间被全部安装。\n\n对于$install$操作，明显可以看出我们的需求包是从$0$号节点到$x$号节点的链上的所有节点，所以我们先求出在这条路径上的安装的软件包的个数，然后再求出这个路径的节点个数，并对整个路径进行修改，最后相减得到答案。\n\n对于$uninstall$操作，很明显可以看出只要把以x为根节点的子树的节点全都给卸载就可以了。\n所有我们求出在这个子树中的安装个数（注意到一颗子树的$id$应当是连续的），这个就是查询的答案，然后我们将这个子树给卸载掉就可以了。\n\n复杂度大约是$O(n \\; log^2{n})$或者稍小一些吧。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nstruct seg_tree{\n    #define lson (nown<<1)\n    #define rson ((nown<<1)|1)\n    #define mid ((l+r)>>1)\n    static const int MAXN = 110000;\n    int sumn[MAXN<<2],lazy[MAXN<<2];\n    seg_tree(){\n        memset(sumn,0,sizeof(sumn));\n        memset(lazy,0,sizeof(lazy));\n    }\n    //添加标记\n    inline void add_tag(int nown,int l,int r,int t){\n        if(t == 1)\n            sumn[nown] = 0,lazy[nown] = 1;\n        if(t == 2)\n            sumn[nown] = r-l+1,lazy[nown] = 2;\n    }\n    //下传区间标记\n    inline void push_down(int nown,int l,int r){\n        if(l == r) return;\n        if(lazy[nown]){\n            add_tag(lson,l,mid,lazy[nown]);\n            add_tag(rson,mid+1,r,lazy[nown]);\n            lazy[nown] = 0;\n        }\n    }\n    //维护区间和\n    inline void maintain(int nown){\n        sumn[nown] = sumn[lson] + sumn[rson];\n    }\n    //区间更新为安装（tag == 2）或未安装（tag == 2）\n    inline void update(int nown,int l,int r,int ql,int qr,int tag){\n        if(ql <= l && r<=qr)\n            add_tag(nown,l,r,tag);\n        else{\n            push_down(nown,l,r);\n            if(ql <= mid)\n                update(lson,l,mid,ql,qr,tag);\n            if(qr >= mid+1)\n                update(rson,mid+1,r,ql,qr,tag);\n            maintain(nown);\n        }\n    }\n    //区间查询安装的个数\n    inline int query(int nown,int l,int r,int ql,int qr){\n        if(ql <= l && r <= qr)\n            return sumn[nown];\n        else{\n            push_down(nown,l,r);\n            int ans = 0;\n            if(ql<=mid)\n                ans+=query(lson,l,mid,ql,qr);\n            if(qr >= mid+1)\n                ans+=query(rson,mid+1,r,ql,qr);\n            return ans;\n        }\n    }\n}tree;\n//线段树\n\nconst int MAXN = 110000;\nint n,m;\nint cnt = 0;\nint dep[MAXN],id[MAXN],son[MAXN],fa[MAXN],top[MAXN],siz[MAXN];\n\nvector<int> edge[MAXN];\n\n//树链剖分\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f;\n    dep[nown] = depth;\n    int maxsum = -1;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to] > maxsum)\n            son[nown] = to,maxsum = siz[to];\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    id[nown] = ++cnt,top[nown] = topf;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown] || to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//查询x到y的路径上的安装的个数\ninline int query(int x,int y){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]] < dep[top[y]]) swap(x,y);\n        ans+=tree.query(1,1,n,id[top[x]],id[x]);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y]) swap(x,y);\n    ans+=tree.query(1,1,n,id[x],id[y]);\n    return ans;\n}\n\n//将x到y路径上的点标记为安装或者卸载\ninline int update(int x,int y,int t){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]] < dep[top[y]]) swap(x,y);\n        ans+=id[x]-id[top[x]]+1;\n        tree.update(1,1,n,id[top[x]],id[x],t);\n        x = fa[top[x]];\n    }\n    if(dep[x] > dep[y]) swap(x,y);\n    ans+=id[y]-id[x]+1;tree.update(1,1,n,id[x],id[y],t);\n    return ans;\n}\n//安装\ninline int install(int x){\n    int b = query(1,x);\n    int e = update(1,x,2);\n    return e-b;\n}\n//卸载\ninline int uninstall(int x){\n    int b = tree.query(1,1,n,id[x],id[x]+siz[x]-1);\n    tree.update(1,1,n,id[x],id[x]+siz[x]-1,1);\n    return b;\n}\n\ninline void init(){\n    read(n);\n    int tmp;\n    for(int i = 2;i<=n;i++){\n        read(tmp);\n        edge[i].push_back(tmp+1);\n        edge[tmp+1].push_back(i);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n}\n\ninline void solve(){\n    read(m);\n    char op[20];int x;\n    for(int i = 1;i<=m;i++){\n        read(op),read(x);\n        if(op[0] == 'u')\n            print(uninstall(x+1)),print('\\n');\n        else if(op[0] == 'i')\n            print(install(x+1)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","slug":"「NOI2015」软件包管理器-树链剖分","published":1,"updated":"2018-04-09T13:28:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jt003sbljrr350wazw","content":"<p>你决定设计你自己的软件包管理器。如果软件包A依赖软件包$B$，那么安装软件包$A$以前，必须先安装软件包$B$。同时，如果想要卸载软件包$B$，则必须卸载软件包$A$。现在你已经获得了所有的软件包之间的依赖关系。除$0$号软件包以外，所有软件包都会依赖一个且仅一个软件包，而$0$号软件包不依赖任何一个软件包。依赖关系不存在环。</p>\n<p>现在有一些安装或卸载软件包的操作，需要求出这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包）。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2146\" target=\"_blank\" rel=\"noopener\">Luogu P2146</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=4196\" target=\"_blank\" rel=\"noopener\">BZOJ 4196</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以说应该还是一道比较裸的树链剖分了。</p>\n<p>先树链剖分，然后根据编号构建一颗线段树。线段树每个节点维护当前区间已经安装的软件包的个数。需要一个$lazy$标记，为$1$意味着这个区间被全部卸载，为$2$意味着这个区间被全部安装。</p>\n<p>对于$install$操作，明显可以看出我们的需求包是从$0$号节点到$x$号节点的链上的所有节点，所以我们先求出在这条路径上的安装的软件包的个数，然后再求出这个路径的节点个数，并对整个路径进行修改，最后相减得到答案。</p>\n<p>对于$uninstall$操作，很明显可以看出只要把以x为根节点的子树的节点全都给卸载就可以了。<br>所有我们求出在这个子树中的安装个数（注意到一颗子树的$id$应当是连续的），这个就是查询的答案，然后我们将这个子树给卸载掉就可以了。</p>\n<p>复杂度大约是$O(n \\; log^2{n})$或者稍小一些吧。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seg_tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson (nown&lt;&lt;1)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson ((nown&lt;&lt;1)|1)</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sumn[MAXN&lt;&lt;<span class=\"number\">2</span>],lazy[MAXN&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\">    seg_tree()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(sumn,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(sumn));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(lazy,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(lazy));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加标记</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">add_tag</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t == <span class=\"number\">1</span>)</span><br><span class=\"line\">            sumn[nown] = <span class=\"number\">0</span>,lazy[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t == <span class=\"number\">2</span>)</span><br><span class=\"line\">            sumn[nown] = r-l+<span class=\"number\">1</span>,lazy[nown] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//下传区间标记</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lazy[nown])&#123;</span><br><span class=\"line\">            add_tag(lson,l,mid,lazy[nown]);</span><br><span class=\"line\">            add_tag(rson,mid+<span class=\"number\">1</span>,r,lazy[nown]);</span><br><span class=\"line\">            lazy[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//维护区间和</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">        sumn[nown] = sumn[lson] + sumn[rson];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//区间更新为安装（tag == 2）或未安装（tag == 2）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr,<span class=\"keyword\">int</span> tag)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql &lt;= l &amp;&amp; r&lt;=qr)</span><br><span class=\"line\">            add_tag(nown,l,r,tag);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            push_down(nown,l,r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql &lt;= mid)</span><br><span class=\"line\">                update(lson,l,mid,ql,qr,tag);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(qr &gt;= mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">                update(rson,mid+<span class=\"number\">1</span>,r,ql,qr,tag);</span><br><span class=\"line\">            maintain(nown);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//区间查询安装的个数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql &lt;= l &amp;&amp; r &lt;= qr)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sumn[nown];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            push_down(nown,l,r);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql&lt;=mid)</span><br><span class=\"line\">                ans+=query(lson,l,mid,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(qr &gt;= mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">                ans+=query(rson,mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;tree;</span><br><span class=\"line\"><span class=\"comment\">//线段树</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> dep[MAXN],id[MAXN],son[MAXN],fa[MAXN],top[MAXN],siz[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树链剖分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,fa[nown] = f;</span><br><span class=\"line\">    dep[nown] = depth;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxsum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == fa[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(to,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        siz[nown]+=siz[to];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[to] &gt; maxsum)</span><br><span class=\"line\">            son[nown] = to,maxsum = siz[to];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    id[nown] = ++cnt,top[nown] = topf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!son[nown]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == fa[nown] || to == son[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(to,to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询x到y的路径上的安装的个数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]] &lt; dep[top[y]]) swap(x,y);</span><br><span class=\"line\">        ans+=tree.query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[x]],id[x]);</span><br><span class=\"line\">        x = fa[top[x]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x] &gt; dep[y]) swap(x,y);</span><br><span class=\"line\">    ans+=tree.query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[y]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将x到y路径上的点标记为安装或者卸载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]] &lt; dep[top[y]]) swap(x,y);</span><br><span class=\"line\">        ans+=id[x]-id[top[x]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">        tree.update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[x]],id[x],t);</span><br><span class=\"line\">        x = fa[top[x]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x] &gt; dep[y]) swap(x,y);</span><br><span class=\"line\">    ans+=id[y]-id[x]+<span class=\"number\">1</span>;tree.update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[y],t);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//安装</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">install</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = query(<span class=\"number\">1</span>,x);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> e = update(<span class=\"number\">1</span>,x,<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e-b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//卸载</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">uninstall</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = tree.query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[x]+siz[x]<span class=\"number\">-1</span>);</span><br><span class=\"line\">    tree.update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[x]+siz[x]<span class=\"number\">-1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(tmp);</span><br><span class=\"line\">        edge[i].push_back(tmp+<span class=\"number\">1</span>);</span><br><span class=\"line\">        edge[tmp+<span class=\"number\">1</span>].push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(m);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op),read(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'u'</span>)</span><br><span class=\"line\">            print(uninstall(x+<span class=\"number\">1</span>)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'i'</span>)</span><br><span class=\"line\">            print(install(x+<span class=\"number\">1</span>)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>你决定设计你自己的软件包管理器。如果软件包A依赖软件包$B$，那么安装软件包$A$以前，必须先安装软件包$B$。同时，如果想要卸载软件包$B$，则必须卸载软件包$A$。现在你已经获得了所有的软件包之间的依赖关系。除$0$号软件包以外，所有软件包都会依赖一个且仅一个软件包，而$0$号软件包不依赖任何一个软件包。依赖关系不存在环。</p>\n<p>现在有一些安装或卸载软件包的操作，需要求出这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包）。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2146\" target=\"_blank\" rel=\"noopener\">Luogu P2146</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=4196\" target=\"_blank\" rel=\"noopener\">BZOJ 4196</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以说应该还是一道比较裸的树链剖分了。</p>\n<p>先树链剖分，然后根据编号构建一颗线段树。线段树每个节点维护当前区间已经安装的软件包的个数。需要一个$lazy$标记，为$1$意味着这个区间被全部卸载，为$2$意味着这个区间被全部安装。</p>\n<p>对于$install$操作，明显可以看出我们的需求包是从$0$号节点到$x$号节点的链上的所有节点，所以我们先求出在这条路径上的安装的软件包的个数，然后再求出这个路径的节点个数，并对整个路径进行修改，最后相减得到答案。</p>\n<p>对于$uninstall$操作，很明显可以看出只要把以x为根节点的子树的节点全都给卸载就可以了。<br>所有我们求出在这个子树中的安装个数（注意到一颗子树的$id$应当是连续的），这个就是查询的答案，然后我们将这个子树给卸载掉就可以了。</p>\n<p>复杂度大约是$O(n \\; log^2{n})$或者稍小一些吧。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�42-->\n\n</div></div>"},{"title":"「POI2014」KUR-Couriers-主席树","urlname":"POI2014-KUR","date":"2018-05-06T11:38:00.000Z","visible":null,"_content":"\n给一个数列$\\{a_n\\}$，每次询问区间$[l,r]$内有没有一个数出现次数超过一半。如果有，输出这个数，如果没有，输出$0$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3567](https://www.luogu.org/problemnew/show/P3567)\n\n## 题解\n\n主席树的模版...然而蒟蒻如我居然并看不出来怎么做...不过现在对权值线段树也更了解了呢。\n\n普通的建立一颗主席树。每个节点维护该区间内权值总和。\n\n在查询的时候，还是两个前缀相减，往大于$\\lceil \\frac{r-l+1}{2} \\rceil$（原始的$[l,r]$）的方向去走，如果没有，就返回0，边界就是$l == r$的时候返回。\n\n其实就是总统选举那道题的弱化版。\n\n很简单。然而我更菜。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cctype>\n#define mid ((l+r)>>1)\n#define pp pair<int,int>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 600000;\n\nnamespace prSegTree{\n    int val[MAXN*20];int ls[MAXN*20],rs[MAXN*20];\n    int cnt = 1;\n    void build(int &nown,int l,int r){\n        nown = cnt++;\n        if(l == r)\n            val[nown] = 0;\n        else{\n            build(ls[nown],l,mid);\n            build(rs[nown],mid+1,r);\n        }\n    }\n    void update(int &nown,int pre,int l,int r,int pos,int d){\n        nown = cnt++;val[nown] = val[pre]+d;\n        ls[nown] = ls[pre];rs[nown] = rs[pre];\n        if(l == r)\n            return;\n        else{\n            if(pos <= mid)\n                update(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos)\n                update(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    int query(int nowl,int nowr,int l,int r,int limit){\n        if(l == r)\n            return l;\n        else{\n            if(val[ls[nowr]] - val[ls[nowl]]>=limit)\n                return query(ls[nowl],ls[nowr],l,mid,limit);\n            if(val[rs[nowr]] - val[rs[nowl]]>=limit)\n                return query(rs[nowl],rs[nowr],mid+1,r,limit);\n            return 0;\n        }\n    }\n}\n\nint n,m;\nint root[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    prSegTree::build(root[0],1,n);\n    int tmp;\n    for(int i = 1;i<=n;i++){\n        read(tmp);\n        root[i] = root[i-1];\n        prSegTree::update(root[i],root[i-1],1,n,tmp,1);\n    }\n}\n\nvoid solve(){\n    int l,r;\n    for(int i = 1;i<=m;i++){\n        read(l),read(r);\n        print(prSegTree::query(root[l-1],root[r],1,n,(r-l+1)/2+1)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「POI2014」KUR-Couriers-主席树.md","raw":"---\ntitle: 「POI2014」KUR-Couriers-主席树\nurlname: POI2014-KUR\ndate: 2018-05-06 19:38:00\ntags:\n- 题解\n- 数据结构\n- 主席树\n- 线段树\n- 可持久化线段树\ncategories: OI\nvisible:\n---\n\n给一个数列$\\{a_n\\}$，每次询问区间$[l,r]$内有没有一个数出现次数超过一半。如果有，输出这个数，如果没有，输出$0$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3567](https://www.luogu.org/problemnew/show/P3567)\n\n## 题解\n\n主席树的模版...然而蒟蒻如我居然并看不出来怎么做...不过现在对权值线段树也更了解了呢。\n\n普通的建立一颗主席树。每个节点维护该区间内权值总和。\n\n在查询的时候，还是两个前缀相减，往大于$\\lceil \\frac{r-l+1}{2} \\rceil$（原始的$[l,r]$）的方向去走，如果没有，就返回0，边界就是$l == r$的时候返回。\n\n其实就是总统选举那道题的弱化版。\n\n很简单。然而我更菜。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cctype>\n#define mid ((l+r)>>1)\n#define pp pair<int,int>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 600000;\n\nnamespace prSegTree{\n    int val[MAXN*20];int ls[MAXN*20],rs[MAXN*20];\n    int cnt = 1;\n    void build(int &nown,int l,int r){\n        nown = cnt++;\n        if(l == r)\n            val[nown] = 0;\n        else{\n            build(ls[nown],l,mid);\n            build(rs[nown],mid+1,r);\n        }\n    }\n    void update(int &nown,int pre,int l,int r,int pos,int d){\n        nown = cnt++;val[nown] = val[pre]+d;\n        ls[nown] = ls[pre];rs[nown] = rs[pre];\n        if(l == r)\n            return;\n        else{\n            if(pos <= mid)\n                update(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos)\n                update(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    int query(int nowl,int nowr,int l,int r,int limit){\n        if(l == r)\n            return l;\n        else{\n            if(val[ls[nowr]] - val[ls[nowl]]>=limit)\n                return query(ls[nowl],ls[nowr],l,mid,limit);\n            if(val[rs[nowr]] - val[rs[nowl]]>=limit)\n                return query(rs[nowl],rs[nowr],mid+1,r,limit);\n            return 0;\n        }\n    }\n}\n\nint n,m;\nint root[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    prSegTree::build(root[0],1,n);\n    int tmp;\n    for(int i = 1;i<=n;i++){\n        read(tmp);\n        root[i] = root[i-1];\n        prSegTree::update(root[i],root[i-1],1,n,tmp,1);\n    }\n}\n\nvoid solve(){\n    int l,r;\n    for(int i = 1;i<=m;i++){\n        read(l),read(r);\n        print(prSegTree::query(root[l-1],root[r],1,n,(r-l+1)/2+1)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「POI2014」KUR-Couriers-主席树","published":1,"updated":"2018-05-06T11:47:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jv003vbljrnuk6yd82","content":"<p>给一个数列${a_n}$，每次询问区间$[l,r]$内有没有一个数出现次数超过一半。如果有，输出这个数，如果没有，输出$0$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3567\" target=\"_blank\" rel=\"noopener\">Luogu P3567</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>主席树的模版…然而蒟蒻如我居然并看不出来怎么做…不过现在对权值线段树也更了解了呢。</p>\n<p>普通的建立一颗主席树。每个节点维护该区间内权值总和。</p>\n<p>在查询的时候，还是两个前缀相减，往大于$\\lceil \\frac{r-l+1}{2} \\rceil$（原始的$[l,r]$）的方向去走，如果没有，就返回0，边界就是$l == r$的时候返回。</p>\n<p>其实就是总统选举那道题的弱化版。</p>\n<p>很简单。然而我更菜。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pp pair<span class=\"meta-string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">600000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> prSegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val[MAXN*<span class=\"number\">20</span>];<span class=\"keyword\">int</span> ls[MAXN*<span class=\"number\">20</span>],rs[MAXN*<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        nown = cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">            val[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            build(ls[nown],l,mid);</span><br><span class=\"line\">            build(rs[nown],mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        nown = cnt++;val[nown] = val[pre]+d;</span><br><span class=\"line\">        ls[nown] = ls[pre];rs[nown] = rs[pre];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos &lt;= mid)</span><br><span class=\"line\">                update(ls[nown],ls[pre],l,mid,pos,d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= pos)</span><br><span class=\"line\">                update(rs[nown],rs[pre],mid+<span class=\"number\">1</span>,r,pos,d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nowl,<span class=\"keyword\">int</span> nowr,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> limit)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val[ls[nowr]] - val[ls[nowl]]&gt;=limit)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> query(ls[nowl],ls[nowr],l,mid,limit);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val[rs[nowr]] - val[rs[nowl]]&gt;=limit)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> query(rs[nowl],rs[nowr],mid+<span class=\"number\">1</span>,r,limit);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> root[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    prSegTree::build(root[<span class=\"number\">0</span>],<span class=\"number\">1</span>,n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(tmp);</span><br><span class=\"line\">        root[i] = root[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        prSegTree::update(root[i],root[i<span class=\"number\">-1</span>],<span class=\"number\">1</span>,n,tmp,<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l,r;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(l),read(r);</span><br><span class=\"line\">        print(prSegTree::query(root[l<span class=\"number\">-1</span>],root[r],<span class=\"number\">1</span>,n,(r-l+<span class=\"number\">1</span>)/<span class=\"number\">2</span>+<span class=\"number\">1</span>)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>给一个数列${a_n}$，每次询问区间$[l,r]$内有没有一个数出现次数超过一半。如果有，输出这个数，如果没有，输出$0$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3567\" target=\"_blank\" rel=\"noopener\">Luogu P3567</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>主席树的模版…然而蒟蒻如我居然并看不出来怎么做…不过现在对权值线段树也更了解了呢。</p>\n<p>普通的建立一颗主席树。每个节点维护该区间内权值总和。</p>\n<p>在查询的时候，还是两个前缀相减，往大于$\\lceil \\frac{r-l+1}{2} \\rceil$（原始的$[l,r]$）的方向去走，如果没有，就返回0，边界就是$l == r$的时候返回。</p>\n<p>其实就是总统选举那道题的弱化版。</p>\n<p>很简单。然而我更菜。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�43-->\n\n</div></div>"},{"title":"「SCOI2010」连续攻击游戏-二分图匹配","urlname":"SCOI2010-game","date":"2018-04-27T10:48:55.000Z","visible":null,"_content":"\n`lxhgww`最近迷上了一款游戏，在游戏里，他拥有$n$个装备（$n < 1000000$），每种装备都有$2$个属性，这些属性的值用$[1,10000]$之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。\n\n游戏进行到最后，`lxhgww`遇到了终极`boss`，这个终极`boss`很奇怪，攻击他的装备所使用的属性值必须从$1$开始连续递增地攻击，才能对`boss`产生伤害。现在`lxhgww`想知道他最多能连续攻击`boss`多少次？\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1640](https://www.luogu.org/problemnew/show/P1640)\n\n[BZOJ 1854](https://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n## 题解\n\n可以看出，这个东西可以转换成二分图的模版。左边的$10000$个点代表属性值，右边的n个点代表装备。\n\n从属性值$1$开始跑匈牙利的$dfs$，如果能增广，就接着往下。不能的话，输出答案返回。复杂度不太会算...不过可以过的。\n\n值得一提的是，网络流虽然我每次直接在残量网络上增广...但仍然慢的要死...$40$分TLE再也优化不了了...\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 2000000,MAXM = 5000000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\n\nstruct Edge{\n    int from,to;\n    int nex;\n}edge[MAXM];\nint fir[MAXN],ecnt = 1;\nvoid addedge(int a,int b){\n    edge[ecnt] = (Edge){a,b,fir[a]};\n    fir[a] = ecnt++;\n}\nint n,a,b;\nint pre[1100000],vis[11000];\n\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++){\n        read(a),read(b);\n        addedge(a,100000+i),addedge(b,100000+i);\t\n    }\n}\n\nbool dfs(int nown){\n    if(vis[nown]) return 0;\n    vis[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(!pre[v] || dfs(pre[v])){\n            pre[v] = nown;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = 1;i<=10000;i++){\n        memset(vis,0,sizeof(vis));\n        if(dfs(i)) ans++;\n        else break;\n    }\n    print(ans);\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SCOI2010」连续攻击游戏-二分图匹配.md","raw":"---\ntitle: 「SCOI2010」连续攻击游戏-二分图匹配\nurlname: SCOI2010-game\ndate: 2018-04-27 18:48:55\ntags:\n- 题解\n- 图论\n- 二分图匹配\ncategories: OI\nvisible:\n---\n\n`lxhgww`最近迷上了一款游戏，在游戏里，他拥有$n$个装备（$n < 1000000$），每种装备都有$2$个属性，这些属性的值用$[1,10000]$之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。\n\n游戏进行到最后，`lxhgww`遇到了终极`boss`，这个终极`boss`很奇怪，攻击他的装备所使用的属性值必须从$1$开始连续递增地攻击，才能对`boss`产生伤害。现在`lxhgww`想知道他最多能连续攻击`boss`多少次？\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1640](https://www.luogu.org/problemnew/show/P1640)\n\n[BZOJ 1854](https://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n## 题解\n\n可以看出，这个东西可以转换成二分图的模版。左边的$10000$个点代表属性值，右边的n个点代表装备。\n\n从属性值$1$开始跑匈牙利的$dfs$，如果能增广，就接着往下。不能的话，输出答案返回。复杂度不太会算...不过可以过的。\n\n值得一提的是，网络流虽然我每次直接在残量网络上增广...但仍然慢的要死...$40$分TLE再也优化不了了...\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 2000000,MAXM = 5000000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\n\nstruct Edge{\n    int from,to;\n    int nex;\n}edge[MAXM];\nint fir[MAXN],ecnt = 1;\nvoid addedge(int a,int b){\n    edge[ecnt] = (Edge){a,b,fir[a]};\n    fir[a] = ecnt++;\n}\nint n,a,b;\nint pre[1100000],vis[11000];\n\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++){\n        read(a),read(b);\n        addedge(a,100000+i),addedge(b,100000+i);\t\n    }\n}\n\nbool dfs(int nown){\n    if(vis[nown]) return 0;\n    vis[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(!pre[v] || dfs(pre[v])){\n            pre[v] = nown;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = 1;i<=10000;i++){\n        memset(vis,0,sizeof(vis));\n        if(dfs(i)) ans++;\n        else break;\n    }\n    print(ans);\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SCOI2010」连续攻击游戏-二分图匹配","published":1,"updated":"2018-06-07T15:03:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jw003zbljr0wy82koz","content":"<p><code>lxhgww</code>最近迷上了一款游戏，在游戏里，他拥有$n$个装备（$n &lt; 1000000$），每种装备都有$2$个属性，这些属性的值用$[1,10000]$之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。</p>\n<p>游戏进行到最后，<code>lxhgww</code>遇到了终极<code>boss</code>，这个终极<code>boss</code>很奇怪，攻击他的装备所使用的属性值必须从$1$开始连续递增地攻击，才能对<code>boss</code>产生伤害。现在<code>lxhgww</code>想知道他最多能连续攻击<code>boss</code>多少次？</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1640\" target=\"_blank\" rel=\"noopener\">Luogu P1640</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1854\" target=\"_blank\" rel=\"noopener\">BZOJ 1854</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以看出，这个东西可以转换成二分图的模版。左边的$10000$个点代表属性值，右边的n个点代表装备。</p>\n<p>从属性值$1$开始跑匈牙利的$dfs$，如果能增广，就接着往下。不能的话，输出答案返回。复杂度不太会算…不过可以过的。</p>\n<p>值得一提的是，网络流虽然我每次直接在残量网络上增广…但仍然慢的要死…$40$分TLE再也优化不了了…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">2000000</span>,MAXM = <span class=\"number\">5000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nex;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN],ecnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;a,b,fir[a]&#125;;</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,a,b;</span><br><span class=\"line\"><span class=\"keyword\">int</span> pre[<span class=\"number\">1100000</span>],vis[<span class=\"number\">11000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        addedge(a,<span class=\"number\">100000</span>+i),addedge(b,<span class=\"number\">100000</span>+i);\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(vis[nown]) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    vis[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!pre[v] || dfs(pre[v]))&#123;</span><br><span class=\"line\">            pre[v] = nown;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=<span class=\"number\">10000</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(vis));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfs(i)) ans++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p><code>lxhgww</code>最近迷上了一款游戏，在游戏里，他拥有$n$个装备（$n &lt; 1000000$），每种装备都有$2$个属性，这些属性的值用$[1,10000]$之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。</p>\n<p>游戏进行到最后，<code>lxhgww</code>遇到了终极<code>boss</code>，这个终极<code>boss</code>很奇怪，攻击他的装备所使用的属性值必须从$1$开始连续递增地攻击，才能对<code>boss</code>产生伤害。现在<code>lxhgww</code>想知道他最多能连续攻击<code>boss</code>多少次？</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1640\" target=\"_blank\" rel=\"noopener\">Luogu P1640</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1854\" target=\"_blank\" rel=\"noopener\">BZOJ 1854</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以看出，这个东西可以转换成二分图的模版。左边的$10000$个点代表属性值，右边的n个点代表装备。</p>\n<p>从属性值$1$开始跑匈牙利的$dfs$，如果能增广，就接着往下。不能的话，输出答案返回。复杂度不太会算…不过可以过的。</p>\n<p>值得一提的是，网络流虽然我每次直接在残量网络上增广…但仍然慢的要死…$40$分TLE再也优化不了了…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�44-->\n\n</div></div>"},{"title":"「SCOI2013」多项式的运算-Splay","urlname":"scoi2013-function","date":"2018-06-01T13:12:47.000Z","visible":null,"_content":"\n维护一个动态的关于$x$的无穷多项式 ，这个多项式初始时对于所有$i$有$a_i = 0$\n\n$f(x)=a_0x^0+a_1x^1+a_2x^2...$\n操作者可以进行四种操作：\n\n+ `mul L R V`表示将 $x^L$ 到 $x^R$ 这些项的系数乘上某个定值$v$；\n\n+ `add L R V`表示将$x^L$ 到 $x^R $这些项的系数加上某个定值$v$；\n\n+ `mulx L R`表示将$x^L$ 到 $x^R$ 这些项乘上x变量；\n\n+ `query V`求$f(v)$的值。\n\n\n操作集中在前三种，第四种操作不会出现超过$10$次。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3278](https://www.luogu.org/problemnew/show/P3278)\n\n## 题解\n\nSplay大毒瘤题。\n\n前两个操作让我们想到线段树的模板，第三个操作如果从序列的角度来看就像是把一个序列向右移动，在把被冲掉的那一个位置加到原来的位数上去。\n\n显然啊！同志们，这是送分题啊！Splay套套套...\n\n- - -\n\n- `add`操作：提取区间，打标记，维护信息。\n\n- `mul`操作：提取区间，打标记，维护信息。\n\n- `mulx`操作：呃...先找到rank为l-1,l,r,r+1,r+2的节点。删除掉r+1号节点，把其值加到r上去，然后在l-1和l之间插入一个值为0的节点，维护信息。\n\n注意：push_down操作先传muln，再传addn。\n\n打标记几乎同线段树模板，就不说了。\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <unistd.h>\n#include <cctype>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 210000;\nconst ll p = 20130426LL;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\ninline void mod(ll &x){x %= p;}\n\nstruct Splay{\n    ll val[MAXN],addn[MAXN],muln[MAXN];\n    int f[MAXN],c[MAXN][2],siz[MAXN],tot,root;\n    int newnode(int v = 0){\n        val[++tot] = v;\n        siz[tot] = 1;\n        addn[tot] = 0,muln[tot] = 1;\n        return tot;     \n    }\n    void add(int x,int num){\n        if(!x) return;\n        addn[x] += num,val[x] += num;\n        mod(val[x]),mod(addn[x]);\n    }\n    void mul(int x,int num){\n        if(!x) return;\n        muln[x] *= num,addn[x] *= num,val[x] *= num;\n        mod(addn[x]),mod(muln[x]),mod(val[x]);\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(muln[x]!=1){\n            mul(c[x][0],muln[x]);\n            mul(c[x][1],muln[x]);\n            muln[x] = 1;\n        }\n        if(addn[x] != 0){\n            add(c[x][0],addn[x]);\n            add(c[x][1],addn[x]);\n            addn[x] = 0;\n        }\n    }\n    void  push_up(int x){\n        if(!x) return;\n        siz[x] = siz[c[x][0]] + siz[c[x][1]] + 1;\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1]==x),w = c[x][1-t];\n        push_down(y),push_down(x);\n        f[x] = z;f[y] = x;\n        if(w) f[w] = y;\n        c[x][1-t] = y,c[y][t] = w;\n        if(z) c[z][c[z][1]==y] = x;\n        push_up(y),push_up(x);\n        if(!f[x]) root = x;\n    }\n    void splay(int x,int target = 0){\n        while(f[x]!=target){\n            int y = f[x],z = f[y];\n            if(z!=target)\n                (c[z][1]==y) ^ (c[y][1]==x)?rotate(x):rotate(y);\n            rotate(x);\n        }\n    }\n    int qrank(int r){\n        int x = root;\n        while(2333){\n            if(r <= siz[c[x][0]])\n                x = c[x][0];\n            else if(r == siz[c[x][0]] + 1)\n                break;\n            else\n                r -= siz[c[x][0]] + 1,x = c[x][1];\n        }\n        return x;\n    }\n    int __build(int l,int r,int fa){\n        if(l > r) return 0;\n        int mid = (l+r)>>1;\n        int x = newnode();\n        f[x] = fa;\n        c[x][0] = __build(l,mid-1,x);\n        c[x][1] = __build(mid+1,r,x);\n        push_up(x);\n        return x;\n    }\n    void build(int num){\n        root = __build(1,num,0);\n    }\n    void __output(int x,ll *a){\n        if(!x) return;\n        push_down(x);\n        __output(c[x][0],a);\n        a += siz[c[x][0]],*a = val[x];\n        __output(c[x][1],a+1);\n    }\n    void output(ll *a){\n        __output(root,a);\n    }\n    void add(int l,int r,int num){\n        int lb = qrank(l),rb = qrank(r+2);\n        splay(lb),splay(rb,lb);\n        add(c[rb][0],num);\n        push_up(rb),push_up(lb);\n    }\n    void mul(int l,int r,int num){\n        int lb = qrank(l),rb = qrank(r+2);\n        splay(lb),splay(rb,lb);\n        mul(c[rb][0],num);\n        push_up(rb),push_up(lb);\n    }\n    void mulx(int l,int r){\n        int x = qrank(l),y = qrank(l+1),z = qrank(r+1),a = qrank(r+2),b = qrank(r+3);\n        splay(z),splay(b,z);\n        c[b][0] = 0;push_up(b),push_up(z);\n        val[z] += val[a];\n        splay(x),splay(y,x);\n        c[y][0] = newnode(),f[c[y][0]] = y;\n        push_up(y),push_up(x);\n    }\n}T;\n\nint n,m = 110000;\n\nll query(ll v){\n    static ll o[MAXN];\n    T.output(o);\n    ll ans = 0;\n    for(int i = m;i>=1;i--){\n        ans = ans * v + o[i];\n        mod(ans);\n    }\n    return ans;\n}\n\n\nvoid init(){\n    read(n);\n    T.build(m+3);\n}\n\nvoid solve(){\n    char op[10];int l,r,v;\n    for(int i = 1;i<=n;i++){\n        read(op);\n        if(op[0] == 'q'){\n            read(v);\n            print(int(query(v))),print('\\n');\n        }\n        else{\n            read(l),read(r);\n            if(op[3] == 'x')\n                T.mulx(l+1,r+1);\n            else{\n                read(v);\n                if(op[0] == 'm')\n                    T.mul(l+1,r+1,v);\n                else if(op[0] == 'a')\n                    T.add(l+1,r+1,v);\n            }\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n\n","source":"_posts/「SCOI2013」多项式的运算-Splay.md","raw":"---\ntitle: 「SCOI2013」多项式的运算-Splay\nurlname: scoi2013-function\ndate: 2018-06-01 21:12:47\ntags:\ncategories:\nvisible:\n---\n\n维护一个动态的关于$x$的无穷多项式 ，这个多项式初始时对于所有$i$有$a_i = 0$\n\n$f(x)=a_0x^0+a_1x^1+a_2x^2...$\n操作者可以进行四种操作：\n\n+ `mul L R V`表示将 $x^L$ 到 $x^R$ 这些项的系数乘上某个定值$v$；\n\n+ `add L R V`表示将$x^L$ 到 $x^R $这些项的系数加上某个定值$v$；\n\n+ `mulx L R`表示将$x^L$ 到 $x^R$ 这些项乘上x变量；\n\n+ `query V`求$f(v)$的值。\n\n\n操作集中在前三种，第四种操作不会出现超过$10$次。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3278](https://www.luogu.org/problemnew/show/P3278)\n\n## 题解\n\nSplay大毒瘤题。\n\n前两个操作让我们想到线段树的模板，第三个操作如果从序列的角度来看就像是把一个序列向右移动，在把被冲掉的那一个位置加到原来的位数上去。\n\n显然啊！同志们，这是送分题啊！Splay套套套...\n\n- - -\n\n- `add`操作：提取区间，打标记，维护信息。\n\n- `mul`操作：提取区间，打标记，维护信息。\n\n- `mulx`操作：呃...先找到rank为l-1,l,r,r+1,r+2的节点。删除掉r+1号节点，把其值加到r上去，然后在l-1和l之间插入一个值为0的节点，维护信息。\n\n注意：push_down操作先传muln，再传addn。\n\n打标记几乎同线段树模板，就不说了。\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <unistd.h>\n#include <cctype>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 210000;\nconst ll p = 20130426LL;\n\nnamespace fast_io {\n\t//...\n}using namespace fast_io;\n\ninline void mod(ll &x){x %= p;}\n\nstruct Splay{\n    ll val[MAXN],addn[MAXN],muln[MAXN];\n    int f[MAXN],c[MAXN][2],siz[MAXN],tot,root;\n    int newnode(int v = 0){\n        val[++tot] = v;\n        siz[tot] = 1;\n        addn[tot] = 0,muln[tot] = 1;\n        return tot;     \n    }\n    void add(int x,int num){\n        if(!x) return;\n        addn[x] += num,val[x] += num;\n        mod(val[x]),mod(addn[x]);\n    }\n    void mul(int x,int num){\n        if(!x) return;\n        muln[x] *= num,addn[x] *= num,val[x] *= num;\n        mod(addn[x]),mod(muln[x]),mod(val[x]);\n    }\n    void push_down(int x){\n        if(!x) return;\n        if(muln[x]!=1){\n            mul(c[x][0],muln[x]);\n            mul(c[x][1],muln[x]);\n            muln[x] = 1;\n        }\n        if(addn[x] != 0){\n            add(c[x][0],addn[x]);\n            add(c[x][1],addn[x]);\n            addn[x] = 0;\n        }\n    }\n    void  push_up(int x){\n        if(!x) return;\n        siz[x] = siz[c[x][0]] + siz[c[x][1]] + 1;\n    }\n    void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1]==x),w = c[x][1-t];\n        push_down(y),push_down(x);\n        f[x] = z;f[y] = x;\n        if(w) f[w] = y;\n        c[x][1-t] = y,c[y][t] = w;\n        if(z) c[z][c[z][1]==y] = x;\n        push_up(y),push_up(x);\n        if(!f[x]) root = x;\n    }\n    void splay(int x,int target = 0){\n        while(f[x]!=target){\n            int y = f[x],z = f[y];\n            if(z!=target)\n                (c[z][1]==y) ^ (c[y][1]==x)?rotate(x):rotate(y);\n            rotate(x);\n        }\n    }\n    int qrank(int r){\n        int x = root;\n        while(2333){\n            if(r <= siz[c[x][0]])\n                x = c[x][0];\n            else if(r == siz[c[x][0]] + 1)\n                break;\n            else\n                r -= siz[c[x][0]] + 1,x = c[x][1];\n        }\n        return x;\n    }\n    int __build(int l,int r,int fa){\n        if(l > r) return 0;\n        int mid = (l+r)>>1;\n        int x = newnode();\n        f[x] = fa;\n        c[x][0] = __build(l,mid-1,x);\n        c[x][1] = __build(mid+1,r,x);\n        push_up(x);\n        return x;\n    }\n    void build(int num){\n        root = __build(1,num,0);\n    }\n    void __output(int x,ll *a){\n        if(!x) return;\n        push_down(x);\n        __output(c[x][0],a);\n        a += siz[c[x][0]],*a = val[x];\n        __output(c[x][1],a+1);\n    }\n    void output(ll *a){\n        __output(root,a);\n    }\n    void add(int l,int r,int num){\n        int lb = qrank(l),rb = qrank(r+2);\n        splay(lb),splay(rb,lb);\n        add(c[rb][0],num);\n        push_up(rb),push_up(lb);\n    }\n    void mul(int l,int r,int num){\n        int lb = qrank(l),rb = qrank(r+2);\n        splay(lb),splay(rb,lb);\n        mul(c[rb][0],num);\n        push_up(rb),push_up(lb);\n    }\n    void mulx(int l,int r){\n        int x = qrank(l),y = qrank(l+1),z = qrank(r+1),a = qrank(r+2),b = qrank(r+3);\n        splay(z),splay(b,z);\n        c[b][0] = 0;push_up(b),push_up(z);\n        val[z] += val[a];\n        splay(x),splay(y,x);\n        c[y][0] = newnode(),f[c[y][0]] = y;\n        push_up(y),push_up(x);\n    }\n}T;\n\nint n,m = 110000;\n\nll query(ll v){\n    static ll o[MAXN];\n    T.output(o);\n    ll ans = 0;\n    for(int i = m;i>=1;i--){\n        ans = ans * v + o[i];\n        mod(ans);\n    }\n    return ans;\n}\n\n\nvoid init(){\n    read(n);\n    T.build(m+3);\n}\n\nvoid solve(){\n    char op[10];int l,r,v;\n    for(int i = 1;i<=n;i++){\n        read(op);\n        if(op[0] == 'q'){\n            read(v);\n            print(int(query(v))),print('\\n');\n        }\n        else{\n            read(l),read(r);\n            if(op[3] == 'x')\n                T.mulx(l+1,r+1);\n            else{\n                read(v);\n                if(op[0] == 'm')\n                    T.mul(l+1,r+1,v);\n                else if(op[0] == 'a')\n                    T.add(l+1,r+1,v);\n            }\n        }\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n\n","slug":"「SCOI2013」多项式的运算-Splay","published":1,"updated":"2018-06-02T15:39:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jx0041bljr5eq36czf","content":"<p>维护一个动态的关于$x$的无穷多项式 ，这个多项式初始时对于所有$i$有$a_i = 0$</p>\n<p>$f(x)=a_0x^0+a_1x^1+a_2x^2…$<br>操作者可以进行四种操作：</p>\n<ul>\n<li><p><code>mul L R V</code>表示将 $x^L$ 到 $x^R$ 这些项的系数乘上某个定值$v$；</p>\n</li>\n<li><p><code>add L R V</code>表示将$x^L$ 到 $x^R $这些项的系数加上某个定值$v$；</p>\n</li>\n<li><p><code>mulx L R</code>表示将$x^L$ 到 $x^R$ 这些项乘上x变量；</p>\n</li>\n<li><p><code>query V</code>求$f(v)$的值。</p>\n</li>\n</ul>\n<p>操作集中在前三种，第四种操作不会出现超过$10$次。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3278\" target=\"_blank\" rel=\"noopener\">Luogu P3278</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>Splay大毒瘤题。</p>\n<p>前两个操作让我们想到线段树的模板，第三个操作如果从序列的角度来看就像是把一个序列向右移动，在把被冲掉的那一个位置加到原来的位数上去。</p>\n<p>显然啊！同志们，这是送分题啊！Splay套套套…</p>\n<hr>\n<ul>\n<li><p><code>add</code>操作：提取区间，打标记，维护信息。</p>\n</li>\n<li><p><code>mul</code>操作：提取区间，打标记，维护信息。</p>\n</li>\n<li><p><code>mulx</code>操作：呃…先找到rank为l-1,l,r,r+1,r+2的节点。删除掉r+1号节点，把其值加到r上去，然后在l-1和l之间插入一个值为0的节点，维护信息。</p>\n</li>\n</ul>\n<p>注意：push_down操作先传muln，再传addn。</p>\n<p>打标记几乎同线段树模板，就不说了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">210000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ll p = <span class=\"number\">20130426L</span>L;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">mod</span><span class=\"params\">(ll &amp;x)</span></span>&#123;x %= p;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Splay</span>&#123;</span></span><br><span class=\"line\">    ll val[MAXN],addn[MAXN],muln[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[MAXN],c[MAXN][<span class=\"number\">2</span>],siz[MAXN],tot,root;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">int</span> v = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        val[++tot] = v;</span><br><span class=\"line\">        siz[tot] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        addn[tot] = <span class=\"number\">0</span>,muln[tot] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tot;     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        addn[x] += num,val[x] += num;</span><br><span class=\"line\">        mod(val[x]),mod(addn[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mul</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        muln[x] *= num,addn[x] *= num,val[x] *= num;</span><br><span class=\"line\">        mod(addn[x]),mod(muln[x]),mod(val[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(muln[x]!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            mul(c[x][<span class=\"number\">0</span>],muln[x]);</span><br><span class=\"line\">            mul(c[x][<span class=\"number\">1</span>],muln[x]);</span><br><span class=\"line\">            muln[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(addn[x] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            add(c[x][<span class=\"number\">0</span>],addn[x]);</span><br><span class=\"line\">            add(c[x][<span class=\"number\">1</span>],addn[x]);</span><br><span class=\"line\">            addn[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">push_up</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        siz[x] = siz[c[x][<span class=\"number\">0</span>]] + siz[c[x][<span class=\"number\">1</span>]] + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = f[x],z = f[y],t = (c[y][<span class=\"number\">1</span>]==x),w = c[x][<span class=\"number\">1</span>-t];</span><br><span class=\"line\">        push_down(y),push_down(x);</span><br><span class=\"line\">        f[x] = z;f[y] = x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w) f[w] = y;</span><br><span class=\"line\">        c[x][<span class=\"number\">1</span>-t] = y,c[y][t] = w;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(z) c[z][c[z][<span class=\"number\">1</span>]==y] = x;</span><br><span class=\"line\">        push_up(y),push_up(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!f[x]) root = x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> target = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(f[x]!=target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = f[x],z = f[y];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(z!=target)</span><br><span class=\"line\">                (c[z][<span class=\"number\">1</span>]==y) ^ (c[y][<span class=\"number\">1</span>]==x)?rotate(x):rotate(y);</span><br><span class=\"line\">            rotate(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">qrank</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">2333</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r &lt;= siz[c[x][<span class=\"number\">0</span>]])</span><br><span class=\"line\">                x = c[x][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r == siz[c[x][<span class=\"number\">0</span>]] + <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                r -= siz[c[x][<span class=\"number\">0</span>]] + <span class=\"number\">1</span>,x = c[x][<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> __build(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> fa)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l &gt; r) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = newnode();</span><br><span class=\"line\">        f[x] = fa;</span><br><span class=\"line\">        c[x][<span class=\"number\">0</span>] = __build(l,mid<span class=\"number\">-1</span>,x);</span><br><span class=\"line\">        c[x][<span class=\"number\">1</span>] = __build(mid+<span class=\"number\">1</span>,r,x);</span><br><span class=\"line\">        push_up(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        root = __build(<span class=\"number\">1</span>,num,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __output(<span class=\"keyword\">int</span> x,ll *a)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">        __output(c[x][<span class=\"number\">0</span>],a);</span><br><span class=\"line\">        a += siz[c[x][<span class=\"number\">0</span>]],*a = val[x];</span><br><span class=\"line\">        __output(c[x][<span class=\"number\">1</span>],a+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">(ll *a)</span></span>&#123;</span><br><span class=\"line\">        __output(root,a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lb = qrank(l),rb = qrank(r+<span class=\"number\">2</span>);</span><br><span class=\"line\">        splay(lb),splay(rb,lb);</span><br><span class=\"line\">        add(c[rb][<span class=\"number\">0</span>],num);</span><br><span class=\"line\">        push_up(rb),push_up(lb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mul</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lb = qrank(l),rb = qrank(r+<span class=\"number\">2</span>);</span><br><span class=\"line\">        splay(lb),splay(rb,lb);</span><br><span class=\"line\">        mul(c[rb][<span class=\"number\">0</span>],num);</span><br><span class=\"line\">        push_up(rb),push_up(lb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mulx</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = qrank(l),y = qrank(l+<span class=\"number\">1</span>),z = qrank(r+<span class=\"number\">1</span>),a = qrank(r+<span class=\"number\">2</span>),b = qrank(r+<span class=\"number\">3</span>);</span><br><span class=\"line\">        splay(z),splay(b,z);</span><br><span class=\"line\">        c[b][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;push_up(b),push_up(z);</span><br><span class=\"line\">        val[z] += val[a];</span><br><span class=\"line\">        splay(x),splay(y,x);</span><br><span class=\"line\">        c[y][<span class=\"number\">0</span>] = newnode(),f[c[y][<span class=\"number\">0</span>]] = y;</span><br><span class=\"line\">        push_up(y),push_up(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(ll v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ll o[MAXN];</span><br><span class=\"line\">    T.output(o);</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">        ans = ans * v + o[i];</span><br><span class=\"line\">        mod(ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    T.build(m+<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];<span class=\"keyword\">int</span> l,r,v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(op);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'q'</span>)&#123;</span><br><span class=\"line\">            read(v);</span><br><span class=\"line\">            print(<span class=\"keyword\">int</span>(query(v))),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            read(l),read(r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(op[<span class=\"number\">3</span>] == <span class=\"string\">'x'</span>)</span><br><span class=\"line\">                T.mulx(l+<span class=\"number\">1</span>,r+<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                read(v);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'m'</span>)</span><br><span class=\"line\">                    T.mul(l+<span class=\"number\">1</span>,r+<span class=\"number\">1</span>,v);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'a'</span>)</span><br><span class=\"line\">                    T.add(l+<span class=\"number\">1</span>,r+<span class=\"number\">1</span>,v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>维护一个动态的关于$x$的无穷多项式 ，这个多项式初始时对于所有$i$有$a_i = 0$</p>\n<p>$f(x)=a_0x^0+a_1x^1+a_2x^2…$<br>操作者可以进行四种操作：</p>\n<ul>\n<li><p><code>mul L R V</code>表示将 $x^L$ 到 $x^R$ 这些项的系数乘上某个定值$v$；</p>\n</li>\n<li><p><code>add L R V</code>表示将$x^L$ 到 $x^R $这些项的系数加上某个定值$v$；</p>\n</li>\n<li><p><code>mulx L R</code>表示将$x^L$ 到 $x^R$ 这些项乘上x变量；</p>\n</li>\n<li><p><code>query V</code>求$f(v)$的值。</p>\n</li>\n</ul>\n<p>操作集中在前三种，第四种操作不会出现超过$10$次。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3278\" target=\"_blank\" rel=\"noopener\">Luogu P3278</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>Splay大毒瘤题。</p>\n<p>前两个操作让我们想到线段树的模板，第三个操作如果从序列的角度来看就像是把一个序列向右移动，在把被冲掉的那一个位置加到原来的位数上去。</p>\n<p>显然啊！同志们，这是送分题啊！Splay套套套…</p>\n<hr>\n<ul>\n<li><p><code>add</code>操作：提取区间，打标记，维护信息。</p>\n</li>\n<li><p><code>mul</code>操作：提取区间，打标记，维护信息。</p>\n</li>\n<li><p><code>mulx</code>操作：呃…先找到rank为l-1,l,r,r+1,r+2的节点。删除掉r+1号节点，把其值加到r上去，然后在l-1和l之间插入一个值为0的节点，维护信息。</p>\n</li>\n</ul>\n<p>注意：push_down操作先传muln，再传addn。</p>\n<p>打标记几乎同线段树模板，就不说了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><!--�45-->"},{"title":"「SCOI2015」小凸玩密室-树形dp","urlname":"SCOI2015-room","date":"2018-06-08T08:08:09.000Z","visible":null,"_content":"\n小凸和小方相约玩密室逃脱，这个密室是一棵有$n$个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。\n\n每个灯泡有个权值$a_i$，每条边也有个权值$b_i$。点亮第$1$个灯泡不需要花费，之后每点亮$1$个新的灯泡$v$的花费，等于上一个被点亮的灯泡$u$到这个点$v$的距离$D_{u,v}$，乘以这个点的权值$a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡**必须连通**，在点亮一个灯泡后**必须先点亮其子树所有灯泡才能点亮其他灯泡**。\n\n请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n## 链接\n\n[BZOJ 4446](https://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n[Luogu 4253](https://www.luogu.org/problemnew/show/P4253)\n\n## 题解\n\n这个树形dp真是可以说神了`orz`...最近做到的神题真多...（萌萌哒，$LCA$，再加上这个...\n\n思考一下怎么表示状态。如果我们已经第一个点亮了一个点（假设其他点都未被点亮），那么我们必须先点亮这两个子树。由于必须联通而且必须只能点子树，下一步只能点亮两个儿子之一。而点亮的那个儿子的子树肯定要先被全部点亮，然后才能点亮另一个一个子树。\n\n如果我们忽略上一个点点在哪里的话，那么我们事实上发现上述的过程是一个无后效性的子结构，这个东西就可以设置成状态了。但这个事情的最关键的问题在于我们忽略了上一个点点在哪里，那我们怎样去表示这个$D_{u,v} \\times a_v$的过程呢？\n\n这个时候我们发现我们不知道上一个点点在哪里，但是我们可以知道下一个点点在哪里。如果我们发现我们点完了一个子树，我们现在只有两种情况：\n\n1. 我们所有目前点完的点构成了一颗更大的完整的子树，这个时候我们就只能去点这个更大的完整的子树的\n根节点的父节点。\n\n2. 我们现在所有点完的点不能构成一棵更大的完整的子树，这个时候我们就必须点完最近的没有点的一个子树。\n\n事实上只有两种情况，也就是到某个祖先，或者某个祖先的兄弟。\n\n所以我们用$dp[i][j][0]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的过程需要的最小花费，$dp[i][j][1]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的另一个儿子的过程需要的最小花费。注意到这是一个完全二叉树，所以保证了我们的状态的数目是$O(n \\log{n})$的。\n\n- - -\n\n转移方程太长，不写了，简单说一说如何转移。\n\n简单来说，需要分成三类讨论：没有儿子；只有一个儿子；有两个儿子。\n\n没有儿子的没啥好说的。有一个儿子的就相当于不变结束节点进入这个子树。有两个儿子的就有两种情况：先进左子树和先进右子树，分开讨论即可。状态转移是$O(1)$的。\n\n具体来说的话看代码注释。\n\n以上只是我们计算答案的一个辅助。\n\n- - -\n\n我们发现，如果选定一个点作为固定的起点，那么这个东西它点的顺序就是确定的。所以我们按照点灯规则确定子树的顺序，再加上子树之间转移的代价，就可以推出答案。这里需要对有没有兄弟节点进行分类讨论。由于树的高度是严格$O(\\log n)$的，所以我们的每个点的递推也是$O(\\log n)$的。\n\n时间复杂度与空间复杂度都是$O(n \\log n)$。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n#define ll long long\n\nconst int SIZE = 1024*1024;char ibuf[SIZE],*s,*t;\n\ninline char read(){\n    if(s==t) t=(s=ibuf)+fread(ibuf,1,SIZE,stdin);\n    return s==t?-1:*s++;\n}\n\ntemplate <typename T>\ninline void read(T &x){\n    static char c;bool iosig;\n    for(c=read(),iosig=0;!isdigit(c);c=read()){\n        if(c==-1) return;\n        iosig |= (c=='-');\n    }\n    for(x=0;isdigit(c);c=read())\n        x = (((x<<2)+x)<<1) + (c^48);\n    if(iosig) x = -x;\n}\n\nconst int MAXN = 210000,logn = 20;\n\nint n;\nll num[MAXN]; \nll dp[MAXN][logn][2];\n//点亮了i这个节点和子树的所有节点，下一个点亮到？级祖先的？儿子的最小代价 \nll dis[MAXN][logn];\n//从i节点向上j个节点的长度 \n\n#define p(i,j) (((1<<(j-1))<=i)?(i>>j):-1)\n//i的j祖先，上设虚拟0节点，其他均为-1\n//num[0] = 0,dis[1][1] = 0\n#define b(i,j) ((i>>(j-1))^1)\n//i的j祖先的另一个儿子\n#define lson (i<<1)\n#define rson ((i<<1)|1)\n\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    dis[1][1] = 0;\n    for(int i = 2;i<=n;i++){\n        read(dis[i][1]);\n        for(int j = 2;~p(i,j);j++)\n            dis[i][j] = dis[p(i,1)][j-1] + dis[i][1];\n    }\n}\n\nvoid solve(){\n    //0 祖先 1 兄弟 \n    for(int i = n;i >= 1;--i){\n        for(int j = 1;~p(i,j);j++){\n            dp[i][j][0] = dp[i][j][1] = 0x3f3f3f3f3f3f3f3f;\n            if((i<<1) > n){//一个儿子都没有 \n                dp[i][j][0] = dis[i][j] * num[p(i,j)];\n                dp[i][j][1] = (dis[i][j] + dis[b(i,j)][1]) * num[b(i,j)];\n            }\n            else if(((i<<1)|1) > n){//只有左儿子 \n            \t//注意要加上从根节点到儿子的代价\n                dp[i][j][0] = dp[lson][j+1][0] + dis[lson][1] * num[lson];\n                dp[i][j][1] = dp[lson][j+1][1] + dis[lson][1] * num[lson];\n            }\n            else{//有两个儿子\n            \t//两种转移方式，左->右 or 右->左 ，注意要加上从根节点到儿子的代价\n                dp[i][j][0] = min(dp[i][j][0],dp[lson][1][1]+dp[rson][j+1][0] + dis[lson][1] * num[lson]);\n                dp[i][j][0] = min(dp[i][j][0],dp[rson][1][1]+dp[lson][j+1][0] + dis[rson][1] * num[rson]);\n                dp[i][j][1] = min(dp[i][j][1],dp[lson][1][1]+dp[rson][j+1][1] + dis[lson][1] * num[lson]);\n                dp[i][j][1] = min(dp[i][j][1],dp[rson][1][1]+dp[lson][j+1][1] + dis[rson][1] * num[rson]);\n            }\n        }\n    }\n    //计算答案\n    ll ans = 0x3f3f3f3f3f3f3f3f;\n    for(int s = 1;s<=n;s++){\n    \t//从s点开始，先点亮所有s子树的节点和s的父亲\n        ll tmp = dp[s][1][0];\n        for(int i = p(s,1),last = s;~i;i = p(i,1),last = p(last,1)){\n            //last节点的子树即i节点已经被点亮，现在要点亮i的父亲节点\n            //有兄弟，就需要去先点亮兄弟，再点亮i的父亲（last兄弟的祖父）节点\n            if(b(last,1) <= n)\n            \ttmp += dis[b(last,1)][1] * num[b(last,1)] + dp[b(last,1)][2][0];\n            else\n                tmp +=  dis[i][1] * num[p(i,1)];\n        \t//加上从i到i的父亲节点的代价\n        }\n        ans = min(ans,tmp);\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SCOI2015」小凸玩密室-树形dp.md","raw":"---\ntitle: 「SCOI2015」小凸玩密室-树形dp\nurlname: SCOI2015-room\ndate: 2018-06-08 16:08:09\ntags:\n- 动态规划\n- 题解\n- 树形结构\ncategories: OI\nvisible:\n---\n\n小凸和小方相约玩密室逃脱，这个密室是一棵有$n$个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。\n\n每个灯泡有个权值$a_i$，每条边也有个权值$b_i$。点亮第$1$个灯泡不需要花费，之后每点亮$1$个新的灯泡$v$的花费，等于上一个被点亮的灯泡$u$到这个点$v$的距离$D_{u,v}$，乘以这个点的权值$a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡**必须连通**，在点亮一个灯泡后**必须先点亮其子树所有灯泡才能点亮其他灯泡**。\n\n请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n## 链接\n\n[BZOJ 4446](https://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n[Luogu 4253](https://www.luogu.org/problemnew/show/P4253)\n\n## 题解\n\n这个树形dp真是可以说神了`orz`...最近做到的神题真多...（萌萌哒，$LCA$，再加上这个...\n\n思考一下怎么表示状态。如果我们已经第一个点亮了一个点（假设其他点都未被点亮），那么我们必须先点亮这两个子树。由于必须联通而且必须只能点子树，下一步只能点亮两个儿子之一。而点亮的那个儿子的子树肯定要先被全部点亮，然后才能点亮另一个一个子树。\n\n如果我们忽略上一个点点在哪里的话，那么我们事实上发现上述的过程是一个无后效性的子结构，这个东西就可以设置成状态了。但这个事情的最关键的问题在于我们忽略了上一个点点在哪里，那我们怎样去表示这个$D_{u,v} \\times a_v$的过程呢？\n\n这个时候我们发现我们不知道上一个点点在哪里，但是我们可以知道下一个点点在哪里。如果我们发现我们点完了一个子树，我们现在只有两种情况：\n\n1. 我们所有目前点完的点构成了一颗更大的完整的子树，这个时候我们就只能去点这个更大的完整的子树的\n根节点的父节点。\n\n2. 我们现在所有点完的点不能构成一棵更大的完整的子树，这个时候我们就必须点完最近的没有点的一个子树。\n\n事实上只有两种情况，也就是到某个祖先，或者某个祖先的兄弟。\n\n所以我们用$dp[i][j][0]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的过程需要的最小花费，$dp[i][j][1]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的另一个儿子的过程需要的最小花费。注意到这是一个完全二叉树，所以保证了我们的状态的数目是$O(n \\log{n})$的。\n\n- - -\n\n转移方程太长，不写了，简单说一说如何转移。\n\n简单来说，需要分成三类讨论：没有儿子；只有一个儿子；有两个儿子。\n\n没有儿子的没啥好说的。有一个儿子的就相当于不变结束节点进入这个子树。有两个儿子的就有两种情况：先进左子树和先进右子树，分开讨论即可。状态转移是$O(1)$的。\n\n具体来说的话看代码注释。\n\n以上只是我们计算答案的一个辅助。\n\n- - -\n\n我们发现，如果选定一个点作为固定的起点，那么这个东西它点的顺序就是确定的。所以我们按照点灯规则确定子树的顺序，再加上子树之间转移的代价，就可以推出答案。这里需要对有没有兄弟节点进行分类讨论。由于树的高度是严格$O(\\log n)$的，所以我们的每个点的递推也是$O(\\log n)$的。\n\n时间复杂度与空间复杂度都是$O(n \\log n)$。\n\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n#define ll long long\n\nconst int SIZE = 1024*1024;char ibuf[SIZE],*s,*t;\n\ninline char read(){\n    if(s==t) t=(s=ibuf)+fread(ibuf,1,SIZE,stdin);\n    return s==t?-1:*s++;\n}\n\ntemplate <typename T>\ninline void read(T &x){\n    static char c;bool iosig;\n    for(c=read(),iosig=0;!isdigit(c);c=read()){\n        if(c==-1) return;\n        iosig |= (c=='-');\n    }\n    for(x=0;isdigit(c);c=read())\n        x = (((x<<2)+x)<<1) + (c^48);\n    if(iosig) x = -x;\n}\n\nconst int MAXN = 210000,logn = 20;\n\nint n;\nll num[MAXN]; \nll dp[MAXN][logn][2];\n//点亮了i这个节点和子树的所有节点，下一个点亮到？级祖先的？儿子的最小代价 \nll dis[MAXN][logn];\n//从i节点向上j个节点的长度 \n\n#define p(i,j) (((1<<(j-1))<=i)?(i>>j):-1)\n//i的j祖先，上设虚拟0节点，其他均为-1\n//num[0] = 0,dis[1][1] = 0\n#define b(i,j) ((i>>(j-1))^1)\n//i的j祖先的另一个儿子\n#define lson (i<<1)\n#define rson ((i<<1)|1)\n\nvoid init(){\n    read(n);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    dis[1][1] = 0;\n    for(int i = 2;i<=n;i++){\n        read(dis[i][1]);\n        for(int j = 2;~p(i,j);j++)\n            dis[i][j] = dis[p(i,1)][j-1] + dis[i][1];\n    }\n}\n\nvoid solve(){\n    //0 祖先 1 兄弟 \n    for(int i = n;i >= 1;--i){\n        for(int j = 1;~p(i,j);j++){\n            dp[i][j][0] = dp[i][j][1] = 0x3f3f3f3f3f3f3f3f;\n            if((i<<1) > n){//一个儿子都没有 \n                dp[i][j][0] = dis[i][j] * num[p(i,j)];\n                dp[i][j][1] = (dis[i][j] + dis[b(i,j)][1]) * num[b(i,j)];\n            }\n            else if(((i<<1)|1) > n){//只有左儿子 \n            \t//注意要加上从根节点到儿子的代价\n                dp[i][j][0] = dp[lson][j+1][0] + dis[lson][1] * num[lson];\n                dp[i][j][1] = dp[lson][j+1][1] + dis[lson][1] * num[lson];\n            }\n            else{//有两个儿子\n            \t//两种转移方式，左->右 or 右->左 ，注意要加上从根节点到儿子的代价\n                dp[i][j][0] = min(dp[i][j][0],dp[lson][1][1]+dp[rson][j+1][0] + dis[lson][1] * num[lson]);\n                dp[i][j][0] = min(dp[i][j][0],dp[rson][1][1]+dp[lson][j+1][0] + dis[rson][1] * num[rson]);\n                dp[i][j][1] = min(dp[i][j][1],dp[lson][1][1]+dp[rson][j+1][1] + dis[lson][1] * num[lson]);\n                dp[i][j][1] = min(dp[i][j][1],dp[rson][1][1]+dp[lson][j+1][1] + dis[rson][1] * num[rson]);\n            }\n        }\n    }\n    //计算答案\n    ll ans = 0x3f3f3f3f3f3f3f3f;\n    for(int s = 1;s<=n;s++){\n    \t//从s点开始，先点亮所有s子树的节点和s的父亲\n        ll tmp = dp[s][1][0];\n        for(int i = p(s,1),last = s;~i;i = p(i,1),last = p(last,1)){\n            //last节点的子树即i节点已经被点亮，现在要点亮i的父亲节点\n            //有兄弟，就需要去先点亮兄弟，再点亮i的父亲（last兄弟的祖父）节点\n            if(b(last,1) <= n)\n            \ttmp += dis[b(last,1)][1] * num[b(last,1)] + dp[b(last,1)][2][0];\n            else\n                tmp +=  dis[i][1] * num[p(i,1)];\n        \t//加上从i到i的父亲节点的代价\n        }\n        ans = min(ans,tmp);\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SCOI2015」小凸玩密室-树形dp","published":1,"updated":"2018-06-08T11:11:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3jz0044bljrg8vs03ho","content":"<p>小凸和小方相约玩密室逃脱，这个密室是一棵有$n$个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。</p>\n<p>每个灯泡有个权值$a_i$，每条边也有个权值$b_i$。点亮第$1$个灯泡不需要花费，之后每点亮$1$个新的灯泡$v$的花费，等于上一个被点亮的灯泡$u$到这个点$v$的距离$D_{u,v}$，乘以这个点的权值$a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡<strong>必须连通</strong>，在点亮一个灯泡后<strong>必须先点亮其子树所有灯泡才能点亮其他灯泡</strong>。</p>\n<p>请告诉他们，逃出密室的最少花费是多少。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=4446\" target=\"_blank\" rel=\"noopener\">BZOJ 4446</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P4253\" target=\"_blank\" rel=\"noopener\">Luogu 4253</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这个树形dp真是可以说神了<code>orz</code>…最近做到的神题真多…（萌萌哒，$LCA$，再加上这个…</p>\n<p>思考一下怎么表示状态。如果我们已经第一个点亮了一个点（假设其他点都未被点亮），那么我们必须先点亮这两个子树。由于必须联通而且必须只能点子树，下一步只能点亮两个儿子之一。而点亮的那个儿子的子树肯定要先被全部点亮，然后才能点亮另一个一个子树。</p>\n<p>如果我们忽略上一个点点在哪里的话，那么我们事实上发现上述的过程是一个无后效性的子结构，这个东西就可以设置成状态了。但这个事情的最关键的问题在于我们忽略了上一个点点在哪里，那我们怎样去表示这个$D_{u,v} \\times a_v$的过程呢？</p>\n<p>这个时候我们发现我们不知道上一个点点在哪里，但是我们可以知道下一个点点在哪里。如果我们发现我们点完了一个子树，我们现在只有两种情况：</p>\n<ol>\n<li><p>我们所有目前点完的点构成了一颗更大的完整的子树，这个时候我们就只能去点这个更大的完整的子树的<br>根节点的父节点。</p>\n</li>\n<li><p>我们现在所有点完的点不能构成一棵更大的完整的子树，这个时候我们就必须点完最近的没有点的一个子树。</p>\n</li>\n</ol>\n<p>事实上只有两种情况，也就是到某个祖先，或者某个祖先的兄弟。</p>\n<p>所以我们用$dp[i][j][0]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的过程需要的最小花费，$dp[i][j][1]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的另一个儿子的过程需要的最小花费。注意到这是一个完全二叉树，所以保证了我们的状态的数目是$O(n \\log{n})$的。</p>\n<hr>\n<p>转移方程太长，不写了，简单说一说如何转移。</p>\n<p>简单来说，需要分成三类讨论：没有儿子；只有一个儿子；有两个儿子。</p>\n<p>没有儿子的没啥好说的。有一个儿子的就相当于不变结束节点进入这个子树。有两个儿子的就有两种情况：先进左子树和先进右子树，分开讨论即可。状态转移是$O(1)$的。</p>\n<p>具体来说的话看代码注释。</p>\n<p>以上只是我们计算答案的一个辅助。</p>\n<hr>\n<p>我们发现，如果选定一个点作为固定的起点，那么这个东西它点的顺序就是确定的。所以我们按照点灯规则确定子树的顺序，再加上子树之间转移的代价，就可以推出答案。这里需要对有没有兄弟节点进行分类讨论。由于树的高度是严格$O(\\log n)$的，所以我们的每个点的递推也是$O(\\log n)$的。</p>\n<p>时间复杂度与空间复杂度都是$O(n \\log n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">1024</span>*<span class=\"number\">1024</span>;<span class=\"keyword\">char</span> ibuf[SIZE],*s,*t;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s==t) t=(s=ibuf)+fread(ibuf,<span class=\"number\">1</span>,SIZE,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s==t?<span class=\"number\">-1</span>:*s++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(T &amp;x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;<span class=\"keyword\">bool</span> iosig;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(c=read(),iosig=<span class=\"number\">0</span>;!<span class=\"built_in\">isdigit</span>(c);c=read())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        iosig |= (c==<span class=\"string\">'-'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;<span class=\"built_in\">isdigit</span>(c);c=read())</span><br><span class=\"line\">        x = (((x&lt;&lt;<span class=\"number\">2</span>)+x)&lt;&lt;<span class=\"number\">1</span>) + (c^<span class=\"number\">48</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iosig) x = -x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">210000</span>,logn = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\">ll num[MAXN]; </span><br><span class=\"line\">ll dp[MAXN][logn][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"comment\">//点亮了i这个节点和子树的所有节点，下一个点亮到？级祖先的？儿子的最小代价 </span></span><br><span class=\"line\">ll dis[MAXN][logn];</span><br><span class=\"line\"><span class=\"comment\">//从i节点向上j个节点的长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> p(i,j) (((1<span class=\"meta-string\">&lt;&lt;(j-1))&lt;=i)?(i&gt;&gt;j):-1)</span></span></span><br><span class=\"line\"><span class=\"comment\">//i的j祖先，上设虚拟0节点，其他均为-1</span></span><br><span class=\"line\"><span class=\"comment\">//num[0] = 0,dis[1][1] = 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> b(i,j) ((i&gt;&gt;(j-1))^1)</span></span><br><span class=\"line\"><span class=\"comment\">//i的j祖先的另一个儿子</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson (i&lt;&lt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson ((i&lt;&lt;1)|1)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">    dis[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(dis[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;~p(i,j);j++)</span><br><span class=\"line\">            dis[i][j] = dis[p(i,<span class=\"number\">1</span>)][j<span class=\"number\">-1</span>] + dis[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//0 祖先 1 兄弟 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n;i &gt;= <span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;~p(i,j);j++)&#123;</span><br><span class=\"line\">            dp[i][j][<span class=\"number\">0</span>] = dp[i][j][<span class=\"number\">1</span>] = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((i&lt;&lt;<span class=\"number\">1</span>) &gt; n)&#123;<span class=\"comment\">//一个儿子都没有 </span></span><br><span class=\"line\">                dp[i][j][<span class=\"number\">0</span>] = dis[i][j] * num[p(i,j)];</span><br><span class=\"line\">                dp[i][j][<span class=\"number\">1</span>] = (dis[i][j] + dis[b(i,j)][<span class=\"number\">1</span>]) * num[b(i,j)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(((i&lt;&lt;<span class=\"number\">1</span>)|<span class=\"number\">1</span>) &gt; n)&#123;<span class=\"comment\">//只有左儿子 </span></span><br><span class=\"line\">            \t<span class=\"comment\">//注意要加上从根节点到儿子的代价</span></span><br><span class=\"line\">                dp[i][j][<span class=\"number\">0</span>] = dp[lson][j+<span class=\"number\">1</span>][<span class=\"number\">0</span>] + dis[lson][<span class=\"number\">1</span>] * num[lson];</span><br><span class=\"line\">                dp[i][j][<span class=\"number\">1</span>] = dp[lson][j+<span class=\"number\">1</span>][<span class=\"number\">1</span>] + dis[lson][<span class=\"number\">1</span>] * num[lson];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;<span class=\"comment\">//有两个儿子</span></span><br><span class=\"line\">            \t<span class=\"comment\">//两种转移方式，左-&gt;右 or 右-&gt;左 ，注意要加上从根节点到儿子的代价</span></span><br><span class=\"line\">                dp[i][j][<span class=\"number\">0</span>] = min(dp[i][j][<span class=\"number\">0</span>],dp[lson][<span class=\"number\">1</span>][<span class=\"number\">1</span>]+dp[rson][j+<span class=\"number\">1</span>][<span class=\"number\">0</span>] + dis[lson][<span class=\"number\">1</span>] * num[lson]);</span><br><span class=\"line\">                dp[i][j][<span class=\"number\">0</span>] = min(dp[i][j][<span class=\"number\">0</span>],dp[rson][<span class=\"number\">1</span>][<span class=\"number\">1</span>]+dp[lson][j+<span class=\"number\">1</span>][<span class=\"number\">0</span>] + dis[rson][<span class=\"number\">1</span>] * num[rson]);</span><br><span class=\"line\">                dp[i][j][<span class=\"number\">1</span>] = min(dp[i][j][<span class=\"number\">1</span>],dp[lson][<span class=\"number\">1</span>][<span class=\"number\">1</span>]+dp[rson][j+<span class=\"number\">1</span>][<span class=\"number\">1</span>] + dis[lson][<span class=\"number\">1</span>] * num[lson]);</span><br><span class=\"line\">                dp[i][j][<span class=\"number\">1</span>] = min(dp[i][j][<span class=\"number\">1</span>],dp[rson][<span class=\"number\">1</span>][<span class=\"number\">1</span>]+dp[lson][j+<span class=\"number\">1</span>][<span class=\"number\">1</span>] + dis[rson][<span class=\"number\">1</span>] * num[rson]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//计算答案</span></span><br><span class=\"line\">    ll ans = <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> s = <span class=\"number\">1</span>;s&lt;=n;s++)&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//从s点开始，先点亮所有s子树的节点和s的父亲</span></span><br><span class=\"line\">        ll tmp = dp[s][<span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = p(s,<span class=\"number\">1</span>),last = s;~i;i = p(i,<span class=\"number\">1</span>),last = p(last,<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//last节点的子树即i节点已经被点亮，现在要点亮i的父亲节点</span></span><br><span class=\"line\">            <span class=\"comment\">//有兄弟，就需要去先点亮兄弟，再点亮i的父亲（last兄弟的祖父）节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b(last,<span class=\"number\">1</span>) &lt;= n)</span><br><span class=\"line\">            \ttmp += dis[b(last,<span class=\"number\">1</span>)][<span class=\"number\">1</span>] * num[b(last,<span class=\"number\">1</span>)] + dp[b(last,<span class=\"number\">1</span>)][<span class=\"number\">2</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                tmp +=  dis[i][<span class=\"number\">1</span>] * num[p(i,<span class=\"number\">1</span>)];</span><br><span class=\"line\">        \t<span class=\"comment\">//加上从i到i的父亲节点的代价</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = min(ans,tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>小凸和小方相约玩密室逃脱，这个密室是一棵有$n$个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。</p>\n<p>每个灯泡有个权值$a_i$，每条边也有个权值$b_i$。点亮第$1$个灯泡不需要花费，之后每点亮$1$个新的灯泡$v$的花费，等于上一个被点亮的灯泡$u$到这个点$v$的距离$D_{u,v}$，乘以这个点的权值$a_v$。在点灯的过程中，要保证任意时刻所有被点亮的灯泡<strong>必须连通</strong>，在点亮一个灯泡后<strong>必须先点亮其子树所有灯泡才能点亮其他灯泡</strong>。</p>\n<p>请告诉他们，逃出密室的最少花费是多少。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=4446\" target=\"_blank\" rel=\"noopener\">BZOJ 4446</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P4253\" target=\"_blank\" rel=\"noopener\">Luogu 4253</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这个树形dp真是可以说神了<code>orz</code>…最近做到的神题真多…（萌萌哒，$LCA$，再加上这个…</p>\n<p>思考一下怎么表示状态。如果我们已经第一个点亮了一个点（假设其他点都未被点亮），那么我们必须先点亮这两个子树。由于必须联通而且必须只能点子树，下一步只能点亮两个儿子之一。而点亮的那个儿子的子树肯定要先被全部点亮，然后才能点亮另一个一个子树。</p>\n<p>如果我们忽略上一个点点在哪里的话，那么我们事实上发现上述的过程是一个无后效性的子结构，这个东西就可以设置成状态了。但这个事情的最关键的问题在于我们忽略了上一个点点在哪里，那我们怎样去表示这个$D_{u,v} \\times a_v$的过程呢？</p>\n<p>这个时候我们发现我们不知道上一个点点在哪里，但是我们可以知道下一个点点在哪里。如果我们发现我们点完了一个子树，我们现在只有两种情况：</p>\n<ol>\n<li><p>我们所有目前点完的点构成了一颗更大的完整的子树，这个时候我们就只能去点这个更大的完整的子树的<br>根节点的父节点。</p>\n</li>\n<li><p>我们现在所有点完的点不能构成一棵更大的完整的子树，这个时候我们就必须点完最近的没有点的一个子树。</p>\n</li>\n</ol>\n<p>事实上只有两种情况，也就是到某个祖先，或者某个祖先的兄弟。</p>\n<p>所以我们用$dp[i][j][0]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的过程需要的最小花费，$dp[i][j][1]$表示点完以第$i$个点为根节点的子树之后，再去点其第$j$个祖先的另一个儿子的过程需要的最小花费。注意到这是一个完全二叉树，所以保证了我们的状态的数目是$O(n \\log{n})$的。</p>\n<hr>\n<p>转移方程太长，不写了，简单说一说如何转移。</p>\n<p>简单来说，需要分成三类讨论：没有儿子；只有一个儿子；有两个儿子。</p>\n<p>没有儿子的没啥好说的。有一个儿子的就相当于不变结束节点进入这个子树。有两个儿子的就有两种情况：先进左子树和先进右子树，分开讨论即可。状态转移是$O(1)$的。</p>\n<p>具体来说的话看代码注释。</p>\n<p>以上只是我们计算答案的一个辅助。</p>\n<hr>\n<p>我们发现，如果选定一个点作为固定的起点，那么这个东西它点的顺序就是确定的。所以我们按照点灯规则确定子树的顺序，再加上子树之间转移的代价，就可以推出答案。这里需要对有没有兄弟节点进行分类讨论。由于树的高度是严格$O(\\log n)$的，所以我们的每个点的递推也是$O(\\log n)$的。</p>\n<p>时间复杂度与空间复杂度都是$O(n \\log n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�46-->\n\n</div></div>"},{"title":"「SDOI2008」洞穴勘测-LCT","urlname":"SDOI2008-cave","date":"2018-05-12T10:06:09.000Z","visible":null,"_content":"\n辉辉热衷于洞穴勘测。\n\n辉辉有一台监测仪器可以实时将通道的每一次改变状况，并在辉辉手边的终端机上显示：\n\n`Connect u v`代表监测到洞穴u和洞穴v之间出现了一条通道，`Destroy u v`代表监测到洞穴u和洞穴v之间的通道被毁。`Query u v`，代表向监测仪询问此时洞穴u和洞穴v是否连通。\n\n保证无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。\n\n已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2147](https://www.luogu.org/problemnew/show/P2147)\n\n[BZOJ2049](https://www.lydsy.com/JudgeOnline/problem.php?id=2049)\n\n## 题解\n\n利用动态树维护森林的连通性。\n\n每次寻找在对应原树中的根，一样就联通，否则不连通。不加更多解释。\n\n注意判断一下加边和切边的合法性判断。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 20000;\n\nstruct Link_Cat_Tree{\n    int f[MAXN],c[MAXN][2];\n    bool rev[MAXN];\n    inline bool noroot(int x){\n        return (c[f[x]][0] == x) || (c[f[x]][1] == x);\n    }\n    inline void reverse(int x){\n        if(!x)  return;\n        swap(c[x][0],c[x][1]);\n        rev[x] ^= 1;\n    }\n    inline void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]),reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    inline void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1] == y] = x;\n        c[y][t] = w,c[x][1-t] = y;  \n        if(w) f[w] = y;\n        f[y] = x,f[x] = z;\n    }\n    inline void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y)){\n                if((c[z][1] == y) ^ (c[y][1] == x))\n                    rotate(x);\n                else rotate(y);\n            }rotate(x);\n        }\n    }\n    inline void access(int x){\n        for(int y = 0;x;x = f[y=x])\n            splay(x),c[x][1] = y;\n    }\n    inline void makeroot(int x){\n        access(x);splay(x);reverse(x);\n    }\n    inline int find(int x){\n        access(x),splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    inline void link(int x,int y){\n        makeroot(x);\n        if(find(y)!=x)\n            f[x] = y;\n    }\n    inline void cat(int x,int y){\n        makeroot(x);\n        if(find(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0;\n    }\n    inline int query(int x,int y){\n        return int(find(x) == find(y));\n    }\n};\n\nLink_Cat_Tree S;\n\nint n,m;\n\nchar yes[6] = \"Yes\\n\",no[5] = \"No\\n\";\n\nvoid solve(){\n    read(n),read(m);\n    char op[20];int a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);read(a),read(b);\n        if(op[0] == 'C')\n            S.link(a,b);\n        if(op[0] == 'D')\n            S.cat(a,b);\n        else if(op[0] == 'Q')\n            print(S.query(a,b) ? yes:no);\n    }\n}\n\nint main(){\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SDOI2008」洞穴勘测-LCT.md","raw":"---\ntitle: 「SDOI2008」洞穴勘测-LCT\nurlname: SDOI2008-cave\ndate: 2018-05-12 18:06:09\ntags:\n- 题解\n- 数据结构\n- 动态树\n- Link Cut Tree(LCT)\ncategories: OI\nvisible:\n---\n\n辉辉热衷于洞穴勘测。\n\n辉辉有一台监测仪器可以实时将通道的每一次改变状况，并在辉辉手边的终端机上显示：\n\n`Connect u v`代表监测到洞穴u和洞穴v之间出现了一条通道，`Destroy u v`代表监测到洞穴u和洞穴v之间的通道被毁。`Query u v`，代表向监测仪询问此时洞穴u和洞穴v是否连通。\n\n保证无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。\n\n已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2147](https://www.luogu.org/problemnew/show/P2147)\n\n[BZOJ2049](https://www.lydsy.com/JudgeOnline/problem.php?id=2049)\n\n## 题解\n\n利用动态树维护森林的连通性。\n\n每次寻找在对应原树中的根，一样就联通，否则不连通。不加更多解释。\n\n注意判断一下加边和切边的合法性判断。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 20000;\n\nstruct Link_Cat_Tree{\n    int f[MAXN],c[MAXN][2];\n    bool rev[MAXN];\n    inline bool noroot(int x){\n        return (c[f[x]][0] == x) || (c[f[x]][1] == x);\n    }\n    inline void reverse(int x){\n        if(!x)  return;\n        swap(c[x][0],c[x][1]);\n        rev[x] ^= 1;\n    }\n    inline void push_down(int x){\n        if(!x) return;\n        if(rev[x]){\n            reverse(c[x][0]),reverse(c[x][1]);\n            rev[x] = 0;\n        }\n    }\n    void push_all(int x){\n        if(!x) return;\n        if(noroot(x)) push_all(f[x]);\n        push_down(x);\n    }\n    inline void rotate(int x){\n        int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t];\n        if(noroot(y)) c[z][c[z][1] == y] = x;\n        c[y][t] = w,c[x][1-t] = y;  \n        if(w) f[w] = y;\n        f[y] = x,f[x] = z;\n    }\n    inline void splay(int x){\n        push_all(x);\n        while(noroot(x)){\n            int y = f[x],z = f[y];\n            if(noroot(y)){\n                if((c[z][1] == y) ^ (c[y][1] == x))\n                    rotate(x);\n                else rotate(y);\n            }rotate(x);\n        }\n    }\n    inline void access(int x){\n        for(int y = 0;x;x = f[y=x])\n            splay(x),c[x][1] = y;\n    }\n    inline void makeroot(int x){\n        access(x);splay(x);reverse(x);\n    }\n    inline int find(int x){\n        access(x),splay(x);\n        push_down(x);\n        while(c[x][0])\n            x = c[x][0],push_down(x);\n        return x;\n    }\n    inline void link(int x,int y){\n        makeroot(x);\n        if(find(y)!=x)\n            f[x] = y;\n    }\n    inline void cat(int x,int y){\n        makeroot(x);\n        if(find(y) == x && f[x] == y && !c[x][1])\n            f[x] = c[y][0] = 0;\n    }\n    inline int query(int x,int y){\n        return int(find(x) == find(y));\n    }\n};\n\nLink_Cat_Tree S;\n\nint n,m;\n\nchar yes[6] = \"Yes\\n\",no[5] = \"No\\n\";\n\nvoid solve(){\n    read(n),read(m);\n    char op[20];int a,b;\n    for(int i = 1;i<=m;i++){\n        read(op);read(a),read(b);\n        if(op[0] == 'C')\n            S.link(a,b);\n        if(op[0] == 'D')\n            S.cat(a,b);\n        else if(op[0] == 'Q')\n            print(S.query(a,b) ? yes:no);\n    }\n}\n\nint main(){\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SDOI2008」洞穴勘测-LCT","published":1,"updated":"2018-05-12T10:14:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3k00046bljr0gwtfq9k","content":"<p>辉辉热衷于洞穴勘测。</p>\n<p>辉辉有一台监测仪器可以实时将通道的每一次改变状况，并在辉辉手边的终端机上显示：</p>\n<p><code>Connect u v</code>代表监测到洞穴u和洞穴v之间出现了一条通道，<code>Destroy u v</code>代表监测到洞穴u和洞穴v之间的通道被毁。<code>Query u v</code>，代表向监测仪询问此时洞穴u和洞穴v是否连通。</p>\n<p>保证无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。</p>\n<p>已知在第一条指令显示之前，洞穴群中没有任何通道存在。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2147\" target=\"_blank\" rel=\"noopener\">Luogu P2147</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2049\" target=\"_blank\" rel=\"noopener\">BZOJ2049</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>利用动态树维护森林的连通性。</p>\n<p>每次寻找在对应原树中的根，一样就联通，否则不连通。不加更多解释。</p>\n<p>注意判断一下加边和切边的合法性判断。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">20000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Link_Cat_Tree</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[MAXN],c[MAXN][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">noroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (c[f[x]][<span class=\"number\">0</span>] == x) || (c[f[x]][<span class=\"number\">1</span>] == x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x)  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(c[x][<span class=\"number\">0</span>],c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        rev[x] ^= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev[x])&#123;</span><br><span class=\"line\">            reverse(c[x][<span class=\"number\">0</span>]),reverse(c[x][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            rev[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_all</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(x)) push_all(f[x]);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> y = f[x],z = f[y],t = (c[y][<span class=\"number\">1</span>] == x),w = c[x][<span class=\"number\">1</span>-t];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(noroot(y)) c[z][c[z][<span class=\"number\">1</span>] == y] = x;</span><br><span class=\"line\">        c[y][t] = w,c[x][<span class=\"number\">1</span>-t] = y;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w) f[w] = y;</span><br><span class=\"line\">        f[y] = x,f[x] = z;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        push_all(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(noroot(x))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = f[x],z = f[y];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(noroot(y))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((c[z][<span class=\"number\">1</span>] == y) ^ (c[y][<span class=\"number\">1</span>] == x))</span><br><span class=\"line\">                    rotate(x);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> rotate(y);</span><br><span class=\"line\">            &#125;rotate(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>;x;x = f[y=x])</span><br><span class=\"line\">            splay(x),c[x][<span class=\"number\">1</span>] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">makeroot</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x);splay(x);reverse(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        access(x),splay(x);</span><br><span class=\"line\">        push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c[x][<span class=\"number\">0</span>])</span><br><span class=\"line\">            x = c[x][<span class=\"number\">0</span>],push_down(x);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(find(y)!=x)</span><br><span class=\"line\">            f[x] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">cat</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        makeroot(x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(find(y) == x &amp;&amp; f[x] == y &amp;&amp; !c[x][<span class=\"number\">1</span>])</span><br><span class=\"line\">            f[x] = c[y][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(find(x) == find(y));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Link_Cat_Tree S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> yes[<span class=\"number\">6</span>] = <span class=\"string\">\"Yes\\n\"</span>,no[<span class=\"number\">5</span>] = <span class=\"string\">\"No\\n\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op);read(a),read(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)</span><br><span class=\"line\">            S.link(a,b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'D'</span>)</span><br><span class=\"line\">            S.cat(a,b);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">            print(S.query(a,b) ? yes:no);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>辉辉热衷于洞穴勘测。</p>\n<p>辉辉有一台监测仪器可以实时将通道的每一次改变状况，并在辉辉手边的终端机上显示：</p>\n<p><code>Connect u v</code>代表监测到洞穴u和洞穴v之间出现了一条通道，<code>Destroy u v</code>代表监测到洞穴u和洞穴v之间的通道被毁。<code>Query u v</code>，代表向监测仪询问此时洞穴u和洞穴v是否连通。</p>\n<p>保证无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。</p>\n<p>已知在第一条指令显示之前，洞穴群中没有任何通道存在。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2147\" target=\"_blank\" rel=\"noopener\">Luogu P2147</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2049\" target=\"_blank\" rel=\"noopener\">BZOJ2049</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>利用动态树维护森林的连通性。</p>\n<p>每次寻找在对应原树中的根，一样就联通，否则不连通。不加更多解释。</p>\n<p>注意判断一下加边和切边的合法性判断。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�47-->\n\n</div></div>"},{"title":"「SDOI2009」HH的项链-莫队or树状数组","urlname":"sdoi2009-necklace","date":"2018-02-05T10:11:47.000Z","visible":null,"_content":"\n给定一个长度为$n$的正整数序列$A$,有$m$次询问在$[l,r]$区间内有多少个不同的数。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1972](https://www.luogu.org/problemnew/show/P1972)\n\n## 题解\n\n这道题目前我只会两种离线的做法。{% spoiler （在线的主席树我还不会  %}\n\n### 做法一：莫队\n\n其实做这道题的时候我是不会莫队了。但现在会了，又想写篇莫队的笔记，所以我把这篇题解写出来了。\n\n莫队的核心思想在{% post_link 莫队算法学习笔记（一） 这篇文章 %}里面已经介绍，这道题又是非常像模版的一道题，也就不详细说了。\n\n首先对序列分块，以查询的左端点所在块的序号为第一关键字，右端点的位置为第二关键字排序，然后暴力转移。\n\n时间复杂度： $O((m+n) \\sqrt{n})$ 或者简单点： $O(n^\\frac{3}{2})$\n\n代码见最后。\n\n### 做法二：离散化+树状数组\n\n注意到，我们最重要的需要处理的就是重复的问题。如果不需要处理重复的问题，那么就可以直接用树状数组或者前缀和出解了。所以我们考虑到这样一个事情，能否使用某些~~玄学~~高端操作，使得我们不需要考虑重复的问题呢？\n\n可以发现，如果一个数已经出现，那么我们就不需要考虑这个数在其他位置上的出现。因此我们有如下的思路：\n\n把查询按照查询的右端点位置从小到大排序。为了发现某个数是否会在我们的查询的序列中出现，我们需要记录这个数最后一次在序列中出现的位置。如果查询区间的左端点在这个数的位置以左，那么查询区间内一定有这个数；而在这个数以右的话，查询区间里一定没有这个数。由于这个数出现多少次我们都只能算一次，所以这个最后出现的数就是我们判断是否含有这个数的依据。\n\n所以我们在树状数组中只给每个数最后出现的这一位赋值$1$,其余的由于上述，不能计入个数，值也就是$0$。这样操作就满足了区间可减性，然后直接树状数组前缀和相减就可以得到每次的结果。\n\n由于数字的范围较大，应该需要离散化。但由于这个跟时间复杂度关系不大，只与空间复杂度有关，所以我就没有这么写。\n\n时间复杂度：$O((m+n) \\log{n})$ 或者大体来说 $O(n \\log{n})$\n\n代码见下。\n\n## 代码\n\n这里提供两种方法的代码。\n\n莫队代码：\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Query{\n    int id,l,r;\n}query[201000];\n\nint times[1001000],res[201000],num[51000];\nint n,m,q;\n\nbool cmp(Query a,Query b){\n    if(a.l/q!=b.l/q)\n        return a.l/q<b.l/q;\n    else\n        return a.r<b.r;\n}\n\n\nint main(){\n    scanf(\"%d\",&n);\n    q = sqrt(n);//q是分块大小\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&num[i]);\n    scanf(\"%d\",&m);\n    for(int i = 0;i<m;i++){\n        scanf(\"%d %d\",&query[i].l,&query[i].r);\n        query[i].id = i;\n    }\n    sort(query,query+m,cmp);//排序\n    int l = 1,r = 1;\n    int ans = 1;times[num[1]]++;\n    for(int i = 0;i<m;i++){\n        int ql = query[i].l,qr = query[i].r;\n        //转移时先扩大再缩小\n        while(ql<l){\n            l--;\n            if(times[num[l]]++ == 0) ans++;\n        }\n        while(r<qr){\n            r++;\n            if(times[num[r]]++ == 0) ans++;\n        }\n        while(l<ql){\n            if(--times[num[l]] == 0) ans--;\n            l++;\n        }\n        while(qr<r){\n            if(--times[num[r]] == 0) ans--;\n            r--;\n        }\n        res[query[i].id] = ans;\n    }\n    for(int i = 0;i<m;i++)\n        printf(\"%d\\n\",res[i]);\n    return 0;\n}\n```\n\n{% endfold %}\n\n- - -\n\n离散化+树状数组代码：\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ninline int lowbit(int x){\n    return x&(-x);\n}\n\nint n,m,num[51000],ans[201000],last[1001000];\n\nint tree[201000];\n\nstruct que{\n    int id,l,r,res;\n}qq[1000000];\n\nbool cmp(que a,que b){\n    if(a.r!=b.r)\n        return a.r<b.r;\n    return a.l<b.l;\n}\n\ninline void insert(int nown,int val){\n    for(int i = nown;i<=n;i+=lowbit(i))\n        tree[i]+=val;\n}\n\ninline int query(int nown){\n    int res = 0;\n    for(int i = nown;i>0;i-=lowbit(i))\n        res += tree[i];\n    return res;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&num[i]);\n    scanf(\"%d\",&m);\n    for(int i = 0;i<m;i++){\n        scanf(\"%d %d\",&qq[i].l,&qq[i].r);\n        qq[i].id = i;\n    }\n    sort(qq,qq+m,cmp);\n    int end = 0;\n    for(int i = 0;i<m;i++){\n        while(end<qq[i].r){//更新last&树状数组\n            end++;\n            if(last[num[end]]!=0)//原来出现过就抹去last位置的数\n                insert(last[num[end]],-1);\n            insert(end,1);//树状数组加入新标记\n            last[num[end]] = end;//更新last值\n        }\n        ans[qq[i].id] = query(qq[i].r) - query(qq[i].l-1);\n    }\n    for(int i = 0;i<m;i++)\n        printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「SDOI2009」HH的项链-莫队or树状数组.md","raw":"---\ntitle: 「SDOI2009」HH的项链-莫队or树状数组\nurlname: sdoi2009-necklace\ndate: 2018-02-05 18:11:47\ntags:\n- 莫队\n- 树状数组\n- 题解\ncategories: OI\nvisible:\n---\n\n给定一个长度为$n$的正整数序列$A$,有$m$次询问在$[l,r]$区间内有多少个不同的数。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1972](https://www.luogu.org/problemnew/show/P1972)\n\n## 题解\n\n这道题目前我只会两种离线的做法。{% spoiler （在线的主席树我还不会  %}\n\n### 做法一：莫队\n\n其实做这道题的时候我是不会莫队了。但现在会了，又想写篇莫队的笔记，所以我把这篇题解写出来了。\n\n莫队的核心思想在{% post_link 莫队算法学习笔记（一） 这篇文章 %}里面已经介绍，这道题又是非常像模版的一道题，也就不详细说了。\n\n首先对序列分块，以查询的左端点所在块的序号为第一关键字，右端点的位置为第二关键字排序，然后暴力转移。\n\n时间复杂度： $O((m+n) \\sqrt{n})$ 或者简单点： $O(n^\\frac{3}{2})$\n\n代码见最后。\n\n### 做法二：离散化+树状数组\n\n注意到，我们最重要的需要处理的就是重复的问题。如果不需要处理重复的问题，那么就可以直接用树状数组或者前缀和出解了。所以我们考虑到这样一个事情，能否使用某些~~玄学~~高端操作，使得我们不需要考虑重复的问题呢？\n\n可以发现，如果一个数已经出现，那么我们就不需要考虑这个数在其他位置上的出现。因此我们有如下的思路：\n\n把查询按照查询的右端点位置从小到大排序。为了发现某个数是否会在我们的查询的序列中出现，我们需要记录这个数最后一次在序列中出现的位置。如果查询区间的左端点在这个数的位置以左，那么查询区间内一定有这个数；而在这个数以右的话，查询区间里一定没有这个数。由于这个数出现多少次我们都只能算一次，所以这个最后出现的数就是我们判断是否含有这个数的依据。\n\n所以我们在树状数组中只给每个数最后出现的这一位赋值$1$,其余的由于上述，不能计入个数，值也就是$0$。这样操作就满足了区间可减性，然后直接树状数组前缀和相减就可以得到每次的结果。\n\n由于数字的范围较大，应该需要离散化。但由于这个跟时间复杂度关系不大，只与空间复杂度有关，所以我就没有这么写。\n\n时间复杂度：$O((m+n) \\log{n})$ 或者大体来说 $O(n \\log{n})$\n\n代码见下。\n\n## 代码\n\n这里提供两种方法的代码。\n\n莫队代码：\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct Query{\n    int id,l,r;\n}query[201000];\n\nint times[1001000],res[201000],num[51000];\nint n,m,q;\n\nbool cmp(Query a,Query b){\n    if(a.l/q!=b.l/q)\n        return a.l/q<b.l/q;\n    else\n        return a.r<b.r;\n}\n\n\nint main(){\n    scanf(\"%d\",&n);\n    q = sqrt(n);//q是分块大小\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&num[i]);\n    scanf(\"%d\",&m);\n    for(int i = 0;i<m;i++){\n        scanf(\"%d %d\",&query[i].l,&query[i].r);\n        query[i].id = i;\n    }\n    sort(query,query+m,cmp);//排序\n    int l = 1,r = 1;\n    int ans = 1;times[num[1]]++;\n    for(int i = 0;i<m;i++){\n        int ql = query[i].l,qr = query[i].r;\n        //转移时先扩大再缩小\n        while(ql<l){\n            l--;\n            if(times[num[l]]++ == 0) ans++;\n        }\n        while(r<qr){\n            r++;\n            if(times[num[r]]++ == 0) ans++;\n        }\n        while(l<ql){\n            if(--times[num[l]] == 0) ans--;\n            l++;\n        }\n        while(qr<r){\n            if(--times[num[r]] == 0) ans--;\n            r--;\n        }\n        res[query[i].id] = ans;\n    }\n    for(int i = 0;i<m;i++)\n        printf(\"%d\\n\",res[i]);\n    return 0;\n}\n```\n\n{% endfold %}\n\n- - -\n\n离散化+树状数组代码：\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ninline int lowbit(int x){\n    return x&(-x);\n}\n\nint n,m,num[51000],ans[201000],last[1001000];\n\nint tree[201000];\n\nstruct que{\n    int id,l,r,res;\n}qq[1000000];\n\nbool cmp(que a,que b){\n    if(a.r!=b.r)\n        return a.r<b.r;\n    return a.l<b.l;\n}\n\ninline void insert(int nown,int val){\n    for(int i = nown;i<=n;i+=lowbit(i))\n        tree[i]+=val;\n}\n\ninline int query(int nown){\n    int res = 0;\n    for(int i = nown;i>0;i-=lowbit(i))\n        res += tree[i];\n    return res;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&num[i]);\n    scanf(\"%d\",&m);\n    for(int i = 0;i<m;i++){\n        scanf(\"%d %d\",&qq[i].l,&qq[i].r);\n        qq[i].id = i;\n    }\n    sort(qq,qq+m,cmp);\n    int end = 0;\n    for(int i = 0;i<m;i++){\n        while(end<qq[i].r){//更新last&树状数组\n            end++;\n            if(last[num[end]]!=0)//原来出现过就抹去last位置的数\n                insert(last[num[end]],-1);\n            insert(end,1);//树状数组加入新标记\n            last[num[end]] = end;//更新last值\n        }\n        ans[qq[i].id] = query(qq[i].r) - query(qq[i].l-1);\n    }\n    for(int i = 0;i<m;i++)\n        printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「SDOI2009」HH的项链-莫队or树状数组","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3k20049bljroj5wxwle","content":"<p>&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A;$n$&#x7684;&#x6B63;&#x6574;&#x6570;&#x5E8F;&#x5217;$A$,&#x6709;$m$&#x6B21;&#x8BE2;&#x95EE;&#x5728;$[l,r]$&#x533A;&#x95F4;&#x5185;&#x6709;&#x591A;&#x5C11;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x6570;&#x3002;</p>\n<a id=\"more\"></a>\n<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1972\" target=\"_blank\" rel=\"noopener\">Luogu P1972</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x76EE;&#x524D;&#x6211;&#x53EA;&#x4F1A;&#x4E24;&#x79CD;&#x79BB;&#x7EBF;&#x7684;&#x505A;&#x6CD5;&#x3002;<span class=\"spoiler\">&#xFF08;&#x5728;&#x7EBF;&#x7684;&#x4E3B;&#x5E2D;&#x6811;&#x6211;&#x8FD8;&#x4E0D;&#x4F1A;\n</span></p>\n<h3 id=\"&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\"><a href=\"#&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\" class=\"headerlink\" title=\"&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\"></a>&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;</h3><p>&#x5176;&#x5B9E;&#x505A;&#x8FD9;&#x9053;&#x9898;&#x7684;&#x65F6;&#x5019;&#x6211;&#x662F;&#x4E0D;&#x4F1A;&#x83AB;&#x961F;&#x4E86;&#x3002;&#x4F46;&#x73B0;&#x5728;&#x4F1A;&#x4E86;&#xFF0C;&#x53C8;&#x60F3;&#x5199;&#x7BC7;&#x83AB;&#x961F;&#x7684;&#x7B14;&#x8BB0;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x628A;&#x8FD9;&#x7BC7;&#x9898;&#x89E3;&#x5199;&#x51FA;&#x6765;&#x4E86;&#x3002;</p>\n<p>&#x83AB;&#x961F;&#x7684;&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x5728;<a href=\"/20180205-mo-algorithm-1/\" title=\"&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;\">&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;</a>&#x91CC;&#x9762;&#x5DF2;&#x7ECF;&#x4ECB;&#x7ECD;&#xFF0C;&#x8FD9;&#x9053;&#x9898;&#x53C8;&#x662F;&#x975E;&#x5E38;&#x50CF;&#x6A21;&#x7248;&#x7684;&#x4E00;&#x9053;&#x9898;&#xFF0C;&#x4E5F;&#x5C31;&#x4E0D;&#x8BE6;&#x7EC6;&#x8BF4;&#x4E86;&#x3002;</p>\n<p>&#x9996;&#x5148;&#x5BF9;&#x5E8F;&#x5217;&#x5206;&#x5757;&#xFF0C;&#x4EE5;&#x67E5;&#x8BE2;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x6240;&#x5728;&#x5757;&#x7684;&#x5E8F;&#x53F7;&#x4E3A;&#x7B2C;&#x4E00;&#x5173;&#x952E;&#x5B57;&#xFF0C;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x4E3A;&#x7B2C;&#x4E8C;&#x5173;&#x952E;&#x5B57;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x66B4;&#x529B;&#x8F6C;&#x79FB;&#x3002;</p>\n<p>&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#xFF1A; $O((m+n) \\sqrt{n})$ &#x6216;&#x8005;&#x7B80;&#x5355;&#x70B9;&#xFF1A; $O(n^\\frac{3}{2})$</p>\n<p>&#x4EE3;&#x7801;&#x89C1;&#x6700;&#x540E;&#x3002;</p>\n<h3 id=\"&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;-&#x6811;&#x72B6;&#x6570;&#x7EC4;\"><a href=\"#&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;-&#x6811;&#x72B6;&#x6570;&#x7EC4;\" class=\"headerlink\" title=\"&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;\"></a>&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;</h3><p>&#x6CE8;&#x610F;&#x5230;&#xFF0C;&#x6211;&#x4EEC;&#x6700;&#x91CD;&#x8981;&#x7684;&#x9700;&#x8981;&#x5904;&#x7406;&#x7684;&#x5C31;&#x662F;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x9700;&#x8981;&#x5904;&#x7406;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7528;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x6216;&#x8005;&#x524D;&#x7F00;&#x548C;&#x51FA;&#x89E3;&#x4E86;&#x3002;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x8003;&#x8651;&#x5230;&#x8FD9;&#x6837;&#x4E00;&#x4E2A;&#x4E8B;&#x60C5;&#xFF0C;&#x80FD;&#x5426;&#x4F7F;&#x7528;&#x67D0;&#x4E9B;<del>&#x7384;&#x5B66;</del>&#x9AD8;&#x7AEF;&#x64CD;&#x4F5C;&#xFF0C;&#x4F7F;&#x5F97;&#x6211;&#x4EEC;&#x4E0D;&#x9700;&#x8981;&#x8003;&#x8651;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#x5462;&#xFF1F;</p>\n<p>&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x6570;&#x5DF2;&#x7ECF;&#x51FA;&#x73B0;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x5C31;&#x4E0D;&#x9700;&#x8981;&#x8003;&#x8651;&#x8FD9;&#x4E2A;&#x6570;&#x5728;&#x5176;&#x4ED6;&#x4F4D;&#x7F6E;&#x4E0A;&#x7684;&#x51FA;&#x73B0;&#x3002;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x6709;&#x5982;&#x4E0B;&#x7684;&#x601D;&#x8DEF;&#xFF1A;</p>\n<p>&#x628A;&#x67E5;&#x8BE2;&#x6309;&#x7167;&#x67E5;&#x8BE2;&#x7684;&#x53F3;&#x7AEF;&#x70B9;&#x4F4D;&#x7F6E;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5E8F;&#x3002;&#x4E3A;&#x4E86;&#x53D1;&#x73B0;&#x67D0;&#x4E2A;&#x6570;&#x662F;&#x5426;&#x4F1A;&#x5728;&#x6211;&#x4EEC;&#x7684;&#x67E5;&#x8BE2;&#x7684;&#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BB0;&#x5F55;&#x8FD9;&#x4E2A;&#x6570;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x5728;&#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x4F4D;&#x7F6E;&#x3002;&#x5982;&#x679C;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x5728;&#x8FD9;&#x4E2A;&#x6570;&#x7684;&#x4F4D;&#x7F6E;&#x4EE5;&#x5DE6;&#xFF0C;&#x90A3;&#x4E48;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x5185;&#x4E00;&#x5B9A;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#xFF1B;&#x800C;&#x5728;&#x8FD9;&#x4E2A;&#x6570;&#x4EE5;&#x53F3;&#x7684;&#x8BDD;&#xFF0C;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x91CC;&#x4E00;&#x5B9A;&#x6CA1;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#x3002;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x6570;&#x51FA;&#x73B0;&#x591A;&#x5C11;&#x6B21;&#x6211;&#x4EEC;&#x90FD;&#x53EA;&#x80FD;&#x7B97;&#x4E00;&#x6B21;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6700;&#x540E;&#x51FA;&#x73B0;&#x7684;&#x6570;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x5224;&#x65AD;&#x662F;&#x5426;&#x542B;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#x7684;&#x4F9D;&#x636E;&#x3002;</p>\n<p>&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x5728;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x4E2D;&#x53EA;&#x7ED9;&#x6BCF;&#x4E2A;&#x6570;&#x6700;&#x540E;&#x51FA;&#x73B0;&#x7684;&#x8FD9;&#x4E00;&#x4F4D;&#x8D4B;&#x503C;$1$,&#x5176;&#x4F59;&#x7684;&#x7531;&#x4E8E;&#x4E0A;&#x8FF0;&#xFF0C;&#x4E0D;&#x80FD;&#x8BA1;&#x5165;&#x4E2A;&#x6570;&#xFF0C;&#x503C;&#x4E5F;&#x5C31;&#x662F;$0$&#x3002;&#x8FD9;&#x6837;&#x64CD;&#x4F5C;&#x5C31;&#x6EE1;&#x8DB3;&#x4E86;&#x533A;&#x95F4;&#x53EF;&#x51CF;&#x6027;&#xFF0C;&#x7136;&#x540E;&#x76F4;&#x63A5;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x524D;&#x7F00;&#x548C;&#x76F8;&#x51CF;&#x5C31;&#x53EF;&#x4EE5;&#x5F97;&#x5230;&#x6BCF;&#x6B21;&#x7684;&#x7ED3;&#x679C;&#x3002;</p>\n<p>&#x7531;&#x4E8E;&#x6570;&#x5B57;&#x7684;&#x8303;&#x56F4;&#x8F83;&#x5927;&#xFF0C;&#x5E94;&#x8BE5;&#x9700;&#x8981;&#x79BB;&#x6563;&#x5316;&#x3002;&#x4F46;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x8DDF;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x5173;&#x7CFB;&#x4E0D;&#x5927;&#xFF0C;&#x53EA;&#x4E0E;&#x7A7A;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x6709;&#x5173;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x5C31;&#x6CA1;&#x6709;&#x8FD9;&#x4E48;&#x5199;&#x3002;</p>\n<p>&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#xFF1A;$O((m+n) \\log{n})$ &#x6216;&#x8005;&#x5927;&#x4F53;&#x6765;&#x8BF4; $O(n \\log{n})$</p>\n<p>&#x4EE3;&#x7801;&#x89C1;&#x4E0B;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><p>&#x8FD9;&#x91CC;&#x63D0;&#x4F9B;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x7684;&#x4EE3;&#x7801;&#x3002;</p>\n<p>&#x83AB;&#x961F;&#x4EE3;&#x7801;&#xFF1A;</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Query</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id,l,r;</span><br><span class=\"line\">&#125;query[<span class=\"number\">201000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> times[<span class=\"number\">1001000</span>],res[<span class=\"number\">201000</span>],num[<span class=\"number\">51000</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Query a,Query b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.l/q!=b.l/q)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.l/q&lt;b.l/q;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.r&lt;b.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    q = <span class=\"built_in\">sqrt</span>(n);<span class=\"comment\">//q是分块大小</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;query[i].l,&amp;query[i].r);</span><br><span class=\"line\">        query[i].id = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(query,query+m,cmp);<span class=\"comment\">//排序</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,r = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">1</span>;times[num[<span class=\"number\">1</span>]]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ql = query[i].l,qr = query[i].r;</span><br><span class=\"line\">        <span class=\"comment\">//转移时先扩大再缩小</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ql&lt;l)&#123;</span><br><span class=\"line\">            l--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(times[num[l]]++ == <span class=\"number\">0</span>) ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r&lt;qr)&#123;</span><br><span class=\"line\">            r++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(times[num[r]]++ == <span class=\"number\">0</span>) ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;ql)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--times[num[l]] == <span class=\"number\">0</span>) ans--;</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(qr&lt;r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(--times[num[r]] == <span class=\"number\">0</span>) ans--;</span><br><span class=\"line\">            r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res[query[i].id] = ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,res[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<hr>\n<p>&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x4EE3;&#x7801;&#xFF1A;</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&amp;(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,num[<span class=\"number\">51000</span>],ans[<span class=\"number\">201000</span>],last[<span class=\"number\">1001000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tree[<span class=\"number\">201000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">que</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id,l,r,res;</span><br><span class=\"line\">&#125;qq[<span class=\"number\">1000000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(que a,que b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.r!=b.r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.r&lt;b.r;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.l&lt;b.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nown;i&lt;=n;i+=lowbit(i))</span><br><span class=\"line\">        tree[i]+=val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = nown;i&gt;<span class=\"number\">0</span>;i-=lowbit(i))</span><br><span class=\"line\">        res += tree[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;num[i]);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d\"</span>,&amp;qq[i].l,&amp;qq[i].r);</span><br><span class=\"line\">        qq[i].id = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(qq,qq+m,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(end&lt;qq[i].r)&#123;<span class=\"comment\">//更新last&amp;树状数组</span></span><br><span class=\"line\">            end++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(last[num[end]]!=<span class=\"number\">0</span>)<span class=\"comment\">//原来出现过就抹去last位置的数</span></span><br><span class=\"line\">                insert(last[num[end]],<span class=\"number\">-1</span>);</span><br><span class=\"line\">            insert(end,<span class=\"number\">1</span>);<span class=\"comment\">//树状数组加入新标记</span></span><br><span class=\"line\">            last[num[end]] = end;<span class=\"comment\">//更新last值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans[qq[i].id] = query(qq[i].r) - query(qq[i].l<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;&#x957F;&#x5EA6;&#x4E3A;$n$&#x7684;&#x6B63;&#x6574;&#x6570;&#x5E8F;&#x5217;$A$,&#x6709;$m$&#x6B21;&#x8BE2;&#x95EE;&#x5728;$[l,r]$&#x533A;&#x95F4;&#x5185;&#x6709;&#x591A;&#x5C11;&#x4E2A;&#x4E0D;&#x540C;&#x7684;&#x6570;&#x3002;</p>","more":"<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1972\" target=\"_blank\" rel=\"noopener\">Luogu P1972</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x76EE;&#x524D;&#x6211;&#x53EA;&#x4F1A;&#x4E24;&#x79CD;&#x79BB;&#x7EBF;&#x7684;&#x505A;&#x6CD5;&#x3002;<span class=\"spoiler\">&#xFF08;&#x5728;&#x7EBF;&#x7684;&#x4E3B;&#x5E2D;&#x6811;&#x6211;&#x8FD8;&#x4E0D;&#x4F1A;\n</span></p>\n<h3 id=\"&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\"><a href=\"#&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\" class=\"headerlink\" title=\"&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;\"></a>&#x505A;&#x6CD5;&#x4E00;&#xFF1A;&#x83AB;&#x961F;</h3><p>&#x5176;&#x5B9E;&#x505A;&#x8FD9;&#x9053;&#x9898;&#x7684;&#x65F6;&#x5019;&#x6211;&#x662F;&#x4E0D;&#x4F1A;&#x83AB;&#x961F;&#x4E86;&#x3002;&#x4F46;&#x73B0;&#x5728;&#x4F1A;&#x4E86;&#xFF0C;&#x53C8;&#x60F3;&#x5199;&#x7BC7;&#x83AB;&#x961F;&#x7684;&#x7B14;&#x8BB0;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x628A;&#x8FD9;&#x7BC7;&#x9898;&#x89E3;&#x5199;&#x51FA;&#x6765;&#x4E86;&#x3002;</p>\n<p>&#x83AB;&#x961F;&#x7684;&#x6838;&#x5FC3;&#x601D;&#x60F3;&#x5728;<a href=\"/20180205-mo-algorithm-1/\" title=\"&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;\">&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;</a>&#x91CC;&#x9762;&#x5DF2;&#x7ECF;&#x4ECB;&#x7ECD;&#xFF0C;&#x8FD9;&#x9053;&#x9898;&#x53C8;&#x662F;&#x975E;&#x5E38;&#x50CF;&#x6A21;&#x7248;&#x7684;&#x4E00;&#x9053;&#x9898;&#xFF0C;&#x4E5F;&#x5C31;&#x4E0D;&#x8BE6;&#x7EC6;&#x8BF4;&#x4E86;&#x3002;</p>\n<p>&#x9996;&#x5148;&#x5BF9;&#x5E8F;&#x5217;&#x5206;&#x5757;&#xFF0C;&#x4EE5;&#x67E5;&#x8BE2;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x6240;&#x5728;&#x5757;&#x7684;&#x5E8F;&#x53F7;&#x4E3A;&#x7B2C;&#x4E00;&#x5173;&#x952E;&#x5B57;&#xFF0C;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x4E3A;&#x7B2C;&#x4E8C;&#x5173;&#x952E;&#x5B57;&#x6392;&#x5E8F;&#xFF0C;&#x7136;&#x540E;&#x66B4;&#x529B;&#x8F6C;&#x79FB;&#x3002;</p>\n<p>&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#xFF1A; $O((m+n) \\sqrt{n})$ &#x6216;&#x8005;&#x7B80;&#x5355;&#x70B9;&#xFF1A; $O(n^\\frac{3}{2})$</p>\n<p>&#x4EE3;&#x7801;&#x89C1;&#x6700;&#x540E;&#x3002;</p>\n<h3 id=\"&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;-&#x6811;&#x72B6;&#x6570;&#x7EC4;\"><a href=\"#&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;-&#x6811;&#x72B6;&#x6570;&#x7EC4;\" class=\"headerlink\" title=\"&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;\"></a>&#x505A;&#x6CD5;&#x4E8C;&#xFF1A;&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;</h3><p>&#x6CE8;&#x610F;&#x5230;&#xFF0C;&#x6211;&#x4EEC;&#x6700;&#x91CD;&#x8981;&#x7684;&#x9700;&#x8981;&#x5904;&#x7406;&#x7684;&#x5C31;&#x662F;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x9700;&#x8981;&#x5904;&#x7406;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x90A3;&#x4E48;&#x5C31;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7528;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x6216;&#x8005;&#x524D;&#x7F00;&#x548C;&#x51FA;&#x89E3;&#x4E86;&#x3002;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x8003;&#x8651;&#x5230;&#x8FD9;&#x6837;&#x4E00;&#x4E2A;&#x4E8B;&#x60C5;&#xFF0C;&#x80FD;&#x5426;&#x4F7F;&#x7528;&#x67D0;&#x4E9B;<del>&#x7384;&#x5B66;</del>&#x9AD8;&#x7AEF;&#x64CD;&#x4F5C;&#xFF0C;&#x4F7F;&#x5F97;&#x6211;&#x4EEC;&#x4E0D;&#x9700;&#x8981;&#x8003;&#x8651;&#x91CD;&#x590D;&#x7684;&#x95EE;&#x9898;&#x5462;&#xFF1F;</p>\n<p>&#x53EF;&#x4EE5;&#x53D1;&#x73B0;&#xFF0C;&#x5982;&#x679C;&#x4E00;&#x4E2A;&#x6570;&#x5DF2;&#x7ECF;&#x51FA;&#x73B0;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x5C31;&#x4E0D;&#x9700;&#x8981;&#x8003;&#x8651;&#x8FD9;&#x4E2A;&#x6570;&#x5728;&#x5176;&#x4ED6;&#x4F4D;&#x7F6E;&#x4E0A;&#x7684;&#x51FA;&#x73B0;&#x3002;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x6709;&#x5982;&#x4E0B;&#x7684;&#x601D;&#x8DEF;&#xFF1A;</p>\n<p>&#x628A;&#x67E5;&#x8BE2;&#x6309;&#x7167;&#x67E5;&#x8BE2;&#x7684;&#x53F3;&#x7AEF;&#x70B9;&#x4F4D;&#x7F6E;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5E8F;&#x3002;&#x4E3A;&#x4E86;&#x53D1;&#x73B0;&#x67D0;&#x4E2A;&#x6570;&#x662F;&#x5426;&#x4F1A;&#x5728;&#x6211;&#x4EEC;&#x7684;&#x67E5;&#x8BE2;&#x7684;&#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8BB0;&#x5F55;&#x8FD9;&#x4E2A;&#x6570;&#x6700;&#x540E;&#x4E00;&#x6B21;&#x5728;&#x5E8F;&#x5217;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x4F4D;&#x7F6E;&#x3002;&#x5982;&#x679C;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x5728;&#x8FD9;&#x4E2A;&#x6570;&#x7684;&#x4F4D;&#x7F6E;&#x4EE5;&#x5DE6;&#xFF0C;&#x90A3;&#x4E48;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x5185;&#x4E00;&#x5B9A;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#xFF1B;&#x800C;&#x5728;&#x8FD9;&#x4E2A;&#x6570;&#x4EE5;&#x53F3;&#x7684;&#x8BDD;&#xFF0C;&#x67E5;&#x8BE2;&#x533A;&#x95F4;&#x91CC;&#x4E00;&#x5B9A;&#x6CA1;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#x3002;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x6570;&#x51FA;&#x73B0;&#x591A;&#x5C11;&#x6B21;&#x6211;&#x4EEC;&#x90FD;&#x53EA;&#x80FD;&#x7B97;&#x4E00;&#x6B21;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6700;&#x540E;&#x51FA;&#x73B0;&#x7684;&#x6570;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x5224;&#x65AD;&#x662F;&#x5426;&#x542B;&#x6709;&#x8FD9;&#x4E2A;&#x6570;&#x7684;&#x4F9D;&#x636E;&#x3002;</p>\n<p>&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x5728;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x4E2D;&#x53EA;&#x7ED9;&#x6BCF;&#x4E2A;&#x6570;&#x6700;&#x540E;&#x51FA;&#x73B0;&#x7684;&#x8FD9;&#x4E00;&#x4F4D;&#x8D4B;&#x503C;$1$,&#x5176;&#x4F59;&#x7684;&#x7531;&#x4E8E;&#x4E0A;&#x8FF0;&#xFF0C;&#x4E0D;&#x80FD;&#x8BA1;&#x5165;&#x4E2A;&#x6570;&#xFF0C;&#x503C;&#x4E5F;&#x5C31;&#x662F;$0$&#x3002;&#x8FD9;&#x6837;&#x64CD;&#x4F5C;&#x5C31;&#x6EE1;&#x8DB3;&#x4E86;&#x533A;&#x95F4;&#x53EF;&#x51CF;&#x6027;&#xFF0C;&#x7136;&#x540E;&#x76F4;&#x63A5;&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x524D;&#x7F00;&#x548C;&#x76F8;&#x51CF;&#x5C31;&#x53EF;&#x4EE5;&#x5F97;&#x5230;&#x6BCF;&#x6B21;&#x7684;&#x7ED3;&#x679C;&#x3002;</p>\n<p>&#x7531;&#x4E8E;&#x6570;&#x5B57;&#x7684;&#x8303;&#x56F4;&#x8F83;&#x5927;&#xFF0C;&#x5E94;&#x8BE5;&#x9700;&#x8981;&#x79BB;&#x6563;&#x5316;&#x3002;&#x4F46;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x8DDF;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x5173;&#x7CFB;&#x4E0D;&#x5927;&#xFF0C;&#x53EA;&#x4E0E;&#x7A7A;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x6709;&#x5173;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x5C31;&#x6CA1;&#x6709;&#x8FD9;&#x4E48;&#x5199;&#x3002;</p>\n<p>&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#xFF1A;$O((m+n) \\log{n})$ &#x6216;&#x8005;&#x5927;&#x4F53;&#x6765;&#x8BF4; $O(n \\log{n})$</p>\n<p>&#x4EE3;&#x7801;&#x89C1;&#x4E0B;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><p>&#x8FD9;&#x91CC;&#x63D0;&#x4F9B;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x7684;&#x4EE3;&#x7801;&#x3002;</p>\n<p>&#x83AB;&#x961F;&#x4EE3;&#x7801;&#xFF1A;</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�48-->\n\n</div></div>\n<hr>\n<p>&#x79BB;&#x6563;&#x5316;+&#x6811;&#x72B6;&#x6570;&#x7EC4;&#x4EE3;&#x7801;&#xFF1A;</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�49-->\n\n</div></div>"},{"title":"「SDOI2011」工作安排-费用流","urlname":"sdoi2011-arrange","date":"2018-04-06T12:00:38.000Z","visible":null,"_content":"\n你的公司需要提供$n$类产品，其中第$i$类产品共需要$C_{i}$件。公司共有$m$名员工。员工能够制造的产品种类有所区别，我们用一个由$0$和$1$组成的$m\\times n$的矩阵$\\mathbb {A}$来描述每名员工能够制造哪些产品。\n\n对于员工$i$，给出$S_i$。定义他的愤怒值与他制作的产品数量之间的函数是一个$S_i+1$段的分段函数。设$T_{i,0}=0$,$T_{i,S_{i+1}}=+\\infty$，那么当他制造第$[T_{i,j-1}+1,T_{i,j}]$件产品时，每件产品会使他的愤怒值增加$W_{i,j}$， $1\\leq j\\leq S_{i+1}$。保证$0<W_{i,j} < W_{i,j+1}, \\; 0 < T_{i,j} < T_{i,j+1}$。\n\n你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2488](https://www.luogu.org/problemnew/show/P2488)\n\n[BZOJ 2245](https://www.lydsy.com/JudgeOnline/problem.php?id=2245)\n\n## 题解\n\n一道费用流的题目。\n\n每个产品的数量可以用一条边来限制，主要需要满足的就是愤怒值分段函数式的结构。\n\n注意到每个人的愤怒值的分段函数与做了具体哪类产品无关，所以我们可以在人这边的边上动点手脚。我们可以拆边，按段来拆边，每段给一条边，通过容量来满足分段的要求。\n\n具体建图：\n\n令$1$至$m$为$m$个员工所代表的点，$m+1$至$m+n$为$n$类产品代表的点，$s$为源点，$t$为汇点。\n\n对于$A$矩阵，如果$A_{i,j}$是$1$，那么我们就连一条起点为$i$，终点为$m+j$，容量为$+\\infty$，费用为$0$的边。\n\n对于第$i$个商品种类，我们连一条起点为$m+i$，终点为$t$，容量为$C_{i}$，费用为$0$的边。\n\n对于第$i$个人，我们连$S_{i}+1$条边，起点均为$s$，终点均为$i$，令第$j$条边的容量为$S_{i,j}-S_{i,j-1}$，$j \\in [1,S_{i}+1]$，费用为$W_{i,j}$。\n\n跑最小费用最大流，得到的费用即为结果。\n\n注意需要开$long\\ long$...\n\n值得一提的是，由于我有一个$j$写成了$i$，导致我绝望的找了$15$分钟的$bug$...令人窒息。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAX = 1e9;\n\nconst int MAXN = 1000,MAXM = 200000;\n\nstruct Edge{\n    int from,to;\n    int flow,cap;\n    int cost;\n    int nex;\n}edge[MAXM];\n\nint n,m,s,t,ecnt = 2;\nint fir[MAXN],pree[MAXN];\nll dis[MAXN];int instack[MAXN];\nqueue<int> q;\n\nvoid addedge(int a,int b,int c,int d){\n    //printf(\"%lld %lld %lld %lld\\n\",a,b,c,d);\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].cap = c,edge[ecnt].flow = 0;\n    edge[ecnt].cost = d,edge[ecnt].nex = fir[a];\n    fir[a] = ecnt++;\n    edge[ecnt].from = b,edge[ecnt].to = a;\n    edge[ecnt].cap = 0,edge[ecnt].flow = 0;\n    edge[ecnt].cost = -d,edge[ecnt].nex = fir[b];\n    fir[b] = ecnt++;\n}\n\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    instack[e.to] = 1;\n                    q.push(e.to);\n                }\n            }\n        } \n    }\n    return dis[t] < 0x3f3f3f3f3f3f3f3f;\n}\n\nvoid argument(ll &sumf,ll &sumc){\n    int nown = t,nowe,delta = MAX;\n    while(nown!=s){\n        nowe = pree[nown];\n        delta = min(delta,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown!=s){\n        nowe = pree[nown];\n        edge[nowe].flow+=delta,edge[nowe^1].flow-=delta;\n        nown = edge[nowe].from;\n    }\n    sumf+=delta,sumc+=delta*dis[t];\n}\n\nvoid min_cost_flow(){\n    ll f = 0,c = 0;\n    while(spfa())\n        argument(f,c);\n    printf(\"%lld\\n\",c);\n}\n\nvoid init(){\n    read(m),read(n);\n    s = m+n+1,t = m+n+2;\n    int tmp = 0;\n    for(int i = 1;i<=n;i++){\n        read(tmp);\n        addedge(m+i,t,tmp,0);\n    }\n    for(int i = 1;i<=m;i++){\n        for(int j = 1;j<=n;j++){\n            read(tmp);\n            if(tmp)\n                addedge(i,m+j,MAX,0);\n        }\n    }\n    int b[10];\n    for(int i = 1;i<=m;i++){\n        read(tmp);\n        for(int j = 1;j<=tmp;j++)\n            read(b[j]);\n        b[0] = 0;b[tmp+1] = MAX;\n\n        for(int j = 1;j<=tmp+1;j++){\n            int w;read(w);\n            addedge(s,i,b[j]-b[j-1],w);\n        } \n    }\n}\n\nint main(){\n    init();\n    min_cost_flow();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SDOI2011」工作安排-费用流.md","raw":"---\ntitle: 「SDOI2011」工作安排-费用流\nurlname: sdoi2011-arrange\ndate: 2018-04-06 20:00:38\ntags:\n- 题解\n- 图论\n- 费用流\ncategories: OI\nvisible:\n---\n\n你的公司需要提供$n$类产品，其中第$i$类产品共需要$C_{i}$件。公司共有$m$名员工。员工能够制造的产品种类有所区别，我们用一个由$0$和$1$组成的$m\\times n$的矩阵$\\mathbb {A}$来描述每名员工能够制造哪些产品。\n\n对于员工$i$，给出$S_i$。定义他的愤怒值与他制作的产品数量之间的函数是一个$S_i+1$段的分段函数。设$T_{i,0}=0$,$T_{i,S_{i+1}}=+\\infty$，那么当他制造第$[T_{i,j-1}+1,T_{i,j}]$件产品时，每件产品会使他的愤怒值增加$W_{i,j}$， $1\\leq j\\leq S_{i+1}$。保证$0<W_{i,j} < W_{i,j+1}, \\; 0 < T_{i,j} < T_{i,j+1}$。\n\n你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2488](https://www.luogu.org/problemnew/show/P2488)\n\n[BZOJ 2245](https://www.lydsy.com/JudgeOnline/problem.php?id=2245)\n\n## 题解\n\n一道费用流的题目。\n\n每个产品的数量可以用一条边来限制，主要需要满足的就是愤怒值分段函数式的结构。\n\n注意到每个人的愤怒值的分段函数与做了具体哪类产品无关，所以我们可以在人这边的边上动点手脚。我们可以拆边，按段来拆边，每段给一条边，通过容量来满足分段的要求。\n\n具体建图：\n\n令$1$至$m$为$m$个员工所代表的点，$m+1$至$m+n$为$n$类产品代表的点，$s$为源点，$t$为汇点。\n\n对于$A$矩阵，如果$A_{i,j}$是$1$，那么我们就连一条起点为$i$，终点为$m+j$，容量为$+\\infty$，费用为$0$的边。\n\n对于第$i$个商品种类，我们连一条起点为$m+i$，终点为$t$，容量为$C_{i}$，费用为$0$的边。\n\n对于第$i$个人，我们连$S_{i}+1$条边，起点均为$s$，终点均为$i$，令第$j$条边的容量为$S_{i,j}-S_{i,j-1}$，$j \\in [1,S_{i}+1]$，费用为$W_{i,j}$。\n\n跑最小费用最大流，得到的费用即为结果。\n\n注意需要开$long\\ long$...\n\n值得一提的是，由于我有一个$j$写成了$i$，导致我绝望的找了$15$分钟的$bug$...令人窒息。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAX = 1e9;\n\nconst int MAXN = 1000,MAXM = 200000;\n\nstruct Edge{\n    int from,to;\n    int flow,cap;\n    int cost;\n    int nex;\n}edge[MAXM];\n\nint n,m,s,t,ecnt = 2;\nint fir[MAXN],pree[MAXN];\nll dis[MAXN];int instack[MAXN];\nqueue<int> q;\n\nvoid addedge(int a,int b,int c,int d){\n    //printf(\"%lld %lld %lld %lld\\n\",a,b,c,d);\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].cap = c,edge[ecnt].flow = 0;\n    edge[ecnt].cost = d,edge[ecnt].nex = fir[a];\n    fir[a] = ecnt++;\n    edge[ecnt].from = b,edge[ecnt].to = a;\n    edge[ecnt].cap = 0,edge[ecnt].flow = 0;\n    edge[ecnt].cost = -d,edge[ecnt].nex = fir[b];\n    fir[b] = ecnt++;\n}\n\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to] > dis[nown] + e.cost && e.cap > e.flow){\n                dis[e.to] = dis[nown] + e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    instack[e.to] = 1;\n                    q.push(e.to);\n                }\n            }\n        } \n    }\n    return dis[t] < 0x3f3f3f3f3f3f3f3f;\n}\n\nvoid argument(ll &sumf,ll &sumc){\n    int nown = t,nowe,delta = MAX;\n    while(nown!=s){\n        nowe = pree[nown];\n        delta = min(delta,edge[nowe].cap - edge[nowe].flow);\n        nown = edge[nowe].from;\n    }\n    nown = t;\n    while(nown!=s){\n        nowe = pree[nown];\n        edge[nowe].flow+=delta,edge[nowe^1].flow-=delta;\n        nown = edge[nowe].from;\n    }\n    sumf+=delta,sumc+=delta*dis[t];\n}\n\nvoid min_cost_flow(){\n    ll f = 0,c = 0;\n    while(spfa())\n        argument(f,c);\n    printf(\"%lld\\n\",c);\n}\n\nvoid init(){\n    read(m),read(n);\n    s = m+n+1,t = m+n+2;\n    int tmp = 0;\n    for(int i = 1;i<=n;i++){\n        read(tmp);\n        addedge(m+i,t,tmp,0);\n    }\n    for(int i = 1;i<=m;i++){\n        for(int j = 1;j<=n;j++){\n            read(tmp);\n            if(tmp)\n                addedge(i,m+j,MAX,0);\n        }\n    }\n    int b[10];\n    for(int i = 1;i<=m;i++){\n        read(tmp);\n        for(int j = 1;j<=tmp;j++)\n            read(b[j]);\n        b[0] = 0;b[tmp+1] = MAX;\n\n        for(int j = 1;j<=tmp+1;j++){\n            int w;read(w);\n            addedge(s,i,b[j]-b[j-1],w);\n        } \n    }\n}\n\nint main(){\n    init();\n    min_cost_flow();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SDOI2011」工作安排-费用流","published":1,"updated":"2018-05-05T14:51:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3k5004bbljrcxjmfy23","content":"<p>你的公司需要提供$n$类产品，其中第$i$类产品共需要$C_{i}$件。公司共有$m$名员工。员工能够制造的产品种类有所区别，我们用一个由$0$和$1$组成的$m\\times n$的矩阵$\\mathbb {A}$来描述每名员工能够制造哪些产品。</p>\n<p>对于员工$i$，给出$S_i$。定义他的愤怒值与他制作的产品数量之间的函数是一个$S_i+1$段的分段函数。设$T_{i,0}=0$,$T_{i,S_{i+1}}=+\\infty$，那么当他制造第$[T_{i,j-1}+1,T_{i,j}]$件产品时，每件产品会使他的愤怒值增加$W_{i,j}$， $1\\leq j\\leq S_{i+1}$。保证$0&lt;W_{i,j} &lt; W_{i,j+1}, \\; 0 &lt; T_{i,j} &lt; T_{i,j+1}$。</p>\n<p>你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2488\" target=\"_blank\" rel=\"noopener\">Luogu P2488</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2245\" target=\"_blank\" rel=\"noopener\">BZOJ 2245</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道费用流的题目。</p>\n<p>每个产品的数量可以用一条边来限制，主要需要满足的就是愤怒值分段函数式的结构。</p>\n<p>注意到每个人的愤怒值的分段函数与做了具体哪类产品无关，所以我们可以在人这边的边上动点手脚。我们可以拆边，按段来拆边，每段给一条边，通过容量来满足分段的要求。</p>\n<p>具体建图：</p>\n<p>令$1$至$m$为$m$个员工所代表的点，$m+1$至$m+n$为$n$类产品代表的点，$s$为源点，$t$为汇点。</p>\n<p>对于$A$矩阵，如果$A_{i,j}$是$1$，那么我们就连一条起点为$i$，终点为$m+j$，容量为$+\\infty$，费用为$0$的边。</p>\n<p>对于第$i$个商品种类，我们连一条起点为$m+i$，终点为$t$，容量为$C_{i}$，费用为$0$的边。</p>\n<p>对于第$i$个人，我们连$S_{i}+1$条边，起点均为$s$，终点均为$i$，令第$j$条边的容量为$S_{i,j}-S_{i,j-1}$，$j \\in [1,S_{i}+1]$，费用为$W_{i,j}$。</p>\n<p>跑最小费用最大流，得到的费用即为结果。</p>\n<p>注意需要开$long\\ long$…</p>\n<p>值得一提的是，由于我有一个$j$写成了$i$，导致我绝望的找了$15$分钟的$bug$…令人窒息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1000</span>,MAXM = <span class=\"number\">200000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flow,cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nex;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,ecnt = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN],pree[MAXN];</span><br><span class=\"line\">ll dis[MAXN];<span class=\"keyword\">int</span> instack[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//printf(\"%lld %lld %lld %lld\\n\",a,b,c,d);</span></span><br><span class=\"line\">    edge[ecnt].from = a,edge[ecnt].to = b;</span><br><span class=\"line\">    edge[ecnt].cap = c,edge[ecnt].flow = <span class=\"number\">0</span>;</span><br><span class=\"line\">    edge[ecnt].cost = d,edge[ecnt].nex = fir[a];</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">    edge[ecnt].from = b,edge[ecnt].to = a;</span><br><span class=\"line\">    edge[ecnt].cap = <span class=\"number\">0</span>,edge[ecnt].flow = <span class=\"number\">0</span>;</span><br><span class=\"line\">    edge[ecnt].cost = -d,edge[ecnt].nex = fir[b];</span><br><span class=\"line\">    fir[b] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) q.pop();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    dis[s] = <span class=\"number\">0</span>;q.push(s);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        instack[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">            Edge e = edge[nowe];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[e.to] &gt; dis[nown] + e.cost &amp;&amp; e.cap &gt; e.flow)&#123;</span><br><span class=\"line\">                dis[e.to] = dis[nown] + e.cost;</span><br><span class=\"line\">                pree[e.to] = nowe;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instack[e.to] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    instack[e.to] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t] &lt; <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">argument</span><span class=\"params\">(ll &amp;sumf,ll &amp;sumc)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nown = t,nowe,delta = MAX;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        delta = min(delta,edge[nowe].cap - edge[nowe].flow);</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nown = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        nowe = pree[nown];</span><br><span class=\"line\">        edge[nowe].flow+=delta,edge[nowe^<span class=\"number\">1</span>].flow-=delta;</span><br><span class=\"line\">        nown = edge[nowe].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sumf+=delta,sumc+=delta*dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ll f = <span class=\"number\">0</span>,c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(spfa())</span><br><span class=\"line\">        argument(f,c);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n\"</span>,c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(m),read(n);</span><br><span class=\"line\">    s = m+n+<span class=\"number\">1</span>,t = m+n+<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(tmp);</span><br><span class=\"line\">        addedge(m+i,t,tmp,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            read(tmp);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp)</span><br><span class=\"line\">                addedge(i,m+j,MAX,<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=tmp;j++)</span><br><span class=\"line\">            read(b[j]);</span><br><span class=\"line\">        b[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;b[tmp+<span class=\"number\">1</span>] = MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=tmp+<span class=\"number\">1</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> w;read(w);</span><br><span class=\"line\">            addedge(s,i,b[j]-b[j<span class=\"number\">-1</span>],w);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    min_cost_flow();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>你的公司需要提供$n$类产品，其中第$i$类产品共需要$C_{i}$件。公司共有$m$名员工。员工能够制造的产品种类有所区别，我们用一个由$0$和$1$组成的$m\\times n$的矩阵$\\mathbb {A}$来描述每名员工能够制造哪些产品。</p>\n<p>对于员工$i$，给出$S_i$。定义他的愤怒值与他制作的产品数量之间的函数是一个$S_i+1$段的分段函数。设$T_{i,0}=0$,$T_{i,S_{i+1}}=+\\infty$，那么当他制造第$[T_{i,j-1}+1,T_{i,j}]$件产品时，每件产品会使他的愤怒值增加$W_{i,j}$， $1\\leq j\\leq S_{i+1}$。保证$0&lt;W_{i,j} &lt; W_{i,j+1}, \\; 0 &lt; T_{i,j} &lt; T_{i,j+1}$。</p>\n<p>你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2488\" target=\"_blank\" rel=\"noopener\">Luogu P2488</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=2245\" target=\"_blank\" rel=\"noopener\">BZOJ 2245</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道费用流的题目。</p>\n<p>每个产品的数量可以用一条边来限制，主要需要满足的就是愤怒值分段函数式的结构。</p>\n<p>注意到每个人的愤怒值的分段函数与做了具体哪类产品无关，所以我们可以在人这边的边上动点手脚。我们可以拆边，按段来拆边，每段给一条边，通过容量来满足分段的要求。</p>\n<p>具体建图：</p>\n<p>令$1$至$m$为$m$个员工所代表的点，$m+1$至$m+n$为$n$类产品代表的点，$s$为源点，$t$为汇点。</p>\n<p>对于$A$矩阵，如果$A_{i,j}$是$1$，那么我们就连一条起点为$i$，终点为$m+j$，容量为$+\\infty$，费用为$0$的边。</p>\n<p>对于第$i$个商品种类，我们连一条起点为$m+i$，终点为$t$，容量为$C_{i}$，费用为$0$的边。</p>\n<p>对于第$i$个人，我们连$S_{i}+1$条边，起点均为$s$，终点均为$i$，令第$j$条边的容量为$S_{i,j}-S_{i,j-1}$，$j \\in [1,S_{i}+1]$，费用为$W_{i,j}$。</p>\n<p>跑最小费用最大流，得到的费用即为结果。</p>\n<p>注意需要开$long\\ long$…</p>\n<p>值得一提的是，由于我有一个$j$写成了$i$，导致我绝望的找了$15$分钟的$bug$…令人窒息。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�50-->\n\n</div></div>"},{"title":"「SDOI2011」染色-树链剖分+线段树","urlname":"SDOI2011-colour","date":"2018-03-14T13:20:54.000Z","visible":null,"_content":"\n给定一棵有$n$个节点的无根树和$m$个操作，操作有$2$类：\n+ 将节点$a$到节点$b$路径上所有点都染成颜色$c$；\n+ 询问节点$a$到节点$b$路径上的颜色段数量（连续相同颜色被认为是同一段），\n如“$112221$”由3段组成：“$11$”、“$222$”和“$1$”。\n请你写一个程序依次完成这$m$个操作。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2486](https://www.luogu.org/problemnew/show/P2486)\n\n## 题解\n\n这道题是一道不是很难的树链剖分+线段树的题目。{% spoiler  虽然我感觉我考场上根本不可能写出来&调出来... %}\n\n很明显是一道树链剖分的题目，我们只需要搞明白：如何维护区间的颜色块的数目。\n\n很容易想到用线段树来维护这个东西。所以我们只要维护三个东西：**左端点的颜色，右端点的颜色，总共的颜色块数目。**\n\n在合并的时候，如果左边块的右端点的颜色等于右边块的左端点颜色，就给总颜色块数目减1，就可以达成合并区间的目的。合并后的块的左颜色等于左孩子的左颜色，右颜色等于右孩子的右颜色。总共的颜色块数目是两块颜色块的数目加起来，再判一下前文提到的相同的颜色就行了\n\n由于我太菜了，所以有的地方懒得去想，就多加了几个`if else...`了事，代码也就长些。\n\n## 代码\n\n{% fold %}\n\n```cpp\n\n#include <cstdio>\n#include <vector>\n#include <cctype>\n#define lson (nown<<1)\n#define rson (nown<<1|1)\n#define mid ((l+r)>>1)\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 110000;\n\nint n,m;\nint son[MAXN],top[MAXN],fa[MAXN],siz[MAXN],dep[MAXN];\nint id[MAXN],id_to[MAXN],num[MAXN],cnt = 1;\n\nvector<int> edge[MAXN];\n\n//线段树节点定义\nstruct node{\n    int num,lcol,rcol;\n    bool lazy;\n    node(int n = 0,int l = 0,int r = 0):num(n),lcol(l),rcol(r){};\n    bool empty(){\n        return num == 0;\n    }\n}pool[MAXN<<2];\n\n//线段树节点的合并\ninline node merge(node l,node r){\n    //特判！！！\n    if(l.empty()) return r;\n    if(r.empty()) return l;\n    node ans;\n    ans.num = l.num+r.num;\n    if(l.rcol == r.lcol) ans.num-=1;\n    ans.lcol = l.lcol,ans.rcol = r.rcol;\n    return ans;\n}\n\n//线段树的标记下传\ninline void push_down(int nown,int l,int r){\n    if(pool[nown].lazy){\n        int c = pool[nown].lcol;\n        pool[lson] = node(1,c,c),pool[lson].lazy = 1;\n        pool[rson] = node(1,c,c),pool[rson].lazy = 1;\n        pool[nown].lazy = 0;\n    }\n}\n\n//反转区间\ninline node reverse(node nown){\n    swap(nown.lcol,nown.rcol);\n    return nown;\n}\n\n//建树\ninline void build(int nown,int l,int r){\n    pool[nown].lazy = 0;\n    if(l == r)\n        pool[nown] = node(1,num[id_to[l]],num[id_to[l]]);\n    else{\n        build(lson,l,mid);\n        build(rson,mid+1,r);\n        pool[nown] = merge(pool[lson],pool[rson]);\n    }\n}\n\n//线段树区间更新\ninline void update(int nown,int l,int r,int ql,int qr,int c){\n    if(ql<=l&&r<=qr){\n        pool[nown] = node(1,c,c);\n        pool[nown].lazy = 1;\n    }\n    else{\n        push_down(nown,l,r);\n        if(ql<=mid) update(lson,l,mid,ql,qr,c);\n        if(qr>=mid+1) update(rson,mid+1,r,ql,qr,c);\n        pool[nown] = merge(pool[lson],pool[rson]);\n    }\n}\n\n//线段树区间查询颜色块树\ninline node query(int nown,int l,int r,int ql,int qr){\n    if(ql<=l&&r<=qr)\n        return pool[nown];//这里的返回值是整个结构体\n    else{\n        push_down(nown,l,r);\n        if(ql<=mid && mid+1<=qr){\n            node ls,rs;\n            ls = query(lson,l,mid,ql,qr);\n            rs = query(rson,mid+1,r,ql,qr);\n            return merge(ls,rs);\n        }\n        else if(qr<=mid)\n            return query(lson,l,mid,ql,qr);\n        else if(ql>=mid+1)\n            return query(rson,mid+1,r,ql,qr);\n    }\n}\n\n/*--- 以下为树链剖分模版 ---*/\ninline void dfs1(int nown,int f,int depth){\n    dep[nown] = depth,fa[nown] = f,siz[nown] = 1;\n    son[nown] = 0;int maxsum = -1;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to]>maxsum) maxsum = siz[to],son[nown] = to;\n    }\n}\n\ninline void dfs2(int nown,int topf){\n    top[nown] = topf,id[nown] = cnt,id_to[cnt] = nown;cnt++;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]||to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\nvoid update_range(int x,int y,int c){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        update(1,1,n,id[top[x]],id[x],c);\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    update(1,1,n,id[x],id[y],c);\n}\n\n//这里多用了几个if else 和reverse来让颜色块接对方向\n//可以同时交换lans和rans等来完成这一项(未经验证)\nint query_range(int x,int y){\n    node lans = node(0,0,0),rans = node(0,0,0);\n    while(top[x]!=top[y]){\n        if(dep[top[x]] > dep[top[y]]){\n            lans = merge(lans,reverse(query(1,1,n,id[top[x]],id[x])));\n            x = fa[top[x]];\n        }\n        else{\n            rans = merge(query(1,1,n,id[top[y]],id[y]),rans);\n            y = fa[top[y]];\n        }\n    }\n    if(dep[x]<dep[y])\n        lans = merge(lans,query(1,1,n,id[x],id[y]));\n    else\n        rans = merge(reverse(query(1,1,n,id[y],id[x])),rans);\n    return merge(lans,rans).num;\n}\n/*--- 以上为树链剖分模版 ---*/\n\n//程序的初始化\ninline void init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n    build(1,1,n);\n}\n\n//回应询问\nvoid solve(){\n    char op[20];int a,b,c;\n    for(int i = 1;i<=m;i++){\n        read(op),read(a),read(b);\n        if(op[0] == 'C')\n            read(c),update_range(a,b,c);\n        else if(op[0] == 'Q')\n            print(query_range(a,b)),print('\\n');\n    }\n}\n\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n\n","source":"_posts/「SDOI2011」染色-树链剖分-线段树.md","raw":"---\ntitle: 「SDOI2011」染色-树链剖分+线段树\nurlname: SDOI2011-colour\ndate: 2018-03-14 21:20:54\ntags:\n- 题解\n- 数据结构\n- 树链剖分\n- 线段树\ncategories: OI\nvisible:\n---\n\n给定一棵有$n$个节点的无根树和$m$个操作，操作有$2$类：\n+ 将节点$a$到节点$b$路径上所有点都染成颜色$c$；\n+ 询问节点$a$到节点$b$路径上的颜色段数量（连续相同颜色被认为是同一段），\n如“$112221$”由3段组成：“$11$”、“$222$”和“$1$”。\n请你写一个程序依次完成这$m$个操作。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2486](https://www.luogu.org/problemnew/show/P2486)\n\n## 题解\n\n这道题是一道不是很难的树链剖分+线段树的题目。{% spoiler  虽然我感觉我考场上根本不可能写出来&调出来... %}\n\n很明显是一道树链剖分的题目，我们只需要搞明白：如何维护区间的颜色块的数目。\n\n很容易想到用线段树来维护这个东西。所以我们只要维护三个东西：**左端点的颜色，右端点的颜色，总共的颜色块数目。**\n\n在合并的时候，如果左边块的右端点的颜色等于右边块的左端点颜色，就给总颜色块数目减1，就可以达成合并区间的目的。合并后的块的左颜色等于左孩子的左颜色，右颜色等于右孩子的右颜色。总共的颜色块数目是两块颜色块的数目加起来，再判一下前文提到的相同的颜色就行了\n\n由于我太菜了，所以有的地方懒得去想，就多加了几个`if else...`了事，代码也就长些。\n\n## 代码\n\n{% fold %}\n\n```cpp\n\n#include <cstdio>\n#include <vector>\n#include <cctype>\n#define lson (nown<<1)\n#define rson (nown<<1|1)\n#define mid ((l+r)>>1)\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 110000;\n\nint n,m;\nint son[MAXN],top[MAXN],fa[MAXN],siz[MAXN],dep[MAXN];\nint id[MAXN],id_to[MAXN],num[MAXN],cnt = 1;\n\nvector<int> edge[MAXN];\n\n//线段树节点定义\nstruct node{\n    int num,lcol,rcol;\n    bool lazy;\n    node(int n = 0,int l = 0,int r = 0):num(n),lcol(l),rcol(r){};\n    bool empty(){\n        return num == 0;\n    }\n}pool[MAXN<<2];\n\n//线段树节点的合并\ninline node merge(node l,node r){\n    //特判！！！\n    if(l.empty()) return r;\n    if(r.empty()) return l;\n    node ans;\n    ans.num = l.num+r.num;\n    if(l.rcol == r.lcol) ans.num-=1;\n    ans.lcol = l.lcol,ans.rcol = r.rcol;\n    return ans;\n}\n\n//线段树的标记下传\ninline void push_down(int nown,int l,int r){\n    if(pool[nown].lazy){\n        int c = pool[nown].lcol;\n        pool[lson] = node(1,c,c),pool[lson].lazy = 1;\n        pool[rson] = node(1,c,c),pool[rson].lazy = 1;\n        pool[nown].lazy = 0;\n    }\n}\n\n//反转区间\ninline node reverse(node nown){\n    swap(nown.lcol,nown.rcol);\n    return nown;\n}\n\n//建树\ninline void build(int nown,int l,int r){\n    pool[nown].lazy = 0;\n    if(l == r)\n        pool[nown] = node(1,num[id_to[l]],num[id_to[l]]);\n    else{\n        build(lson,l,mid);\n        build(rson,mid+1,r);\n        pool[nown] = merge(pool[lson],pool[rson]);\n    }\n}\n\n//线段树区间更新\ninline void update(int nown,int l,int r,int ql,int qr,int c){\n    if(ql<=l&&r<=qr){\n        pool[nown] = node(1,c,c);\n        pool[nown].lazy = 1;\n    }\n    else{\n        push_down(nown,l,r);\n        if(ql<=mid) update(lson,l,mid,ql,qr,c);\n        if(qr>=mid+1) update(rson,mid+1,r,ql,qr,c);\n        pool[nown] = merge(pool[lson],pool[rson]);\n    }\n}\n\n//线段树区间查询颜色块树\ninline node query(int nown,int l,int r,int ql,int qr){\n    if(ql<=l&&r<=qr)\n        return pool[nown];//这里的返回值是整个结构体\n    else{\n        push_down(nown,l,r);\n        if(ql<=mid && mid+1<=qr){\n            node ls,rs;\n            ls = query(lson,l,mid,ql,qr);\n            rs = query(rson,mid+1,r,ql,qr);\n            return merge(ls,rs);\n        }\n        else if(qr<=mid)\n            return query(lson,l,mid,ql,qr);\n        else if(ql>=mid+1)\n            return query(rson,mid+1,r,ql,qr);\n    }\n}\n\n/*--- 以下为树链剖分模版 ---*/\ninline void dfs1(int nown,int f,int depth){\n    dep[nown] = depth,fa[nown] = f,siz[nown] = 1;\n    son[nown] = 0;int maxsum = -1;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to]>maxsum) maxsum = siz[to],son[nown] = to;\n    }\n}\n\ninline void dfs2(int nown,int topf){\n    top[nown] = topf,id[nown] = cnt,id_to[cnt] = nown;cnt++;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == fa[nown]||to == son[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\nvoid update_range(int x,int y,int c){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        update(1,1,n,id[top[x]],id[x],c);\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    update(1,1,n,id[x],id[y],c);\n}\n\n//这里多用了几个if else 和reverse来让颜色块接对方向\n//可以同时交换lans和rans等来完成这一项(未经验证)\nint query_range(int x,int y){\n    node lans = node(0,0,0),rans = node(0,0,0);\n    while(top[x]!=top[y]){\n        if(dep[top[x]] > dep[top[y]]){\n            lans = merge(lans,reverse(query(1,1,n,id[top[x]],id[x])));\n            x = fa[top[x]];\n        }\n        else{\n            rans = merge(query(1,1,n,id[top[y]],id[y]),rans);\n            y = fa[top[y]];\n        }\n    }\n    if(dep[x]<dep[y])\n        lans = merge(lans,query(1,1,n,id[x],id[y]));\n    else\n        rans = merge(reverse(query(1,1,n,id[y],id[x])),rans);\n    return merge(lans,rans).num;\n}\n/*--- 以上为树链剖分模版 ---*/\n\n//程序的初始化\ninline void init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n    build(1,1,n);\n}\n\n//回应询问\nvoid solve(){\n    char op[20];int a,b,c;\n    for(int i = 1;i<=m;i++){\n        read(op),read(a),read(b);\n        if(op[0] == 'C')\n            read(c),update_range(a,b,c);\n        else if(op[0] == 'Q')\n            print(query_range(a,b)),print('\\n');\n    }\n}\n\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n\n","slug":"「SDOI2011」染色-树链剖分-线段树","published":1,"updated":"2018-03-14T14:21:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3kc004fbljrm8z8orav","content":"<p>&#x7ED9;&#x5B9A;&#x4E00;&#x68F5;&#x6709;$n$&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x65E0;&#x6839;&#x6811;&#x548C;$m$&#x4E2A;&#x64CD;&#x4F5C;&#xFF0C;&#x64CD;&#x4F5C;&#x6709;$2$&#x7C7B;&#xFF1A;</p>\n<ul>\n<li>&#x5C06;&#x8282;&#x70B9;$a$&#x5230;&#x8282;&#x70B9;$b$&#x8DEF;&#x5F84;&#x4E0A;&#x6240;&#x6709;&#x70B9;&#x90FD;&#x67D3;&#x6210;&#x989C;&#x8272;$c$&#xFF1B;</li>\n<li>&#x8BE2;&#x95EE;&#x8282;&#x70B9;$a$&#x5230;&#x8282;&#x70B9;$b$&#x8DEF;&#x5F84;&#x4E0A;&#x7684;&#x989C;&#x8272;&#x6BB5;&#x6570;&#x91CF;&#xFF08;&#x8FDE;&#x7EED;&#x76F8;&#x540C;&#x989C;&#x8272;&#x88AB;&#x8BA4;&#x4E3A;&#x662F;&#x540C;&#x4E00;&#x6BB5;&#xFF09;&#xFF0C;<br>&#x5982;&#x201C;$112221$&#x201D;&#x7531;3&#x6BB5;&#x7EC4;&#x6210;&#xFF1A;&#x201C;$11$&#x201D;&#x3001;&#x201C;$222$&#x201D;&#x548C;&#x201C;$1$&#x201D;&#x3002;<br>&#x8BF7;&#x4F60;&#x5199;&#x4E00;&#x4E2A;&#x7A0B;&#x5E8F;&#x4F9D;&#x6B21;&#x5B8C;&#x6210;&#x8FD9;$m$&#x4E2A;&#x64CD;&#x4F5C;&#x3002;</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2486\" target=\"_blank\" rel=\"noopener\">Luogu P2486</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x662F;&#x4E00;&#x9053;&#x4E0D;&#x662F;&#x5F88;&#x96BE;&#x7684;&#x6811;&#x94FE;&#x5256;&#x5206;+&#x7EBF;&#x6BB5;&#x6811;&#x7684;&#x9898;&#x76EE;&#x3002;<span class=\"spoiler\">&#x867D;&#x7136;&#x6211;&#x611F;&#x89C9;&#x6211;&#x8003;&#x573A;&#x4E0A;&#x6839;&#x672C;&#x4E0D;&#x53EF;&#x80FD;&#x5199;&#x51FA;&#x6765;&amp;&#x8C03;&#x51FA;&#x6765;&#x2026;\n</span></p>\n<p>&#x5F88;&#x660E;&#x663E;&#x662F;&#x4E00;&#x9053;&#x6811;&#x94FE;&#x5256;&#x5206;&#x7684;&#x9898;&#x76EE;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x9700;&#x8981;&#x641E;&#x660E;&#x767D;&#xFF1A;&#x5982;&#x4F55;&#x7EF4;&#x62A4;&#x533A;&#x95F4;&#x7684;&#x989C;&#x8272;&#x5757;&#x7684;&#x6570;&#x76EE;&#x3002;</p>\n<p>&#x5F88;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x6765;&#x7EF4;&#x62A4;&#x8FD9;&#x4E2A;&#x4E1C;&#x897F;&#x3002;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EA;&#x8981;&#x7EF4;&#x62A4;&#x4E09;&#x4E2A;&#x4E1C;&#x897F;&#xFF1A;<strong>&#x5DE6;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x603B;&#x5171;&#x7684;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x3002;</strong></p>\n<p>&#x5728;&#x5408;&#x5E76;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5982;&#x679C;&#x5DE6;&#x8FB9;&#x5757;&#x7684;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x53F3;&#x8FB9;&#x5757;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x989C;&#x8272;&#xFF0C;&#x5C31;&#x7ED9;&#x603B;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x51CF;1&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x8FBE;&#x6210;&#x5408;&#x5E76;&#x533A;&#x95F4;&#x7684;&#x76EE;&#x7684;&#x3002;&#x5408;&#x5E76;&#x540E;&#x7684;&#x5757;&#x7684;&#x5DE6;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x5DE6;&#x5B69;&#x5B50;&#x7684;&#x5DE6;&#x989C;&#x8272;&#xFF0C;&#x53F3;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x53F3;&#x5B69;&#x5B50;&#x7684;&#x53F3;&#x989C;&#x8272;&#x3002;&#x603B;&#x5171;&#x7684;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x662F;&#x4E24;&#x5757;&#x989C;&#x8272;&#x5757;&#x7684;&#x6570;&#x76EE;&#x52A0;&#x8D77;&#x6765;&#xFF0C;&#x518D;&#x5224;&#x4E00;&#x4E0B;&#x524D;&#x6587;&#x63D0;&#x5230;&#x7684;&#x76F8;&#x540C;&#x7684;&#x989C;&#x8272;&#x5C31;&#x884C;&#x4E86;</p>\n<p>&#x7531;&#x4E8E;&#x6211;&#x592A;&#x83DC;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x6709;&#x7684;&#x5730;&#x65B9;&#x61D2;&#x5F97;&#x53BB;&#x60F3;&#xFF0C;&#x5C31;&#x591A;&#x52A0;&#x4E86;&#x51E0;&#x4E2A;<code>if else...</code>&#x4E86;&#x4E8B;&#xFF0C;&#x4EE3;&#x7801;&#x4E5F;&#x5C31;&#x957F;&#x4E9B;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lson (nown&lt;&lt;1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> rson (nown&lt;&lt;1|1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//快读模版</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> son[MAXN],top[MAXN],fa[MAXN],siz[MAXN],dep[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> id[MAXN],id_to[MAXN],num[MAXN],cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树节点定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num,lcol,rcol;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> lazy;</span><br><span class=\"line\">    node(<span class=\"keyword\">int</span> n = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>):num(n),lcol(l),rcol(r)&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;pool[MAXN&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树节点的合并</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">merge</span><span class=\"params\">(node l,node r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//特判！！！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l.empty()) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r.empty()) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    node ans;</span><br><span class=\"line\">    ans.num = l.num+r.num;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l.rcol == r.lcol) ans.num-=<span class=\"number\">1</span>;</span><br><span class=\"line\">    ans.lcol = l.lcol,ans.rcol = r.rcol;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树的标记下传</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">push_down</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pool[nown].lazy)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = pool[nown].lcol;</span><br><span class=\"line\">        pool[lson] = node(<span class=\"number\">1</span>,c,c),pool[lson].lazy = <span class=\"number\">1</span>;</span><br><span class=\"line\">        pool[rson] = node(<span class=\"number\">1</span>,c,c),pool[rson].lazy = <span class=\"number\">1</span>;</span><br><span class=\"line\">        pool[nown].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反转区间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">reverse</span><span class=\"params\">(node nown)</span></span>&#123;</span><br><span class=\"line\">    swap(nown.lcol,nown.rcol);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nown;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//建树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    pool[nown].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">        pool[nown] = node(<span class=\"number\">1</span>,num[id_to[l]],num[id_to[l]]);</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        build(lson,l,mid);</span><br><span class=\"line\">        build(rson,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">        pool[nown] = merge(pool[lson],pool[rson]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树区间更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;</span><br><span class=\"line\">        pool[nown] = node(<span class=\"number\">1</span>,c,c);</span><br><span class=\"line\">        pool[nown].lazy = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        push_down(nown,l,r);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql&lt;=mid) update(lson,l,mid,ql,qr,c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(qr&gt;=mid+<span class=\"number\">1</span>) update(rson,mid+<span class=\"number\">1</span>,r,ql,qr,c);</span><br><span class=\"line\">        pool[nown] = merge(pool[lson],pool[rson]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//线段树区间查询颜色块树</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> node <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pool[nown];<span class=\"comment\">//这里的返回值是整个结构体</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        push_down(nown,l,r);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql&lt;=mid &amp;&amp; mid+<span class=\"number\">1</span>&lt;=qr)&#123;</span><br><span class=\"line\">            node ls,rs;</span><br><span class=\"line\">            ls = query(lson,l,mid,ql,qr);</span><br><span class=\"line\">            rs = query(rson,mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> merge(ls,rs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(qr&lt;=mid)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> query(lson,l,mid,ql,qr);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ql&gt;=mid+<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> query(rson,mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--- 以下为树链剖分模版 ---*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    dep[nown] = depth,fa[nown] = f,siz[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    son[nown] = <span class=\"number\">0</span>;<span class=\"keyword\">int</span> maxsum = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(to,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        siz[nown]+=siz[to];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[to]&gt;maxsum) maxsum = siz[to],son[nown] = to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    top[nown] = topf,id[nown] = cnt,id_to[cnt] = nown;cnt++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!son[nown]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == fa[nown]||to == son[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(to,to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_range</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class=\"line\">        update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[x]],id[x],c);</span><br><span class=\"line\">        x = fa[top[x]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class=\"line\">    update(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[y],c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里多用了几个if else 和reverse来让颜色块接对方向</span></span><br><span class=\"line\"><span class=\"comment\">//可以同时交换lans和rans等来完成这一项(未经验证)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query_range</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    node lans = node(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>),rans = node(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]] &gt; dep[top[y]])&#123;</span><br><span class=\"line\">            lans = merge(lans,reverse(query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[x]],id[x])));</span><br><span class=\"line\">            x = fa[top[x]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            rans = merge(query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[top[y]],id[y]),rans);</span><br><span class=\"line\">            y = fa[top[y]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x]&lt;dep[y])</span><br><span class=\"line\">        lans = merge(lans,query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[x],id[y]));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        rans = merge(reverse(query(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,id[y],id[x])),rans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(lans,rans).num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*--- 以上为树链剖分模版 ---*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//程序的初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        edge[a].push_back(b);</span><br><span class=\"line\">        edge[b].push_back(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    build(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//回应询问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op),read(a),read(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)</span><br><span class=\"line\">            read(c),update_range(a,b,c);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">            print(query_range(a,b)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>&#x7ED9;&#x5B9A;&#x4E00;&#x68F5;&#x6709;$n$&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x65E0;&#x6839;&#x6811;&#x548C;$m$&#x4E2A;&#x64CD;&#x4F5C;&#xFF0C;&#x64CD;&#x4F5C;&#x6709;$2$&#x7C7B;&#xFF1A;</p>\n<ul>\n<li>&#x5C06;&#x8282;&#x70B9;$a$&#x5230;&#x8282;&#x70B9;$b$&#x8DEF;&#x5F84;&#x4E0A;&#x6240;&#x6709;&#x70B9;&#x90FD;&#x67D3;&#x6210;&#x989C;&#x8272;$c$&#xFF1B;</li>\n<li>&#x8BE2;&#x95EE;&#x8282;&#x70B9;$a$&#x5230;&#x8282;&#x70B9;$b$&#x8DEF;&#x5F84;&#x4E0A;&#x7684;&#x989C;&#x8272;&#x6BB5;&#x6570;&#x91CF;&#xFF08;&#x8FDE;&#x7EED;&#x76F8;&#x540C;&#x989C;&#x8272;&#x88AB;&#x8BA4;&#x4E3A;&#x662F;&#x540C;&#x4E00;&#x6BB5;&#xFF09;&#xFF0C;<br>&#x5982;&#x201C;$112221$&#x201D;&#x7531;3&#x6BB5;&#x7EC4;&#x6210;&#xFF1A;&#x201C;$11$&#x201D;&#x3001;&#x201C;$222$&#x201D;&#x548C;&#x201C;$1$&#x201D;&#x3002;<br>&#x8BF7;&#x4F60;&#x5199;&#x4E00;&#x4E2A;&#x7A0B;&#x5E8F;&#x4F9D;&#x6B21;&#x5B8C;&#x6210;&#x8FD9;$m$&#x4E2A;&#x64CD;&#x4F5C;&#x3002;</li>\n</ul>","more":"<h2 id=\"&#x94FE;&#x63A5;\"><a href=\"#&#x94FE;&#x63A5;\" class=\"headerlink\" title=\"&#x94FE;&#x63A5;\"></a>&#x94FE;&#x63A5;</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2486\" target=\"_blank\" rel=\"noopener\">Luogu P2486</a></p>\n<h2 id=\"&#x9898;&#x89E3;\"><a href=\"#&#x9898;&#x89E3;\" class=\"headerlink\" title=\"&#x9898;&#x89E3;\"></a>&#x9898;&#x89E3;</h2><p>&#x8FD9;&#x9053;&#x9898;&#x662F;&#x4E00;&#x9053;&#x4E0D;&#x662F;&#x5F88;&#x96BE;&#x7684;&#x6811;&#x94FE;&#x5256;&#x5206;+&#x7EBF;&#x6BB5;&#x6811;&#x7684;&#x9898;&#x76EE;&#x3002;<span class=\"spoiler\">&#x867D;&#x7136;&#x6211;&#x611F;&#x89C9;&#x6211;&#x8003;&#x573A;&#x4E0A;&#x6839;&#x672C;&#x4E0D;&#x53EF;&#x80FD;&#x5199;&#x51FA;&#x6765;&amp;&#x8C03;&#x51FA;&#x6765;&#x2026;\n</span></p>\n<p>&#x5F88;&#x660E;&#x663E;&#x662F;&#x4E00;&#x9053;&#x6811;&#x94FE;&#x5256;&#x5206;&#x7684;&#x9898;&#x76EE;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x9700;&#x8981;&#x641E;&#x660E;&#x767D;&#xFF1A;&#x5982;&#x4F55;&#x7EF4;&#x62A4;&#x533A;&#x95F4;&#x7684;&#x989C;&#x8272;&#x5757;&#x7684;&#x6570;&#x76EE;&#x3002;</p>\n<p>&#x5F88;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x7528;&#x7EBF;&#x6BB5;&#x6811;&#x6765;&#x7EF4;&#x62A4;&#x8FD9;&#x4E2A;&#x4E1C;&#x897F;&#x3002;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EA;&#x8981;&#x7EF4;&#x62A4;&#x4E09;&#x4E2A;&#x4E1C;&#x897F;&#xFF1A;<strong>&#x5DE6;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x603B;&#x5171;&#x7684;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x3002;</strong></p>\n<p>&#x5728;&#x5408;&#x5E76;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5982;&#x679C;&#x5DE6;&#x8FB9;&#x5757;&#x7684;&#x53F3;&#x7AEF;&#x70B9;&#x7684;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x53F3;&#x8FB9;&#x5757;&#x7684;&#x5DE6;&#x7AEF;&#x70B9;&#x989C;&#x8272;&#xFF0C;&#x5C31;&#x7ED9;&#x603B;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x51CF;1&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x8FBE;&#x6210;&#x5408;&#x5E76;&#x533A;&#x95F4;&#x7684;&#x76EE;&#x7684;&#x3002;&#x5408;&#x5E76;&#x540E;&#x7684;&#x5757;&#x7684;&#x5DE6;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x5DE6;&#x5B69;&#x5B50;&#x7684;&#x5DE6;&#x989C;&#x8272;&#xFF0C;&#x53F3;&#x989C;&#x8272;&#x7B49;&#x4E8E;&#x53F3;&#x5B69;&#x5B50;&#x7684;&#x53F3;&#x989C;&#x8272;&#x3002;&#x603B;&#x5171;&#x7684;&#x989C;&#x8272;&#x5757;&#x6570;&#x76EE;&#x662F;&#x4E24;&#x5757;&#x989C;&#x8272;&#x5757;&#x7684;&#x6570;&#x76EE;&#x52A0;&#x8D77;&#x6765;&#xFF0C;&#x518D;&#x5224;&#x4E00;&#x4E0B;&#x524D;&#x6587;&#x63D0;&#x5230;&#x7684;&#x76F8;&#x540C;&#x7684;&#x989C;&#x8272;&#x5C31;&#x884C;&#x4E86;</p>\n<p>&#x7531;&#x4E8E;&#x6211;&#x592A;&#x83DC;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x6709;&#x7684;&#x5730;&#x65B9;&#x61D2;&#x5F97;&#x53BB;&#x60F3;&#xFF0C;&#x5C31;&#x591A;&#x52A0;&#x4E86;&#x51E0;&#x4E2A;<code>if else...</code>&#x4E86;&#x4E8B;&#xFF0C;&#x4EE3;&#x7801;&#x4E5F;&#x5C31;&#x957F;&#x4E9B;&#x3002;</p>\n<h2 id=\"&#x4EE3;&#x7801;\"><a href=\"#&#x4EE3;&#x7801;\" class=\"headerlink\" title=\"&#x4EE3;&#x7801;\"></a>&#x4EE3;&#x7801;</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">&#x70B9;&#x51FB;&#x5207;&#x6362;&#x663E;&#x793A;&#x72B6;&#x6001;</div></div><div class=\"fold\">\n<!--�51-->\n\n</div></div>"},{"title":"「SDOI2011」消防-树的直径+单调队列","urlname":"SDOI2011-fireman","date":"2018-05-21T12:11:00.000Z","visible":null,"_content":"\n某个国家有$n$个城市，这$n$个点之间的边构成一棵树。\n\n现求一条边长度和不超过$S$的路径（两端都是城市，可以只为一个城市），使得所有城市到这条路径的距离的最大值最小，并输出这个最小值。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2491](https://www.luogu.org/problemnew/show/P2491)\n\n## 题解\n\n很有趣的题。\n\n很明显，这条路径必须全部位于直径上。具体证明不会，大概可以感性理解一下。\n\n那么我们就要考虑，在直径上选出一段长度不大于S的路径，如何维护这颗树上的所有点到这条路径的长度的最大值。\n\n考虑到只有两种情况：\n\n+ 在树的直径上叉出来的一支\n+ 路径上的两个端点到同侧直径端点的距离\n\n第一个先$O(n)$预处理出来，第二个记录直径的一个端点到直径上所有点的距离，然后可以$O(1)$的计算。\n\n我们枚举路径的右端点$r$，然后把左端点$l$推到最左侧可以满足 $d \\leq S$ 的点，这个过程是$O(n)$的，注意到$l,r$都是单调递增的，我们可以用一个单调队列维护$[l,r]$的最大值，然后再与第二个情况取一个$max$。然后最小值就是我们的$ans$。\n\n总时间复杂度$O(n)$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cctype>\n#define pp pair<int,int>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 310000;\n\nstruct Edge{\n    int from,to;\n    int len;\n};\n\nint n,k;\nvector<Edge> edge[MAXN];\n\nvoid init(){\n    read(n),read(k);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        edge[a].push_back((Edge){a,b,c});\n        edge[b].push_back((Edge){b,a,c});\n    }\n}\n\nint dis[MAXN],f[MAXN];\n\nvoid dfs(int nown,int fa){\n    f[nown] = fa;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i].to,l = edge[nown][i].len;\n        if(v == f[nown]) continue;\n        dis[v] = dis[nown] + l;\n        dfs(v,nown);\n    }\n}\n\nint getmax(int nown){\n    int ans = dis[nown];\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i].to;\n        if(v == f[nown]) continue; \n        ans = max(ans,getmax(v));\n    }\n    return ans;\n}\n\nint num[MAXN],d[MAXN],maxn[MAXN],tot = 0;\n\nvoid build(){\n    int u = 0,v = 0;\n    dis[1] = 0;\n    dfs(1,0);\n    for(int i = 1;i<=n;i++)\n        if(dis[u] < dis[i]) u = i;\n    dis[u] = 0;\n    dfs(u,0);\n    for(int i = 1;i<=n;i++)\n        if(dis[v] < dis[i]) v = i;\n    for(int i = v;i;i = f[i])\n        num[++tot] = i;\n    reverse(num+1,num+tot+1);\n    for(int i = 1;i<=tot;i++)\n        d[i] = dis[num[i]];\n    for(int i = 1;i<=tot;i++){\n        int nown = num[i];\n        for(int j = 0;j<edge[nown].size();j++){\n            int v = edge[nown][j].to;\n            if(v == num[i+1] || v == num[i-1]) continue;\n            maxn[i] = max(maxn[i],getmax(v));\n        }\n        if(maxn[i]) maxn[i] -= d[i];\n    }\n}\n\nvoid solve(){\n    deque<pp> q;\n    int l = 1,ans = 0x3f3f3f3f;\n    \n    for(int i = 1;i<=tot;i++){\n        while(!q.empty() && q.back().second < maxn[i])\n            q.pop_back();\n        q.push_back(make_pair(i,maxn[i]));\n        while(d[i] - d[l] > k)\n            l++;\n        while(!q.empty() && q.front().first < l)\n            q.pop_front();\n        ans = min(ans,max(max(d[l],d[tot] - d[i]),q.front().second));\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SDOI2011」消防-树的直径-单调队列.md","raw":"---\ntitle: 「SDOI2011」消防-树的直径+单调队列\nurlname: SDOI2011-fireman\ndate: 2018-05-21 20:11:00\ntags:\n- 题解\n- 单调队列\n- 树的直径\n- 树形结构\ncategories: OI\nvisible:\n---\n\n某个国家有$n$个城市，这$n$个点之间的边构成一棵树。\n\n现求一条边长度和不超过$S$的路径（两端都是城市，可以只为一个城市），使得所有城市到这条路径的距离的最大值最小，并输出这个最小值。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2491](https://www.luogu.org/problemnew/show/P2491)\n\n## 题解\n\n很有趣的题。\n\n很明显，这条路径必须全部位于直径上。具体证明不会，大概可以感性理解一下。\n\n那么我们就要考虑，在直径上选出一段长度不大于S的路径，如何维护这颗树上的所有点到这条路径的长度的最大值。\n\n考虑到只有两种情况：\n\n+ 在树的直径上叉出来的一支\n+ 路径上的两个端点到同侧直径端点的距离\n\n第一个先$O(n)$预处理出来，第二个记录直径的一个端点到直径上所有点的距离，然后可以$O(1)$的计算。\n\n我们枚举路径的右端点$r$，然后把左端点$l$推到最左侧可以满足 $d \\leq S$ 的点，这个过程是$O(n)$的，注意到$l,r$都是单调递增的，我们可以用一个单调队列维护$[l,r]$的最大值，然后再与第二个情况取一个$max$。然后最小值就是我们的$ans$。\n\n总时间复杂度$O(n)$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cctype>\n#define pp pair<int,int>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 310000;\n\nstruct Edge{\n    int from,to;\n    int len;\n};\n\nint n,k;\nvector<Edge> edge[MAXN];\n\nvoid init(){\n    read(n),read(k);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        edge[a].push_back((Edge){a,b,c});\n        edge[b].push_back((Edge){b,a,c});\n    }\n}\n\nint dis[MAXN],f[MAXN];\n\nvoid dfs(int nown,int fa){\n    f[nown] = fa;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i].to,l = edge[nown][i].len;\n        if(v == f[nown]) continue;\n        dis[v] = dis[nown] + l;\n        dfs(v,nown);\n    }\n}\n\nint getmax(int nown){\n    int ans = dis[nown];\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i].to;\n        if(v == f[nown]) continue; \n        ans = max(ans,getmax(v));\n    }\n    return ans;\n}\n\nint num[MAXN],d[MAXN],maxn[MAXN],tot = 0;\n\nvoid build(){\n    int u = 0,v = 0;\n    dis[1] = 0;\n    dfs(1,0);\n    for(int i = 1;i<=n;i++)\n        if(dis[u] < dis[i]) u = i;\n    dis[u] = 0;\n    dfs(u,0);\n    for(int i = 1;i<=n;i++)\n        if(dis[v] < dis[i]) v = i;\n    for(int i = v;i;i = f[i])\n        num[++tot] = i;\n    reverse(num+1,num+tot+1);\n    for(int i = 1;i<=tot;i++)\n        d[i] = dis[num[i]];\n    for(int i = 1;i<=tot;i++){\n        int nown = num[i];\n        for(int j = 0;j<edge[nown].size();j++){\n            int v = edge[nown][j].to;\n            if(v == num[i+1] || v == num[i-1]) continue;\n            maxn[i] = max(maxn[i],getmax(v));\n        }\n        if(maxn[i]) maxn[i] -= d[i];\n    }\n}\n\nvoid solve(){\n    deque<pp> q;\n    int l = 1,ans = 0x3f3f3f3f;\n    \n    for(int i = 1;i<=tot;i++){\n        while(!q.empty() && q.back().second < maxn[i])\n            q.pop_back();\n        q.push_back(make_pair(i,maxn[i]));\n        while(d[i] - d[l] > k)\n            l++;\n        while(!q.empty() && q.front().first < l)\n            q.pop_front();\n        ans = min(ans,max(max(d[l],d[tot] - d[i]),q.front().second));\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SDOI2011」消防-树的直径-单调队列","published":1,"updated":"2018-05-21T13:10:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3kh004ibljrmum4rael","content":"<p>某个国家有$n$个城市，这$n$个点之间的边构成一棵树。</p>\n<p>现求一条边长度和不超过$S$的路径（两端都是城市，可以只为一个城市），使得所有城市到这条路径的距离的最大值最小，并输出这个最小值。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2491\" target=\"_blank\" rel=\"noopener\">Luogu P2491</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很有趣的题。</p>\n<p>很明显，这条路径必须全部位于直径上。具体证明不会，大概可以感性理解一下。</p>\n<p>那么我们就要考虑，在直径上选出一段长度不大于S的路径，如何维护这颗树上的所有点到这条路径的长度的最大值。</p>\n<p>考虑到只有两种情况：</p>\n<ul>\n<li>在树的直径上叉出来的一支</li>\n<li>路径上的两个端点到同侧直径端点的距离</li>\n</ul>\n<p>第一个先$O(n)$预处理出来，第二个记录直径的一个端点到直径上所有点的距离，然后可以$O(1)$的计算。</p>\n<p>我们枚举路径的右端点$r$，然后把左端点$l$推到最左侧可以满足 $d \\leq S$ 的点，这个过程是$O(n)$的，注意到$l,r$都是单调递增的，我们可以用一个单调队列维护$[l,r]$的最大值，然后再与第二个情况取一个$max$。然后最小值就是我们的$ans$。</p>\n<p>总时间复杂度$O(n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pp pair<span class=\"meta-string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">310000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Edge&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        edge[a].push_back((Edge)&#123;a,b,c&#125;);</span><br><span class=\"line\">        edge[b].push_back((Edge)&#123;b,a,c&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[MAXN],f[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">    f[nown] = fa;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i].to,l = edge[nown][i].len;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == f[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dis[v] = dis[nown] + l;</span><br><span class=\"line\">        dfs(v,nown);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getmax</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = dis[nown];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == f[nown]) <span class=\"keyword\">continue</span>; </span><br><span class=\"line\">        ans = max(ans,getmax(v));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> num[MAXN],d[MAXN],maxn[MAXN],tot = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> u = <span class=\"number\">0</span>,v = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dis[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[u] &lt; dis[i]) u = i;</span><br><span class=\"line\">    dis[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dfs(u,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[v] &lt; dis[i]) v = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = v;i;i = f[i])</span><br><span class=\"line\">        num[++tot] = i;</span><br><span class=\"line\">    reverse(num+<span class=\"number\">1</span>,num+tot+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=tot;i++)</span><br><span class=\"line\">        d[i] = dis[num[i]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = num[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;edge[nown].size();j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = edge[nown][j].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(v == num[i+<span class=\"number\">1</span>] || v == num[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            maxn[i] = max(maxn[i],getmax(v));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxn[i]) maxn[i] -= d[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">deque</span>&lt;pp&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty() &amp;&amp; q.back().second &lt; maxn[i])</span><br><span class=\"line\">            q.pop_back();</span><br><span class=\"line\">        q.push_back(make_pair(i,maxn[i]));</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(d[i] - d[l] &gt; k)</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.empty() &amp;&amp; q.front().first &lt; l)</span><br><span class=\"line\">            q.pop_front();</span><br><span class=\"line\">        ans = min(ans,max(max(d[l],d[tot] - d[i]),q.front().second));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>某个国家有$n$个城市，这$n$个点之间的边构成一棵树。</p>\n<p>现求一条边长度和不超过$S$的路径（两端都是城市，可以只为一个城市），使得所有城市到这条路径的距离的最大值最小，并输出这个最小值。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2491\" target=\"_blank\" rel=\"noopener\">Luogu P2491</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很有趣的题。</p>\n<p>很明显，这条路径必须全部位于直径上。具体证明不会，大概可以感性理解一下。</p>\n<p>那么我们就要考虑，在直径上选出一段长度不大于S的路径，如何维护这颗树上的所有点到这条路径的长度的最大值。</p>\n<p>考虑到只有两种情况：</p>\n<ul>\n<li>在树的直径上叉出来的一支</li>\n<li>路径上的两个端点到同侧直径端点的距离</li>\n</ul>\n<p>第一个先$O(n)$预处理出来，第二个记录直径的一个端点到直径上所有点的距离，然后可以$O(1)$的计算。</p>\n<p>我们枚举路径的右端点$r$，然后把左端点$l$推到最左侧可以满足 $d \\leq S$ 的点，这个过程是$O(n)$的，注意到$l,r$都是单调递增的，我们可以用一个单调队列维护$[l,r]$的最大值，然后再与第二个情况取一个$max$。然后最小值就是我们的$ans$。</p>\n<p>总时间复杂度$O(n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�52-->\n\n</div></div>"},{"title":"「SDOI2013」森林-主席树+LCA+启发式合并","urlname":"SDOI2013-forest","date":"2018-05-21T12:10:00.000Z","visible":null,"_content":"\n小Z有一片森林，含有$N$个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有$M$条边。\n\n小Z希望执行$T$个操作，操作有两类：\n\n+ `Q x y k`查询点$x$到点$y$路径上所有的权值中，第$k$小的权值是多少。此操作保证点$x$和点$y$连通，同时这两个节点的路径上至少有$k$个点。\n\n+ `L x y`在点$x$和点$y$之间连接一条边。保证完成此操作后，仍然是一片森林。\n\n强制在线。\n\n对于所有的数据$n,m,T \\leq 8 \\times 10^4$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3302](https://www.luogu.org/problemnew/show/P3302)\n\n## 题解\n\n恶心的大数据结构。\n\n对于合并操作，我们会想到`LCT`，而对于查询路径上的第$k$大，又让我们想到主席树。\n\n只能牺牲一种操作。注意到这里没有`cut`，所以我们可以通过启发式合并的方式，减少一个$\\log$。\n\n用并查集维护森林的大小，每次合并的时候强势暴力dfs修改树上路径主席树，以及求`lca`的倍增数组即可。\n\n然后就是常规操作了。\n\n需要用离散化，这里用了$map$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <map>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 81000,maxb = 20,logn = 500;\n\nnamespace prSegTree{\n    int sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 1;\n    #define mid ((l+r)>>1)\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];\n        sumn[nown] = sumn[pre] + d;\n        if(l == r) return;\n        else{\n            if(pos <= mid) insert(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    int query(int x1,int x2,int y1,int y2,int l,int r,int k){\n        if(l == r) return l;\n        else{\n            int sum = sumn[ls[x1]] + sumn[ls[x2]] - sumn[ls[y1]] - sumn[ls[y2]];\n            if(k <= sum) return query(ls[x1],ls[x2],ls[y1],ls[y2],l,mid,k);\n            if(sum+1 <= k) return query(rs[x1],rs[x2],rs[y1],rs[y2],mid+1,r,k-sum);\n        }\n    }\n    void build(int &nown,int l,int r){\n        nown = ++cnt;\n        if(l == r) return;\n        else{\n            build(ls[nown],l,mid);\n            build(rs[nown],mid+1,r);\n        }\n    }\n}\n\nint fir[MAXN];\nint to[MAXN*2],nex[MAXN*2],ecnt = 1;\n\nint n,m,q,num[MAXN],last[MAXN],tot = 0;\nint rt[MAXN];\nint f[MAXN][maxb],dep[MAXN];\nmap<int,int> S;\n\nvoid addedge(int u,int v){\n    to[ecnt] = v,nex[ecnt] = fir[u],fir[u] = ecnt++;\n    to[ecnt] = u,nex[ecnt] = fir[v],fir[v] = ecnt++;\n}\n\nnamespace BCJ{\n    int f[MAXN],siz[MAXN];\n    int find(int x){\n        return f[x]==x?x:find(f[x]);\n    }\n    int query(int x){\n        return siz[find(x)];\n    }\n    void un(int x,int y){\n        //y->x\n        int xx = find(x),yy = find(y);\n        f[yy] = xx;siz[xx] += siz[yy];\n    }\n    void init(){\n        for(int i = 1;i<=n;i++)\n            f[i] = i,siz[i] = 1;\n    }\n}\n\nvoid pre_dfs(int nown,int fa,int depth){\n    prSegTree::insert(rt[nown],rt[fa],1,tot,S[num[nown]],1);\n    dep[nown] = depth;\n    f[nown][0] = fa;\n    for(int j = 1;j<maxb;j++)\n        f[nown][j] = f[ f[nown][j-1] ][j-1];\n    for(int i = fir[nown];i;i=nex[i]){\n        int v = to[i];\n        if(v == fa) continue;\n        pre_dfs(v,nown,depth+1);\n    }\n}\n\nint lca(int u,int v){\n    if(dep[u] < dep[v]) swap(u,v);\n    for(int j = maxb-1;j>=0;j--)\n        if(dep[f[u][j]] >= dep[v])\n            u = f[u][j];\n    if(u == v) return u;\n    for(int j = maxb-1;j>=0;j--)\n        if(f[u][j] != f[v][j])\n            u = f[u][j],v = f[v][j];\n    return f[u][0]; \n}\n\nvoid init(){\n    int T;\n    read(T);\n    read(n),read(m),read(q);\n    BCJ::init();\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        S[num[i]] = 0;\n    }\n    for(map<int,int>::iterator it = S.begin();it!=S.end();it++){\n        it->second = ++tot;last[tot] = it->first;\n    }\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        addedge(a,b);\n        BCJ::un(a,b);\n    }\n}\n\nvoid build(){\n    for(int i = 1;i<=n;i++){\n        if(BCJ::find(i)==i)\n            pre_dfs(i,0,1);\n    }\n}\n\nvoid link(int u,int v){\n    addedge(u,v);\n    if(BCJ::query(u) < BCJ::query(v)) swap(u,v);\n    pre_dfs(v,u,dep[u]+1);\n    BCJ::un(u,v);\n}\n\nint query(int u,int v,int k){\n    int l = lca(u,v),fl = f[l][0];\n    int ans = prSegTree::query(rt[u],rt[v],rt[l],rt[fl],1,tot,k);\n    //printf(\"query: u:%d v:%d l:%d fl:%d k:%d ANS:%d\\n\",u,v,l,fl,k,ans);\n    return last[ans];\n}\n\nvoid solve(){\n    char op[10];int a,b,k,last = 0;\n    for(int i = 1;i<=q;i++){\n        read(op);read(a),read(b);\n        a^=last,b^=last;\n        if(op[0] == 'L')\n            link(a,b);\n        else if(op[0] == 'Q')\n            read(k),k^=last,print(last = query(a,b,k)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「SDOI2013」森林-主席树-LCA-启发式合并.md","raw":"---\ntitle: 「SDOI2013」森林-主席树+LCA+启发式合并\nurlname: SDOI2013-forest\ndate: 2018-05-21 20:10:00\ntags:\n- 题解\n- 可持久化线段树\n- 最近公共祖先\n- 启发式合并\ncategories: OI\nvisible:\n---\n\n小Z有一片森林，含有$N$个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有$M$条边。\n\n小Z希望执行$T$个操作，操作有两类：\n\n+ `Q x y k`查询点$x$到点$y$路径上所有的权值中，第$k$小的权值是多少。此操作保证点$x$和点$y$连通，同时这两个节点的路径上至少有$k$个点。\n\n+ `L x y`在点$x$和点$y$之间连接一条边。保证完成此操作后，仍然是一片森林。\n\n强制在线。\n\n对于所有的数据$n,m,T \\leq 8 \\times 10^4$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3302](https://www.luogu.org/problemnew/show/P3302)\n\n## 题解\n\n恶心的大数据结构。\n\n对于合并操作，我们会想到`LCT`，而对于查询路径上的第$k$大，又让我们想到主席树。\n\n只能牺牲一种操作。注意到这里没有`cut`，所以我们可以通过启发式合并的方式，减少一个$\\log$。\n\n用并查集维护森林的大小，每次合并的时候强势暴力dfs修改树上路径主席树，以及求`lca`的倍增数组即可。\n\n然后就是常规操作了。\n\n需要用离散化，这里用了$map$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <map>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 81000,maxb = 20,logn = 500;\n\nnamespace prSegTree{\n    int sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 1;\n    #define mid ((l+r)>>1)\n    void insert(int &nown,int pre,int l,int r,int pos,int d){\n        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];\n        sumn[nown] = sumn[pre] + d;\n        if(l == r) return;\n        else{\n            if(pos <= mid) insert(ls[nown],ls[pre],l,mid,pos,d);\n            if(mid+1 <= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d);\n        }\n    }\n    int query(int x1,int x2,int y1,int y2,int l,int r,int k){\n        if(l == r) return l;\n        else{\n            int sum = sumn[ls[x1]] + sumn[ls[x2]] - sumn[ls[y1]] - sumn[ls[y2]];\n            if(k <= sum) return query(ls[x1],ls[x2],ls[y1],ls[y2],l,mid,k);\n            if(sum+1 <= k) return query(rs[x1],rs[x2],rs[y1],rs[y2],mid+1,r,k-sum);\n        }\n    }\n    void build(int &nown,int l,int r){\n        nown = ++cnt;\n        if(l == r) return;\n        else{\n            build(ls[nown],l,mid);\n            build(rs[nown],mid+1,r);\n        }\n    }\n}\n\nint fir[MAXN];\nint to[MAXN*2],nex[MAXN*2],ecnt = 1;\n\nint n,m,q,num[MAXN],last[MAXN],tot = 0;\nint rt[MAXN];\nint f[MAXN][maxb],dep[MAXN];\nmap<int,int> S;\n\nvoid addedge(int u,int v){\n    to[ecnt] = v,nex[ecnt] = fir[u],fir[u] = ecnt++;\n    to[ecnt] = u,nex[ecnt] = fir[v],fir[v] = ecnt++;\n}\n\nnamespace BCJ{\n    int f[MAXN],siz[MAXN];\n    int find(int x){\n        return f[x]==x?x:find(f[x]);\n    }\n    int query(int x){\n        return siz[find(x)];\n    }\n    void un(int x,int y){\n        //y->x\n        int xx = find(x),yy = find(y);\n        f[yy] = xx;siz[xx] += siz[yy];\n    }\n    void init(){\n        for(int i = 1;i<=n;i++)\n            f[i] = i,siz[i] = 1;\n    }\n}\n\nvoid pre_dfs(int nown,int fa,int depth){\n    prSegTree::insert(rt[nown],rt[fa],1,tot,S[num[nown]],1);\n    dep[nown] = depth;\n    f[nown][0] = fa;\n    for(int j = 1;j<maxb;j++)\n        f[nown][j] = f[ f[nown][j-1] ][j-1];\n    for(int i = fir[nown];i;i=nex[i]){\n        int v = to[i];\n        if(v == fa) continue;\n        pre_dfs(v,nown,depth+1);\n    }\n}\n\nint lca(int u,int v){\n    if(dep[u] < dep[v]) swap(u,v);\n    for(int j = maxb-1;j>=0;j--)\n        if(dep[f[u][j]] >= dep[v])\n            u = f[u][j];\n    if(u == v) return u;\n    for(int j = maxb-1;j>=0;j--)\n        if(f[u][j] != f[v][j])\n            u = f[u][j],v = f[v][j];\n    return f[u][0]; \n}\n\nvoid init(){\n    int T;\n    read(T);\n    read(n),read(m),read(q);\n    BCJ::init();\n    for(int i = 1;i<=n;i++){\n        read(num[i]);\n        S[num[i]] = 0;\n    }\n    for(map<int,int>::iterator it = S.begin();it!=S.end();it++){\n        it->second = ++tot;last[tot] = it->first;\n    }\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        addedge(a,b);\n        BCJ::un(a,b);\n    }\n}\n\nvoid build(){\n    for(int i = 1;i<=n;i++){\n        if(BCJ::find(i)==i)\n            pre_dfs(i,0,1);\n    }\n}\n\nvoid link(int u,int v){\n    addedge(u,v);\n    if(BCJ::query(u) < BCJ::query(v)) swap(u,v);\n    pre_dfs(v,u,dep[u]+1);\n    BCJ::un(u,v);\n}\n\nint query(int u,int v,int k){\n    int l = lca(u,v),fl = f[l][0];\n    int ans = prSegTree::query(rt[u],rt[v],rt[l],rt[fl],1,tot,k);\n    //printf(\"query: u:%d v:%d l:%d fl:%d k:%d ANS:%d\\n\",u,v,l,fl,k,ans);\n    return last[ans];\n}\n\nvoid solve(){\n    char op[10];int a,b,k,last = 0;\n    for(int i = 1;i<=q;i++){\n        read(op);read(a),read(b);\n        a^=last,b^=last;\n        if(op[0] == 'L')\n            link(a,b);\n        else if(op[0] == 'Q')\n            read(k),k^=last,print(last = query(a,b,k)),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「SDOI2013」森林-主席树-LCA-启发式合并","published":1,"updated":"2018-06-07T15:06:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3kj004mbljrximb5fi7","content":"<p>小Z有一片森林，含有$N$个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有$M$条边。</p>\n<p>小Z希望执行$T$个操作，操作有两类：</p>\n<ul>\n<li><p><code>Q x y k</code>查询点$x$到点$y$路径上所有的权值中，第$k$小的权值是多少。此操作保证点$x$和点$y$连通，同时这两个节点的路径上至少有$k$个点。</p>\n</li>\n<li><p><code>L x y</code>在点$x$和点$y$之间连接一条边。保证完成此操作后，仍然是一片森林。</p>\n</li>\n</ul>\n<p>强制在线。</p>\n<p>对于所有的数据$n,m,T \\leq 8 \\times 10^4$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3302\" target=\"_blank\" rel=\"noopener\">Luogu P3302</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>恶心的大数据结构。</p>\n<p>对于合并操作，我们会想到<code>LCT</code>，而对于查询路径上的第$k$大，又让我们想到主席树。</p>\n<p>只能牺牲一种操作。注意到这里没有<code>cut</code>，所以我们可以通过启发式合并的方式，减少一个$\\log$。</p>\n<p>用并查集维护森林的大小，每次合并的时候强势暴力dfs修改树上路径主席树，以及求<code>lca</code>的倍增数组即可。</p>\n<p>然后就是常规操作了。</p>\n<p>需要用离散化，这里用了$map$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">81000</span>,maxb = <span class=\"number\">20</span>,logn = <span class=\"number\">500</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> prSegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> pre,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre];</span><br><span class=\"line\">        sumn[nown] = sumn[pre] + d;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos &lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= pos) insert(rs[nown],rs[pre],mid+<span class=\"number\">1</span>,r,pos,d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x1,<span class=\"keyword\">int</span> x2,<span class=\"keyword\">int</span> y1,<span class=\"keyword\">int</span> y2,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = sumn[ls[x1]] + sumn[ls[x2]] - sumn[ls[y1]] - sumn[ls[y2]];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(k &lt;= sum) <span class=\"keyword\">return</span> query(ls[x1],ls[x2],ls[y1],ls[y2],l,mid,k);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum+<span class=\"number\">1</span> &lt;= k) <span class=\"keyword\">return</span> query(rs[x1],rs[x2],rs[y1],rs[y2],mid+<span class=\"number\">1</span>,r,k-sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        nown = ++cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            build(ls[nown],l,mid);</span><br><span class=\"line\">            build(rs[nown],mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> to[MAXN*<span class=\"number\">2</span>],nex[MAXN*<span class=\"number\">2</span>],ecnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,q,num[MAXN],last[MAXN],tot = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rt[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAXN][maxb],dep[MAXN];</span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; S;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    to[ecnt] = v,nex[ecnt] = fir[u],fir[u] = ecnt++;</span><br><span class=\"line\">    to[ecnt] = u,nex[ecnt] = fir[v],fir[v] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> BCJ&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> f[MAXN],siz[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f[x]==x?x:find(f[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> siz[find(x)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">un</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//y-&gt;x</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> xx = find(x),yy = find(y);</span><br><span class=\"line\">        f[yy] = xx;siz[xx] += siz[yy];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            f[i] = i,siz[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pre_dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    prSegTree::insert(rt[nown],rt[fa],<span class=\"number\">1</span>,tot,S[num[nown]],<span class=\"number\">1</span>);</span><br><span class=\"line\">    dep[nown] = depth;</span><br><span class=\"line\">    f[nown][<span class=\"number\">0</span>] = fa;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;maxb;j++)</span><br><span class=\"line\">        f[nown][j] = f[ f[nown][j<span class=\"number\">-1</span>] ][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = fir[nown];i;i=nex[i])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = to[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        pre_dfs(v,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[u] &lt; dep[v]) swap(u,v);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = maxb<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[f[u][j]] &gt;= dep[v])</span><br><span class=\"line\">            u = f[u][j];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(u == v) <span class=\"keyword\">return</span> u;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = maxb<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f[u][j] != f[v][j])</span><br><span class=\"line\">            u = f[u][j],v = f[v][j];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f[u][<span class=\"number\">0</span>]; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;</span><br><span class=\"line\">    read(T);</span><br><span class=\"line\">    read(n),read(m),read(q);</span><br><span class=\"line\">    BCJ::init();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">        S[num[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt;::iterator it = S.begin();it!=S.end();it++)&#123;</span><br><span class=\"line\">        it-&gt;second = ++tot;last[tot] = it-&gt;first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        addedge(a,b);</span><br><span class=\"line\">        BCJ::un(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(BCJ::find(i)==i)</span><br><span class=\"line\">            pre_dfs(i,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">    addedge(u,v);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(BCJ::query(u) &lt; BCJ::query(v)) swap(u,v);</span><br><span class=\"line\">    pre_dfs(v,u,dep[u]+<span class=\"number\">1</span>);</span><br><span class=\"line\">    BCJ::un(u,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = lca(u,v),fl = f[l][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = prSegTree::query(rt[u],rt[v],rt[l],rt[fl],<span class=\"number\">1</span>,tot,k);</span><br><span class=\"line\">    <span class=\"comment\">//printf(\"query: u:%d v:%d l:%d fl:%d k:%d ANS:%d\\n\",u,v,l,fl,k,ans);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> last[ans];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];<span class=\"keyword\">int</span> a,b,k,last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=q;i++)&#123;</span><br><span class=\"line\">        read(op);read(a),read(b);</span><br><span class=\"line\">        a^=last,b^=last;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'L'</span>)</span><br><span class=\"line\">            link(a,b);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)</span><br><span class=\"line\">            read(k),k^=last,print(last = query(a,b,k)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>小Z有一片森林，含有$N$个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有$M$条边。</p>\n<p>小Z希望执行$T$个操作，操作有两类：</p>\n<ul>\n<li><p><code>Q x y k</code>查询点$x$到点$y$路径上所有的权值中，第$k$小的权值是多少。此操作保证点$x$和点$y$连通，同时这两个节点的路径上至少有$k$个点。</p>\n</li>\n<li><p><code>L x y</code>在点$x$和点$y$之间连接一条边。保证完成此操作后，仍然是一片森林。</p>\n</li>\n</ul>\n<p>强制在线。</p>\n<p>对于所有的数据$n,m,T \\leq 8 \\times 10^4$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3302\" target=\"_blank\" rel=\"noopener\">Luogu P3302</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>恶心的大数据结构。</p>\n<p>对于合并操作，我们会想到<code>LCT</code>，而对于查询路径上的第$k$大，又让我们想到主席树。</p>\n<p>只能牺牲一种操作。注意到这里没有<code>cut</code>，所以我们可以通过启发式合并的方式，减少一个$\\log$。</p>\n<p>用并查集维护森林的大小，每次合并的时候强势暴力dfs修改树上路径主席树，以及求<code>lca</code>的倍增数组即可。</p>\n<p>然后就是常规操作了。</p>\n<p>需要用离散化，这里用了$map$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�53-->\n\n</div></div>"},{"title":"「SDOI2013」直径-树的直径","urlname":"SDOI2013-diameter","date":"2018-05-12T10:04:01.000Z","visible":null,"_content":"\n定义一棵树上最长的路径为树的直径。树的直径可能不唯一。\n\n给定的一棵$n$个结点的树，求其直径的长度，以及有多少条边满足所有的直径都经过该边。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3304](https://www.luogu.org/problemnew/show/P3304)\n\n[BZOJ 3124](https://www.lydsy.com/JudgeOnline/problem.php?id=3124)\n\n## 题解\n\n很有趣的一道题\n\n首先找直径。先从任取点$t$出发，到达最远的一个点$u$。再从$u$出发，到达最远的点$v$，$u$，$v$之间的路径即为树的直径。\n\n这比较显然。\n\n令$\\delta (u,v)$为$u,v$两点间路径，其数值即为路径长度。\n\n**引理**：在一棵树中，$x$、$y$ 和 $z$ 是三个不同的结点。当 $x$ 到 $y$ 的最短路与 $y$ 到 $z$ 的最短路不重合时，$x$ 到 $z$ 的最短路就是这两条最短路的拼接。\n\n**定理1**：在一棵树中，以任意结点出发所能到达的最远结点，一定是该树直径的端点之一。\n\n**证明**：假设这条直径是$\\delta (u,v)$。分两种情况：\n\n当出发结点 $y$ 在$\\delta(u,v)$上时，假设到达的最远结点 $z$ 不是 $u,v$ 中的任一个。这时将$\\delta(y,z)$与不与之重合的$\\delta(y,u)$拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的路径，矛盾。\n\n当出发结点 $y$ 不在$\\delta(u,v)$上时，分两种情况：\n\n+ 当 $y$ 到达的最远结点 $z$ 横穿$\\delta(u,v)$时，记与之相交的结点为 $x$。此时有$\\delta(y,z)=\\delta(y,x)+\\delta(x,z)$。而此时$\\delta(y,z)>\\delta(y,v)$，故可得$\\delta(x,z)>\\delta(x,v)$。由$1$的结论可知该假设不成立。\n\n+ 当 $y$ 到达的最远结点 $z$ 与$\\delta(u,v)$不相交时，记 $y$ 到 $v$ 的最短路首先与$\\delta(u,v)$相交的结点是 $x$。由假设$\\delta(y,z)>\\delta(y,x)+\\delta(x,v)$。而$\\delta(y,z)+\\delta(y,x)+\\delta(x,u)$又可以形成$\\delta(z,u)$，而$\\delta(z,u)>\\delta(x,u)+\\delta(x,v)+2\\delta(y,x)=\\delta(u,v)+2\\delta(y,x)$矛盾。\n\n- - -\n\n\n先求出了直径，我们就发现一件好玩的事情。\n\n**定理2**：对于一个边权为正数的树，其所有的直径必然两两有交点。\n\n**证明**：设树的一条直径为$\\delta (u,v)$，任取另一直径为$\\delta (u',v')$。其长度设为$d$。\n\n若两直径有公共部分，显然有公共点。\n\n若没有公共部分，则必有一条路径$\\delta (x,y)$连接两条直径，$x$在$\\delta (u,v)$上，$y$在$\\delta (u',v')$上。\n\n在$\\delta(u,x)$和$\\delta(x,v)$中，不妨设$\\delta(u,x) \\geq \\frac{1}{2} \\times d$。同理设$\\delta(u',y) \\geq \\frac{1}{2} \\times d$，又因为$\\delta (x,y) > 0$，所以$\\delta (u,u') = \\delta(u,x) + \\delta(x,y) + \\delta(y,u') > d = \\delta(u,v)$，矛盾。\n\n- - -\n\n我们要求的是有多少个边在在所有的直径上。我们已经求得了一条直径$\\delta(u,v)$。\n\n令$x$为在$\\delta(u,v)$上离$u$点最远的点，满足存在点$u'$，使得$\\delta(x,u') = \\delta(x,u)$，且$u \\neq u'$，则可得$\\delta(u',v)$也是一条直径。\n\n同理$y$为在$\\delta(u,v)$上离$v$点最远的点，满足存在点$v'$，使得$\\delta(x,v') = \\delta(x,v)$，且$v \\neq v'$，则可得$\\delta(u,v')$也是一条直径。\n\n这两个东西都可以在找出直径之后一边扫直径一边$dfs$出来。这个时候我们注意到，$x$应当在$y$左侧，且$x$在直径左半部，$y$在直径右半部，排列顺序大概是这个样子$u\\leftrightarrow x \\leftrightarrow y \\leftrightarrow v$。很容易看出，$x$与$y$之间的部分，就是所有直径的公共边。答案即为$\\delta(x,y)$。\n\n时间复杂度大约是一个常数比较大的$O(n)$。\n\n## 代码\n\n懒得写`bfs`，于是就比较的慢...\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {//快速输入模板\n    inline char read(){\n        static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x){\n        static bool iosig;static char c;\n        for (iosig=false,c=read();!isdigit(c);c=read()){\n            if(c=='-')iosig=true;if(c==-1)return;\n        }\n        for(x=0;isdigit(c);c=read())\n            x=((x+(x<<2))<<1)+(c^'0');\n        if(iosig)x=-x;\n    }\n}using namespace fast_io;\n\nconst int MAXN = 300000;\nstruct Edge{\n    int from,to,len;\n};\nint n,u=0,v=0,fa[MAXN];\nll dis[MAXN],ans1,ans2;\nvector<Edge> edge[MAXN];\nvoid addedge(int a,int b,int c){\n    edge[a].push_back((Edge){a,b,c});\n    edge[b].push_back((Edge){b,a,c});\n}\n\nvoid init(){\n    read(n);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n}\n\n\nvoid dfs(int nown,int f){//寻找从nown节点出发的最长路\n    fa[nown] = f;\n    for(int i = 0;i<edge[nown].size();i++){\n        Edge e = edge[nown][i];\n        if(e.to == f) continue;\n        dis[e.to] = dis[nown] + e.len;\n        dfs(e.to,nown);\n    }\n}\n\nvoid find(){\n    memset(dis,0,sizeof(dis));\n    dfs(1,0);\n    for(int i = 1;i<=n;i++)//第一次搜到的节点记作直径的一个端点u\n        if(dis[i] > dis[u])\n            u = i;\n    memset(dis,0,sizeof(dis));\n    dfs(u,0);\n    for(int i = 1;i<=n;i++)//第二次搜到的节点记作直径的另一个端点v\n        if(dis[i] > dis[v])\n            v = i;\n}\n\nbool dfs2(int nown,ll len){//dfs寻找是否从某个节点存在长度为len的路径\n    if(len == 0) return true;\n    for(int i = 0;i < edge[nown].size();i++){\n        Edge e = edge[nown][i];\n        if(e.to == fa[nown]) continue;\n        if(dfs2(e.to,len - e.len))\n            return true;\n    }\n    return false;\n}\n\nvoid solve(){\n    static int nex[MAXN];\n    int t = v,tmp = 0;//tmp为直径长度\n    while(t!=u){//记录从u到v的路径\n        nex[fa[t]] = t;\n        t = fa[t];\n        tmp++;\n    }\n    //l代表到右节点最近的满足上文性质的点，r代表到左节点最近的满足上文性质的点\n    int l = 0,r = tmp,nowt = 0;\n    //循环中dis[t] = d(u,t)\n    for(t = u;t!=v;t = nex[t]){\n        for(int i = 0;i<edge[t].size();i++){\n            Edge e = edge[t][i];\n            if(e.to == fa[t] || e.to == nex[t]) continue;\n            if(dfs2(e.to,dis[t] - e.len)) \n                l = max(nowt,l);//寻找离u最远的t,满足d(u',t) = d(u,t),得到即为x,名字叫做l\n            else if(dfs2(e.to,(dis[v] - dis[t])- e.len)) \n                r = min(r,nowt);//寻找离v最远的t,满足d(t,v') = d(t,v),得到即为y,名字叫做r\n        }\n        nowt++;\n    }\n    ans1 = dis[v];//直径长度\n    ans2 = r - l;//在这里事实上是求了r和l的位置并求出ans2\n}\n\n\nint main(){\n    init();\n    find();\n    solve();\n    printf(\"%lld\\n%lld\\n\",ans1,ans2);\n    return 0;   \n}\n```\n\n{% endfold %}","source":"_posts/「SDOI2013」直径-树的直径.md","raw":"---\ntitle: 「SDOI2013」直径-树的直径\nurlname: SDOI2013-diameter\ndate: 2018-05-12 18:04:01\ntags:\n- 题解\n- 图论\n- 树形结构\n- 树的直径\ncategories: OI\nvisible:\n---\n\n定义一棵树上最长的路径为树的直径。树的直径可能不唯一。\n\n给定的一棵$n$个结点的树，求其直径的长度，以及有多少条边满足所有的直径都经过该边。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3304](https://www.luogu.org/problemnew/show/P3304)\n\n[BZOJ 3124](https://www.lydsy.com/JudgeOnline/problem.php?id=3124)\n\n## 题解\n\n很有趣的一道题\n\n首先找直径。先从任取点$t$出发，到达最远的一个点$u$。再从$u$出发，到达最远的点$v$，$u$，$v$之间的路径即为树的直径。\n\n这比较显然。\n\n令$\\delta (u,v)$为$u,v$两点间路径，其数值即为路径长度。\n\n**引理**：在一棵树中，$x$、$y$ 和 $z$ 是三个不同的结点。当 $x$ 到 $y$ 的最短路与 $y$ 到 $z$ 的最短路不重合时，$x$ 到 $z$ 的最短路就是这两条最短路的拼接。\n\n**定理1**：在一棵树中，以任意结点出发所能到达的最远结点，一定是该树直径的端点之一。\n\n**证明**：假设这条直径是$\\delta (u,v)$。分两种情况：\n\n当出发结点 $y$ 在$\\delta(u,v)$上时，假设到达的最远结点 $z$ 不是 $u,v$ 中的任一个。这时将$\\delta(y,z)$与不与之重合的$\\delta(y,u)$拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的路径，矛盾。\n\n当出发结点 $y$ 不在$\\delta(u,v)$上时，分两种情况：\n\n+ 当 $y$ 到达的最远结点 $z$ 横穿$\\delta(u,v)$时，记与之相交的结点为 $x$。此时有$\\delta(y,z)=\\delta(y,x)+\\delta(x,z)$。而此时$\\delta(y,z)>\\delta(y,v)$，故可得$\\delta(x,z)>\\delta(x,v)$。由$1$的结论可知该假设不成立。\n\n+ 当 $y$ 到达的最远结点 $z$ 与$\\delta(u,v)$不相交时，记 $y$ 到 $v$ 的最短路首先与$\\delta(u,v)$相交的结点是 $x$。由假设$\\delta(y,z)>\\delta(y,x)+\\delta(x,v)$。而$\\delta(y,z)+\\delta(y,x)+\\delta(x,u)$又可以形成$\\delta(z,u)$，而$\\delta(z,u)>\\delta(x,u)+\\delta(x,v)+2\\delta(y,x)=\\delta(u,v)+2\\delta(y,x)$矛盾。\n\n- - -\n\n\n先求出了直径，我们就发现一件好玩的事情。\n\n**定理2**：对于一个边权为正数的树，其所有的直径必然两两有交点。\n\n**证明**：设树的一条直径为$\\delta (u,v)$，任取另一直径为$\\delta (u',v')$。其长度设为$d$。\n\n若两直径有公共部分，显然有公共点。\n\n若没有公共部分，则必有一条路径$\\delta (x,y)$连接两条直径，$x$在$\\delta (u,v)$上，$y$在$\\delta (u',v')$上。\n\n在$\\delta(u,x)$和$\\delta(x,v)$中，不妨设$\\delta(u,x) \\geq \\frac{1}{2} \\times d$。同理设$\\delta(u',y) \\geq \\frac{1}{2} \\times d$，又因为$\\delta (x,y) > 0$，所以$\\delta (u,u') = \\delta(u,x) + \\delta(x,y) + \\delta(y,u') > d = \\delta(u,v)$，矛盾。\n\n- - -\n\n我们要求的是有多少个边在在所有的直径上。我们已经求得了一条直径$\\delta(u,v)$。\n\n令$x$为在$\\delta(u,v)$上离$u$点最远的点，满足存在点$u'$，使得$\\delta(x,u') = \\delta(x,u)$，且$u \\neq u'$，则可得$\\delta(u',v)$也是一条直径。\n\n同理$y$为在$\\delta(u,v)$上离$v$点最远的点，满足存在点$v'$，使得$\\delta(x,v') = \\delta(x,v)$，且$v \\neq v'$，则可得$\\delta(u,v')$也是一条直径。\n\n这两个东西都可以在找出直径之后一边扫直径一边$dfs$出来。这个时候我们注意到，$x$应当在$y$左侧，且$x$在直径左半部，$y$在直径右半部，排列顺序大概是这个样子$u\\leftrightarrow x \\leftrightarrow y \\leftrightarrow v$。很容易看出，$x$与$y$之间的部分，就是所有直径的公共边。答案即为$\\delta(x,y)$。\n\n时间复杂度大约是一个常数比较大的$O(n)$。\n\n## 代码\n\n懒得写`bfs`，于是就比较的慢...\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nnamespace fast_io {//快速输入模板\n    inline char read(){\n        static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x){\n        static bool iosig;static char c;\n        for (iosig=false,c=read();!isdigit(c);c=read()){\n            if(c=='-')iosig=true;if(c==-1)return;\n        }\n        for(x=0;isdigit(c);c=read())\n            x=((x+(x<<2))<<1)+(c^'0');\n        if(iosig)x=-x;\n    }\n}using namespace fast_io;\n\nconst int MAXN = 300000;\nstruct Edge{\n    int from,to,len;\n};\nint n,u=0,v=0,fa[MAXN];\nll dis[MAXN],ans1,ans2;\nvector<Edge> edge[MAXN];\nvoid addedge(int a,int b,int c){\n    edge[a].push_back((Edge){a,b,c});\n    edge[b].push_back((Edge){b,a,c});\n}\n\nvoid init(){\n    read(n);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n}\n\n\nvoid dfs(int nown,int f){//寻找从nown节点出发的最长路\n    fa[nown] = f;\n    for(int i = 0;i<edge[nown].size();i++){\n        Edge e = edge[nown][i];\n        if(e.to == f) continue;\n        dis[e.to] = dis[nown] + e.len;\n        dfs(e.to,nown);\n    }\n}\n\nvoid find(){\n    memset(dis,0,sizeof(dis));\n    dfs(1,0);\n    for(int i = 1;i<=n;i++)//第一次搜到的节点记作直径的一个端点u\n        if(dis[i] > dis[u])\n            u = i;\n    memset(dis,0,sizeof(dis));\n    dfs(u,0);\n    for(int i = 1;i<=n;i++)//第二次搜到的节点记作直径的另一个端点v\n        if(dis[i] > dis[v])\n            v = i;\n}\n\nbool dfs2(int nown,ll len){//dfs寻找是否从某个节点存在长度为len的路径\n    if(len == 0) return true;\n    for(int i = 0;i < edge[nown].size();i++){\n        Edge e = edge[nown][i];\n        if(e.to == fa[nown]) continue;\n        if(dfs2(e.to,len - e.len))\n            return true;\n    }\n    return false;\n}\n\nvoid solve(){\n    static int nex[MAXN];\n    int t = v,tmp = 0;//tmp为直径长度\n    while(t!=u){//记录从u到v的路径\n        nex[fa[t]] = t;\n        t = fa[t];\n        tmp++;\n    }\n    //l代表到右节点最近的满足上文性质的点，r代表到左节点最近的满足上文性质的点\n    int l = 0,r = tmp,nowt = 0;\n    //循环中dis[t] = d(u,t)\n    for(t = u;t!=v;t = nex[t]){\n        for(int i = 0;i<edge[t].size();i++){\n            Edge e = edge[t][i];\n            if(e.to == fa[t] || e.to == nex[t]) continue;\n            if(dfs2(e.to,dis[t] - e.len)) \n                l = max(nowt,l);//寻找离u最远的t,满足d(u',t) = d(u,t),得到即为x,名字叫做l\n            else if(dfs2(e.to,(dis[v] - dis[t])- e.len)) \n                r = min(r,nowt);//寻找离v最远的t,满足d(t,v') = d(t,v),得到即为y,名字叫做r\n        }\n        nowt++;\n    }\n    ans1 = dis[v];//直径长度\n    ans2 = r - l;//在这里事实上是求了r和l的位置并求出ans2\n}\n\n\nint main(){\n    init();\n    find();\n    solve();\n    printf(\"%lld\\n%lld\\n\",ans1,ans2);\n    return 0;   \n}\n```\n\n{% endfold %}","slug":"「SDOI2013」直径-树的直径","published":1,"updated":"2018-05-12T12:44:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3km004pbljrg1nfg0wf","content":"<p>定义一棵树上最长的路径为树的直径。树的直径可能不唯一。</p>\n<p>给定的一棵$n$个结点的树，求其直径的长度，以及有多少条边满足所有的直径都经过该边。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3304\" target=\"_blank\" rel=\"noopener\">Luogu P3304</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3124\" target=\"_blank\" rel=\"noopener\">BZOJ 3124</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很有趣的一道题</p>\n<p>首先找直径。先从任取点$t$出发，到达最远的一个点$u$。再从$u$出发，到达最远的点$v$，$u$，$v$之间的路径即为树的直径。</p>\n<p>这比较显然。</p>\n<p>令$\\delta (u,v)$为$u,v$两点间路径，其数值即为路径长度。</p>\n<p><strong>引理</strong>：在一棵树中，$x$、$y$ 和 $z$ 是三个不同的结点。当 $x$ 到 $y$ 的最短路与 $y$ 到 $z$ 的最短路不重合时，$x$ 到 $z$ 的最短路就是这两条最短路的拼接。</p>\n<p><strong>定理1</strong>：在一棵树中，以任意结点出发所能到达的最远结点，一定是该树直径的端点之一。</p>\n<p><strong>证明</strong>：假设这条直径是$\\delta (u,v)$。分两种情况：</p>\n<p>当出发结点 $y$ 在$\\delta(u,v)$上时，假设到达的最远结点 $z$ 不是 $u,v$ 中的任一个。这时将$\\delta(y,z)$与不与之重合的$\\delta(y,u)$拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的路径，矛盾。</p>\n<p>当出发结点 $y$ 不在$\\delta(u,v)$上时，分两种情况：</p>\n<ul>\n<li><p>当 $y$ 到达的最远结点 $z$ 横穿$\\delta(u,v)$时，记与之相交的结点为 $x$。此时有$\\delta(y,z)=\\delta(y,x)+\\delta(x,z)$。而此时$\\delta(y,z)&gt;\\delta(y,v)$，故可得$\\delta(x,z)&gt;\\delta(x,v)$。由$1$的结论可知该假设不成立。</p>\n</li>\n<li><p>当 $y$ 到达的最远结点 $z$ 与$\\delta(u,v)$不相交时，记 $y$ 到 $v$ 的最短路首先与$\\delta(u,v)$相交的结点是 $x$。由假设$\\delta(y,z)&gt;\\delta(y,x)+\\delta(x,v)$。而$\\delta(y,z)+\\delta(y,x)+\\delta(x,u)$又可以形成$\\delta(z,u)$，而$\\delta(z,u)&gt;\\delta(x,u)+\\delta(x,v)+2\\delta(y,x)=\\delta(u,v)+2\\delta(y,x)$矛盾。</p>\n</li>\n</ul>\n<hr>\n<p>先求出了直径，我们就发现一件好玩的事情。</p>\n<p><strong>定理2</strong>：对于一个边权为正数的树，其所有的直径必然两两有交点。</p>\n<p><strong>证明</strong>：设树的一条直径为$\\delta (u,v)$，任取另一直径为$\\delta (u’,v’)$。其长度设为$d$。</p>\n<p>若两直径有公共部分，显然有公共点。</p>\n<p>若没有公共部分，则必有一条路径$\\delta (x,y)$连接两条直径，$x$在$\\delta (u,v)$上，$y$在$\\delta (u’,v’)$上。</p>\n<p>在$\\delta(u,x)$和$\\delta(x,v)$中，不妨设$\\delta(u,x) \\geq \\frac{1}{2} \\times d$。同理设$\\delta(u’,y) \\geq \\frac{1}{2} \\times d$，又因为$\\delta (x,y) &gt; 0$，所以$\\delta (u,u’) = \\delta(u,x) + \\delta(x,y) + \\delta(y,u’) &gt; d = \\delta(u,v)$，矛盾。</p>\n<hr>\n<p>我们要求的是有多少个边在在所有的直径上。我们已经求得了一条直径$\\delta(u,v)$。</p>\n<p>令$x$为在$\\delta(u,v)$上离$u$点最远的点，满足存在点$u’$，使得$\\delta(x,u’) = \\delta(x,u)$，且$u \\neq u’$，则可得$\\delta(u’,v)$也是一条直径。</p>\n<p>同理$y$为在$\\delta(u,v)$上离$v$点最远的点，满足存在点$v’$，使得$\\delta(x,v’) = \\delta(x,v)$，且$v \\neq v’$，则可得$\\delta(u,v’)$也是一条直径。</p>\n<p>这两个东西都可以在找出直径之后一边扫直径一边$dfs$出来。这个时候我们注意到，$x$应当在$y$左侧，且$x$在直径左半部，$y$在直径右半部，排列顺序大概是这个样子$u\\leftrightarrow x \\leftrightarrow y \\leftrightarrow v$。很容易看出，$x$与$y$之间的部分，就是所有直径的公共边。答案即为$\\delta(x,y)$。</p>\n<p>时间复杂度大约是一个常数比较大的$O(n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>懒得写<code>bfs</code>，于是就比较的慢…<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;<span class=\"comment\">//快速输入模板</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN=<span class=\"number\">1000000</span>;<span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN],*s,*t;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s==t?(((t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>))==s)?<span class=\"number\">-1</span>:*s++) : *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;<span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (iosig=<span class=\"literal\">false</span>,c=read();!<span class=\"built_in\">isdigit</span>(c);c=read())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c==<span class=\"string\">'-'</span>)iosig=<span class=\"literal\">true</span>;<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;<span class=\"built_in\">isdigit</span>(c);c=read())</span><br><span class=\"line\">            x=((x+(x&lt;&lt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(iosig)x=-x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">300000</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,len;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,u=<span class=\"number\">0</span>,v=<span class=\"number\">0</span>,fa[MAXN];</span><br><span class=\"line\">ll dis[MAXN],ans1,ans2;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Edge&gt; edge[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    edge[a].push_back((Edge)&#123;a,b,c&#125;);</span><br><span class=\"line\">    edge[b].push_back((Edge)&#123;b,a,c&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        addedge(a,b,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f)</span></span>&#123;<span class=\"comment\">//寻找从nown节点出发的最长路</span></span><br><span class=\"line\">    fa[nown] = f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        Edge e = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.to == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dis[e.to] = dis[nown] + e.len;</span><br><span class=\"line\">        dfs(e.to,nown);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//第一次搜到的节点记作直径的一个端点u</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[i] &gt; dis[u])</span><br><span class=\"line\">            u = i;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    dfs(u,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//第二次搜到的节点记作直径的另一个端点v</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[i] &gt; dis[v])</span><br><span class=\"line\">            v = i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,ll len)</span></span>&#123;<span class=\"comment\">//dfs寻找是否从某个节点存在长度为len的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; edge[nown].size();i++)&#123;</span><br><span class=\"line\">        Edge e = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(e.to == fa[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfs2(e.to,len - e.len))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nex[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> t = v,tmp = <span class=\"number\">0</span>;<span class=\"comment\">//tmp为直径长度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t!=u)&#123;<span class=\"comment\">//记录从u到v的路径</span></span><br><span class=\"line\">        nex[fa[t]] = t;</span><br><span class=\"line\">        t = fa[t];</span><br><span class=\"line\">        tmp++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//l代表到右节点最近的满足上文性质的点，r代表到左节点最近的满足上文性质的点</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,r = tmp,nowt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//循环中dis[t] = d(u,t)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(t = u;t!=v;t = nex[t])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[t].size();i++)&#123;</span><br><span class=\"line\">            Edge e = edge[t][i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(e.to == fa[t] || e.to == nex[t]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dfs2(e.to,dis[t] - e.len)) </span><br><span class=\"line\">                l = max(nowt,l);<span class=\"comment\">//寻找离u最远的t,满足d(u',t) = d(u,t),得到即为x,名字叫做l</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dfs2(e.to,(dis[v] - dis[t])- e.len)) </span><br><span class=\"line\">                r = min(r,nowt);<span class=\"comment\">//寻找离v最远的t,满足d(t,v') = d(t,v),得到即为y,名字叫做r</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nowt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans1 = dis[v];<span class=\"comment\">//直径长度</span></span><br><span class=\"line\">    ans2 = r - l;<span class=\"comment\">//在这里事实上是求了r和l的位置并求出ans2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    find();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\\n%lld\\n\"</span>,ans1,ans2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div></p>\n","site":{"data":{}},"excerpt":"<p>定义一棵树上最长的路径为树的直径。树的直径可能不唯一。</p>\n<p>给定的一棵$n$个结点的树，求其直径的长度，以及有多少条边满足所有的直径都经过该边。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3304\" target=\"_blank\" rel=\"noopener\">Luogu P3304</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3124\" target=\"_blank\" rel=\"noopener\">BZOJ 3124</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>很有趣的一道题</p>\n<p>首先找直径。先从任取点$t$出发，到达最远的一个点$u$。再从$u$出发，到达最远的点$v$，$u$，$v$之间的路径即为树的直径。</p>\n<p>这比较显然。</p>\n<p>令$\\delta (u,v)$为$u,v$两点间路径，其数值即为路径长度。</p>\n<p><strong>引理</strong>：在一棵树中，$x$、$y$ 和 $z$ 是三个不同的结点。当 $x$ 到 $y$ 的最短路与 $y$ 到 $z$ 的最短路不重合时，$x$ 到 $z$ 的最短路就是这两条最短路的拼接。</p>\n<p><strong>定理1</strong>：在一棵树中，以任意结点出发所能到达的最远结点，一定是该树直径的端点之一。</p>\n<p><strong>证明</strong>：假设这条直径是$\\delta (u,v)$。分两种情况：</p>\n<p>当出发结点 $y$ 在$\\delta(u,v)$上时，假设到达的最远结点 $z$ 不是 $u,v$ 中的任一个。这时将$\\delta(y,z)$与不与之重合的$\\delta(y,u)$拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的路径，矛盾。</p>\n<p>当出发结点 $y$ 不在$\\delta(u,v)$上时，分两种情况：</p>\n<ul>\n<li><p>当 $y$ 到达的最远结点 $z$ 横穿$\\delta(u,v)$时，记与之相交的结点为 $x$。此时有$\\delta(y,z)=\\delta(y,x)+\\delta(x,z)$。而此时$\\delta(y,z)&gt;\\delta(y,v)$，故可得$\\delta(x,z)&gt;\\delta(x,v)$。由$1$的结论可知该假设不成立。</p>\n</li>\n<li><p>当 $y$ 到达的最远结点 $z$ 与$\\delta(u,v)$不相交时，记 $y$ 到 $v$ 的最短路首先与$\\delta(u,v)$相交的结点是 $x$。由假设$\\delta(y,z)&gt;\\delta(y,x)+\\delta(x,v)$。而$\\delta(y,z)+\\delta(y,x)+\\delta(x,u)$又可以形成$\\delta(z,u)$，而$\\delta(z,u)&gt;\\delta(x,u)+\\delta(x,v)+2\\delta(y,x)=\\delta(u,v)+2\\delta(y,x)$矛盾。</p>\n</li>\n</ul>\n<hr>\n<p>先求出了直径，我们就发现一件好玩的事情。</p>\n<p><strong>定理2</strong>：对于一个边权为正数的树，其所有的直径必然两两有交点。</p>\n<p><strong>证明</strong>：设树的一条直径为$\\delta (u,v)$，任取另一直径为$\\delta (u’,v’)$。其长度设为$d$。</p>\n<p>若两直径有公共部分，显然有公共点。</p>\n<p>若没有公共部分，则必有一条路径$\\delta (x,y)$连接两条直径，$x$在$\\delta (u,v)$上，$y$在$\\delta (u’,v’)$上。</p>\n<p>在$\\delta(u,x)$和$\\delta(x,v)$中，不妨设$\\delta(u,x) \\geq \\frac{1}{2} \\times d$。同理设$\\delta(u’,y) \\geq \\frac{1}{2} \\times d$，又因为$\\delta (x,y) &gt; 0$，所以$\\delta (u,u’) = \\delta(u,x) + \\delta(x,y) + \\delta(y,u’) &gt; d = \\delta(u,v)$，矛盾。</p>\n<hr>\n<p>我们要求的是有多少个边在在所有的直径上。我们已经求得了一条直径$\\delta(u,v)$。</p>\n<p>令$x$为在$\\delta(u,v)$上离$u$点最远的点，满足存在点$u’$，使得$\\delta(x,u’) = \\delta(x,u)$，且$u \\neq u’$，则可得$\\delta(u’,v)$也是一条直径。</p>\n<p>同理$y$为在$\\delta(u,v)$上离$v$点最远的点，满足存在点$v’$，使得$\\delta(x,v’) = \\delta(x,v)$，且$v \\neq v’$，则可得$\\delta(u,v’)$也是一条直径。</p>\n<p>这两个东西都可以在找出直径之后一边扫直径一边$dfs$出来。这个时候我们注意到，$x$应当在$y$左侧，且$x$在直径左半部，$y$在直径右半部，排列顺序大概是这个样子$u\\leftrightarrow x \\leftrightarrow y \\leftrightarrow v$。很容易看出，$x$与$y$之间的部分，就是所有直径的公共边。答案即为$\\delta(x,y)$。</p>\n<p>时间复杂度大约是一个常数比较大的$O(n)$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>懒得写<code>bfs</code>，于是就比较的慢…<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�54-->\n\n</div></div></p>"},{"title":"「SDOI2014」旅行-树链剖分+动态开点线段树","urlname":"SDOI2014-journey","date":"2018-05-24T12:38:27.000Z","visible":null,"_content":"\n给定一棵$n$个节点的树，对于每个点都有两个权值$w_i,c_i$。\n\n存在$m$个操作，分为4类。\n\n+ “`CC x c`”：将$c_x$更改为$c$；\n\n+ “`CW x w`”：将$w_x$更改为$w$；\n\n+ “`QS x y`”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\sum w_i$；\n\n+ “`QM x y`”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\max(w_i)$；\n\n对于后两个操作，保证$c_x = c_y$。\n\n<!-- more -->\n\n对于所有数据，$n,m \\leq 10^5$，在任意时刻均满足$w_i \\leq 10^4,c_i \\leq 10^5,\\; w_i,c_i \\in \\mathbb{N}^+$。\n\n## 链接\n\n[Luogu P3313](https://www.luogu.org/problemnew/show/P3313)\n\n## 题解\n\n没什么太多好说的。几乎是裸题了。\n\n对于每一种$c$，建立一颗动态开点的线段树，每个节点维护当前区间的最大值和区间和。\n\n对于树进行树链剖分，查询的时候直接按照树链剖分查询就好了。\n\n时间复杂度$O(m \\log^{2}{n})$，空间复杂度$O(m \\log n)$\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 110000,logn = 30;\n\nint n,m,cnt;\nint son[MAXN],dep[MAXN],fa[MAXN],siz[MAXN],top[MAXN],id[MAXN];\n\nvector<int> edge[MAXN];\n\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f;\n    dep[nown] = depth,son[nown] = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == f) continue;\n        dfs1(v,nown,depth+1);\n        siz[nown] += siz[v];\n        if(siz[v] > siz[son[nown]]) son[nown] = v;\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    top[nown] = topf;id[nown] = ++cnt;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i < edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa[nown] || v == son[nown]) continue;\n        dfs2(v,v);\n    }\n}\n\nnamespace SegTree{\n    int sumn[MAXN*logn],maxn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 0;\n    #define mid ((l+r)>>1)\n    void maintain(int nown){\n        maxn[nown] = max(maxn[ls[nown]],maxn[rs[nown]]);\n        sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]];\n    }\n    int query_sum(int nown,int l,int r,int ql,int qr){\n        if(nown == 0 || (ql <= l && r <= qr) )\n            return sumn[nown];\n        else{\n            int ans = 0;\n            if(ql <= mid) ans += query_sum(ls[nown],l,mid,ql,qr);\n            if(mid+1 <= qr) ans += query_sum(rs[nown],mid+1,r,ql,qr);\n            return ans;\n        }\n    }\n    int query_max(int nown,int l,int r,int ql,int qr){\n        if(nown == 0 || (ql <= l && r <= qr))\n            return maxn[nown];\n        else{\n            int ans = 0;\n            if(ql <= mid) ans = max(ans,query_max(ls[nown],l,mid,ql,qr));\n            if(mid+1 <= qr) ans = max(ans,query_max(rs[nown],mid+1,r,ql,qr));\n            return ans;\n        }\n    }\n    void update(int &nown,int l,int r,int pos,int d){\n        if(!nown) nown = ++cnt,ls[nown] = 0,rs[nown] = 0;\n        if(l == r)\n            sumn[nown] = maxn[nown] = d;\n        else{\n            if(pos <= mid) update(ls[nown],l,mid,pos,d);\n            if(mid+1 <= pos) update(rs[nown],mid+1,r,pos,d);\n            maintain(nown);\n        }\n    }\n}\n\nint rt[MAXN],r[MAXN],b[MAXN];\n\n\nint query_max(int u,int v,int k){\n    int ans = 0;\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans = max(ans,SegTree::query_max(rt[k],1,n,id[top[u]],id[u]));\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans = max(ans,SegTree::query_max(rt[k],1,n,id[u],id[v]));\n    return ans;\n}\n\nint query_sum(int u,int v,int k){\n    int ans = 0;\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans += SegTree::query_sum(rt[k],1,n,id[top[u]],id[u]);\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans += SegTree::query_sum(rt[k],1,n,id[u],id[v]);\n    return ans;\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(r[i]),read(b[i]);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n}\n\nvoid build(){\n    dfs1(1,0,1),dfs2(1,1);\n    for(int i = 1;i<=n;i++)\n        SegTree::update(rt[b[i]],1,n,id[i],r[i]);\n}\n\nvoid solve(){\n    char op[10];int x,y;\n    for(int i = 1;i<=m;i++){\n        read(op),read(x),read(y);\n        if(op[0] == 'C'){\n            if(op[1] == 'W'){\n                SegTree::update(rt[b[x]],1,n,id[x],y);\n                r[x] = y;\n            }\n            else if(op[1] == 'C'){\n                SegTree::update(rt[b[x]],1,n,id[x],0);\n                SegTree::update(rt[y],1,n,id[x],r[x]);\n                b[x] = y;\n            }\n        }\n        else if(op[0] == 'Q'){\n            if(op[1] == 'S')\n                print(query_sum(x,y,b[x])),print('\\n');\n            else if(op[1] == 'M')\n                print(query_max(x,y,b[x])),print('\\n');\n        }\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「SDOI2014」旅行-树链剖分-动态开点线段树.md","raw":"---\ntitle: 「SDOI2014」旅行-树链剖分+动态开点线段树\nurlname: SDOI2014-journey\ndate: 2018-05-24 20:38:27\ntags:\n- 题解\n- 数据结构\n- 线段树\n- 树链剖分\ncategories: OI\nvisible:\n---\n\n给定一棵$n$个节点的树，对于每个点都有两个权值$w_i,c_i$。\n\n存在$m$个操作，分为4类。\n\n+ “`CC x c`”：将$c_x$更改为$c$；\n\n+ “`CW x w`”：将$w_x$更改为$w$；\n\n+ “`QS x y`”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\sum w_i$；\n\n+ “`QM x y`”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\max(w_i)$；\n\n对于后两个操作，保证$c_x = c_y$。\n\n<!-- more -->\n\n对于所有数据，$n,m \\leq 10^5$，在任意时刻均满足$w_i \\leq 10^4,c_i \\leq 10^5,\\; w_i,c_i \\in \\mathbb{N}^+$。\n\n## 链接\n\n[Luogu P3313](https://www.luogu.org/problemnew/show/P3313)\n\n## 题解\n\n没什么太多好说的。几乎是裸题了。\n\n对于每一种$c$，建立一颗动态开点的线段树，每个节点维护当前区间的最大值和区间和。\n\n对于树进行树链剖分，查询的时候直接按照树链剖分查询就好了。\n\n时间复杂度$O(m \\log^{2}{n})$，空间复杂度$O(m \\log n)$\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nconst int MAXN = 110000,logn = 30;\n\nint n,m,cnt;\nint son[MAXN],dep[MAXN],fa[MAXN],siz[MAXN],top[MAXN],id[MAXN];\n\nvector<int> edge[MAXN];\n\nvoid dfs1(int nown,int f,int depth){\n    siz[nown] = 1,fa[nown] = f;\n    dep[nown] = depth,son[nown] = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == f) continue;\n        dfs1(v,nown,depth+1);\n        siz[nown] += siz[v];\n        if(siz[v] > siz[son[nown]]) son[nown] = v;\n    }\n}\n\nvoid dfs2(int nown,int topf){\n    top[nown] = topf;id[nown] = ++cnt;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i < edge[nown].size();i++){\n        int v = edge[nown][i];\n        if(v == fa[nown] || v == son[nown]) continue;\n        dfs2(v,v);\n    }\n}\n\nnamespace SegTree{\n    int sumn[MAXN*logn],maxn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 0;\n    #define mid ((l+r)>>1)\n    void maintain(int nown){\n        maxn[nown] = max(maxn[ls[nown]],maxn[rs[nown]]);\n        sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]];\n    }\n    int query_sum(int nown,int l,int r,int ql,int qr){\n        if(nown == 0 || (ql <= l && r <= qr) )\n            return sumn[nown];\n        else{\n            int ans = 0;\n            if(ql <= mid) ans += query_sum(ls[nown],l,mid,ql,qr);\n            if(mid+1 <= qr) ans += query_sum(rs[nown],mid+1,r,ql,qr);\n            return ans;\n        }\n    }\n    int query_max(int nown,int l,int r,int ql,int qr){\n        if(nown == 0 || (ql <= l && r <= qr))\n            return maxn[nown];\n        else{\n            int ans = 0;\n            if(ql <= mid) ans = max(ans,query_max(ls[nown],l,mid,ql,qr));\n            if(mid+1 <= qr) ans = max(ans,query_max(rs[nown],mid+1,r,ql,qr));\n            return ans;\n        }\n    }\n    void update(int &nown,int l,int r,int pos,int d){\n        if(!nown) nown = ++cnt,ls[nown] = 0,rs[nown] = 0;\n        if(l == r)\n            sumn[nown] = maxn[nown] = d;\n        else{\n            if(pos <= mid) update(ls[nown],l,mid,pos,d);\n            if(mid+1 <= pos) update(rs[nown],mid+1,r,pos,d);\n            maintain(nown);\n        }\n    }\n}\n\nint rt[MAXN],r[MAXN],b[MAXN];\n\n\nint query_max(int u,int v,int k){\n    int ans = 0;\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans = max(ans,SegTree::query_max(rt[k],1,n,id[top[u]],id[u]));\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans = max(ans,SegTree::query_max(rt[k],1,n,id[u],id[v]));\n    return ans;\n}\n\nint query_sum(int u,int v,int k){\n    int ans = 0;\n    while(top[u]!=top[v]){\n        if(dep[top[u]] < dep[top[v]]) swap(u,v);\n        ans += SegTree::query_sum(rt[k],1,n,id[top[u]],id[u]);\n        u = fa[top[u]];\n    }\n    if(dep[u] > dep[v]) swap(u,v);\n    ans += SegTree::query_sum(rt[k],1,n,id[u],id[v]);\n    return ans;\n}\n\nvoid init(){\n    read(n),read(m);\n    for(int i = 1;i<=n;i++)\n        read(r[i]),read(b[i]);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n}\n\nvoid build(){\n    dfs1(1,0,1),dfs2(1,1);\n    for(int i = 1;i<=n;i++)\n        SegTree::update(rt[b[i]],1,n,id[i],r[i]);\n}\n\nvoid solve(){\n    char op[10];int x,y;\n    for(int i = 1;i<=m;i++){\n        read(op),read(x),read(y);\n        if(op[0] == 'C'){\n            if(op[1] == 'W'){\n                SegTree::update(rt[b[x]],1,n,id[x],y);\n                r[x] = y;\n            }\n            else if(op[1] == 'C'){\n                SegTree::update(rt[b[x]],1,n,id[x],0);\n                SegTree::update(rt[y],1,n,id[x],r[x]);\n                b[x] = y;\n            }\n        }\n        else if(op[0] == 'Q'){\n            if(op[1] == 'S')\n                print(query_sum(x,y,b[x])),print('\\n');\n            else if(op[1] == 'M')\n                print(query_max(x,y,b[x])),print('\\n');\n        }\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「SDOI2014」旅行-树链剖分-动态开点线段树","published":1,"updated":"2018-06-02T13:22:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3kp004rbljr5wu2r2d2","content":"<p>给定一棵$n$个节点的树，对于每个点都有两个权值$w_i,c_i$。</p>\n<p>存在$m$个操作，分为4类。</p>\n<ul>\n<li><p>“<code>CC x c</code>”：将$c_x$更改为$c$；</p>\n</li>\n<li><p>“<code>CW x w</code>”：将$w_x$更改为$w$；</p>\n</li>\n<li><p>“<code>QS x y</code>”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\sum w_i$；</p>\n</li>\n<li><p>“<code>QM x y</code>”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\max(w_i)$；</p>\n</li>\n</ul>\n<p>对于后两个操作，保证$c_x = c_y$。</p>\n<a id=\"more\"></a>\n<p>对于所有数据，$n,m \\leq 10^5$，在任意时刻均满足$w_i \\leq 10^4,c_i \\leq 10^5,\\; w_i,c_i \\in \\mathbb{N}^+$。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3313\" target=\"_blank\" rel=\"noopener\">Luogu P3313</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>没什么太多好说的。几乎是裸题了。</p>\n<p>对于每一种$c$，建立一颗动态开点的线段树，每个节点维护当前区间的最大值和区间和。</p>\n<p>对于树进行树链剖分，查询的时候直接按照树链剖分查询就好了。</p>\n<p>时间复杂度$O(m \\log^{2}{n})$，空间复杂度$O(m \\log n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>,logn = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,cnt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> son[MAXN],dep[MAXN],fa[MAXN],siz[MAXN],top[MAXN],id[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,fa[nown] = f;</span><br><span class=\"line\">    dep[nown] = depth,son[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(v,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        siz[nown] += siz[v];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[v] &gt; siz[son[nown]]) son[nown] = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    top[nown] = topf;id[nown] = ++cnt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!son[nown]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v == fa[nown] || v == son[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(v,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> SegTree&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sumn[MAXN*logn],maxn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">maintain</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">        maxn[nown] = max(maxn[ls[nown]],maxn[rs[nown]]);</span><br><span class=\"line\">        sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nown == <span class=\"number\">0</span> || (ql &lt;= l &amp;&amp; r &lt;= qr) )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sumn[nown];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql &lt;= mid) ans += query_sum(ls[nown],l,mid,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= qr) ans += query_sum(rs[nown],mid+<span class=\"number\">1</span>,r,ql,qr);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query_max</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nown == <span class=\"number\">0</span> || (ql &lt;= l &amp;&amp; r &lt;= qr))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> maxn[nown];</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ql &lt;= mid) ans = max(ans,query_max(ls[nown],l,mid,ql,qr));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= qr) ans = max(ans,query_max(rs[nown],mid+<span class=\"number\">1</span>,r,ql,qr));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;nown,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!nown) nown = ++cnt,ls[nown] = <span class=\"number\">0</span>,rs[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l == r)</span><br><span class=\"line\">            sumn[nown] = maxn[nown] = d;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pos &lt;= mid) update(ls[nown],l,mid,pos,d);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mid+<span class=\"number\">1</span> &lt;= pos) update(rs[nown],mid+<span class=\"number\">1</span>,r,pos,d);</span><br><span class=\"line\">            maintain(nown);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> rt[MAXN],r[MAXN],b[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query_max</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[u]!=top[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[u]] &lt; dep[top[v]]) swap(u,v);</span><br><span class=\"line\">        ans = max(ans,SegTree::query_max(rt[k],<span class=\"number\">1</span>,n,id[top[u]],id[u]));</span><br><span class=\"line\">        u = fa[top[u]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class=\"line\">    ans = max(ans,SegTree::query_max(rt[k],<span class=\"number\">1</span>,n,id[u],id[v]));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> u,<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[u]!=top[v])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[u]] &lt; dep[top[v]]) swap(u,v);</span><br><span class=\"line\">        ans += SegTree::query_sum(rt[k],<span class=\"number\">1</span>,n,id[top[u]],id[u]);</span><br><span class=\"line\">        u = fa[top[u]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[u] &gt; dep[v]) swap(u,v);</span><br><span class=\"line\">    ans += SegTree::query_sum(rt[k],<span class=\"number\">1</span>,n,id[u],id[v]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(r[i]),read(b[i]);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        edge[a].push_back(b);</span><br><span class=\"line\">        edge[b].push_back(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>),dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        SegTree::update(rt[b[i]],<span class=\"number\">1</span>,n,id[i],r[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];<span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op),read(x),read(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'W'</span>)&#123;</span><br><span class=\"line\">                SegTree::update(rt[b[x]],<span class=\"number\">1</span>,n,id[x],y);</span><br><span class=\"line\">                r[x] = y;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'C'</span>)&#123;</span><br><span class=\"line\">                SegTree::update(rt[b[x]],<span class=\"number\">1</span>,n,id[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">                SegTree::update(rt[y],<span class=\"number\">1</span>,n,id[x],r[x]);</span><br><span class=\"line\">                b[x] = y;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'S'</span>)</span><br><span class=\"line\">                print(query_sum(x,y,b[x])),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'M'</span>)</span><br><span class=\"line\">                print(query_max(x,y,b[x])),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定一棵$n$个节点的树，对于每个点都有两个权值$w_i,c_i$。</p>\n<p>存在$m$个操作，分为4类。</p>\n<ul>\n<li><p>“<code>CC x c</code>”：将$c_x$更改为$c$；</p>\n</li>\n<li><p>“<code>CW x w</code>”：将$w_x$更改为$w$；</p>\n</li>\n<li><p>“<code>QS x y</code>”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\sum w_i$；</p>\n</li>\n<li><p>“<code>QM x y</code>”：对所有满足在$x$到$y$路径上且$c_i = c_x = c_y$的节点$i$，求$\\max(w_i)$；</p>\n</li>\n</ul>\n<p>对于后两个操作，保证$c_x = c_y$。</p>","more":"<p>对于所有数据，$n,m \\leq 10^5$，在任意时刻均满足$w_i \\leq 10^4,c_i \\leq 10^5,\\; w_i,c_i \\in \\mathbb{N}^+$。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3313\" target=\"_blank\" rel=\"noopener\">Luogu P3313</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>没什么太多好说的。几乎是裸题了。</p>\n<p>对于每一种$c$，建立一颗动态开点的线段树，每个节点维护当前区间的最大值和区间和。</p>\n<p>对于树进行树链剖分，查询的时候直接按照树链剖分查询就好了。</p>\n<p>时间复杂度$O(m \\log^{2}{n})$，空间复杂度$O(m \\log n)$</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�55-->\n\n</div></div>"},{"title":"「TJOI2017」DNA-后缀数组","urlname":"TJOI2017-DNA","date":"2018-06-23T12:43:31.000Z","visible":null,"_content":"\n加里敦大学的生物研究所发现了决定人喜不喜欢吃藕的基因序列$S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列$S$,任意修改其中不超过$3$个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在$DNA$链$S0$上的位置。所以你需要统计在一个表现出吃藕性状的人的$DNA$序列$S0$上，有多少个连续子串可能是该基因，即有多少个$S0$的连续子串修改小于等于三个字母能够变成$S$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3763](https://www.luogu.org/problemnew/show/P3763)\n\n## 题解\n\n先把两个串拼到一起，然后处理出后缀数组，建立出RMQ的ST表。然后对于每一位都判断是否满足条件即可，即往后取三个LCP，然后判断长度关系即可。\n\n时间复杂度O(n)。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 210000;\n\nnamespace SA{\nint sa[MAXN],rk[MAXN],ht[MAXN],s[MAXN<<1],t[MAXN<<1];\nint p[MAXN],b[MAXN],cur[MAXN];\n#define pushS(x) sa[cur[s[x]]--] = x\n#define pushL(x) sa[cur[s[x]]++] = x\n#define inducedSort(v)\\\n    fill_n(b,m,0),fill_n(sa,n,-1);\\\n    for(int i=0;i<n;i++) b[s[i]]++;\\\n    for(int j=1;j<m;j++) b[j]+=b[j-1];\\\n    for(int j=0;j<m;j++) cur[j] = b[j]-1;\\\n    for(int i=n1-1;~i;--i) pushS(v[i]);\\\n    for(int j=1;j<m;j++) cur[j] = b[j-1];\\\n    for(int i=0;i<n;i++) if(sa[i]>0 && t[sa[i]-1]) pushL(sa[i]-1);\\\n    for(int j=0;j<m;j++) cur[j] = b[j]-1;\\\n    for(int i=n-1;~i;--i) if(sa[i]>0 && !t[sa[i]-1]) pushS(sa[i]-1);\nvoid sais(int n,int m,int *s,int *t,int *p){\n    int n1 = t[n-1] = 0,ch = rk[0] = -1,*s1 = s+n;\n    for(int i=n-2;~i;--i) t[i] = s[i]==s[i+1]?t[i+1]:s[i]>s[i+1];\n    for(int i=1;i<n;i++) rk[i] = (t[i-1]&&!t[i])?(p[n1] = i,n1++):-1;\n    inducedSort(p);\n    for(int i=0,x,y;i<n;i++)if(~(x=rk[sa[i]])){\n        if(ch<1||p[x+1]-p[x]!=p[y+1]-p[y]) ch++;\n        else for(int j=p[x],k=p[y];j<=p[x+1];j++,k++)\n            if((s[j]<<1|t[j]) != (s[k]<<1|t[k])){ch++;break;}\n        s1[y=x] = ch;\n    }\n    if(ch+1 < n1) sais(n1,ch+1,s1,t+n,p+n1);\n    else for(int i = 0;i<n1;i++) sa[s1[i]] = i;\n    for(int i = 0;i<n1;i++) s1[i] = p[sa[i]];\n    inducedSort(s1);\n}\ntemplate <typename T>\nint mapChartoInt(int n,const T *str){\n    int m = *max_element(str,str+n);\n    fill_n(rk,m+1,0);//+1!!!\n    for(int i = 0;i<n;i++) rk[str[i]] = 1;//=1!\n    for(int j = 0;j<m;j++) rk[j+1] += rk[j]; \n    for(int i = 0;i<n;i++) s[i] = rk[str[i]]-1;\n    return rk[m];\n}\n// str[n] yange zidianxu zuixiao\ntemplate <typename T>\nvoid suffixArray(int n,const T *str){\n    int m = mapChartoInt(++n,str);\n    sais(n,m,s,t,p);\n}\nvoid getHeight(int n){\n    // 这里的循环一定要到a！\n    for(int i = 0;i<=n;i++) rk[sa[i]] = i;\n    for(int i = 0,h = ht[0] = 0;i<=n;i++){\n        int j = sa[rk[i]-1];\n        while(i+h<n && j+h<n && s[i+h] == s[j+h]) h++;\n        if(ht[rk[i]] = h) --h;\n    }\n}\n}\n\nint n,x,y;\nchar s[MAXN];\n\nnamespace ST{\n    int st[20][MAXN];\n    void build(int n,int *num){\n        for(int i = 1;i<=n;i++) st[0][i] = num[i];\n        for(int j = 1,t = 2;t<=n;j++,t<<=1)\n            for(int i = 1;i+(t>>1)<=n;i++)\n                st[j][i] = min(st[j-1][i],st[j-1][i+(t>>1)]);\n    }\n    int query(int l,int r){\n        int t = log2(r-l+1);\n        return min(st[t][l],st[t][r-(1<<t)+1]);\n    }\n}\n\nvoid init(){\n    scanf(\"%s\",s);\n    x = strlen(s);\n    scanf(\"%s\",s+x);\n    n = strlen(s);\n    y = n-x;\n    s[n] = 'A'-1;\n    SA::suffixArray(n,s);\n    SA::getHeight(n);\n    ST::build(n,SA::ht);\n}\n\nint lcp(int a,int b){\n    if(a == b) return n - a + 1;\n    a = SA::rk[a],b = SA::rk[b];\n    if(a > b) swap(a,b);\n    return ST::query(a+1,b);\n}\n\nbool judge(int p){\n    int cnt = 0,len = 0;\n    while(len < y){\n        len += lcp(p+len,x+len);\n        if(cnt >= 3 && len < y) return false;\n        len++,cnt++;\n    }\n    return true;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = 0;i<=x-y;i++)\n        if(judge(i)) ans++;\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    for(int i = 1;i<=T;i++)\n        init(),solve();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「TJOI2017」DNA-后缀数组.md","raw":"---\ntitle: 「TJOI2017」DNA-后缀数组\nurlname: TJOI2017-DNA\ndate: 2018-06-23 20:43:31\ntags:\n- 字符串\n- 题解\n- 后缀数组\ncategories: OI\nvisible:\n---\n\n加里敦大学的生物研究所发现了决定人喜不喜欢吃藕的基因序列$S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列$S$,任意修改其中不超过$3$个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在$DNA$链$S0$上的位置。所以你需要统计在一个表现出吃藕性状的人的$DNA$序列$S0$上，有多少个连续子串可能是该基因，即有多少个$S0$的连续子串修改小于等于三个字母能够变成$S$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3763](https://www.luogu.org/problemnew/show/P3763)\n\n## 题解\n\n先把两个串拼到一起，然后处理出后缀数组，建立出RMQ的ST表。然后对于每一位都判断是否满足条件即可，即往后取三个LCP，然后判断长度关系即可。\n\n时间复杂度O(n)。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 210000;\n\nnamespace SA{\nint sa[MAXN],rk[MAXN],ht[MAXN],s[MAXN<<1],t[MAXN<<1];\nint p[MAXN],b[MAXN],cur[MAXN];\n#define pushS(x) sa[cur[s[x]]--] = x\n#define pushL(x) sa[cur[s[x]]++] = x\n#define inducedSort(v)\\\n    fill_n(b,m,0),fill_n(sa,n,-1);\\\n    for(int i=0;i<n;i++) b[s[i]]++;\\\n    for(int j=1;j<m;j++) b[j]+=b[j-1];\\\n    for(int j=0;j<m;j++) cur[j] = b[j]-1;\\\n    for(int i=n1-1;~i;--i) pushS(v[i]);\\\n    for(int j=1;j<m;j++) cur[j] = b[j-1];\\\n    for(int i=0;i<n;i++) if(sa[i]>0 && t[sa[i]-1]) pushL(sa[i]-1);\\\n    for(int j=0;j<m;j++) cur[j] = b[j]-1;\\\n    for(int i=n-1;~i;--i) if(sa[i]>0 && !t[sa[i]-1]) pushS(sa[i]-1);\nvoid sais(int n,int m,int *s,int *t,int *p){\n    int n1 = t[n-1] = 0,ch = rk[0] = -1,*s1 = s+n;\n    for(int i=n-2;~i;--i) t[i] = s[i]==s[i+1]?t[i+1]:s[i]>s[i+1];\n    for(int i=1;i<n;i++) rk[i] = (t[i-1]&&!t[i])?(p[n1] = i,n1++):-1;\n    inducedSort(p);\n    for(int i=0,x,y;i<n;i++)if(~(x=rk[sa[i]])){\n        if(ch<1||p[x+1]-p[x]!=p[y+1]-p[y]) ch++;\n        else for(int j=p[x],k=p[y];j<=p[x+1];j++,k++)\n            if((s[j]<<1|t[j]) != (s[k]<<1|t[k])){ch++;break;}\n        s1[y=x] = ch;\n    }\n    if(ch+1 < n1) sais(n1,ch+1,s1,t+n,p+n1);\n    else for(int i = 0;i<n1;i++) sa[s1[i]] = i;\n    for(int i = 0;i<n1;i++) s1[i] = p[sa[i]];\n    inducedSort(s1);\n}\ntemplate <typename T>\nint mapChartoInt(int n,const T *str){\n    int m = *max_element(str,str+n);\n    fill_n(rk,m+1,0);//+1!!!\n    for(int i = 0;i<n;i++) rk[str[i]] = 1;//=1!\n    for(int j = 0;j<m;j++) rk[j+1] += rk[j]; \n    for(int i = 0;i<n;i++) s[i] = rk[str[i]]-1;\n    return rk[m];\n}\n// str[n] yange zidianxu zuixiao\ntemplate <typename T>\nvoid suffixArray(int n,const T *str){\n    int m = mapChartoInt(++n,str);\n    sais(n,m,s,t,p);\n}\nvoid getHeight(int n){\n    // 这里的循环一定要到a！\n    for(int i = 0;i<=n;i++) rk[sa[i]] = i;\n    for(int i = 0,h = ht[0] = 0;i<=n;i++){\n        int j = sa[rk[i]-1];\n        while(i+h<n && j+h<n && s[i+h] == s[j+h]) h++;\n        if(ht[rk[i]] = h) --h;\n    }\n}\n}\n\nint n,x,y;\nchar s[MAXN];\n\nnamespace ST{\n    int st[20][MAXN];\n    void build(int n,int *num){\n        for(int i = 1;i<=n;i++) st[0][i] = num[i];\n        for(int j = 1,t = 2;t<=n;j++,t<<=1)\n            for(int i = 1;i+(t>>1)<=n;i++)\n                st[j][i] = min(st[j-1][i],st[j-1][i+(t>>1)]);\n    }\n    int query(int l,int r){\n        int t = log2(r-l+1);\n        return min(st[t][l],st[t][r-(1<<t)+1]);\n    }\n}\n\nvoid init(){\n    scanf(\"%s\",s);\n    x = strlen(s);\n    scanf(\"%s\",s+x);\n    n = strlen(s);\n    y = n-x;\n    s[n] = 'A'-1;\n    SA::suffixArray(n,s);\n    SA::getHeight(n);\n    ST::build(n,SA::ht);\n}\n\nint lcp(int a,int b){\n    if(a == b) return n - a + 1;\n    a = SA::rk[a],b = SA::rk[b];\n    if(a > b) swap(a,b);\n    return ST::query(a+1,b);\n}\n\nbool judge(int p){\n    int cnt = 0,len = 0;\n    while(len < y){\n        len += lcp(p+len,x+len);\n        if(cnt >= 3 && len < y) return false;\n        len++,cnt++;\n    }\n    return true;\n}\n\nvoid solve(){\n    int ans = 0;\n    for(int i = 0;i<=x-y;i++)\n        if(judge(i)) ans++;\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    int T;scanf(\"%d\",&T);\n    for(int i = 1;i<=T;i++)\n        init(),solve();\n    return 0;\n}\n```\n{% endfold %}","slug":"「TJOI2017」DNA-后缀数组","published":1,"updated":"2018-06-23T12:54:21.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ks004vbljrnp6zkadm","content":"<p>加里敦大学的生物研究所发现了决定人喜不喜欢吃藕的基因序列$S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列$S$,任意修改其中不超过$3$个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在$DNA$链$S0$上的位置。所以你需要统计在一个表现出吃藕性状的人的$DNA$序列$S0$上，有多少个连续子串可能是该基因，即有多少个$S0$的连续子串修改小于等于三个字母能够变成$S$。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3763\" target=\"_blank\" rel=\"noopener\">Luogu P3763</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先把两个串拼到一起，然后处理出后缀数组，建立出RMQ的ST表。然后对于每一位都判断是否满足条件即可，即往后取三个LCP，然后判断长度关系即可。</p>\n<p>时间复杂度O(n)。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">210000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> SA&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sa[MAXN],rk[MAXN],ht[MAXN],s[MAXN&lt;&lt;<span class=\"number\">1</span>],t[MAXN&lt;&lt;<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> p[MAXN],b[MAXN],cur[MAXN];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pushS(x) sa[cur[s[x]]--] = x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> pushL(x) sa[cur[s[x]]++] = x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> inducedSort(v)\\</span></span><br><span class=\"line\">    fill_n(b,m,<span class=\"number\">0</span>),fill_n(sa,n,<span class=\"number\">-1</span>);\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) b[s[i]]++;\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++) b[j]+=b[j<span class=\"number\">-1</span>];\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;m;j++) cur[j] = b[j]<span class=\"number\">-1</span>;\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n1<span class=\"number\">-1</span>;~i;--i) pushS(v[i]);\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;m;j++) cur[j] = b[j<span class=\"number\">-1</span>];\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"keyword\">if</span>(sa[i]&gt;<span class=\"number\">0</span> &amp;&amp; t[sa[i]<span class=\"number\">-1</span>]) pushL(sa[i]<span class=\"number\">-1</span>);\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;m;j++) cur[j] = b[j]<span class=\"number\">-1</span>;\\</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n<span class=\"number\">-1</span>;~i;--i) <span class=\"keyword\">if</span>(sa[i]&gt;<span class=\"number\">0</span> &amp;&amp; !t[sa[i]<span class=\"number\">-1</span>]) pushS(sa[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sais</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> m,<span class=\"keyword\">int</span> *s,<span class=\"keyword\">int</span> *t,<span class=\"keyword\">int</span> *p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = t[n<span class=\"number\">-1</span>] = <span class=\"number\">0</span>,ch = rk[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>,*s1 = s+n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=n<span class=\"number\">-2</span>;~i;--i) t[i] = s[i]==s[i+<span class=\"number\">1</span>]?t[i+<span class=\"number\">1</span>]:s[i]&gt;s[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++) rk[i] = (t[i<span class=\"number\">-1</span>]&amp;&amp;!t[i])?(p[n1] = i,n1++):<span class=\"number\">-1</span>;</span><br><span class=\"line\">    inducedSort(p);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,x,y;i&lt;n;i++)<span class=\"keyword\">if</span>(~(x=rk[sa[i]]))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch&lt;<span class=\"number\">1</span>||p[x+<span class=\"number\">1</span>]-p[x]!=p[y+<span class=\"number\">1</span>]-p[y]) ch++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=p[x],k=p[y];j&lt;=p[x+<span class=\"number\">1</span>];j++,k++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((s[j]&lt;&lt;<span class=\"number\">1</span>|t[j]) != (s[k]&lt;&lt;<span class=\"number\">1</span>|t[k]))&#123;ch++;<span class=\"keyword\">break</span>;&#125;</span><br><span class=\"line\">        s1[y=x] = ch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ch+<span class=\"number\">1</span> &lt; n1) sais(n1,ch+<span class=\"number\">1</span>,s1,t+n,p+n1);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n1;i++) sa[s1[i]] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n1;i++) s1[i] = p[sa[i]];</span><br><span class=\"line\">    inducedSort(s1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mapChartoInt</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">const</span> T *str)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = *max_element(str,str+n);</span><br><span class=\"line\">    fill_n(rk,m+<span class=\"number\">1</span>,<span class=\"number\">0</span>);<span class=\"comment\">//+1!!!</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++) rk[str[i]] = <span class=\"number\">1</span>;<span class=\"comment\">//=1!</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;j++) rk[j+<span class=\"number\">1</span>] += rk[j]; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++) s[i] = rk[str[i]]<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rk[m];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// str[n] yange zidianxu zuixiao</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">suffixArray</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">const</span> T *str)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = mapChartoInt(++n,str);</span><br><span class=\"line\">    sais(n,m,s,t,p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getHeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的循环一定要到a！</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;i++) rk[sa[i]] = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,h = ht[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = sa[rk[i]<span class=\"number\">-1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i+h&lt;n &amp;&amp; j+h&lt;n &amp;&amp; s[i+h] == s[j+h]) h++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ht[rk[i]] = h) --h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,x,y;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> ST&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> st[<span class=\"number\">20</span>][MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> *num)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++) st[<span class=\"number\">0</span>][i] = num[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>,t = <span class=\"number\">2</span>;t&lt;=n;j++,t&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i+(t&gt;&gt;<span class=\"number\">1</span>)&lt;=n;i++)</span><br><span class=\"line\">                st[j][i] = min(st[j<span class=\"number\">-1</span>][i],st[j<span class=\"number\">-1</span>][i+(t&gt;&gt;<span class=\"number\">1</span>)]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = log2(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(st[t][l],st[t][r-(<span class=\"number\">1</span>&lt;&lt;t)+<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s);</span><br><span class=\"line\">    x = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,s+x);</span><br><span class=\"line\">    n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    y = n-x;</span><br><span class=\"line\">    s[n] = <span class=\"string\">'A'</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">    SA::suffixArray(n,s);</span><br><span class=\"line\">    SA::getHeight(n);</span><br><span class=\"line\">    ST::build(n,SA::ht);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lcp</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == b) <span class=\"keyword\">return</span> n - a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    a = SA::rk[a],b = SA::rk[b];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a &gt; b) swap(a,b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ST::query(a+<span class=\"number\">1</span>,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>,len = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(len &lt; y)&#123;</span><br><span class=\"line\">        len += lcp(p+len,x+len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt &gt;= <span class=\"number\">3</span> &amp;&amp; len &lt; y) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        len++,cnt++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=x-y;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(judge(i)) ans++;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,ans);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> T;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=T;i++)</span><br><span class=\"line\">        init(),solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>加里敦大学的生物研究所发现了决定人喜不喜欢吃藕的基因序列$S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列$S$,任意修改其中不超过$3$个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在$DNA$链$S0$上的位置。所以你需要统计在一个表现出吃藕性状的人的$DNA$序列$S0$上，有多少个连续子串可能是该基因，即有多少个$S0$的连续子串修改小于等于三个字母能够变成$S$。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3763\" target=\"_blank\" rel=\"noopener\">Luogu P3763</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>先把两个串拼到一起，然后处理出后缀数组，建立出RMQ的ST表。然后对于每一位都判断是否满足条件即可，即往后取三个LCP，然后判断长度关系即可。</p>\n<p>时间复杂度O(n)。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�56-->\n\n</div></div>"},{"title":"「Violet」蒲公英-分块","urlname":"violet-dandelions","date":"2018-03-31T03:30:45.000Z","visible":null,"_content":"\n给定一个数列${a\\_n}$，$m$次询问在$[l,r]$区间内的最小众数。\n强制在线。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4168](https://www.luogu.org/problemnew/show/P4168)\n\n## 题解\n\n为了在课上讲分块，特地做了一道大分块的题。\n\n\n做法一：\n预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；$cnt[i][c]$，表示在前i个数中颜色为c的数的个数。\n\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n\n每次查询，先将答案设成整块的众数。对于零散的数，暴力统计出在零散块中出现的次数，然后加上在整块出现的次数（前缀和相减），尝试更新答案。\n\n可以证明，复杂度大约是$O(n\\ \\sqrt{n} )$。\n\n- - -\n\n做法二：\n预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；对于每一种颜色，开一个vector把这个数每次出现的位置，按从前到后顺序加进去。这样，我们可以在$O(\\log{n})$的时间内通过二分查询出一个数在[l,r]区间出现了多少次。\n\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n\n每次查询，先将答案设成整块的众数，并且记录其在$[l,r]$出现次数，然后对于每一个零散块中的数，查询其在[l,r]中出现的次数，并尝试更新答案。\n\n可以证明，复杂度大约是$O(n\\ \\sqrt {n}\\ \\log{n})$。这个复杂度存在被卡死的可能。\n\n- - -\n\n由于数据范围很大，需要离散化并且记录离散化后的数对应之前的数是什么。\n\n## 代码\n\n做法一：\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 101000,MAXQ = 1000;\n\nstruct pu{\n    int col,id,belong;\n}pgy[MAXN];\n\nint n,m,Q;\nint bl[MAXQ],br[MAXQ],id_to[MAXN],numc = 0;\nint z[MAXQ][MAXQ],cnt[MAXN][MAXQ],t[MAXN];\n\nbool cmp1(pu a,pu b){return a.col < b.col;}\nbool cmp2(pu a,pu b){return a.id < b.id;}\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n);\n    for(int i = 1;i<=n;i++){\n        read(pgy[i].col);\n        pgy[i].id = i,pgy[i].belong = (i-1)/Q+1;\n\n        if(!bl[pgy[i].belong]) \n            bl[pgy[i].belong] = i;\n        br[pgy[i].belong] = i;\n    }\n    sort(pgy+1,pgy+n+1,cmp1);\n    int lastc = 0;\n    for(int i = 1;i<=n;i++){\n        if(pgy[i].col!=lastc)\n            numc++,id_to[numc] = pgy[i].col;\n        lastc = pgy[i].col;\n        pgy[i].col = numc;\n    }\n    sort(pgy+1,pgy+n+1,cmp2);\n    \n    for(int i = 1;i<=n;i++)\n        cnt[pgy[i].col][pgy[i].belong]++;\n    for(int i = 1;i<=numc;i++)\n        for(int j = 1;j<=n/Q;j++)\n            cnt[i][j] += cnt[i][j-1];\n}\n\nvoid build(){\n    for(int i = 1;i<=n;i+=Q){\n        memset(t,0,sizeof(t));\n        int maxn = 0;\n        for(int j = i;j<=n;j++){\n            int nowc = pgy[j].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n            if(j%Q == 0)\n                z[(i-1)/Q+1][j/Q] = maxn;\n        }\n    }\n}\n\n\n\nint answer(int ql,int qr){\n    int lb = pgy[ql].belong,rb = pgy[qr].belong,maxn = 0;\n    //printf(\"lblock:%d rblock:%d\\n\",lb,rb);\n    if(lb == rb || lb+1 == rb){\n        for(int i = ql;i<=qr;i++)\n            t[pgy[i].col] = 0;\n        for(int i = ql;i<=qr;i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n        }\n    }\n    else{\n        for(int i = ql;i<bl[lb+1];i++)\n            t[pgy[i].col] = 0;\n        for(int i = br[rb-1]+1;i<=qr;i++)\n            t[pgy[i].col] = 0;\n        maxn = z[lb+1][rb-1];\n        t[maxn] = 0;\n        for(int i = ql;i<bl[lb+1];i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb];\n            int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb];\n            if(tmp > maxnum || (tmp == maxnum && nowc < maxn))\n                maxn = nowc;\n        }\n        for(int i = br[rb-1]+1;i<=qr;i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb];\n            int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb];\n            if(tmp > maxnum || (tmp == maxnum && nowc < maxn))\n                maxn = nowc;\n        }\n    }\n    return id_to[maxn];\n}\n\n\nvoid solve(){\n    int a,b,lastans = 0;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1;\n        if(a > b) swap(a,b);\n        lastans = answer(a,b);\n        print(lastans),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n\n做法二：\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 101000,MAXQ = 1000;\n\nvector<int> pos[MAXN];\n\nint n,m,Q;\n\nstruct pu{\n    int col,id;\n}pgy[MAXN];\n\n//在[i,j]块中的众数\nint z[MAXQ][MAXQ];\n\nint id_to[MAXN];\n\nbool cmp1(pu a,pu b){\n    return a.col < b.col;\n}\n\nbool cmp2(pu a,pu b){\n    return a.id < b.id;\n}\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n*5);\n    for(int i = 1;i<=n;i++)\n        read(pgy[i].col),pgy[i].id = i;\n    sort(pgy+1,pgy+n+1,cmp1);\n    int lastc = 0,numc = 0;\n    for(int i = 1;i<=n;i++){\n        if(pgy[i].col!=lastc)\n            numc++,id_to[numc] = pgy[i].col;\n        lastc = pgy[i].col;\n        pgy[i].col = numc;\n    }\n    sort(pgy+1,pgy+n+1,cmp2);\n    for(int i = 1;i<=n;i++){\n        pos[pgy[i].col].push_back(i);\n    }\n}\n\nvoid build(){\n    static int t[MAXN];\n    for(int i = 1;i<=n;i+=Q){\n        memset(t,0,sizeof(t));\n        int maxn = 0;\n        for(int j = i;j<=n;j++){\n            int nowc = pgy[j].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n            if(j%Q == 0)\n                z[(i-1)/Q+1][j/Q] = maxn;\n        }\n    }\n}\n\n\nint count_num(int lb,int rb,int num){\n    return lower_bound(pos[num].begin(),pos[num].end(),rb+1)-lower_bound(pos[num].begin(),pos[num].end(),lb);\n}\n\nint answer(int ql,int qr){\n    int lb = floor(double(ql-2)/Q)+2,rb = qr/Q,maxn = 0,maxnum = 0;\n    if(lb <= rb) maxn = z[lb][rb],maxnum = count_num(ql,qr,maxn);\n    //printf(\"lblock:%d rblock:%d\\n\",lb,rb);\n    lb = (lb-1)*Q+1,rb = rb*Q;\n    //printf(\"lbound:%d rbound:%d maxn:%d\\n\",lb,rb,maxn);\n    while(ql < lb){\n        --lb;\n        int c = pgy[lb].col,w = count_num(ql,qr,c);\n        if(w > maxnum || (w == maxnum && c < maxn))\n            maxn = c,maxnum = w;\n    }\n    while(rb < qr){\n        rb++;\n        int c = pgy[rb].col,w = count_num(ql,qr,c);\n        if(w > maxnum || (w == maxnum && c < maxn))\n            maxn = c,maxnum = w;\n    }\n    return id_to[maxn];\n}\n\n\nvoid solve(){\n    int a,b,lastans = 0;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1;\n        if(a > b) swap(a,b);\n        lastans = answer(a,b);\n        print(lastans),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「Violet」蒲公英-分块.md","raw":"---\ntitle: 「Violet」蒲公英-分块\nurlname: violet-dandelions\ndate: 2018-03-31 11:30:45\ntags:\n- 题解\n- 分块\ncategories: OI\nvisible:\n---\n\n给定一个数列${a\\_n}$，$m$次询问在$[l,r]$区间内的最小众数。\n强制在线。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P4168](https://www.luogu.org/problemnew/show/P4168)\n\n## 题解\n\n为了在课上讲分块，特地做了一道大分块的题。\n\n\n做法一：\n预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；$cnt[i][c]$，表示在前i个数中颜色为c的数的个数。\n\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n\n每次查询，先将答案设成整块的众数。对于零散的数，暴力统计出在零散块中出现的次数，然后加上在整块出现的次数（前缀和相减），尝试更新答案。\n\n可以证明，复杂度大约是$O(n\\ \\sqrt{n} )$。\n\n- - -\n\n做法二：\n预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；对于每一种颜色，开一个vector把这个数每次出现的位置，按从前到后顺序加进去。这样，我们可以在$O(\\log{n})$的时间内通过二分查询出一个数在[l,r]区间出现了多少次。\n\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n\n每次查询，先将答案设成整块的众数，并且记录其在$[l,r]$出现次数，然后对于每一个零散块中的数，查询其在[l,r]中出现的次数，并尝试更新答案。\n\n可以证明，复杂度大约是$O(n\\ \\sqrt {n}\\ \\log{n})$。这个复杂度存在被卡死的可能。\n\n- - -\n\n由于数据范围很大，需要离散化并且记录离散化后的数对应之前的数是什么。\n\n## 代码\n\n做法一：\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 101000,MAXQ = 1000;\n\nstruct pu{\n    int col,id,belong;\n}pgy[MAXN];\n\nint n,m,Q;\nint bl[MAXQ],br[MAXQ],id_to[MAXN],numc = 0;\nint z[MAXQ][MAXQ],cnt[MAXN][MAXQ],t[MAXN];\n\nbool cmp1(pu a,pu b){return a.col < b.col;}\nbool cmp2(pu a,pu b){return a.id < b.id;}\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n);\n    for(int i = 1;i<=n;i++){\n        read(pgy[i].col);\n        pgy[i].id = i,pgy[i].belong = (i-1)/Q+1;\n\n        if(!bl[pgy[i].belong]) \n            bl[pgy[i].belong] = i;\n        br[pgy[i].belong] = i;\n    }\n    sort(pgy+1,pgy+n+1,cmp1);\n    int lastc = 0;\n    for(int i = 1;i<=n;i++){\n        if(pgy[i].col!=lastc)\n            numc++,id_to[numc] = pgy[i].col;\n        lastc = pgy[i].col;\n        pgy[i].col = numc;\n    }\n    sort(pgy+1,pgy+n+1,cmp2);\n    \n    for(int i = 1;i<=n;i++)\n        cnt[pgy[i].col][pgy[i].belong]++;\n    for(int i = 1;i<=numc;i++)\n        for(int j = 1;j<=n/Q;j++)\n            cnt[i][j] += cnt[i][j-1];\n}\n\nvoid build(){\n    for(int i = 1;i<=n;i+=Q){\n        memset(t,0,sizeof(t));\n        int maxn = 0;\n        for(int j = i;j<=n;j++){\n            int nowc = pgy[j].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n            if(j%Q == 0)\n                z[(i-1)/Q+1][j/Q] = maxn;\n        }\n    }\n}\n\n\n\nint answer(int ql,int qr){\n    int lb = pgy[ql].belong,rb = pgy[qr].belong,maxn = 0;\n    //printf(\"lblock:%d rblock:%d\\n\",lb,rb);\n    if(lb == rb || lb+1 == rb){\n        for(int i = ql;i<=qr;i++)\n            t[pgy[i].col] = 0;\n        for(int i = ql;i<=qr;i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n        }\n    }\n    else{\n        for(int i = ql;i<bl[lb+1];i++)\n            t[pgy[i].col] = 0;\n        for(int i = br[rb-1]+1;i<=qr;i++)\n            t[pgy[i].col] = 0;\n        maxn = z[lb+1][rb-1];\n        t[maxn] = 0;\n        for(int i = ql;i<bl[lb+1];i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb];\n            int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb];\n            if(tmp > maxnum || (tmp == maxnum && nowc < maxn))\n                maxn = nowc;\n        }\n        for(int i = br[rb-1]+1;i<=qr;i++){\n            int nowc = pgy[i].col;\n            t[nowc]++;\n            int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb];\n            int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb];\n            if(tmp > maxnum || (tmp == maxnum && nowc < maxn))\n                maxn = nowc;\n        }\n    }\n    return id_to[maxn];\n}\n\n\nvoid solve(){\n    int a,b,lastans = 0;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1;\n        if(a > b) swap(a,b);\n        lastans = answer(a,b);\n        print(lastans),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n\n做法二：\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n//快读模版\nnamespace fast_io {\n    inline char read() {...}\n    inline void read(int &x) {...}\n    inline void read(char *a){...}\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {...}\n    inline void print(int x) {...}\n    inline void print(char *a){...}\n    inline void flush() {...}\n}using namespace fast_io;\n\nconst int MAXN = 101000,MAXQ = 1000;\n\nvector<int> pos[MAXN];\n\nint n,m,Q;\n\nstruct pu{\n    int col,id;\n}pgy[MAXN];\n\n//在[i,j]块中的众数\nint z[MAXQ][MAXQ];\n\nint id_to[MAXN];\n\nbool cmp1(pu a,pu b){\n    return a.col < b.col;\n}\n\nbool cmp2(pu a,pu b){\n    return a.id < b.id;\n}\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n*5);\n    for(int i = 1;i<=n;i++)\n        read(pgy[i].col),pgy[i].id = i;\n    sort(pgy+1,pgy+n+1,cmp1);\n    int lastc = 0,numc = 0;\n    for(int i = 1;i<=n;i++){\n        if(pgy[i].col!=lastc)\n            numc++,id_to[numc] = pgy[i].col;\n        lastc = pgy[i].col;\n        pgy[i].col = numc;\n    }\n    sort(pgy+1,pgy+n+1,cmp2);\n    for(int i = 1;i<=n;i++){\n        pos[pgy[i].col].push_back(i);\n    }\n}\n\nvoid build(){\n    static int t[MAXN];\n    for(int i = 1;i<=n;i+=Q){\n        memset(t,0,sizeof(t));\n        int maxn = 0;\n        for(int j = i;j<=n;j++){\n            int nowc = pgy[j].col;\n            t[nowc]++;\n            if(t[nowc] > t[maxn] ||(t[nowc] == t[maxn] && nowc < maxn))\n                maxn = nowc;\n            if(j%Q == 0)\n                z[(i-1)/Q+1][j/Q] = maxn;\n        }\n    }\n}\n\n\nint count_num(int lb,int rb,int num){\n    return lower_bound(pos[num].begin(),pos[num].end(),rb+1)-lower_bound(pos[num].begin(),pos[num].end(),lb);\n}\n\nint answer(int ql,int qr){\n    int lb = floor(double(ql-2)/Q)+2,rb = qr/Q,maxn = 0,maxnum = 0;\n    if(lb <= rb) maxn = z[lb][rb],maxnum = count_num(ql,qr,maxn);\n    //printf(\"lblock:%d rblock:%d\\n\",lb,rb);\n    lb = (lb-1)*Q+1,rb = rb*Q;\n    //printf(\"lbound:%d rbound:%d maxn:%d\\n\",lb,rb,maxn);\n    while(ql < lb){\n        --lb;\n        int c = pgy[lb].col,w = count_num(ql,qr,c);\n        if(w > maxnum || (w == maxnum && c < maxn))\n            maxn = c,maxnum = w;\n    }\n    while(rb < qr){\n        rb++;\n        int c = pgy[rb].col,w = count_num(ql,qr,c);\n        if(w > maxnum || (w == maxnum && c < maxn))\n            maxn = c,maxnum = w;\n    }\n    return id_to[maxn];\n}\n\n\nvoid solve(){\n    int a,b,lastans = 0;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1;\n        if(a > b) swap(a,b);\n        lastans = answer(a,b);\n        print(lastans),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「Violet」蒲公英-分块","published":1,"updated":"2018-03-31T04:33:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3kz004ybljr8t3guaec","content":"<p>给定一个数列${a_n}$，$m$次询问在$[l,r]$区间内的最小众数。<br>强制在线。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4168\" target=\"_blank\" rel=\"noopener\">Luogu P4168</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>为了在课上讲分块，特地做了一道大分块的题。</p>\n<p>做法一：<br>预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；$cnt[i][c]$，表示在前i个数中颜色为c的数的个数。</p>\n<p>可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。</p>\n<p>每次查询，先将答案设成整块的众数。对于零散的数，暴力统计出在零散块中出现的次数，然后加上在整块出现的次数（前缀和相减），尝试更新答案。</p>\n<p>可以证明，复杂度大约是$O(n\\ \\sqrt{n} )$。</p>\n<hr>\n<p>做法二：<br>预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；对于每一种颜色，开一个vector把这个数每次出现的位置，按从前到后顺序加进去。这样，我们可以在$O(\\log{n})$的时间内通过二分查询出一个数在[l,r]区间出现了多少次。</p>\n<p>可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。</p>\n<p>每次查询，先将答案设成整块的众数，并且记录其在$[l,r]$出现次数，然后对于每一个零散块中的数，查询其在[l,r]中出现的次数，并尝试更新答案。</p>\n<p>可以证明，复杂度大约是$O(n\\ \\sqrt {n}\\ \\log{n})$。这个复杂度存在被卡死的可能。</p>\n<hr>\n<p>由于数据范围很大，需要离散化并且记录离散化后的数对应之前的数是什么。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>做法一：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//快读模版</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">101000</span>,MAXQ = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pu</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> col,id,belong;</span><br><span class=\"line\">&#125;pgy[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,Q;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bl[MAXQ],br[MAXQ],id_to[MAXN],numc = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> z[MAXQ][MAXQ],cnt[MAXN][MAXQ],t[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(pu a,pu b)</span></span>&#123;<span class=\"keyword\">return</span> a.col &lt; b.col;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(pu a,pu b)</span></span>&#123;<span class=\"keyword\">return</span> a.id &lt; b.id;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);Q = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(pgy[i].col);</span><br><span class=\"line\">        pgy[i].id = i,pgy[i].belong = (i<span class=\"number\">-1</span>)/Q+<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!bl[pgy[i].belong]) </span><br><span class=\"line\">            bl[pgy[i].belong] = i;</span><br><span class=\"line\">        br[pgy[i].belong] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(pgy+<span class=\"number\">1</span>,pgy+n+<span class=\"number\">1</span>,cmp1);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pgy[i].col!=lastc)</span><br><span class=\"line\">            numc++,id_to[numc] = pgy[i].col;</span><br><span class=\"line\">        lastc = pgy[i].col;</span><br><span class=\"line\">        pgy[i].col = numc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(pgy+<span class=\"number\">1</span>,pgy+n+<span class=\"number\">1</span>,cmp2);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cnt[pgy[i].col][pgy[i].belong]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=numc;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=n/Q;j++)</span><br><span class=\"line\">            cnt[i][j] += cnt[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i+=Q)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(t,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(t));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowc = pgy[j].col;</span><br><span class=\"line\">            t[nowc]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t[nowc] &gt; t[maxn] ||(t[nowc] == t[maxn] &amp;&amp; nowc &lt; maxn))</span><br><span class=\"line\">                maxn = nowc;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j%Q == <span class=\"number\">0</span>)</span><br><span class=\"line\">                z[(i<span class=\"number\">-1</span>)/Q+<span class=\"number\">1</span>][j/Q] = maxn;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">answer</span><span class=\"params\">(<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lb = pgy[ql].belong,rb = pgy[qr].belong,maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//printf(\"lblock:%d rblock:%d\\n\",lb,rb);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lb == rb || lb+<span class=\"number\">1</span> == rb)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = ql;i&lt;=qr;i++)</span><br><span class=\"line\">            t[pgy[i].col] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = ql;i&lt;=qr;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowc = pgy[i].col;</span><br><span class=\"line\">            t[nowc]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t[nowc] &gt; t[maxn] ||(t[nowc] == t[maxn] &amp;&amp; nowc &lt; maxn))</span><br><span class=\"line\">                maxn = nowc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = ql;i&lt;bl[lb+<span class=\"number\">1</span>];i++)</span><br><span class=\"line\">            t[pgy[i].col] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = br[rb<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;i&lt;=qr;i++)</span><br><span class=\"line\">            t[pgy[i].col] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        maxn = z[lb+<span class=\"number\">1</span>][rb<span class=\"number\">-1</span>];</span><br><span class=\"line\">        t[maxn] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = ql;i&lt;bl[lb+<span class=\"number\">1</span>];i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowc = pgy[i].col;</span><br><span class=\"line\">            t[nowc]++;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxnum = t[maxn] + cnt[maxn][rb<span class=\"number\">-1</span>]-cnt[maxn][lb];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = t[nowc] + cnt[nowc][rb<span class=\"number\">-1</span>]-cnt[nowc][lb];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; maxnum || (tmp == maxnum &amp;&amp; nowc &lt; maxn))</span><br><span class=\"line\">                maxn = nowc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = br[rb<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;i&lt;=qr;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowc = pgy[i].col;</span><br><span class=\"line\">            t[nowc]++;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxnum = t[maxn] + cnt[maxn][rb<span class=\"number\">-1</span>]-cnt[maxn][lb];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = t[nowc] + cnt[nowc][rb<span class=\"number\">-1</span>]-cnt[nowc][lb];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp &gt; maxnum || (tmp == maxnum &amp;&amp; nowc &lt; maxn))</span><br><span class=\"line\">                maxn = nowc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id_to[maxn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,lastans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        a = (a+lastans<span class=\"number\">-1</span>)%n+<span class=\"number\">1</span>,b = (b+lastans<span class=\"number\">-1</span>)%n+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a &gt; b) swap(a,b);</span><br><span class=\"line\">        lastans = answer(a,b);</span><br><span class=\"line\">        print(lastans),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div></p>\n<p>做法二：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//快读模版</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">101000</span>,MAXQ = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; pos[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,Q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pu</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> col,id;</span><br><span class=\"line\">&#125;pgy[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在[i,j]块中的众数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> z[MAXQ][MAXQ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> id_to[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(pu a,pu b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.col &lt; b.col;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(pu a,pu b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id &lt; b.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);Q = <span class=\"built_in\">sqrt</span>(n*<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(pgy[i].col),pgy[i].id = i;</span><br><span class=\"line\">    sort(pgy+<span class=\"number\">1</span>,pgy+n+<span class=\"number\">1</span>,cmp1);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastc = <span class=\"number\">0</span>,numc = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pgy[i].col!=lastc)</span><br><span class=\"line\">            numc++,id_to[numc] = pgy[i].col;</span><br><span class=\"line\">        lastc = pgy[i].col;</span><br><span class=\"line\">        pgy[i].col = numc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(pgy+<span class=\"number\">1</span>,pgy+n+<span class=\"number\">1</span>,cmp2);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        pos[pgy[i].col].push_back(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> t[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i+=Q)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(t,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(t));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxn = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowc = pgy[j].col;</span><br><span class=\"line\">            t[nowc]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t[nowc] &gt; t[maxn] ||(t[nowc] == t[maxn] &amp;&amp; nowc &lt; maxn))</span><br><span class=\"line\">                maxn = nowc;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j%Q == <span class=\"number\">0</span>)</span><br><span class=\"line\">                z[(i<span class=\"number\">-1</span>)/Q+<span class=\"number\">1</span>][j/Q] = maxn;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count_num</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> rb,<span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lower_bound(pos[num].begin(),pos[num].end(),rb+<span class=\"number\">1</span>)-lower_bound(pos[num].begin(),pos[num].end(),lb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">answer</span><span class=\"params\">(<span class=\"keyword\">int</span> ql,<span class=\"keyword\">int</span> qr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lb = <span class=\"built_in\">floor</span>(<span class=\"keyword\">double</span>(ql<span class=\"number\">-2</span>)/Q)+<span class=\"number\">2</span>,rb = qr/Q,maxn = <span class=\"number\">0</span>,maxnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lb &lt;= rb) maxn = z[lb][rb],maxnum = count_num(ql,qr,maxn);</span><br><span class=\"line\">    <span class=\"comment\">//printf(\"lblock:%d rblock:%d\\n\",lb,rb);</span></span><br><span class=\"line\">    lb = (lb<span class=\"number\">-1</span>)*Q+<span class=\"number\">1</span>,rb = rb*Q;</span><br><span class=\"line\">    <span class=\"comment\">//printf(\"lbound:%d rbound:%d maxn:%d\\n\",lb,rb,maxn);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ql &lt; lb)&#123;</span><br><span class=\"line\">        --lb;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = pgy[lb].col,w = count_num(ql,qr,c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w &gt; maxnum || (w == maxnum &amp;&amp; c &lt; maxn))</span><br><span class=\"line\">            maxn = c,maxnum = w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(rb &lt; qr)&#123;</span><br><span class=\"line\">        rb++;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = pgy[rb].col,w = count_num(ql,qr,c);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(w &gt; maxnum || (w == maxnum &amp;&amp; c &lt; maxn))</span><br><span class=\"line\">            maxn = c,maxnum = w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> id_to[maxn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,lastans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        a = (a+lastans<span class=\"number\">-1</span>)%n+<span class=\"number\">1</span>,b = (b+lastans<span class=\"number\">-1</span>)%n+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a &gt; b) swap(a,b);</span><br><span class=\"line\">        lastans = answer(a,b);</span><br><span class=\"line\">        print(lastans),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div></p>\n","site":{"data":{}},"excerpt":"<p>给定一个数列${a_n}$，$m$次询问在$[l,r]$区间内的最小众数。<br>强制在线。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P4168\" target=\"_blank\" rel=\"noopener\">Luogu P4168</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>为了在课上讲分块，特地做了一道大分块的题。</p>\n<p>做法一：<br>预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；$cnt[i][c]$，表示在前i个数中颜色为c的数的个数。</p>\n<p>可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。</p>\n<p>每次查询，先将答案设成整块的众数。对于零散的数，暴力统计出在零散块中出现的次数，然后加上在整块出现的次数（前缀和相减），尝试更新答案。</p>\n<p>可以证明，复杂度大约是$O(n\\ \\sqrt{n} )$。</p>\n<hr>\n<p>做法二：<br>预处理出$z[i][j]$，表示在$[i,j]$个块的区间中的众数；对于每一种颜色，开一个vector把这个数每次出现的位置，按从前到后顺序加进去。这样，我们可以在$O(\\log{n})$的时间内通过二分查询出一个数在[l,r]区间出现了多少次。</p>\n<p>可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。</p>\n<p>每次查询，先将答案设成整块的众数，并且记录其在$[l,r]$出现次数，然后对于每一个零散块中的数，查询其在[l,r]中出现的次数，并尝试更新答案。</p>\n<p>可以证明，复杂度大约是$O(n\\ \\sqrt {n}\\ \\log{n})$。这个复杂度存在被卡死的可能。</p>\n<hr>\n<p>由于数据范围很大，需要离散化并且记录离散化后的数对应之前的数是什么。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>做法一：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�57-->\n\n</div></div></p>\n<p>做法二：<br><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�58-->\n\n</div></div></p>"},{"title":"「ZJOI2007」报表统计-平衡树","urlname":"zjoi2007-count","date":"2018-03-03T10:29:17.000Z","visible":null,"_content":"\n\n有一个长度为$n$的整数序列，并且有以下三种操作：\n\n+ $INSERT\\ i\\ k$：在原数列的第$i$个数后面添加一个新数$k$；如果原数列的第$i$个数已经添加了若干数，则添加在这些数的最后\n\n+ $MIN\\ GAP$：查询相邻两个数的之间差值（绝对值）的最小值\n\n+ $MIN\\ SORT\\ GAP$：查询所有数中最接近的两个数的差值（绝对值）\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1110](https://www.luogu.org/problemnew/show/P1110)\n\n## 题解\n\n一道近乎于裸的`Treap`，然而由于我十分蒟蒻而且好久没敲`Treap`，调了两个小时才调完。\n\n- - -\n\n这道题我们维护两棵平衡树，一颗$b$记录所有相邻数的差的绝对值，一颗$b$记录所有的数；一个列表，记录每个块的最前面和最后面的数。我们注意到询问三的结果随插入的数不增，所以只需要维护一个最小值$minn$就可以了。\n\n- - -\n\n+ $insert$ 操作：首先根据列表内容从$b$里删除对应位置块间两数的差，然后把插入后多出来的相邻元素差，这个数与这一块结尾，下一块最前面的数的差分别插入平衡树$b$，注意`i == n`时需要特判；并把插入的数加到$a$里面，根据其与前驱后继的差更新$minn$，注意需要判断一下是否这个数已经在平衡树里面存在。\n\n+ 相邻元素的差值最小值：直接在$b$里求最小值并输出。\n\n+ 排序后的最小差值：直接输出$minn$。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    ...//隐去快读模版\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(char *c){\n    \tscanf(\"%s\",c);\n    }\n    inline void read(int &x){\n        scanf(\"%d\",&x);\n    }\n    inline void print(int x){\n        printf(\"%d\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}using namespace normal_io;\n\nstruct treap{\n    struct node{\n        int val,p,cnt;\n        node* son[2];\n    };\n    const static int MAXN = 1000000;\n    int treapcnt;\n    node pool[MAXN],*null,*root;\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        srand(19260817);\n        null->val = -0x3f3f3f3f;\n        null->p = 2147483647;\n        null->cnt = 0;\n        root = null;\n    }\n    void rotate(node *&r,int tmp){\n        node *t = r->son[1-tmp];\n        r->son[1-tmp] = t->son[tmp];\n        t->son[tmp] = r;\n        r = t;\n    }\n    void newnode(node *&r){\n        r = &pool[treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void __insert(node *&r,int v){\n        if(r == null){\n            newnode(r);\n            r->val = v;r->p = rand();r->cnt = 1;\n        }\n        else{\n            if(r->val == v)\n                r->cnt++;\n            else{\n                int tmp = v > r->val;\n                __insert(r->son[tmp],v);\n                if(r->son[tmp]->p < r->p)\n                    rotate(r,1-tmp);\n            }\n        }\n    }\n    node *find(node *r,int t){\n        while(r->son[t]!=null)\n            r = r->son[t];\n        return r;\n    }\n    void __erase(node *&r,int v){\n        if(r->val == v){\n            if(r->cnt > 1)\n                r->cnt--;\n            else{\n                if(r->son[0] == null&&r->son[1] == null){\n                    r = null;return;\n                }\n                else{\n                    int tt = r->son[0]->p > r->son[1]->p;\n                    rotate(r,1-tt);\n                    __erase(r,v);\n                }\n            }\n        }\n        else{\n            int tmp = v > r->val;\n            __erase(r->son[tmp],v);\n        }\n    }\n    node *nei(int v,int t){\n        node* nown = root,*last = null;\n        while(nown!=null&&nown->val!=v){\n            //printf(\"2\\n\");\n            int tmp = v > nown->val;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null){\n            last = find(nown->son[t],1-t);\n        }\n        return last;\n    }\n    bool find(int v){\n        node *r = root;\n        while(r!=null&&r->val!=v){\n            int tmp = v > r->val;\n            r = r->son[tmp];\n        }\n        return r != null;\n    }\n    inline void __print(node *r,int depth = 0){\n    \tif(r == null) return;\n    \telse{\n        \t__print(r->son[0],depth+1);\n        \tfor(int i = 0;i<depth;i++) putchar(' ');\n        \tprintf(\"val:%d cnt:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->p,r->son[0]!=null,r->son[1]!=null);\n        \t__print(r->son[1],depth+1);\n    \t}\n    }\n    void insert(int v){\n        __insert(root,v);\n    }\n    void erase(int v){\n        __erase(root,v);\n    }\n    void print(){\n        __print(root);\n    }\n};\n//以上treap常规模版\n\ntreap a,b;\nconst int MAXN = 1000000;\n\nint head[MAXN],tail[MAXN],minn,n,m;\n//a是所有数，b是所有相邻数差值\n//head记录此块最前数，tail记录最后数。\n\nvoid init(){\n    minn = 0x3f3f3f3f;\n    read(n),read(m);\n    static int tmp[MAXN];\n    for(int i = 1;i<=n;i++){\n        int t;read(t);\n        a.insert(t);\n        head[i] = tail[i] = tmp[i] = t;\n    }\n    sort(tmp+1,tmp+n+1);\n    for(int i = 2;i<=n;i++){\n        //更新初始的两个查询答案\n        b.insert(abs(head[i]-head[i-1]));\n        minn = min(minn,tmp[i]-tmp[i-1]);\n    }\n}\n\nvoid solve(){\n    char op[20];int x,y;\n    for(int i = 1;i<=m;i++){\n        read(op);\n        if(op[4] == 'G'){\n            print(b.find(b.root,0)->val),print('\\n');\n            //寻找最小相邻元素差值\n        }\n        else if(op[4] == 'S'){\n            print(minn),print('\\n');\n            //寻找排序元素差值\n        }\n        else if(op[4] == 'R'){\n            read(x),read(y);\n            if(x != n){\n                b.erase(abs(head[x+1]-tail[x]));\n                b.insert(abs(head[x+1]-y));\n            }\n            b.insert(abs(tail[x]-y));\n            tail[x] = y;\n            //更新查询2答案\n            if(a.find(y)) minn = 0;\n            else{\n                int low = a.nei(y,0)->val,up = a.nei(y,1)->val;\n                minn = min(minn,min(abs(y-low),abs(up-y)));\n            }\n            a.insert(y);\n            //更新查询3答案\n        }\n        else if(op[4] =='P'){\n            a.print();\n            printf(\"------------------------\\n\");\n            b.print();\n            //调试用\n        }\n        //printf(\"Finish\\n\");\n    }\n    \n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n\n```\n\n{% endfold %}\n","source":"_posts/「ZJOI2007」报表统计-平衡树.md","raw":"---\ntitle: 「ZJOI2007」报表统计-平衡树\nurlname: zjoi2007-count\ndate: 2018-03-03 18:29:17\ntags:\n- 题解\n- Treap\n- 平衡树\n- 数据结构\ncategories: OI\nvisible:\n---\n\n\n有一个长度为$n$的整数序列，并且有以下三种操作：\n\n+ $INSERT\\ i\\ k$：在原数列的第$i$个数后面添加一个新数$k$；如果原数列的第$i$个数已经添加了若干数，则添加在这些数的最后\n\n+ $MIN\\ GAP$：查询相邻两个数的之间差值（绝对值）的最小值\n\n+ $MIN\\ SORT\\ GAP$：查询所有数中最接近的两个数的差值（绝对值）\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1110](https://www.luogu.org/problemnew/show/P1110)\n\n## 题解\n\n一道近乎于裸的`Treap`，然而由于我十分蒟蒻而且好久没敲`Treap`，调了两个小时才调完。\n\n- - -\n\n这道题我们维护两棵平衡树，一颗$b$记录所有相邻数的差的绝对值，一颗$b$记录所有的数；一个列表，记录每个块的最前面和最后面的数。我们注意到询问三的结果随插入的数不增，所以只需要维护一个最小值$minn$就可以了。\n\n- - -\n\n+ $insert$ 操作：首先根据列表内容从$b$里删除对应位置块间两数的差，然后把插入后多出来的相邻元素差，这个数与这一块结尾，下一块最前面的数的差分别插入平衡树$b$，注意`i == n`时需要特判；并把插入的数加到$a$里面，根据其与前驱后继的差更新$minn$，注意需要判断一下是否这个数已经在平衡树里面存在。\n\n+ 相邻元素的差值最小值：直接在$b$里求最小值并输出。\n\n+ 排序后的最小差值：直接输出$minn$。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\nnamespace fast_io {\n    ...//隐去快读模版\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(char *c){\n    \tscanf(\"%s\",c);\n    }\n    inline void read(int &x){\n        scanf(\"%d\",&x);\n    }\n    inline void print(int x){\n        printf(\"%d\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}using namespace normal_io;\n\nstruct treap{\n    struct node{\n        int val,p,cnt;\n        node* son[2];\n    };\n    const static int MAXN = 1000000;\n    int treapcnt;\n    node pool[MAXN],*null,*root;\n    treap(){\n        treapcnt = 0;\n        newnode(null);\n        srand(19260817);\n        null->val = -0x3f3f3f3f;\n        null->p = 2147483647;\n        null->cnt = 0;\n        root = null;\n    }\n    void rotate(node *&r,int tmp){\n        node *t = r->son[1-tmp];\n        r->son[1-tmp] = t->son[tmp];\n        t->son[tmp] = r;\n        r = t;\n    }\n    void newnode(node *&r){\n        r = &pool[treapcnt++];\n        r->son[0] = r->son[1] = null;\n    }\n    void __insert(node *&r,int v){\n        if(r == null){\n            newnode(r);\n            r->val = v;r->p = rand();r->cnt = 1;\n        }\n        else{\n            if(r->val == v)\n                r->cnt++;\n            else{\n                int tmp = v > r->val;\n                __insert(r->son[tmp],v);\n                if(r->son[tmp]->p < r->p)\n                    rotate(r,1-tmp);\n            }\n        }\n    }\n    node *find(node *r,int t){\n        while(r->son[t]!=null)\n            r = r->son[t];\n        return r;\n    }\n    void __erase(node *&r,int v){\n        if(r->val == v){\n            if(r->cnt > 1)\n                r->cnt--;\n            else{\n                if(r->son[0] == null&&r->son[1] == null){\n                    r = null;return;\n                }\n                else{\n                    int tt = r->son[0]->p > r->son[1]->p;\n                    rotate(r,1-tt);\n                    __erase(r,v);\n                }\n            }\n        }\n        else{\n            int tmp = v > r->val;\n            __erase(r->son[tmp],v);\n        }\n    }\n    node *nei(int v,int t){\n        node* nown = root,*last = null;\n        while(nown!=null&&nown->val!=v){\n            //printf(\"2\\n\");\n            int tmp = v > nown->val;\n            if(tmp!=t) last = nown;\n            nown = nown->son[tmp];\n        }\n        if(nown->son[t]!=null){\n            last = find(nown->son[t],1-t);\n        }\n        return last;\n    }\n    bool find(int v){\n        node *r = root;\n        while(r!=null&&r->val!=v){\n            int tmp = v > r->val;\n            r = r->son[tmp];\n        }\n        return r != null;\n    }\n    inline void __print(node *r,int depth = 0){\n    \tif(r == null) return;\n    \telse{\n        \t__print(r->son[0],depth+1);\n        \tfor(int i = 0;i<depth;i++) putchar(' ');\n        \tprintf(\"val:%d cnt:%d P:%d son?:%d %d\\n\",r->val,r->cnt,r->p,r->son[0]!=null,r->son[1]!=null);\n        \t__print(r->son[1],depth+1);\n    \t}\n    }\n    void insert(int v){\n        __insert(root,v);\n    }\n    void erase(int v){\n        __erase(root,v);\n    }\n    void print(){\n        __print(root);\n    }\n};\n//以上treap常规模版\n\ntreap a,b;\nconst int MAXN = 1000000;\n\nint head[MAXN],tail[MAXN],minn,n,m;\n//a是所有数，b是所有相邻数差值\n//head记录此块最前数，tail记录最后数。\n\nvoid init(){\n    minn = 0x3f3f3f3f;\n    read(n),read(m);\n    static int tmp[MAXN];\n    for(int i = 1;i<=n;i++){\n        int t;read(t);\n        a.insert(t);\n        head[i] = tail[i] = tmp[i] = t;\n    }\n    sort(tmp+1,tmp+n+1);\n    for(int i = 2;i<=n;i++){\n        //更新初始的两个查询答案\n        b.insert(abs(head[i]-head[i-1]));\n        minn = min(minn,tmp[i]-tmp[i-1]);\n    }\n}\n\nvoid solve(){\n    char op[20];int x,y;\n    for(int i = 1;i<=m;i++){\n        read(op);\n        if(op[4] == 'G'){\n            print(b.find(b.root,0)->val),print('\\n');\n            //寻找最小相邻元素差值\n        }\n        else if(op[4] == 'S'){\n            print(minn),print('\\n');\n            //寻找排序元素差值\n        }\n        else if(op[4] == 'R'){\n            read(x),read(y);\n            if(x != n){\n                b.erase(abs(head[x+1]-tail[x]));\n                b.insert(abs(head[x+1]-y));\n            }\n            b.insert(abs(tail[x]-y));\n            tail[x] = y;\n            //更新查询2答案\n            if(a.find(y)) minn = 0;\n            else{\n                int low = a.nei(y,0)->val,up = a.nei(y,1)->val;\n                minn = min(minn,min(abs(y-low),abs(up-y)));\n            }\n            a.insert(y);\n            //更新查询3答案\n        }\n        else if(op[4] =='P'){\n            a.print();\n            printf(\"------------------------\\n\");\n            b.print();\n            //调试用\n        }\n        //printf(\"Finish\\n\");\n    }\n    \n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n\n```\n\n{% endfold %}\n","slug":"「ZJOI2007」报表统计-平衡树","published":1,"updated":"2018-03-14T14:21:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3l10052bljr1fdtzfcu","content":"<p>有一个长度为$n$的整数序列，并且有以下三种操作：</p>\n<ul>\n<li><p>$INSERT\\ i\\ k$：在原数列的第$i$个数后面添加一个新数$k$；如果原数列的第$i$个数已经添加了若干数，则添加在这些数的最后</p>\n</li>\n<li><p>$MIN\\ GAP$：查询相邻两个数的之间差值（绝对值）的最小值</p>\n</li>\n<li><p>$MIN\\ SORT\\ GAP$：查询所有数中最接近的两个数的差值（绝对值）</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1110\" target=\"_blank\" rel=\"noopener\">Luogu P1110</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道近乎于裸的<code>Treap</code>，然而由于我十分蒟蒻而且好久没敲<code>Treap</code>，调了两个小时才调完。</p>\n<hr>\n<p>这道题我们维护两棵平衡树，一颗$b$记录所有相邻数的差的绝对值，一颗$b$记录所有的数；一个列表，记录每个块的最前面和最后面的数。我们注意到询问三的结果随插入的数不增，所以只需要维护一个最小值$minn$就可以了。</p>\n<hr>\n<ul>\n<li><p>$insert$ 操作：首先根据列表内容从$b$里删除对应位置块间两数的差，然后把插入后多出来的相邻元素差，这个数与这一块结尾，下一块最前面的数的差分别插入平衡树$b$，注意<code>i == n</code>时需要特判；并把插入的数加到$a$里面，根据其与前驱后继的差更新$minn$，注意需要判断一下是否这个数已经在平衡树里面存在。</p>\n</li>\n<li><p>相邻元素的差值最小值：直接在$b$里求最小值并输出。</p>\n</li>\n<li><p>排序后的最小差值：直接输出$minn$。</p>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//隐去快读模版</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> normal_io&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *c)</span></span>&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> normal_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">treap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> val,p,cnt;</span><br><span class=\"line\">        node* son[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> treapcnt;</span><br><span class=\"line\">    node pool[MAXN],*null,*root;</span><br><span class=\"line\">    treap()&#123;</span><br><span class=\"line\">        treapcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        newnode(null);</span><br><span class=\"line\">        srand(<span class=\"number\">19260817</span>);</span><br><span class=\"line\">        null-&gt;val = <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">        null-&gt;p = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\">        null-&gt;cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        root = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(node *&amp;r,<span class=\"keyword\">int</span> tmp)</span></span>&#123;</span><br><span class=\"line\">        node *t = r-&gt;son[<span class=\"number\">1</span>-tmp];</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">1</span>-tmp] = t-&gt;son[tmp];</span><br><span class=\"line\">        t-&gt;son[tmp] = r;</span><br><span class=\"line\">        r = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(node *&amp;r)</span></span>&#123;</span><br><span class=\"line\">        r = &amp;pool[treapcnt++];</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __insert(node *&amp;r,<span class=\"keyword\">int</span> v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null)&#123;</span><br><span class=\"line\">            newnode(r);</span><br><span class=\"line\">            r-&gt;val = v;r-&gt;p = rand();r-&gt;cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;val == v)</span><br><span class=\"line\">                r-&gt;cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp = v &gt; r-&gt;val;</span><br><span class=\"line\">                __insert(r-&gt;son[tmp],v);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r-&gt;son[tmp]-&gt;p &lt; r-&gt;p)</span><br><span class=\"line\">                    rotate(r,<span class=\"number\">1</span>-tmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">node *<span class=\"title\">find</span><span class=\"params\">(node *r,<span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r-&gt;son[t]!=null)</span><br><span class=\"line\">            r = r-&gt;son[t];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> __erase(node *&amp;r,<span class=\"keyword\">int</span> v)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;val == v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-&gt;cnt &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                r-&gt;cnt--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>] == null&amp;&amp;r-&gt;son[<span class=\"number\">1</span>] == null)&#123;</span><br><span class=\"line\">                    r = null;<span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tt = r-&gt;son[<span class=\"number\">0</span>]-&gt;p &gt; r-&gt;son[<span class=\"number\">1</span>]-&gt;p;</span><br><span class=\"line\">                    rotate(r,<span class=\"number\">1</span>-tt);</span><br><span class=\"line\">                    __erase(r,v);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = v &gt; r-&gt;val;</span><br><span class=\"line\">            __erase(r-&gt;son[tmp],v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">node *<span class=\"title\">nei</span><span class=\"params\">(<span class=\"keyword\">int</span> v,<span class=\"keyword\">int</span> t)</span></span>&#123;</span><br><span class=\"line\">        node* nown = root,*last = null;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(nown!=null&amp;&amp;nown-&gt;val!=v)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//printf(\"2\\n\");</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = v &gt; nown-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tmp!=t) last = nown;</span><br><span class=\"line\">            nown = nown-&gt;son[tmp];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nown-&gt;son[t]!=null)&#123;</span><br><span class=\"line\">            last = find(nown-&gt;son[t],<span class=\"number\">1</span>-t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        node *r = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r!=null&amp;&amp;r-&gt;val!=v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> tmp = v &gt; r-&gt;val;</span><br><span class=\"line\">            r = r-&gt;son[tmp];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r != null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> __print(node *r,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        \t__print(r-&gt;son[<span class=\"number\">0</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        \t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;depth;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"val:%d cnt:%d P:%d son?:%d %d\\n\"</span>,r-&gt;val,r-&gt;cnt,r-&gt;p,r-&gt;son[<span class=\"number\">0</span>]!=null,r-&gt;son[<span class=\"number\">1</span>]!=null);</span><br><span class=\"line\">        \t__print(r-&gt;son[<span class=\"number\">1</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        __insert(root,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"keyword\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">        __erase(root,v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        __print(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//以上treap常规模版</span></span><br><span class=\"line\"></span><br><span class=\"line\">treap a,b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> head[MAXN],tail[MAXN],minn,n,m;</span><br><span class=\"line\"><span class=\"comment\">//a是所有数，b是所有相邻数差值</span></span><br><span class=\"line\"><span class=\"comment\">//head记录此块最前数，tail记录最后数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    minn = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> tmp[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t;read(t);</span><br><span class=\"line\">        a.insert(t);</span><br><span class=\"line\">        head[i] = tail[i] = tmp[i] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(tmp+<span class=\"number\">1</span>,tmp+n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//更新初始的两个查询答案</span></span><br><span class=\"line\">        b.insert(<span class=\"built_in\">abs</span>(head[i]-head[i<span class=\"number\">-1</span>]));</span><br><span class=\"line\">        minn = min(minn,tmp[i]-tmp[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];<span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(op);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">4</span>] == <span class=\"string\">'G'</span>)&#123;</span><br><span class=\"line\">            print(b.find(b.root,<span class=\"number\">0</span>)-&gt;val),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">            <span class=\"comment\">//寻找最小相邻元素差值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">4</span>] == <span class=\"string\">'S'</span>)&#123;</span><br><span class=\"line\">            print(minn),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">            <span class=\"comment\">//寻找排序元素差值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">4</span>] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            read(x),read(y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(x != n)&#123;</span><br><span class=\"line\">                b.erase(<span class=\"built_in\">abs</span>(head[x+<span class=\"number\">1</span>]-tail[x]));</span><br><span class=\"line\">                b.insert(<span class=\"built_in\">abs</span>(head[x+<span class=\"number\">1</span>]-y));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            b.insert(<span class=\"built_in\">abs</span>(tail[x]-y));</span><br><span class=\"line\">            tail[x] = y;</span><br><span class=\"line\">            <span class=\"comment\">//更新查询2答案</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a.find(y)) minn = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> low = a.nei(y,<span class=\"number\">0</span>)-&gt;val,up = a.nei(y,<span class=\"number\">1</span>)-&gt;val;</span><br><span class=\"line\">                minn = min(minn,min(<span class=\"built_in\">abs</span>(y-low),<span class=\"built_in\">abs</span>(up-y)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            a.insert(y);</span><br><span class=\"line\">            <span class=\"comment\">//更新查询3答案</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">4</span>] ==<span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">            a.print();</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"------------------------\\n\"</span>);</span><br><span class=\"line\">            b.print();</span><br><span class=\"line\">            <span class=\"comment\">//调试用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//printf(\"Finish\\n\");</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>有一个长度为$n$的整数序列，并且有以下三种操作：</p>\n<ul>\n<li><p>$INSERT\\ i\\ k$：在原数列的第$i$个数后面添加一个新数$k$；如果原数列的第$i$个数已经添加了若干数，则添加在这些数的最后</p>\n</li>\n<li><p>$MIN\\ GAP$：查询相邻两个数的之间差值（绝对值）的最小值</p>\n</li>\n<li><p>$MIN\\ SORT\\ GAP$：查询所有数中最接近的两个数的差值（绝对值）</p>\n</li>\n</ul>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1110\" target=\"_blank\" rel=\"noopener\">Luogu P1110</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道近乎于裸的<code>Treap</code>，然而由于我十分蒟蒻而且好久没敲<code>Treap</code>，调了两个小时才调完。</p>\n<hr>\n<p>这道题我们维护两棵平衡树，一颗$b$记录所有相邻数的差的绝对值，一颗$b$记录所有的数；一个列表，记录每个块的最前面和最后面的数。我们注意到询问三的结果随插入的数不增，所以只需要维护一个最小值$minn$就可以了。</p>\n<hr>\n<ul>\n<li><p>$insert$ 操作：首先根据列表内容从$b$里删除对应位置块间两数的差，然后把插入后多出来的相邻元素差，这个数与这一块结尾，下一块最前面的数的差分别插入平衡树$b$，注意<code>i == n</code>时需要特判；并把插入的数加到$a$里面，根据其与前驱后继的差更新$minn$，注意需要判断一下是否这个数已经在平衡树里面存在。</p>\n</li>\n<li><p>相邻元素的差值最小值：直接在$b$里求最小值并输出。</p>\n</li>\n<li><p>排序后的最小差值：直接输出$minn$。</p>\n</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�59-->\n\n</div></div>"},{"title":"「ZJOI2007」时态同步-树形dp","urlname":"ZJOI2007-sync","date":"2018-03-03T10:30:16.000Z","visible":null,"_content":"\n给定一棵由$n$个节点构成的树。\n\n在树上存在一个“激发器”，标号为$s$。当激发器工作后，电流会延边传向每一个相邻节点。而中间节点接收到电流后，会将该电流传向与它连接并且尚未接收到电流的节点。对于每条边$e$，电流通过它需要的时间为$t\\_e$，电流的转发可以认为是在瞬间完成的。最终，激电流将到达一些“终止节点”――接收电流之后不再转发的节点。\n\n使用一次道具可以使得电流通过某条边的时间增加一个单位。请问最少使用多少次道具才可达到每一个“终止节点”同时收到电流？\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1131](https://www.luogu.org/problemnew/show/P1131)\n\n## 题解\n\n注意到子树无论怎么搞，对上面的选择有影响的只是一个最后电流到达终点同步的时间，所以我们把这个设计进状态里面。\n\n注意到如果子树的同步的时间最少的话，那么它的消耗道具次数就应该是最少的，同时因为这棵子树的每一层之间，至少含有一条边，那么如果子树的同步时间变多$x$，那么在子树上的道具消耗次数就一定要变多大于等于$x$，而这个时候在子树与父节点的同步中，子树的根节点与父节点间的边的同步时间最多减少$x$，所以可以证明父节点的最优消耗道具次数一定是在子节点的最优同步时间下取得的，也就可以证明$dp$的正确性。\n\n状态转移方程：\n\n$$\ntime[u] = max(time[v]+len(u,v))\n$$\n\n$$\nans[u] = sum(ans[v]+time[u]-(time[v]+len(u,v))\n$$\n\n其中$u$，$v$\b有一条边，且$v$\b非\u001d$u$的父亲。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nnamespace fast_io {\n    ...//省略快读模版\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(int &x){\n        scanf(\"%lld\",&x);\n    }\n    inline void print(int x){\n        printf(\"%lld\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}using namespace normal_io;\n\nconst int MAXN = 510000;\n\nint n,s;\n\nstruct Edge{\n    int t,l;\n    Edge(int b = 0,int c = 0):t(b),l(c){};\n};\n\nvector<Edge> edge[MAXN];\n\nint ans[MAXN],times[MAXN];\n\nbool vis[MAXN];\n\nvoid addedge(int a,int b,int c){\n    edge[a].push_back(Edge(b,c));\n    edge[b].push_back(Edge(a,c));\n}\n\nvoid init(){\n    read(n),read(s);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n}\n\nvoid dp(int nown){\n    vis[nown] = 1;\n    int tmpsum = 0,mintime = 0,k = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i].t,len = edge[nown][i].l;\n        if(vis[to] == 1)\n            continue;\n        dp(to);\n        ans[nown] += ans[to];\n        mintime = max(mintime,times[to]+len);\n        tmpsum += (times[to]+len);\n        k++;\n    }\n    ans[nown] += k * mintime - tmpsum,times[nown] = mintime;\n}\n\nvoid solve(){\n    dp(s);\n    print(ans[s]);\n}\n\nmain(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「ZJOI2007」时态同步-树形dp.md","raw":"---\ntitle: 「ZJOI2007」时态同步-树形dp\nurlname: ZJOI2007-sync\ndate: 2018-03-03 18:30:16\ntags:\n- 题解\n- 动态规划\n- 树形dp\ncategories: OI\nvisible:\n---\n\n给定一棵由$n$个节点构成的树。\n\n在树上存在一个“激发器”，标号为$s$。当激发器工作后，电流会延边传向每一个相邻节点。而中间节点接收到电流后，会将该电流传向与它连接并且尚未接收到电流的节点。对于每条边$e$，电流通过它需要的时间为$t\\_e$，电流的转发可以认为是在瞬间完成的。最终，激电流将到达一些“终止节点”――接收电流之后不再转发的节点。\n\n使用一次道具可以使得电流通过某条边的时间增加一个单位。请问最少使用多少次道具才可达到每一个“终止节点”同时收到电流？\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1131](https://www.luogu.org/problemnew/show/P1131)\n\n## 题解\n\n注意到子树无论怎么搞，对上面的选择有影响的只是一个最后电流到达终点同步的时间，所以我们把这个设计进状态里面。\n\n注意到如果子树的同步的时间最少的话，那么它的消耗道具次数就应该是最少的，同时因为这棵子树的每一层之间，至少含有一条边，那么如果子树的同步时间变多$x$，那么在子树上的道具消耗次数就一定要变多大于等于$x$，而这个时候在子树与父节点的同步中，子树的根节点与父节点间的边的同步时间最多减少$x$，所以可以证明父节点的最优消耗道具次数一定是在子节点的最优同步时间下取得的，也就可以证明$dp$的正确性。\n\n状态转移方程：\n\n$$\ntime[u] = max(time[v]+len(u,v))\n$$\n\n$$\nans[u] = sum(ans[v]+time[u]-(time[v]+len(u,v))\n$$\n\n其中$u$，$v$\b有一条边，且$v$\b非\u001d$u$的父亲。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nnamespace fast_io {\n    ...//省略快读模版\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(int &x){\n        scanf(\"%lld\",&x);\n    }\n    inline void print(int x){\n        printf(\"%lld\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}using namespace normal_io;\n\nconst int MAXN = 510000;\n\nint n,s;\n\nstruct Edge{\n    int t,l;\n    Edge(int b = 0,int c = 0):t(b),l(c){};\n};\n\nvector<Edge> edge[MAXN];\n\nint ans[MAXN],times[MAXN];\n\nbool vis[MAXN];\n\nvoid addedge(int a,int b,int c){\n    edge[a].push_back(Edge(b,c));\n    edge[b].push_back(Edge(a,c));\n}\n\nvoid init(){\n    read(n),read(s);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n}\n\nvoid dp(int nown){\n    vis[nown] = 1;\n    int tmpsum = 0,mintime = 0,k = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i].t,len = edge[nown][i].l;\n        if(vis[to] == 1)\n            continue;\n        dp(to);\n        ans[nown] += ans[to];\n        mintime = max(mintime,times[to]+len);\n        tmpsum += (times[to]+len);\n        k++;\n    }\n    ans[nown] += k * mintime - tmpsum,times[nown] = mintime;\n}\n\nvoid solve(){\n    dp(s);\n    print(ans[s]);\n}\n\nmain(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「ZJOI2007」时态同步-树形dp","published":1,"updated":"2018-03-14T14:22:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3l30054bljr5pbtphfj","content":"<p>给定一棵由$n$个节点构成的树。</p>\n<p>在树上存在一个“激发器”，标号为$s$。当激发器工作后，电流会延边传向每一个相邻节点。而中间节点接收到电流后，会将该电流传向与它连接并且尚未接收到电流的节点。对于每条边$e$，电流通过它需要的时间为$t_e$，电流的转发可以认为是在瞬间完成的。最终，激电流将到达一些“终止节点”――接收电流之后不再转发的节点。</p>\n<p>使用一次道具可以使得电流通过某条边的时间增加一个单位。请问最少使用多少次道具才可达到每一个“终止节点”同时收到电流？</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1131\" target=\"_blank\" rel=\"noopener\">Luogu P1131</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>注意到子树无论怎么搞，对上面的选择有影响的只是一个最后电流到达终点同步的时间，所以我们把这个设计进状态里面。</p>\n<p>注意到如果子树的同步的时间最少的话，那么它的消耗道具次数就应该是最少的，同时因为这棵子树的每一层之间，至少含有一条边，那么如果子树的同步时间变多$x$，那么在子树上的道具消耗次数就一定要变多大于等于$x$，而这个时候在子树与父节点的同步中，子树的根节点与父节点间的边的同步时间最多减少$x$，所以可以证明父节点的最优消耗道具次数一定是在子节点的最优同步时间下取得的，也就可以证明$dp$的正确性。</p>\n<p>状态转移方程：</p>\n<p>$$<br>time[u] = max(time[v]+len(u,v))<br>$$</p>\n<p>$$<br>ans[u] = sum(ans[v]+time[u]-(time[v]+len(u,v))<br>$$</p>\n<p>其中$u$，$v$\b有一条边，且$v$\b非\u001d$u$的父亲。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//省略快读模版</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> normal_io&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld\"</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld\"</span>,x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> normal_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">510000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> t,l;</span><br><span class=\"line\">    Edge(<span class=\"keyword\">int</span> b = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>):t(b),l(c)&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Edge&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[MAXN],times[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> vis[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    edge[a].push_back(Edge(b,c));</span><br><span class=\"line\">    edge[b].push_back(Edge(a,c));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(s);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        addedge(a,b,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    vis[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmpsum = <span class=\"number\">0</span>,mintime = <span class=\"number\">0</span>,k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i].t,len = edge[nown][i].l;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[to] == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dp(to);</span><br><span class=\"line\">        ans[nown] += ans[to];</span><br><span class=\"line\">        mintime = max(mintime,times[to]+len);</span><br><span class=\"line\">        tmpsum += (times[to]+len);</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans[nown] += k * mintime - tmpsum,times[nown] = mintime;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    dp(s);</span><br><span class=\"line\">    print(ans[s]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">main()&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定一棵由$n$个节点构成的树。</p>\n<p>在树上存在一个“激发器”，标号为$s$。当激发器工作后，电流会延边传向每一个相邻节点。而中间节点接收到电流后，会将该电流传向与它连接并且尚未接收到电流的节点。对于每条边$e$，电流通过它需要的时间为$t_e$，电流的转发可以认为是在瞬间完成的。最终，激电流将到达一些“终止节点”――接收电流之后不再转发的节点。</p>\n<p>使用一次道具可以使得电流通过某条边的时间增加一个单位。请问最少使用多少次道具才可达到每一个“终止节点”同时收到电流？</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1131\" target=\"_blank\" rel=\"noopener\">Luogu P1131</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>注意到子树无论怎么搞，对上面的选择有影响的只是一个最后电流到达终点同步的时间，所以我们把这个设计进状态里面。</p>\n<p>注意到如果子树的同步的时间最少的话，那么它的消耗道具次数就应该是最少的，同时因为这棵子树的每一层之间，至少含有一条边，那么如果子树的同步时间变多$x$，那么在子树上的道具消耗次数就一定要变多大于等于$x$，而这个时候在子树与父节点的同步中，子树的根节点与父节点间的边的同步时间最多减少$x$，所以可以证明父节点的最优消耗道具次数一定是在子节点的最优同步时间下取得的，也就可以证明$dp$的正确性。</p>\n<p>状态转移方程：</p>\n<p>$$<br>time[u] = max(time[v]+len(u,v))<br>$$</p>\n<p>$$<br>ans[u] = sum(ans[v]+time[u]-(time[v]+len(u,v))<br>$$</p>\n<p>其中$u$，$v$\b有一条边，且$v$\b非\u001d$u$的父亲。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�60-->\n\n</div></div>"},{"title":"「ZJOI2007」最大半连通子图-强连通分量-dp","urlname":"zjoi2007-semi-connected","date":"2018-04-05T08:54:05.000Z","visible":null,"_content":"\n给定一个有向图$G$，请求出$G$的最大半连通子图拥有的节点数$K$，以及不同的最大半连通子图的数目$C$。\n\n<!-- more -->\n由于$C$可能比较大，仅要求输出$C$对$X$的余数。\n\n具体定义：\n\n一个有向图$G=(V,E)$称为半连通的$(Semi-Connected)$，如果满足：$\\forall u,v∈V$，存在$u→v$或$v→u$。即对于图中任意两点$u,v$，存在一条$u$到$v$的有向路径或者从$v$到$u$的有向路径。\n\n若$G'=(V',E')$满足$V'\\subset V$，$E'$是$E$中所有跟$V'$有关的边，则称$G'$是$G$的一个导出子图。\n\n若$G'$是$G$的导出子图，且$G'$半连通，则称$G'$为$G$的半连通子图。\n\n若$G'$是$G$所有半连通子图中包含节点数最多的，则称$G'$是$G$的最大半连通子图。\n\n## 链接\n\n[Luogu P2272](https://www.luogu.org/problemnew/show/P2272)\n\n[BZOJ 1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n## 题解\n\n经过观察和分析发现，一个有向图是一个半连通子图当且仅当其缩点后成为一条链。\n\n这个很显然，画画图就发现了。那么现在问题就变成了寻找一张有向无环图里面最长链的长度及个数。\n\n可以用dp的方法来求。\n\n状态转移方程：\n\n$$\nlen[u] = max(len[v])+1 ,\\quad \\{u,v\\} \\in E \n$$\n$$\nnum[u] = sum(num[v]) ,\\quad \\{u,v\\} \\in E , \\;len[u] = len[v] + 1 \n$$\n\n有一点很坑的就是，不能有重边，要不然就会死的很惨，重复计算导致答案偏大。\n\n所以重建图要去重！！！\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 110000,MAXM = 2100000;\n\nstruct stack{\n    int num[MAXN],topnum;\n    stack(){topnum = 0;}\n    void pop(){topnum--;}\n    int top(){return num[topnum-1];}\n    void push(int val){num[topnum++] = val;}\n    bool empty(){return topnum != 0;}\n}a;\n\nint n,m,ecnt = 1,X;\n\nint fir[MAXN];\nint cnt = 1,cnum = 0;\nint low[MAXN],dfn[MAXN],siz[MAXN];\nint col[MAXN];\nint instack[MAXN];\n\nstruct Edge{\n    int from,to,nex;\n    bool operator < (Edge a)const{\n        if(from == a.from)\n            return to < a.to;\n        return from < a.from;\n    }\n}edge[MAXM];\n\nvoid addedge(int a,int b){\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].nex = fir[a];fir[a] = ecnt++;\n}\n\nvoid dfs(int nown){\n    low[nown] = dfn[nown] = cnt++;\n    instack[nown] = 1;a.push(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dfn[v] == 0)\n            dfs(v),low[nown] = min(low[v],low[nown]);\n        else if(instack[v] == 1)\n            low[nown] = min(dfn[v],low[nown]);\n    }\n    if(low[nown] == dfn[nown]){\n        cnum++;int j = -1;\n        do{\n            j = a.top();a.pop();\n            instack[j] = 0;\n            col[j] = cnum;\n            siz[cnum]++;\n        }while(j!=nown);\n    }\n}\n\nvoid tarjan(){\n    for(int i = 1;i<=n;i++)\n        if(dfn[i] == 0)\n            dfs(i);\n    for(int i = 1;i<=m;i++){\n        edge[i].from = col[edge[i].from];\n        edge[i].to = col[edge[i].to];\n    }\n    memset(fir,0,sizeof(fir));\n    //去重！！！\n    sort(edge+1,edge+m+1);\n    int lastu = 0,lastv = 0;\n    for(int i = 1;i<=m;i++){\n        int u = edge[i].from,v = edge[i].to;\n        if(u!=v&&(!(u==lastu&&v==lastv)))\n            addedge(u,v);\n        lastu = u,lastv = v;\n    }\n}\n\nint dp[MAXN],num[MAXN];\n\nvoid dfs2(int nown){\n    dp[nown] = siz[nown],num[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dp[v] == 0) dfs2(v);\n        if(dp[nown] < dp[v] + siz[nown])\n            dp[nown] = dp[v] + siz[nown],num[nown] = num[v];\n        else if(dp[nown] == dp[v] + siz[nown])\n            num[nown] += num[v], num[nown] %= X;\n    }\n}\n\nvoid solve(){\n    for(int i = 1;i<=cnum;i++)\n        if(num[i] == 0)\n            dfs2(i);\n    int ans1 = 0,ans2 = 0;\n    for(int i = 1;i<=cnum;i++){\n        if(dp[i] > ans1) ans1 = dp[i],ans2 = num[i];\n        else if(dp[i] == ans1) ans2 += num[i],ans2 %=X;\n    }\n    print(ans1),print('\\n'),print(ans2),print('\\n');\n}\n\nvoid init(){\n    read(n),read(m),read(X);\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        addedge(a,b);\n    }\n}\n\nint main(){\n    init();\n    tarjan();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","source":"_posts/「ZJOI2007」最大半连通子图-强连通分量-dp.md","raw":"---\ntitle: 「ZJOI2007」最大半连通子图-强连通分量-dp\nurlname: zjoi2007-semi-connected\ndate: 2018-04-05 16:54:05\ntags:\n- 题解\n- 图论\n- 强连通分量\n- 动态规划\ncategories: OI\nvisible:\n---\n\n给定一个有向图$G$，请求出$G$的最大半连通子图拥有的节点数$K$，以及不同的最大半连通子图的数目$C$。\n\n<!-- more -->\n由于$C$可能比较大，仅要求输出$C$对$X$的余数。\n\n具体定义：\n\n一个有向图$G=(V,E)$称为半连通的$(Semi-Connected)$，如果满足：$\\forall u,v∈V$，存在$u→v$或$v→u$。即对于图中任意两点$u,v$，存在一条$u$到$v$的有向路径或者从$v$到$u$的有向路径。\n\n若$G'=(V',E')$满足$V'\\subset V$，$E'$是$E$中所有跟$V'$有关的边，则称$G'$是$G$的一个导出子图。\n\n若$G'$是$G$的导出子图，且$G'$半连通，则称$G'$为$G$的半连通子图。\n\n若$G'$是$G$所有半连通子图中包含节点数最多的，则称$G'$是$G$的最大半连通子图。\n\n## 链接\n\n[Luogu P2272](https://www.luogu.org/problemnew/show/P2272)\n\n[BZOJ 1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n## 题解\n\n经过观察和分析发现，一个有向图是一个半连通子图当且仅当其缩点后成为一条链。\n\n这个很显然，画画图就发现了。那么现在问题就变成了寻找一张有向无环图里面最长链的长度及个数。\n\n可以用dp的方法来求。\n\n状态转移方程：\n\n$$\nlen[u] = max(len[v])+1 ,\\quad \\{u,v\\} \\in E \n$$\n$$\nnum[u] = sum(num[v]) ,\\quad \\{u,v\\} \\in E , \\;len[u] = len[v] + 1 \n$$\n\n有一点很坑的就是，不能有重边，要不然就会死的很惨，重复计算导致答案偏大。\n\n所以重建图要去重！！！\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 110000,MAXM = 2100000;\n\nstruct stack{\n    int num[MAXN],topnum;\n    stack(){topnum = 0;}\n    void pop(){topnum--;}\n    int top(){return num[topnum-1];}\n    void push(int val){num[topnum++] = val;}\n    bool empty(){return topnum != 0;}\n}a;\n\nint n,m,ecnt = 1,X;\n\nint fir[MAXN];\nint cnt = 1,cnum = 0;\nint low[MAXN],dfn[MAXN],siz[MAXN];\nint col[MAXN];\nint instack[MAXN];\n\nstruct Edge{\n    int from,to,nex;\n    bool operator < (Edge a)const{\n        if(from == a.from)\n            return to < a.to;\n        return from < a.from;\n    }\n}edge[MAXM];\n\nvoid addedge(int a,int b){\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].nex = fir[a];fir[a] = ecnt++;\n}\n\nvoid dfs(int nown){\n    low[nown] = dfn[nown] = cnt++;\n    instack[nown] = 1;a.push(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dfn[v] == 0)\n            dfs(v),low[nown] = min(low[v],low[nown]);\n        else if(instack[v] == 1)\n            low[nown] = min(dfn[v],low[nown]);\n    }\n    if(low[nown] == dfn[nown]){\n        cnum++;int j = -1;\n        do{\n            j = a.top();a.pop();\n            instack[j] = 0;\n            col[j] = cnum;\n            siz[cnum]++;\n        }while(j!=nown);\n    }\n}\n\nvoid tarjan(){\n    for(int i = 1;i<=n;i++)\n        if(dfn[i] == 0)\n            dfs(i);\n    for(int i = 1;i<=m;i++){\n        edge[i].from = col[edge[i].from];\n        edge[i].to = col[edge[i].to];\n    }\n    memset(fir,0,sizeof(fir));\n    //去重！！！\n    sort(edge+1,edge+m+1);\n    int lastu = 0,lastv = 0;\n    for(int i = 1;i<=m;i++){\n        int u = edge[i].from,v = edge[i].to;\n        if(u!=v&&(!(u==lastu&&v==lastv)))\n            addedge(u,v);\n        lastu = u,lastv = v;\n    }\n}\n\nint dp[MAXN],num[MAXN];\n\nvoid dfs2(int nown){\n    dp[nown] = siz[nown],num[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dp[v] == 0) dfs2(v);\n        if(dp[nown] < dp[v] + siz[nown])\n            dp[nown] = dp[v] + siz[nown],num[nown] = num[v];\n        else if(dp[nown] == dp[v] + siz[nown])\n            num[nown] += num[v], num[nown] %= X;\n    }\n}\n\nvoid solve(){\n    for(int i = 1;i<=cnum;i++)\n        if(num[i] == 0)\n            dfs2(i);\n    int ans1 = 0,ans2 = 0;\n    for(int i = 1;i<=cnum;i++){\n        if(dp[i] > ans1) ans1 = dp[i],ans2 = num[i];\n        else if(dp[i] == ans1) ans2 += num[i],ans2 %=X;\n    }\n    print(ans1),print('\\n'),print(ans2),print('\\n');\n}\n\nvoid init(){\n    read(n),read(m),read(X);\n    int a,b;\n    for(int i = 1;i<=m;i++){\n        read(a),read(b);\n        addedge(a,b);\n    }\n}\n\nint main(){\n    init();\n    tarjan();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}","slug":"「ZJOI2007」最大半连通子图-强连通分量-dp","published":1,"updated":"2018-05-05T14:51:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3l50058bljrqofzyfln","content":"<p>给定一个有向图$G$，请求出$G$的最大半连通子图拥有的节点数$K$，以及不同的最大半连通子图的数目$C$。</p>\n<a id=\"more\"></a>\n<p>由于$C$可能比较大，仅要求输出$C$对$X$的余数。</p>\n<p>具体定义：</p>\n<p>一个有向图$G=(V,E)$称为半连通的$(Semi-Connected)$，如果满足：$\\forall u,v∈V$，存在$u→v$或$v→u$。即对于图中任意两点$u,v$，存在一条$u$到$v$的有向路径或者从$v$到$u$的有向路径。</p>\n<p>若$G’=(V’,E’)$满足$V’\\subset V$，$E’$是$E$中所有跟$V’$有关的边，则称$G’$是$G$的一个导出子图。</p>\n<p>若$G’$是$G$的导出子图，且$G’$半连通，则称$G’$为$G$的半连通子图。</p>\n<p>若$G’$是$G$所有半连通子图中包含节点数最多的，则称$G’$是$G$的最大半连通子图。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2272\" target=\"_blank\" rel=\"noopener\">Luogu P2272</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1093\" target=\"_blank\" rel=\"noopener\">BZOJ 1093</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>经过观察和分析发现，一个有向图是一个半连通子图当且仅当其缩点后成为一条链。</p>\n<p>这个很显然，画画图就发现了。那么现在问题就变成了寻找一张有向无环图里面最长链的长度及个数。</p>\n<p>可以用dp的方法来求。</p>\n<p>状态转移方程：</p>\n<p>$$<br>len[u] = max(len[v])+1 ,\\quad {u,v} \\in E<br>$$<br>$$<br>num[u] = sum(num[v]) ,\\quad {u,v} \\in E , \\;len[u] = len[v] + 1<br>$$</p>\n<p>有一点很坑的就是，不能有重边，要不然就会死的很惨，重复计算导致答案偏大。</p>\n<p>所以重建图要去重！！！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>,MAXM = <span class=\"number\">2100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stack</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> num[MAXN],topnum;</span><br><span class=\"line\">    <span class=\"built_in\">stack</span>()&#123;topnum = <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span>&#123;topnum--;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> num[topnum<span class=\"number\">-1</span>];&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span></span>&#123;num[topnum++] = val;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> topnum != <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">&#125;a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,ecnt = <span class=\"number\">1</span>,X;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>,cnum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> low[MAXN],dfn[MAXN],siz[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> col[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> instack[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,nex;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (Edge a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(from == a.from)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> to &lt; a.to;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> from &lt; a.from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt].from = a,edge[ecnt].to = b;</span><br><span class=\"line\">    edge[ecnt].nex = fir[a];fir[a] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    low[nown] = dfn[nown] = cnt++;</span><br><span class=\"line\">    instack[nown] = <span class=\"number\">1</span>;a.push(nown);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfn[v] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            dfs(v),low[nown] = min(low[v],low[nown]);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(instack[v] == <span class=\"number\">1</span>)</span><br><span class=\"line\">            low[nown] = min(dfn[v],low[nown]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(low[nown] == dfn[nown])&#123;</span><br><span class=\"line\">        cnum++;<span class=\"keyword\">int</span> j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            j = a.top();a.pop();</span><br><span class=\"line\">            instack[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            col[j] = cnum;</span><br><span class=\"line\">            siz[cnum]++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(j!=nown);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tarjan</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dfn[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            dfs(i);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        edge[i].from = col[edge[i].from];</span><br><span class=\"line\">        edge[i].to = col[edge[i].to];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(fir,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(fir));</span><br><span class=\"line\">    <span class=\"comment\">//去重！！！</span></span><br><span class=\"line\">    sort(edge+<span class=\"number\">1</span>,edge+m+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastu = <span class=\"number\">0</span>,lastv = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> u = edge[i].from,v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(u!=v&amp;&amp;(!(u==lastu&amp;&amp;v==lastv)))</span><br><span class=\"line\">            addedge(u,v);</span><br><span class=\"line\">        lastu = u,lastv = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dp[MAXN],num[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    dp[nown] = siz[nown],num[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[v] == <span class=\"number\">0</span>) dfs2(v);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[nown] &lt; dp[v] + siz[nown])</span><br><span class=\"line\">            dp[nown] = dp[v] + siz[nown],num[nown] = num[v];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dp[nown] == dp[v] + siz[nown])</span><br><span class=\"line\">            num[nown] += num[v], num[nown] %= X;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=cnum;i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            dfs2(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans1 = <span class=\"number\">0</span>,ans2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=cnum;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dp[i] &gt; ans1) ans1 = dp[i],ans2 = num[i];</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dp[i] == ans1) ans2 += num[i],ans2 %=X;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(ans1),print(<span class=\"string\">'\\n'</span>),print(ans2),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m),read(X);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        addedge(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    tarjan();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>给定一个有向图$G$，请求出$G$的最大半连通子图拥有的节点数$K$，以及不同的最大半连通子图的数目$C$。</p>","more":"<p>由于$C$可能比较大，仅要求输出$C$对$X$的余数。</p>\n<p>具体定义：</p>\n<p>一个有向图$G=(V,E)$称为半连通的$(Semi-Connected)$，如果满足：$\\forall u,v∈V$，存在$u→v$或$v→u$。即对于图中任意两点$u,v$，存在一条$u$到$v$的有向路径或者从$v$到$u$的有向路径。</p>\n<p>若$G’=(V’,E’)$满足$V’\\subset V$，$E’$是$E$中所有跟$V’$有关的边，则称$G’$是$G$的一个导出子图。</p>\n<p>若$G’$是$G$的导出子图，且$G’$半连通，则称$G’$为$G$的半连通子图。</p>\n<p>若$G’$是$G$所有半连通子图中包含节点数最多的，则称$G’$是$G$的最大半连通子图。</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2272\" target=\"_blank\" rel=\"noopener\">Luogu P2272</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1093\" target=\"_blank\" rel=\"noopener\">BZOJ 1093</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>经过观察和分析发现，一个有向图是一个半连通子图当且仅当其缩点后成为一条链。</p>\n<p>这个很显然，画画图就发现了。那么现在问题就变成了寻找一张有向无环图里面最长链的长度及个数。</p>\n<p>可以用dp的方法来求。</p>\n<p>状态转移方程：</p>\n<p>$$<br>len[u] = max(len[v])+1 ,\\quad {u,v} \\in E<br>$$<br>$$<br>num[u] = sum(num[v]) ,\\quad {u,v} \\in E , \\;len[u] = len[v] + 1<br>$$</p>\n<p>有一点很坑的就是，不能有重边，要不然就会死的很惨，重复计算导致答案偏大。</p>\n<p>所以重建图要去重！！！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�61-->\n\n</div></div>"},{"title":"「ZJOI2009」假期的宿舍-二分图匹配","urlname":"zjoi2009-vacation","date":"2018-02-07T23:48:00.000Z","visible":null,"_content":"\n有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。我们假设每个人只能睡和自己直接认识的人的床。我们已知一共有$n$个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2055](https://www.luogu.org/problemnew/show/P2055)\n\n## 题解\n\n这道题其实\b可以转化成二分图匹配的问题。如果把所有不回家的在校生和前来探访的朋友放在二分图一侧，所有\b本校学生床放在二分图另一侧，再将认识的人&床连边（包括自己和自己的床），注意上面的\b人不包括回家的人。\n\n然后就是一个模版的二分图匹配了。然而我只会写网络流，所以写了一个$Dinic$上去，使用了单路增广&当前弧优化。\n\n然而开始调了一个下午也没调对。然而回家调了一个晚上也没调对。\b\b\b最后还算是调对了。奇怪的是我今天又敲了另一个$Dinic$，然后竟然1次AC了。\b缘妙不可言啊。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge{\n    int from,to,flow,cap;\n    int next;\n}edge[20000];\n\nint fir[300],dis[300],cur[300];\nint n,T,home[300],local[300],s,t,tot;\n\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int e = fir[nown];e!=0;e = edge[e].next){\n            int v = edge[e].to;\n            if(dis[v] == 0 && edge[e].cap > edge[e].flow){\n                dis[v] = dis[nown]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[t];\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    if(nown == t || limit == 0) return limit;\n    for(int &e = cur[nown];e!=0;e = edge[e].next){\n        int f,v = edge[e].to;\n        if(dis[v] == dis[nown]+1&&edge[e].flow <edge[e].cap){\n            int f = dfs(v,min(edge[e].cap-edge[e].flow,limit));\n            if(f>0){\n                edge[e].flow+=f;\n                edge[e^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs()){\n        while((f = dfs(s)>0))\n            ans+=f;\n    }\n    return ans;\n}\n\nvoid addedge(int from,int to,int c){\n    edge[tot].from = from;edge[tot].to = to;\n    edge[tot].cap = c;edge[tot].flow = 0;\n    edge[tot].next = fir[from];fir[from] = tot;\n    tot++;\n}\n\nint main(){\n    scanf(\"%d\",&T);\n    for(int i = 1;i<=T;i++){\n        scanf(\"%d\",&n);\n        //清零\n        memset(edge,0,sizeof(edge));\n        memset(home,0,sizeof(home));\n        memset(local,0,sizeof(local));\n        memset(fir,0,sizeof(fir));\n        tot = 2;int cnt = 0;\n        s = 2*n+1,t = 2*n+2;\n        //是否\b本校\n        for(int i = 1;i<=n;i++){\n            scanf(\"%d\",&local[i]);\n        }\n        //是否回家\n        for(int i = 1;i<=n;i++){\n            scanf(\"%d\",&home[i]);\n            if(local[i] == 0) home[i] = 0;\n        }\n        //是否认识且符合条件\n        for(int i = 1;i<=n;i++){\n            for(int j = 1;j<=n;j++){\n                int tmp;scanf(\"%d\",&tmp);\n                if(i == j) tmp = 1;\n                if(home[i] == 1||local[j] == 0||tmp == 0)\n                    continue;\n                else addedge(i,j+n,1),addedge(j+n,i,0);\n            }\n        }\n        //超级源点&&汇点\n        for(int i = 1;i<=n;i++){\n            if(home[i] == 0)\n                addedge(s,i,1),addedge(i,s,0),cnt++;\n            if(local[i] == 1)\n                addedge(i+n,t,1),addedge(t,i+n,0);\n        }\n        if(dinic()==cnt) printf(\"^_^\\n\");\n        else printf(\"T_T\\n\");\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「ZJOI2009」假期的宿舍-二分图匹配.md","raw":"---\ntitle: 「ZJOI2009」假期的宿舍-二分图匹配\nurlname: zjoi2009-vacation\ndate: 2018-02-08 07:48:00\ntags:\n- 题解\n- 图论\n- 二分图匹配\n- Dinic\ncategories: OI\nvisible:\n---\n\n有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。我们假设每个人只能睡和自己直接认识的人的床。我们已知一共有$n$个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2055](https://www.luogu.org/problemnew/show/P2055)\n\n## 题解\n\n这道题其实\b可以转化成二分图匹配的问题。如果把所有不回家的在校生和前来探访的朋友放在二分图一侧，所有\b本校学生床放在二分图另一侧，再将认识的人&床连边（包括自己和自己的床），注意上面的\b人不包括回家的人。\n\n然后就是一个模版的二分图匹配了。然而我只会写网络流，所以写了一个$Dinic$上去，使用了单路增广&当前弧优化。\n\n然而开始调了一个下午也没调对。然而回家调了一个晚上也没调对。\b\b\b最后还算是调对了。奇怪的是我今天又敲了另一个$Dinic$，然后竟然1次AC了。\b缘妙不可言啊。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge{\n    int from,to,flow,cap;\n    int next;\n}edge[20000];\n\nint fir[300],dis[300],cur[300];\nint n,T,home[300],local[300],s,t,tot;\n\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int e = fir[nown];e!=0;e = edge[e].next){\n            int v = edge[e].to;\n            if(dis[v] == 0 && edge[e].cap > edge[e].flow){\n                dis[v] = dis[nown]+1;\n                q.push(v);\n            }\n        }\n    }\n    return dis[t];\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    if(nown == t || limit == 0) return limit;\n    for(int &e = cur[nown];e!=0;e = edge[e].next){\n        int f,v = edge[e].to;\n        if(dis[v] == dis[nown]+1&&edge[e].flow <edge[e].cap){\n            int f = dfs(v,min(edge[e].cap-edge[e].flow,limit));\n            if(f>0){\n                edge[e].flow+=f;\n                edge[e^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs()){\n        while((f = dfs(s)>0))\n            ans+=f;\n    }\n    return ans;\n}\n\nvoid addedge(int from,int to,int c){\n    edge[tot].from = from;edge[tot].to = to;\n    edge[tot].cap = c;edge[tot].flow = 0;\n    edge[tot].next = fir[from];fir[from] = tot;\n    tot++;\n}\n\nint main(){\n    scanf(\"%d\",&T);\n    for(int i = 1;i<=T;i++){\n        scanf(\"%d\",&n);\n        //清零\n        memset(edge,0,sizeof(edge));\n        memset(home,0,sizeof(home));\n        memset(local,0,sizeof(local));\n        memset(fir,0,sizeof(fir));\n        tot = 2;int cnt = 0;\n        s = 2*n+1,t = 2*n+2;\n        //是否\b本校\n        for(int i = 1;i<=n;i++){\n            scanf(\"%d\",&local[i]);\n        }\n        //是否回家\n        for(int i = 1;i<=n;i++){\n            scanf(\"%d\",&home[i]);\n            if(local[i] == 0) home[i] = 0;\n        }\n        //是否认识且符合条件\n        for(int i = 1;i<=n;i++){\n            for(int j = 1;j<=n;j++){\n                int tmp;scanf(\"%d\",&tmp);\n                if(i == j) tmp = 1;\n                if(home[i] == 1||local[j] == 0||tmp == 0)\n                    continue;\n                else addedge(i,j+n,1),addedge(j+n,i,0);\n            }\n        }\n        //超级源点&&汇点\n        for(int i = 1;i<=n;i++){\n            if(home[i] == 0)\n                addedge(s,i,1),addedge(i,s,0),cnt++;\n            if(local[i] == 1)\n                addedge(i+n,t,1),addedge(t,i+n,0);\n        }\n        if(dinic()==cnt) printf(\"^_^\\n\");\n        else printf(\"T_T\\n\");\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「ZJOI2009」假期的宿舍-二分图匹配","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3lx005bbljrjczups0b","content":"<p>有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。我们假设每个人只能睡和自己直接认识的人的床。我们已知一共有$n$个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2055\" target=\"_blank\" rel=\"noopener\">Luogu P2055</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这道题其实\b可以转化成二分图匹配的问题。如果把所有不回家的在校生和前来探访的朋友放在二分图一侧，所有\b本校学生床放在二分图另一侧，再将认识的人&amp;床连边（包括自己和自己的床），注意上面的\b人不包括回家的人。</p>\n<p>然后就是一个模版的二分图匹配了。然而我只会写网络流，所以写了一个$Dinic$上去，使用了单路增广&amp;当前弧优化。</p>\n<p>然而开始调了一个下午也没调对。然而回家调了一个晚上也没调对。\b\b\b最后还算是调对了。奇怪的是我今天又敲了另一个$Dinic$，然后竟然1次AC了。\b缘妙不可言啊。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to,flow,cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> next;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">20000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[<span class=\"number\">300</span>],dis[<span class=\"number\">300</span>],cur[<span class=\"number\">300</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,T,home[<span class=\"number\">300</span>],local[<span class=\"number\">300</span>],s,t,tot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(cur,fir,<span class=\"keyword\">sizeof</span>(fir));</span><br><span class=\"line\">    q.push(s);dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e = fir[nown];e!=<span class=\"number\">0</span>;e = edge[e].next)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = edge[e].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[v] == <span class=\"number\">0</span> &amp;&amp; edge[e].cap &gt; edge[e].flow)&#123;</span><br><span class=\"line\">                dis[v] = dis[nown]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                q.push(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> limit = <span class=\"number\">0x3f3f3f3f</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nown == t || limit == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> limit;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> &amp;e = cur[nown];e!=<span class=\"number\">0</span>;e = edge[e].next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> f,v = edge[e].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[v] == dis[nown]+<span class=\"number\">1</span>&amp;&amp;edge[e].flow &lt;edge[e].cap)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> f = dfs(v,min(edge[e].cap-edge[e].flow,limit));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                edge[e].flow+=f;</span><br><span class=\"line\">                edge[e^<span class=\"number\">1</span>].flow-=f;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dinic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>,f;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(bfs())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((f = dfs(s)&gt;<span class=\"number\">0</span>))</span><br><span class=\"line\">            ans+=f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> from,<span class=\"keyword\">int</span> to,<span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">    edge[tot].from = from;edge[tot].to = to;</span><br><span class=\"line\">    edge[tot].cap = c;edge[tot].flow = <span class=\"number\">0</span>;</span><br><span class=\"line\">    edge[tot].next = fir[from];fir[from] = tot;</span><br><span class=\"line\">    tot++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;T);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=T;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">        <span class=\"comment\">//清零</span></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(edge,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(edge));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(home,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(home));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(local,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(local));</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(fir,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(fir));</span><br><span class=\"line\">        tot = <span class=\"number\">2</span>;<span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        s = <span class=\"number\">2</span>*n+<span class=\"number\">1</span>,t = <span class=\"number\">2</span>*n+<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//是否\b本校</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;local[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//是否回家</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;home[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(local[i] == <span class=\"number\">0</span>) home[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//是否认识且符合条件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> tmp;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;tmp);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) tmp = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(home[i] == <span class=\"number\">1</span>||local[j] == <span class=\"number\">0</span>||tmp == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> addedge(i,j+n,<span class=\"number\">1</span>),addedge(j+n,i,<span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//超级源点&amp;&amp;汇点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(home[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addedge(s,i,<span class=\"number\">1</span>),addedge(i,s,<span class=\"number\">0</span>),cnt++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(local[i] == <span class=\"number\">1</span>)</span><br><span class=\"line\">                addedge(i+n,t,<span class=\"number\">1</span>),addedge(t,i+n,<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dinic()==cnt) <span class=\"built_in\">printf</span>(<span class=\"string\">\"^_^\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">\"T_T\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。我们假设每个人只能睡和自己直接认识的人的床。我们已知一共有$n$个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2055\" target=\"_blank\" rel=\"noopener\">Luogu P2055</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这道题其实\b可以转化成二分图匹配的问题。如果把所有不回家的在校生和前来探访的朋友放在二分图一侧，所有\b本校学生床放在二分图另一侧，再将认识的人&amp;床连边（包括自己和自己的床），注意上面的\b人不包括回家的人。</p>\n<p>然后就是一个模版的二分图匹配了。然而我只会写网络流，所以写了一个$Dinic$上去，使用了单路增广&amp;当前弧优化。</p>\n<p>然而开始调了一个下午也没调对。然而回家调了一个晚上也没调对。\b\b\b最后还算是调对了。奇怪的是我今天又敲了另一个$Dinic$，然后竟然1次AC了。\b缘妙不可言啊。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�62-->\n\n</div></div>"},{"title":"「ZJOI2008」树的统计-树链剖分","urlname":"zjoi2008-count","date":"2018-03-10T13:18:32.000Z","visible":null,"_content":"\n\b给定一颗$n$个节点的树，节点编号为$1$到$n$，每个节点都有一个权值$w\\_i$。\n\n有以下三种操作或询问：\n\nI. $CHANGE\\ u\\ t$ : 把结点$u$的权值改为$t$\n\nII. $QMAX\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的最大权值\n\nIII. $QSUM\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的权值和\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2590](https://www.luogu.org/problemnew/show/P2590)\n\n## 题解\n\n树链剖分模版题。\n\n进行树链剖分之后，由于注意到这里只有单点修改，所以我们用一个$zkw$线段树来维护这些信息。\n\n+ 对于$CHANGE$操作，我们直接更改叶子节点的值，然后进行$zkw$线段树的从下到上的更新操作，直到根。\n\n+ 对于$QMAX$操作，我们就用树链剖分的常规操作，每一步求一个最大值，然后更新答案即可。$QSUM$同理。\n\n事实上，这个题凸显出来$zkw$线段树在单点修改上真是不一般的快，以我的垃圾`coding`水平居然能在`bzoj`上排到第一页。\n\n$zkw$大法好！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\nusing namespace std;\nconst int MAXN = 31000;\n\ninline int max(int a,int b){\n    return b>a?b:a;\n}\n\nnamespace fast_io {\n    inline char read() {\n\t\t//return getchar();\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x + (x << 2)) << 1)+(c^48);\n        if (iosig) x = -x;\n    }\n    inline void read(char *a){\n        static char c = read();\n        while(c!= -1&&(c == ' '||c =='\\n'))\n            c = read();\n        while(c!= -1&&c!=' '&&c!='\\n')\n            *a++ = c,c = read();\n        *a = 0;\n    }\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if(ooh == obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if(x == 0)\n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void print(char *a){\n        while(*a) print(*a++);\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nint maxn[MAXN<<2],sumn[MAXN<<2];\nint n,M,q,num[MAXN];\n\n//top数组是链子最上面的节点，fa是父节点，son是重儿子节点，siz是子树大小，dep是dfs深度\nint top[MAXN],fa[MAXN],son[MAXN],siz[MAXN],dep[MAXN];\n//id_to 是i号id指向的节点编号，id就是i号节点的dfs编号\nint id_to[MAXN],id[MAXN];\nint cnt = 1;\n\nvector<int> edge[MAXN];\n\n//zkw线段树初始化\ninline void init_seg(){\n    for(M = 1;M<n+2;M<<=1);\n    for(int i = 1;i<=n;i++)\n        maxn[M+i] = sumn[M+i] = num[id_to[i]];\n    for(int i = M-1;i;i--)\n        maxn[i]=max(maxn[i<<1],maxn[i<<1|1]),sumn[i]=sumn[i<<1]+sumn[i<<1|1];\n}\n\n//zkw线段树区间最值\ninline int max_seg(int l,int r){\n    int ans = -100000;\n    for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1 && maxn[l^1]>ans) ans = maxn[l^1];\n        if(r&1 && maxn[r^1]>ans) ans = maxn[r^1];\n    }\n    return ans;\n}\n\n//zkw线段树区间求和\ninline int sum_seg(int l,int r){\n    int ans = 0;\n    for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1) ans += sumn[l^1];\n        if(r&1) ans += sumn[r^1];\n    }    \n    return ans;\n}\n\n//zkw线段树修改\ninline void upd_seg(int pos,int x){\n    int nown = pos+M;\n    maxn[nown] = sumn[nown] = x;\n    while(nown>>=1){\n        maxn[nown] = max(maxn[nown<<1],maxn[nown<<1|1]);\n        sumn[nown] = sumn[nown<<1]+sumn[nown<<1|1];\n    }\n}\n\n//树链剖分的第一个dfs\ninline void dfs1(int nown,int f,int depth){\n    son[nown] = 0,dep[nown] = depth,siz[nown] = 1,fa[nown] = f;\n    int maxsum = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to]>maxsum) maxsum = siz[to],son[nown] = to;\n    }\n}\n\n//树链剖分的第二个dfs\ninline void dfs2(int nown,int topf){\n    id[nown] = cnt;\n    id_to[cnt++] = nown;\n    top[nown] = topf;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == son[nown]||to == fa[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//查询路径和\ninline int query_sum(int x,int y){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans+=sum_seg(id[top[x]],id[x]);\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    ans+=sum_seg(id[x],id[y]);\n    return ans;\n}\n\n//查询路径最大值\ninline int query_max(int x,int y){\n    int ans = -100000;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans = max(ans,max_seg(id[top[x]],id[x]));\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    ans = max(ans,max_seg(id[x],id[y]));\n    return ans;\n}\n\n//修改某个节点\ninline void update(int pos,int x){\n    upd_seg(id[pos],x);\n}\n\n//初始化图和线段树还有两次dfs\nvoid init(){\n    read(n);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    dfs1(1,0,1);\n    dfs2(1,1);\n    init_seg();\n}\n\n//进行操作以及回答询问\nvoid solve(){\n    read(q);\n    char op[20];\n    int a,b;\n    for(int i = 1;i<=q;i++){\n        read(op),read(a),read(b);\n        if(op[1] == 'M')\n            print(query_max(a,b)),print('\\n');\n        else if(op[1] == 'S')\n            print(query_sum(a,b)),print('\\n');\n        else if(op[1] == 'H')\n            update(a,b);\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/「ZJOI2008」树的统计-树链剖分.md","raw":"---\ntitle: 「ZJOI2008」树的统计-树链剖分\nurlname: zjoi2008-count\ndate: 2018-03-10 21:18:32\ntags:\n- 数据结构\n- 树链剖分\n- 题解\ncategories: OI\nvisible:\n---\n\n\b给定一颗$n$个节点的树，节点编号为$1$到$n$，每个节点都有一个权值$w\\_i$。\n\n有以下三种操作或询问：\n\nI. $CHANGE\\ u\\ t$ : 把结点$u$的权值改为$t$\n\nII. $QMAX\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的最大权值\n\nIII. $QSUM\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的权值和\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2590](https://www.luogu.org/problemnew/show/P2590)\n\n## 题解\n\n树链剖分模版题。\n\n进行树链剖分之后，由于注意到这里只有单点修改，所以我们用一个$zkw$线段树来维护这些信息。\n\n+ 对于$CHANGE$操作，我们直接更改叶子节点的值，然后进行$zkw$线段树的从下到上的更新操作，直到根。\n\n+ 对于$QMAX$操作，我们就用树链剖分的常规操作，每一步求一个最大值，然后更新答案即可。$QSUM$同理。\n\n事实上，这个题凸显出来$zkw$线段树在单点修改上真是不一般的快，以我的垃圾`coding`水平居然能在`bzoj`上排到第一页。\n\n$zkw$大法好！\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cctype>\nusing namespace std;\nconst int MAXN = 31000;\n\ninline int max(int a,int b){\n    return b>a?b:a;\n}\n\nnamespace fast_io {\n    inline char read() {\n\t\t//return getchar();\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x + (x << 2)) << 1)+(c^48);\n        if (iosig) x = -x;\n    }\n    inline void read(char *a){\n        static char c = read();\n        while(c!= -1&&(c == ' '||c =='\\n'))\n            c = read();\n        while(c!= -1&&c!=' '&&c!='\\n')\n            *a++ = c,c = read();\n        *a = 0;\n    }\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if(ooh == obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if(x == 0)\n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void print(char *a){\n        while(*a) print(*a++);\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nint maxn[MAXN<<2],sumn[MAXN<<2];\nint n,M,q,num[MAXN];\n\n//top数组是链子最上面的节点，fa是父节点，son是重儿子节点，siz是子树大小，dep是dfs深度\nint top[MAXN],fa[MAXN],son[MAXN],siz[MAXN],dep[MAXN];\n//id_to 是i号id指向的节点编号，id就是i号节点的dfs编号\nint id_to[MAXN],id[MAXN];\nint cnt = 1;\n\nvector<int> edge[MAXN];\n\n//zkw线段树初始化\ninline void init_seg(){\n    for(M = 1;M<n+2;M<<=1);\n    for(int i = 1;i<=n;i++)\n        maxn[M+i] = sumn[M+i] = num[id_to[i]];\n    for(int i = M-1;i;i--)\n        maxn[i]=max(maxn[i<<1],maxn[i<<1|1]),sumn[i]=sumn[i<<1]+sumn[i<<1|1];\n}\n\n//zkw线段树区间最值\ninline int max_seg(int l,int r){\n    int ans = -100000;\n    for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1 && maxn[l^1]>ans) ans = maxn[l^1];\n        if(r&1 && maxn[r^1]>ans) ans = maxn[r^1];\n    }\n    return ans;\n}\n\n//zkw线段树区间求和\ninline int sum_seg(int l,int r){\n    int ans = 0;\n    for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1) ans += sumn[l^1];\n        if(r&1) ans += sumn[r^1];\n    }    \n    return ans;\n}\n\n//zkw线段树修改\ninline void upd_seg(int pos,int x){\n    int nown = pos+M;\n    maxn[nown] = sumn[nown] = x;\n    while(nown>>=1){\n        maxn[nown] = max(maxn[nown<<1],maxn[nown<<1|1]);\n        sumn[nown] = sumn[nown<<1]+sumn[nown<<1|1];\n    }\n}\n\n//树链剖分的第一个dfs\ninline void dfs1(int nown,int f,int depth){\n    son[nown] = 0,dep[nown] = depth,siz[nown] = 1,fa[nown] = f;\n    int maxsum = 0;\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == f) continue;\n        dfs1(to,nown,depth+1);\n        siz[nown]+=siz[to];\n        if(siz[to]>maxsum) maxsum = siz[to],son[nown] = to;\n    }\n}\n\n//树链剖分的第二个dfs\ninline void dfs2(int nown,int topf){\n    id[nown] = cnt;\n    id_to[cnt++] = nown;\n    top[nown] = topf;\n    if(!son[nown]) return;\n    dfs2(son[nown],topf);\n    for(int i = 0;i<edge[nown].size();i++){\n        int to = edge[nown][i];\n        if(to == son[nown]||to == fa[nown]) continue;\n        dfs2(to,to);\n    }\n}\n\n//查询路径和\ninline int query_sum(int x,int y){\n    int ans = 0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans+=sum_seg(id[top[x]],id[x]);\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    ans+=sum_seg(id[x],id[y]);\n    return ans;\n}\n\n//查询路径最大值\ninline int query_max(int x,int y){\n    int ans = -100000;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans = max(ans,max_seg(id[top[x]],id[x]));\n        x = fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    ans = max(ans,max_seg(id[x],id[y]));\n    return ans;\n}\n\n//修改某个节点\ninline void update(int pos,int x){\n    upd_seg(id[pos],x);\n}\n\n//初始化图和线段树还有两次dfs\nvoid init(){\n    read(n);\n    int a,b;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b);\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    for(int i = 1;i<=n;i++)\n        read(num[i]);\n    dfs1(1,0,1);\n    dfs2(1,1);\n    init_seg();\n}\n\n//进行操作以及回答询问\nvoid solve(){\n    read(q);\n    char op[20];\n    int a,b;\n    for(int i = 1;i<=q;i++){\n        read(op),read(a),read(b);\n        if(op[1] == 'M')\n            print(query_max(a,b)),print('\\n');\n        else if(op[1] == 'S')\n            print(query_sum(a,b)),print('\\n');\n        else if(op[1] == 'H')\n            update(a,b);\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n","slug":"「ZJOI2008」树的统计-树链剖分","published":1,"updated":"2018-03-14T14:21:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3m3005fbljrsje9qoo2","content":"<p>\b给定一颗$n$个节点的树，节点编号为$1$到$n$，每个节点都有一个权值$w_i$。</p>\n<p>有以下三种操作或询问：</p>\n<p>I. $CHANGE\\ u\\ t$ : 把结点$u$的权值改为$t$</p>\n<p>II. $QMAX\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的最大权值</p>\n<p>III. $QSUM\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的权值和</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2590\" target=\"_blank\" rel=\"noopener\">Luogu P2590</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树链剖分模版题。</p>\n<p>进行树链剖分之后，由于注意到这里只有单点修改，所以我们用一个$zkw$线段树来维护这些信息。</p>\n<ul>\n<li><p>对于$CHANGE$操作，我们直接更改叶子节点的值，然后进行$zkw$线段树的从下到上的更新操作，直到根。</p>\n</li>\n<li><p>对于$QMAX$操作，我们就用树链剖分的常规操作，每一步求一个最大值，然后更新答案即可。$QSUM$同理。</p>\n</li>\n</ul>\n<p>事实上，这个题凸显出来$zkw$线段树在单点修改上真是不一般的快，以我的垃圾<code>coding</code>水平居然能在<code>bzoj</code>上排到第一页。</p>\n<p>$zkw$大法好！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">31000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b&gt;a?b:a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//return getchar();</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN], *s, *t;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s==t?(((t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>))== s)?<span class=\"number\">-1</span>:*s++) : *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (iosig = <span class=\"literal\">false</span>, c = read(); !<span class=\"built_in\">isdigit</span>(c); c = read()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">'-'</span>) iosig = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (x = <span class=\"number\">0</span>; <span class=\"built_in\">isdigit</span>(c); c = read())</span><br><span class=\"line\">            x = ((x + (x &lt;&lt; <span class=\"number\">2</span>)) &lt;&lt; <span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iosig) x = -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c = read();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c!= <span class=\"number\">-1</span>&amp;&amp;(c == <span class=\"string\">' '</span>||c ==<span class=\"string\">'\\n'</span>))</span><br><span class=\"line\">            c = read();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c!= <span class=\"number\">-1</span>&amp;&amp;c!=<span class=\"string\">' '</span>&amp;&amp;c!=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            *a++ = c,c = read();</span><br><span class=\"line\">        *a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ooh == obuf+OUT_LEN) fwrite(obuf,<span class=\"number\">1</span>,OUT_LEN,<span class=\"built_in\">stdout</span>),ooh=obuf;</span><br><span class=\"line\">        *ooh++ = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> buf[<span class=\"number\">30</span>], cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>)</span><br><span class=\"line\">            print(<span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) print(<span class=\"string\">'-'</span>), x = -x;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (cnt = <span class=\"number\">0</span>; x; x /= <span class=\"number\">10</span>) buf[++cnt] = x % <span class=\"number\">10</span> + <span class=\"number\">48</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt) print((<span class=\"keyword\">char</span>)buf[cnt--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*a) print(*a++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        fwrite(obuf, <span class=\"number\">1</span>, ooh - obuf, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> maxn[MAXN&lt;&lt;<span class=\"number\">2</span>],sumn[MAXN&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n,M,q,num[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//top数组是链子最上面的节点，fa是父节点，son是重儿子节点，siz是子树大小，dep是dfs深度</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> top[MAXN],fa[MAXN],son[MAXN],siz[MAXN],dep[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//id_to 是i号id指向的节点编号，id就是i号节点的dfs编号</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> id_to[MAXN],id[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; edge[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//zkw线段树初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">init_seg</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(M = <span class=\"number\">1</span>;M&lt;n+<span class=\"number\">2</span>;M&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        maxn[M+i] = sumn[M+i] = num[id_to[i]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = M<span class=\"number\">-1</span>;i;i--)</span><br><span class=\"line\">        maxn[i]=max(maxn[i&lt;&lt;<span class=\"number\">1</span>],maxn[i&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]),sumn[i]=sumn[i&lt;&lt;<span class=\"number\">1</span>]+sumn[i&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//zkw线段树区间最值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">max_seg</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">-100000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(l=l+M<span class=\"number\">-1</span>,r=r+M+<span class=\"number\">1</span>;l^r^<span class=\"number\">1</span>;l&gt;&gt;=<span class=\"number\">1</span>,r&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(~l&amp;<span class=\"number\">1</span> &amp;&amp; maxn[l^<span class=\"number\">1</span>]&gt;ans) ans = maxn[l^<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r&amp;<span class=\"number\">1</span> &amp;&amp; maxn[r^<span class=\"number\">1</span>]&gt;ans) ans = maxn[r^<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//zkw线段树区间求和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">sum_seg</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(l=l+M<span class=\"number\">-1</span>,r=r+M+<span class=\"number\">1</span>;l^r^<span class=\"number\">1</span>;l&gt;&gt;=<span class=\"number\">1</span>,r&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(~l&amp;<span class=\"number\">1</span>) ans += sumn[l^<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r&amp;<span class=\"number\">1</span>) ans += sumn[r^<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//zkw线段树修改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">upd_seg</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nown = pos+M;</span><br><span class=\"line\">    maxn[nown] = sumn[nown] = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown&gt;&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        maxn[nown] = max(maxn[nown&lt;&lt;<span class=\"number\">1</span>],maxn[nown&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]);</span><br><span class=\"line\">        sumn[nown] = sumn[nown&lt;&lt;<span class=\"number\">1</span>]+sumn[nown&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树链剖分的第一个dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> f,<span class=\"keyword\">int</span> depth)</span></span>&#123;</span><br><span class=\"line\">    son[nown] = <span class=\"number\">0</span>,dep[nown] = depth,siz[nown] = <span class=\"number\">1</span>,fa[nown] = f;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> maxsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs1(to,nown,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        siz[nown]+=siz[to];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(siz[to]&gt;maxsum) maxsum = siz[to],son[nown] = to;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//树链剖分的第二个dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> topf)</span></span>&#123;</span><br><span class=\"line\">    id[nown] = cnt;</span><br><span class=\"line\">    id_to[cnt++] = nown;</span><br><span class=\"line\">    top[nown] = topf;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!son[nown]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    dfs2(son[nown],topf);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;edge[nown].size();i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> to = edge[nown][i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(to == son[nown]||to == fa[nown]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs2(to,to);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询路径和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class=\"line\">        ans+=sum_seg(id[top[x]],id[x]);</span><br><span class=\"line\">        x = fa[top[x]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class=\"line\">    ans+=sum_seg(id[x],id[y]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询路径最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">query_max</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">-100000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top[x]!=top[y])&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class=\"line\">        ans = max(ans,max_seg(id[top[x]],id[x]));</span><br><span class=\"line\">        x = fa[top[x]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class=\"line\">    ans = max(ans,max_seg(id[x],id[y]));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修改某个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> pos,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    upd_seg(id[pos],x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化图和线段树还有两次dfs</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        edge[a].push_back(b);</span><br><span class=\"line\">        edge[b].push_back(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(num[i]);</span><br><span class=\"line\">    dfs1(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    dfs2(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    init_seg();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进行操作以及回答询问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(q);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> op[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=q;i++)&#123;</span><br><span class=\"line\">        read(op),read(a),read(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'M'</span>)</span><br><span class=\"line\">            print(query_max(a,b)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'S'</span>)</span><br><span class=\"line\">            print(query_sum(a,b)),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">1</span>] == <span class=\"string\">'H'</span>)</span><br><span class=\"line\">            update(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>\b给定一颗$n$个节点的树，节点编号为$1$到$n$，每个节点都有一个权值$w_i$。</p>\n<p>有以下三种操作或询问：</p>\n<p>I. $CHANGE\\ u\\ t$ : 把结点$u$的权值改为$t$</p>\n<p>II. $QMAX\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的最大权值</p>\n<p>III. $QSUM\\ u\\ v$: 询问从点$u$到点$v$的路径上的节点的权值和</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2590\" target=\"_blank\" rel=\"noopener\">Luogu P2590</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>树链剖分模版题。</p>\n<p>进行树链剖分之后，由于注意到这里只有单点修改，所以我们用一个$zkw$线段树来维护这些信息。</p>\n<ul>\n<li><p>对于$CHANGE$操作，我们直接更改叶子节点的值，然后进行$zkw$线段树的从下到上的更新操作，直到根。</p>\n</li>\n<li><p>对于$QMAX$操作，我们就用树链剖分的常规操作，每一步求一个最大值，然后更新答案即可。$QSUM$同理。</p>\n</li>\n</ul>\n<p>事实上，这个题凸显出来$zkw$线段树在单点修改上真是不一般的快，以我的垃圾<code>coding</code>水平居然能在<code>bzoj</code>上排到第一页。</p>\n<p>$zkw$大法好！</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�63-->\n\n</div></div>"},{"title":"「ZJOI2010」数字计数-数位dp","urlname":"ZJOI2010-count","date":"2018-06-18T01:35:53.000Z","visible":null,"_content":"\n给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数码(`digit`)各出现了多少次。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2602](https://www.luogu.org/problemnew/show/P2602)\n\n## 题解\n\n比较入门的数位dp...很适合我这种蒟蒻。\n\n令$dp[i][j]$为当倒数第$i$位为$j$时，后$i$位的数码总计（一个储存着十个整数的结构体，加减即为对位加减）。若$j=10$，则代表这位是前导$0$。(感觉这个搞法有点笨拙...巨佬能不能教教我...)\n\n令$sum(i,j)$为有$i$数码有$j$个，其他均为$0$的状态。\n\n则状态转移方程为：\n\n$$dp[1][j] = sum(j,1)$$\n\n$$dp[i][j] = sum(j,10^{i-1}) + \\sum_{w = 0}^{9} dp[i-1][w]\\; ,0\\leq j \\leq 9$$\n\n$$dp[i][10] = \\sum_{w = 1}^{10} dp[i-1][w]$$\n\n计算答案时，这个实在不太好说...看代码的注释会更好理解...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\nusing namespace std;\n#define ll long long \n\nll a,b;\n\nconst int MAXN = 20;\n\nstruct sum{\n    ll num[10];\n    sum(int pos = -1,ll d = 1){\n        for(int i = 0;i<10;i++) num[i] = 0;\n        if(~pos)\n            num[pos] = d;\n    }\n    sum operator +(const sum a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] + a.num[i];\n        return ans;\n    }\n    sum operator *(const int a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] * a;\n        return ans;\n    }\n    sum operator -(const sum a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] - a.num[i];\n        return ans;\n    }\n};\n\nsum dp[MAXN][MAXN];\nll t[MAXN];\n//dp[i][j] -> 后i位，倒数第i位为j,j == 10 代表为先导0\n\nvoid init(){\n    scanf(\"%lld %lld\",&a,&b);\n    t[0] = 1;\n    for(int i = 1;i<=15;i++)\n        t[i] = 10*t[i-1];\n}\n\nvoid build(){\n    for(int j = 0;j<=9;j++)\n        dp[1][j] = sum(j,1); \n    for(int i = 2;i<=15;i++){\n        for(int j = 0;j<=9;j++){\n            dp[i][j] = sum(j,t[i-1]);\n            for(int w = 0;w<=9;w++)\n                dp[i][j] = dp[i][j] + dp[i-1][w];\n        }\n        dp[i][10] = sum();\n        for(int w = 1;w<=10;w++)\n            dp[i][10] = dp[i][10] + dp[i-1][w]; \n    }\n}\n\nsum getnum(ll a){\n    ll tmp = a;\n    sum ans = sum(0,1);\n    if(a == 0) return sum(0,1);\n    int num[15],cnt = 0;\n    while(a){\n        num[++cnt] = a % 10;\n        a/=10;\n    }\n    ans = ans + dp[cnt][10] - dp[cnt][0];\n    //加上在这一位有前导0，再除去在这一位是0的\n    for(int i = cnt;i>=1;--i){\n        for(int j = 0;j<num[i];++j)\n            ans = ans + dp[i][j];\n        //加上所有比当前位置小的数的数码\n        ans = ans + sum(num[i],tmp%t[i-1]+1);\n        //补上后面的数中不再计算的这一位的数码\n    }\n    return ans;\n}\n\nvoid solve(){\n    sum ans = getnum(b)-getnum(a-1);\n    for(int i = 0;i<=9;i++){\n        printf(\"%lld \",ans.num[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n\n","source":"_posts/「ZJOI2010」数字计数-数位dp.md","raw":"---\ntitle: 「ZJOI2010」数字计数-数位dp\nurlname: ZJOI2010-count\ndate: 2018-06-18 09:35:53\ntags:\n- 数位dp\n- 题解\n- 动态规划\ncategories:\nvisible:\n---\n\n给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数码(`digit`)各出现了多少次。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2602](https://www.luogu.org/problemnew/show/P2602)\n\n## 题解\n\n比较入门的数位dp...很适合我这种蒟蒻。\n\n令$dp[i][j]$为当倒数第$i$位为$j$时，后$i$位的数码总计（一个储存着十个整数的结构体，加减即为对位加减）。若$j=10$，则代表这位是前导$0$。(感觉这个搞法有点笨拙...巨佬能不能教教我...)\n\n令$sum(i,j)$为有$i$数码有$j$个，其他均为$0$的状态。\n\n则状态转移方程为：\n\n$$dp[1][j] = sum(j,1)$$\n\n$$dp[i][j] = sum(j,10^{i-1}) + \\sum_{w = 0}^{9} dp[i-1][w]\\; ,0\\leq j \\leq 9$$\n\n$$dp[i][10] = \\sum_{w = 1}^{10} dp[i-1][w]$$\n\n计算答案时，这个实在不太好说...看代码的注释会更好理解...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\nusing namespace std;\n#define ll long long \n\nll a,b;\n\nconst int MAXN = 20;\n\nstruct sum{\n    ll num[10];\n    sum(int pos = -1,ll d = 1){\n        for(int i = 0;i<10;i++) num[i] = 0;\n        if(~pos)\n            num[pos] = d;\n    }\n    sum operator +(const sum a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] + a.num[i];\n        return ans;\n    }\n    sum operator *(const int a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] * a;\n        return ans;\n    }\n    sum operator -(const sum a)const{\n        sum ans = sum();\n        for(int i = 0;i<=9;i++)\n            ans.num[i] = this->num[i] - a.num[i];\n        return ans;\n    }\n};\n\nsum dp[MAXN][MAXN];\nll t[MAXN];\n//dp[i][j] -> 后i位，倒数第i位为j,j == 10 代表为先导0\n\nvoid init(){\n    scanf(\"%lld %lld\",&a,&b);\n    t[0] = 1;\n    for(int i = 1;i<=15;i++)\n        t[i] = 10*t[i-1];\n}\n\nvoid build(){\n    for(int j = 0;j<=9;j++)\n        dp[1][j] = sum(j,1); \n    for(int i = 2;i<=15;i++){\n        for(int j = 0;j<=9;j++){\n            dp[i][j] = sum(j,t[i-1]);\n            for(int w = 0;w<=9;w++)\n                dp[i][j] = dp[i][j] + dp[i-1][w];\n        }\n        dp[i][10] = sum();\n        for(int w = 1;w<=10;w++)\n            dp[i][10] = dp[i][10] + dp[i-1][w]; \n    }\n}\n\nsum getnum(ll a){\n    ll tmp = a;\n    sum ans = sum(0,1);\n    if(a == 0) return sum(0,1);\n    int num[15],cnt = 0;\n    while(a){\n        num[++cnt] = a % 10;\n        a/=10;\n    }\n    ans = ans + dp[cnt][10] - dp[cnt][0];\n    //加上在这一位有前导0，再除去在这一位是0的\n    for(int i = cnt;i>=1;--i){\n        for(int j = 0;j<num[i];++j)\n            ans = ans + dp[i][j];\n        //加上所有比当前位置小的数的数码\n        ans = ans + sum(num[i],tmp%t[i-1]+1);\n        //补上后面的数中不再计算的这一位的数码\n    }\n    return ans;\n}\n\nvoid solve(){\n    sum ans = getnum(b)-getnum(a-1);\n    for(int i = 0;i<=9;i++){\n        printf(\"%lld \",ans.num[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(){\n    init();\n    build();\n    solve();\n    return 0;\n}\n```\n{% endfold %}\n\n","slug":"「ZJOI2010」数字计数-数位dp","published":1,"updated":"2018-06-18T03:47:23.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3m6005ibljrybzceqjf","content":"<p>给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数码(<code>digit</code>)各出现了多少次。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2602\" target=\"_blank\" rel=\"noopener\">Luogu P2602</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较入门的数位dp…很适合我这种蒟蒻。</p>\n<p>令$dp[i][j]$为当倒数第$i$位为$j$时，后$i$位的数码总计（一个储存着十个整数的结构体，加减即为对位加减）。若$j=10$，则代表这位是前导$0$。(感觉这个搞法有点笨拙…巨佬能不能教教我…)</p>\n<p>令$sum(i,j)$为有$i$数码有$j$个，其他均为$0$的状态。</p>\n<p>则状态转移方程为：</p>\n<p>$$dp[1][j] = sum(j,1)$$</p>\n<p>$$dp[i][j] = sum(j,10^{i-1}) + \\sum_{w = 0}^{9} dp[i-1][w]\\; ,0\\leq j \\leq 9$$</p>\n<p>$$dp[i][10] = \\sum_{w = 1}^{10} dp[i-1][w]$$</p>\n<p>计算答案时，这个实在不太好说…看代码的注释会更好理解…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long </span></span><br><span class=\"line\"></span><br><span class=\"line\">ll a,b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sum</span>&#123;</span></span><br><span class=\"line\">    ll num[<span class=\"number\">10</span>];</span><br><span class=\"line\">    sum(<span class=\"keyword\">int</span> pos = <span class=\"number\">-1</span>,ll d = <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++) num[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(~pos)</span><br><span class=\"line\">            num[pos] = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum <span class=\"keyword\">operator</span> +(<span class=\"keyword\">const</span> sum a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        sum ans = sum();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">            ans.num[i] = <span class=\"keyword\">this</span>-&gt;num[i] + a.num[i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum <span class=\"keyword\">operator</span> *(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        sum ans = sum();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">            ans.num[i] = <span class=\"keyword\">this</span>-&gt;num[i] * a;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sum <span class=\"keyword\">operator</span> -(<span class=\"keyword\">const</span> sum a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        sum ans = sum();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">            ans.num[i] = <span class=\"keyword\">this</span>-&gt;num[i] - a.num[i];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">sum dp[MAXN][MAXN];</span><br><span class=\"line\">ll t[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//dp[i][j] -&gt; 后i位，倒数第i位为j,j == 10 代表为先导0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lld %lld\"</span>,&amp;a,&amp;b);</span><br><span class=\"line\">    t[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=<span class=\"number\">15</span>;i++)</span><br><span class=\"line\">        t[i] = <span class=\"number\">10</span>*t[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;=<span class=\"number\">9</span>;j++)</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>][j] = sum(j,<span class=\"number\">1</span>); </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=<span class=\"number\">15</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;=<span class=\"number\">9</span>;j++)&#123;</span><br><span class=\"line\">            dp[i][j] = sum(j,t[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> w = <span class=\"number\">0</span>;w&lt;=<span class=\"number\">9</span>;w++)</span><br><span class=\"line\">                dp[i][j] = dp[i][j] + dp[i<span class=\"number\">-1</span>][w];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dp[i][<span class=\"number\">10</span>] = sum();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> w = <span class=\"number\">1</span>;w&lt;=<span class=\"number\">10</span>;w++)</span><br><span class=\"line\">            dp[i][<span class=\"number\">10</span>] = dp[i][<span class=\"number\">10</span>] + dp[i<span class=\"number\">-1</span>][w]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sum <span class=\"title\">getnum</span><span class=\"params\">(ll a)</span></span>&#123;</span><br><span class=\"line\">    ll tmp = a;</span><br><span class=\"line\">    sum ans = sum(<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> sum(<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num[<span class=\"number\">15</span>],cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(a)&#123;</span><br><span class=\"line\">        num[++cnt] = a % <span class=\"number\">10</span>;</span><br><span class=\"line\">        a/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = ans + dp[cnt][<span class=\"number\">10</span>] - dp[cnt][<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">//加上在这一位有前导0，再除去在这一位是0的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = cnt;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;num[i];++j)</span><br><span class=\"line\">            ans = ans + dp[i][j];</span><br><span class=\"line\">        <span class=\"comment\">//加上所有比当前位置小的数的数码</span></span><br><span class=\"line\">        ans = ans + sum(num[i],tmp%t[i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//补上后面的数中不再计算的这一位的数码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sum ans = getnum(b)-getnum(a<span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld \"</span>,ans.num[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    build();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数码(<code>digit</code>)各出现了多少次。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2602\" target=\"_blank\" rel=\"noopener\">Luogu P2602</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>比较入门的数位dp…很适合我这种蒟蒻。</p>\n<p>令$dp[i][j]$为当倒数第$i$位为$j$时，后$i$位的数码总计（一个储存着十个整数的结构体，加减即为对位加减）。若$j=10$，则代表这位是前导$0$。(感觉这个搞法有点笨拙…巨佬能不能教教我…)</p>\n<p>令$sum(i,j)$为有$i$数码有$j$个，其他均为$0$的状态。</p>\n<p>则状态转移方程为：</p>\n<p>$$dp[1][j] = sum(j,1)$$</p>\n<p>$$dp[i][j] = sum(j,10^{i-1}) + \\sum_{w = 0}^{9} dp[i-1][w]\\; ,0\\leq j \\leq 9$$</p>\n<p>$$dp[i][10] = \\sum_{w = 1}^{10} dp[i-1][w]$$</p>\n<p>计算答案时，这个实在不太好说…看代码的注释会更好理解…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�64-->\n\n</div></div>"},{"title":"「ZJOI2010」网络扩容-网络流-费用流","urlname":"zjoi2010-network","date":"2018-04-05T08:55:11.000Z","visible":null,"_content":"\n给定一张有向图，每条边都有一个容量$C$和一个扩容费用$W$。这里扩容费用是指将容量扩大$1$所需的费用。\n\n现在请你编写一个程序求出：\n1. 在不扩容的情况下，$1$到$N$的最大流； \n2. 将$1$到$N$的最大流增加$K$所需的最小扩容费用。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2604](https://www.luogu.org/problemnew/show/P2604)\n\n[BZOJ 1834](https://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n## 题解\n\n一道最大流和费用流的题。\n\n第一问不说了。第二问事实上我们注意到我们可以把每条边想像成，$C$的免费流量和费用为$W$的流量。因为答案问我们在最大流为$ans+k$的时候，最小费用是多少，所以我们需要引入一条边来控制流量，再跑得到的费用流就是最小费用了。\n\n怎么来达成边的约束呢？事实上拆边为两条就好，一条免费边，一条收费边。\n\n- - -\n\n具体建图方法如下。\n\n先按照费用流的样子建图，所有边的费用为$0$，源点为$1$，终点为$n$，然后跑`Dinic`得到$ans1$。\n\n关于$ans2$，稍微复杂一些。\n\n保留原图。对于图中的每条边，再建一条容量为$ans1+k$，费用为$w\\_i$的边。由$n$号节点向$n+1$号节点建一条容量为$ans1+K$，费用为$0$的边，并把汇点设置为$n+1$，注意把流量初始需要设置成$ans1$。直接在残量网络上跑费用流，得到费用即为$ans2$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 6000,MAXM = 110000;\n\nint fx[MAXM],tx[MAXM],cx[MAXM],wx[MAXM];\n\nstruct Edge{\n    int from,to;\n    int flow,cap;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t,k;\nint fir[MAXN],cur[MAXN],pree[MAXN],ecnt = 2;\n\nvoid addedge(int a,int b,int ca,int co = 0,int f = 0){\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].cost = co,edge[ecnt].cap = ca;\n    edge[ecnt].flow = f;\n    edge[ecnt].nex = fir[a],fir[a] = ecnt;\n    ecnt++;\n    edge[ecnt].from = b,edge[ecnt].to = a;\n    edge[ecnt].cost = -co,edge[ecnt].cap = 0;\n    edge[ecnt].flow = -f;\n    edge[ecnt].nex = fir[b],fir[b] = ecnt;\n    ecnt++;\n}\n\nint dis[MAXN],instack[MAXN];\n\nqueue<int> q;\n\n//Dinic\nbool bfs(){\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));\n    while(!q.empty()) q.pop();\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            int v = edge[nowe].to;\n            if(dis[v] == 0 && edge[nowe].cap > edge[nowe].flow){\n                dis[v] = dis[nown]+1;\n                q.push(v);\n                if(v == t)\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    if(nown == t||limit == 0)\n        return limit;\n    for(int &nowe = cur[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dis[v] == dis[nown]+1 && edge[nowe].cap > edge[nowe].flow){\n            int f = dfs(v,min(limit,edge[nowe].cap - edge[nowe].flow));\n            if(f>0){\n                edge[nowe].flow+=f;\n                edge[nowe^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs())\n        while((f=dfs(s))>0)\n            ans+=f;\n    return ans;\n}\n\n//费用流\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to]>dis[nown]+e.cost&&e.cap>e.flow){\n                dis[e.to] = dis[nown]+e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(int &sumc,int &sumf){\n    int nown = t,delta = 0x3f3f3f3f;\n    while(nown!=s){\n        delta = min(delta,edge[pree[nown]].cap - edge[pree[nown]].flow);\n        nown = edge[pree[nown]].from;\n    }\n    nown = t;\n    while(nown!=s){\n        edge[pree[nown]].flow += delta;\n        edge[pree[nown]^1].flow -= delta;\n        nown = edge[pree[nown]].from;\n    }\n    sumf+=delta,sumc+=delta*dis[t];\n}\n\nint min_cost_flow(int ans){\n    int c = 0,f = ans;\n    while(spfa())\n        argument(c,f);\n    return c;\n}\n\n//主程序\nvoid init(){\n    read(n),read(m),read(k);s = 1,t = n;\n    for(int i = 1;i<=m;i++){\n        read(fx[i]),read(tx[i]),read(cx[i]),read(wx[i]);\n        addedge(fx[i],tx[i],cx[i]);\n    }\n}\n\nvoid solve(){\n    int ans1 = dinic(),ans2;\n    for(int i = 1;i<=m;i++)\n        addedge(fx[i],tx[i],ans1+k,wx[i]);\n    addedge(n,n+1,ans1+k,0,ans1);t = n+1;\n    //注意这个地方需要改变汇点，加边的时候需要给定初始流量\n    ans2 = min_cost_flow(ans1);\n    print(ans1),print(' '),print(ans2),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","source":"_posts/「ZJOI2010」网络扩容-网络流-费用流.md","raw":"---\ntitle: 「ZJOI2010」网络扩容-网络流-费用流\nurlname: zjoi2010-network\ndate: 2018-04-05 16:55:11\ntags:\n- 题解\n- 图论\n- 费用流\n- 网络流\ncategories: OI\nvisible:\n---\n\n给定一张有向图，每条边都有一个容量$C$和一个扩容费用$W$。这里扩容费用是指将容量扩大$1$所需的费用。\n\n现在请你编写一个程序求出：\n1. 在不扩容的情况下，$1$到$N$的最大流； \n2. 将$1$到$N$的最大流增加$K$所需的最小扩容费用。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2604](https://www.luogu.org/problemnew/show/P2604)\n\n[BZOJ 1834](https://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n## 题解\n\n一道最大流和费用流的题。\n\n第一问不说了。第二问事实上我们注意到我们可以把每条边想像成，$C$的免费流量和费用为$W$的流量。因为答案问我们在最大流为$ans+k$的时候，最小费用是多少，所以我们需要引入一条边来控制流量，再跑得到的费用流就是最小费用了。\n\n怎么来达成边的约束呢？事实上拆边为两条就好，一条免费边，一条收费边。\n\n- - -\n\n具体建图方法如下。\n\n先按照费用流的样子建图，所有边的费用为$0$，源点为$1$，终点为$n$，然后跑`Dinic`得到$ans1$。\n\n关于$ans2$，稍微复杂一些。\n\n保留原图。对于图中的每条边，再建一条容量为$ans1+k$，费用为$w\\_i$的边。由$n$号节点向$n+1$号节点建一条容量为$ans1+K$，费用为$0$的边，并把汇点设置为$n+1$，注意把流量初始需要设置成$ans1$。直接在残量网络上跑费用流，得到费用即为$ans2$。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 6000,MAXM = 110000;\n\nint fx[MAXM],tx[MAXM],cx[MAXM],wx[MAXM];\n\nstruct Edge{\n    int from,to;\n    int flow,cap;\n    int cost,nex;\n}edge[MAXM];\n\nint n,m,s,t,k;\nint fir[MAXN],cur[MAXN],pree[MAXN],ecnt = 2;\n\nvoid addedge(int a,int b,int ca,int co = 0,int f = 0){\n    edge[ecnt].from = a,edge[ecnt].to = b;\n    edge[ecnt].cost = co,edge[ecnt].cap = ca;\n    edge[ecnt].flow = f;\n    edge[ecnt].nex = fir[a],fir[a] = ecnt;\n    ecnt++;\n    edge[ecnt].from = b,edge[ecnt].to = a;\n    edge[ecnt].cost = -co,edge[ecnt].cap = 0;\n    edge[ecnt].flow = -f;\n    edge[ecnt].nex = fir[b],fir[b] = ecnt;\n    ecnt++;\n}\n\nint dis[MAXN],instack[MAXN];\n\nqueue<int> q;\n\n//Dinic\nbool bfs(){\n    memset(dis,0,sizeof(dis));\n    memcpy(cur,fir,sizeof(fir));\n    while(!q.empty()) q.pop();\n    q.push(s);dis[s] = 1;\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            int v = edge[nowe].to;\n            if(dis[v] == 0 && edge[nowe].cap > edge[nowe].flow){\n                dis[v] = dis[nown]+1;\n                q.push(v);\n                if(v == t)\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint dfs(int nown,int limit = 0x3f3f3f3f){\n    if(nown == t||limit == 0)\n        return limit;\n    for(int &nowe = cur[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(dis[v] == dis[nown]+1 && edge[nowe].cap > edge[nowe].flow){\n            int f = dfs(v,min(limit,edge[nowe].cap - edge[nowe].flow));\n            if(f>0){\n                edge[nowe].flow+=f;\n                edge[nowe^1].flow-=f;\n                return f;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(){\n    int ans = 0,f;\n    while(bfs())\n        while((f=dfs(s))>0)\n            ans+=f;\n    return ans;\n}\n\n//费用流\nbool spfa(){\n    while(!q.empty()) q.pop();\n    memset(dis,0x3f,sizeof(dis));\n    memset(instack,0,sizeof(instack));\n    dis[s] = 0;q.push(s);\n    while(!q.empty()){\n        int nown = q.front();q.pop();\n        instack[nown] = 0;\n        for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n            Edge e = edge[nowe];\n            if(dis[e.to]>dis[nown]+e.cost&&e.cap>e.flow){\n                dis[e.to] = dis[nown]+e.cost;\n                pree[e.to] = nowe;\n                if(instack[e.to] == 0){\n                    q.push(e.to);\n                    instack[e.to] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] < 0x3f3f3f3f;\n}\n\nvoid argument(int &sumc,int &sumf){\n    int nown = t,delta = 0x3f3f3f3f;\n    while(nown!=s){\n        delta = min(delta,edge[pree[nown]].cap - edge[pree[nown]].flow);\n        nown = edge[pree[nown]].from;\n    }\n    nown = t;\n    while(nown!=s){\n        edge[pree[nown]].flow += delta;\n        edge[pree[nown]^1].flow -= delta;\n        nown = edge[pree[nown]].from;\n    }\n    sumf+=delta,sumc+=delta*dis[t];\n}\n\nint min_cost_flow(int ans){\n    int c = 0,f = ans;\n    while(spfa())\n        argument(c,f);\n    return c;\n}\n\n//主程序\nvoid init(){\n    read(n),read(m),read(k);s = 1,t = n;\n    for(int i = 1;i<=m;i++){\n        read(fx[i]),read(tx[i]),read(cx[i]),read(wx[i]);\n        addedge(fx[i],tx[i],cx[i]);\n    }\n}\n\nvoid solve(){\n    int ans1 = dinic(),ans2;\n    for(int i = 1;i<=m;i++)\n        addedge(fx[i],tx[i],ans1+k,wx[i]);\n    addedge(n,n+1,ans1+k,0,ans1);t = n+1;\n    //注意这个地方需要改变汇点，加边的时候需要给定初始流量\n    ans2 = min_cost_flow(ans1);\n    print(ans1),print(' '),print(ans2),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n","slug":"「ZJOI2010」网络扩容-网络流-费用流","published":1,"updated":"2018-04-06T12:54:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3m9005mbljrsbe83c5v","content":"<p>给定一张有向图，每条边都有一个容量$C$和一个扩容费用$W$。这里扩容费用是指将容量扩大$1$所需的费用。</p>\n<p>现在请你编写一个程序求出：</p>\n<ol>\n<li>在不扩容的情况下，$1$到$N$的最大流； </li>\n<li>将$1$到$N$的最大流增加$K$所需的最小扩容费用。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2604\" target=\"_blank\" rel=\"noopener\">Luogu P2604</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1834\" target=\"_blank\" rel=\"noopener\">BZOJ 1834</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道最大流和费用流的题。</p>\n<p>第一问不说了。第二问事实上我们注意到我们可以把每条边想像成，$C$的免费流量和费用为$W$的流量。因为答案问我们在最大流为$ans+k$的时候，最小费用是多少，所以我们需要引入一条边来控制流量，再跑得到的费用流就是最小费用了。</p>\n<p>怎么来达成边的约束呢？事实上拆边为两条就好，一条免费边，一条收费边。</p>\n<hr>\n<p>具体建图方法如下。</p>\n<p>先按照费用流的样子建图，所有边的费用为$0$，源点为$1$，终点为$n$，然后跑<code>Dinic</code>得到$ans1$。</p>\n<p>关于$ans2$，稍微复杂一些。</p>\n<p>保留原图。对于图中的每条边，再建一条容量为$ans1+k$，费用为$w_i$的边。由$n$号节点向$n+1$号节点建一条容量为$ans1+K$，费用为$0$的边，并把汇点设置为$n+1$，注意把流量初始需要设置成$ans1$。直接在残量网络上跑费用流，得到费用即为$ans2$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">6000</span>,MAXM = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> fx[MAXM],tx[MAXM],cx[MAXM],wx[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flow,cap;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cost,nex;</span><br><span class=\"line\">&#125;edge[MAXM];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,s,t,k;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN],cur[MAXN],pree[MAXN],ecnt = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> ca,<span class=\"keyword\">int</span> co = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> f = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt].from = a,edge[ecnt].to = b;</span><br><span class=\"line\">    edge[ecnt].cost = co,edge[ecnt].cap = ca;</span><br><span class=\"line\">    edge[ecnt].flow = f;</span><br><span class=\"line\">    edge[ecnt].nex = fir[a],fir[a] = ecnt;</span><br><span class=\"line\">    ecnt++;</span><br><span class=\"line\">    edge[ecnt].from = b,edge[ecnt].to = a;</span><br><span class=\"line\">    edge[ecnt].cost = -co,edge[ecnt].cap = <span class=\"number\">0</span>;</span><br><span class=\"line\">    edge[ecnt].flow = -f;</span><br><span class=\"line\">    edge[ecnt].nex = fir[b],fir[b] = ecnt;</span><br><span class=\"line\">    ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> dis[MAXN],instack[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">queue</span>&lt;<span class=\"keyword\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Dinic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(cur,fir,<span class=\"keyword\">sizeof</span>(fir));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) q.pop();</span><br><span class=\"line\">    q.push(s);dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[v] == <span class=\"number\">0</span> &amp;&amp; edge[nowe].cap &gt; edge[nowe].flow)&#123;</span><br><span class=\"line\">                dis[v] = dis[nown]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                q.push(v);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(v == t)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> limit = <span class=\"number\">0x3f3f3f3f</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nown == t||limit == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> limit;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> &amp;nowe = cur[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[v] == dis[nown]+<span class=\"number\">1</span> &amp;&amp; edge[nowe].cap &gt; edge[nowe].flow)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> f = dfs(v,min(limit,edge[nowe].cap - edge[nowe].flow));</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                edge[nowe].flow+=f;</span><br><span class=\"line\">                edge[nowe^<span class=\"number\">1</span>].flow-=f;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dinic</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>,f;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(bfs())</span><br><span class=\"line\">        <span class=\"keyword\">while</span>((f=dfs(s))&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            ans+=f;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//费用流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty()) q.pop();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span>(dis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(instack,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(instack));</span><br><span class=\"line\">    dis[s] = <span class=\"number\">0</span>;q.push(s);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.empty())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nown = q.front();q.pop();</span><br><span class=\"line\">        instack[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">            Edge e = edge[nowe];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[e.to]&gt;dis[nown]+e.cost&amp;&amp;e.cap&gt;e.flow)&#123;</span><br><span class=\"line\">                dis[e.to] = dis[nown]+e.cost;</span><br><span class=\"line\">                pree[e.to] = nowe;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instack[e.to] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    q.push(e.to);</span><br><span class=\"line\">                    instack[e.to] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dis[t] &lt; <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">argument</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;sumc,<span class=\"keyword\">int</span> &amp;sumf)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nown = t,delta = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        delta = min(delta,edge[pree[nown]].cap - edge[pree[nown]].flow);</span><br><span class=\"line\">        nown = edge[pree[nown]].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nown = t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(nown!=s)&#123;</span><br><span class=\"line\">        edge[pree[nown]].flow += delta;</span><br><span class=\"line\">        edge[pree[nown]^<span class=\"number\">1</span>].flow -= delta;</span><br><span class=\"line\">        nown = edge[pree[nown]].from;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sumf+=delta,sumc+=delta*dis[t];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">min_cost_flow</span><span class=\"params\">(<span class=\"keyword\">int</span> ans)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>,f = ans;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(spfa())</span><br><span class=\"line\">        argument(c,f);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//主程序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m),read(k);s = <span class=\"number\">1</span>,t = n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        read(fx[i]),read(tx[i]),read(cx[i]),read(wx[i]);</span><br><span class=\"line\">        addedge(fx[i],tx[i],cx[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans1 = dinic(),ans2;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        addedge(fx[i],tx[i],ans1+k,wx[i]);</span><br><span class=\"line\">    addedge(n,n+<span class=\"number\">1</span>,ans1+k,<span class=\"number\">0</span>,ans1);t = n+<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//注意这个地方需要改变汇点，加边的时候需要给定初始流量</span></span><br><span class=\"line\">    ans2 = min_cost_flow(ans1);</span><br><span class=\"line\">    print(ans1),print(<span class=\"string\">' '</span>),print(ans2),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>给定一张有向图，每条边都有一个容量$C$和一个扩容费用$W$。这里扩容费用是指将容量扩大$1$所需的费用。</p>\n<p>现在请你编写一个程序求出：</p>\n<ol>\n<li>在不扩容的情况下，$1$到$N$的最大流； </li>\n<li>将$1$到$N$的最大流增加$K$所需的最小扩容费用。</li>\n</ol>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2604\" target=\"_blank\" rel=\"noopener\">Luogu P2604</a></p>\n<p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=1834\" target=\"_blank\" rel=\"noopener\">BZOJ 1834</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>一道最大流和费用流的题。</p>\n<p>第一问不说了。第二问事实上我们注意到我们可以把每条边想像成，$C$的免费流量和费用为$W$的流量。因为答案问我们在最大流为$ans+k$的时候，最小费用是多少，所以我们需要引入一条边来控制流量，再跑得到的费用流就是最小费用了。</p>\n<p>怎么来达成边的约束呢？事实上拆边为两条就好，一条免费边，一条收费边。</p>\n<hr>\n<p>具体建图方法如下。</p>\n<p>先按照费用流的样子建图，所有边的费用为$0$，源点为$1$，终点为$n$，然后跑<code>Dinic</code>得到$ans1$。</p>\n<p>关于$ans2$，稍微复杂一些。</p>\n<p>保留原图。对于图中的每条边，再建一条容量为$ans1+k$，费用为$w_i$的边。由$n$号节点向$n+1$号节点建一条容量为$ans1+K$，费用为$0$的边，并把汇点设置为$n+1$，注意把流量初始需要设置成$ans1$。直接在残量网络上跑费用流，得到费用即为$ans2$。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�65-->\n\n</div></div>"},{"title":"「ZJOI2013」K大数查询-整体二分","urlname":"ZJOI2013-kth","date":"2018-06-06T11:17:02.000Z","visible":null,"_content":"\n有$N$个位置，$M$个操作。\n\n操作有两种：\n+ 如果是`1 a b c`的形式表示在第$a$个位置到第$b$个位置，每个位置加入一个数$c$；\n+ 如果是`2 a b c`形式，表示询问从第$a$个位置到第$b$个位置，第$C$大的数是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3332](https://www.luogu.org/problemnew/show/P3332)\n\n## 题解\n\n可以树套树。然后基本上就会死在树上。\n\n正解整体二分。\n\n比较模板，就不讲思路了，主要说一说实现。这个地方的区间加数其实和单点加数是一样的，只不过把原来单点修改的树状数组改成区间修改的线段树。\n\n注意，整体二分是按答案二分，每次二分我们的在原区间上处理范围仍然是整个区间，不要搞错成啥的...\n\n还有注意，这里每一层递归的复杂度一定只能与你的正在处理的询问的个数有关！不能带有其他项，所以我们这里归零线段树的时候是一个个减回去，复杂度就是$O(n \\log {n})$。\n\n递归的每层都要处理$n$个操作，一共有$\\log n$层，处理每个询问的时间是$O(\\log n)$，最后的复杂度就是$O(n \\log ^{2} {n})$。\n\n莫名跑的就特别慢...明明我写了$zkw$线段树啊...`BZOJ`莫名$RE$...明明我`luogu`和`codevs`上全$AC$了啊...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n#define ll long long\n#define mid ((l+r)>>1)\nconst int MAXN = 51000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nstruct ZKW{\n    //区间修改、求和zkw线段树\n    ll sumn[MAXN<<2],addn[MAXN<<2];\n    int M;\n    void init(int n){\n        for(M = 1;M<=n+2;M<<=1);\n    }\n    void update(int l,int r,ll d){\n        int i=1,L=0,R=0;\n        for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1,i<<=1){\n            sumn[l]+=L*d,sumn[r]+=R*d;\n            if(~l&1) addn[l^1]+=d,sumn[l^1]+=d*i,L+=i;\n            if(r&1) addn[r^1]+=d,sumn[r^1]+=d*i,R+=i;\n        }\n        sumn[l]+=L*d,sumn[r]+=R*d;\n        while(l>>=1) sumn[l]+=(L+R)*d;\n    }\n    ll query(int l,int r){\n        ll ans = 0;int i=1,L=0,R=0;\n        for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1,i<<=1){\n            ans+=addn[l]*L,ans+=addn[r]*R;\n            if(~l&1) ans+=sumn[l^1],L+=i;\n            if(r&1) ans+=sumn[r^1],R+=i;\n        }\n        ans+=addn[l]*L,ans+=addn[r]*R;\n        while(l>>=1) ans+=addn[l]*(L+R);\n        return ans;\n    }\n}tree;\n\nstruct Q{\n    int o,ql,qr;\n    ll k;\n    // o == 0 -> update l r val; o == 1 -> query l r k\n    Q(){}\n    Q(int a,int b,int c,ll d):o(a),ql(b),qr(c),k(d){}\n}query[MAXN];\n\nint tl[MAXN],tr[MAXN],ans[MAXN];\n\nvoid solve(int *a,int n,int l,int r){\n    //表示要处理的询问在q[0]->q[n-1]，二分答案范围为[l,r]\n    if(n == 0) return;//一个微小的剪枝\n    if(l == r){\n        //递归边界\n        for(int i = 0;i<n;i++) ans[a[i]] = l;\n        return;\n    }\n    int n1 = 0,n2 = 0;ll sum;\n    for(int i = 0;i<n;i++){\n        Q &q = query[a[i]];\n        if(q.o == 1){\n            //修改如果值大于mid，就应用修改；否则不管\n            if(q.k > mid) tree.update(q.ql,q.qr,1),tr[n2++] = a[i];\n            else tl[n1++] = a[i];\n        }\n        else if(q.o == 2){\n            //查询的结果sum大于k，二分到右边；否则左边\n            sum = tree.query(q.ql,q.qr);\n            if(q.k <= sum) tr[n2++] = a[i];\n            else q.k -= sum,tl[n1++] = a[i];\n        }\n    }\n    //原样减回去\n    for(int i = 0;i<n;i++){\n        Q &q = query[a[i]];\n        if(q.o == 1 && q.k > mid) tree.update(q.ql,q.qr,-1);\n    }\n    memcpy(a,tl,sizeof(int) * n1),memcpy(a+n1,tr,sizeof(int) * n2);\n    //递归二分\n    solve(a,n1,l,mid),solve(a+n1,n2,mid+1,r);\n}\n\nint n,m,t[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    tree.init(n);\n    int op,l,r;ll c;\n    for(int i = 0;i<m;i++){\n        read(op),read(l),read(r),read(c);\n        query[i] = Q(op,l,r,c);\n        t[i] = i;\n    }\n}\n\nvoid solve(){\n    solve(t,m,-n,n);\n    for(int i = 0;i<m;i++){\n        if(query[i].o == 2)\n            print(ans[i]),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「ZJOI2013」K大数查询-整体二分.md","raw":"---\ntitle: 「ZJOI2013」K大数查询-整体二分\nurlname: ZJOI2013-kth\ndate: 2018-06-06 19:17:02\ntags:\n- 题解\n- 整体二分\n- 数据结构\ncategories: OI\nvisible:\n---\n\n有$N$个位置，$M$个操作。\n\n操作有两种：\n+ 如果是`1 a b c`的形式表示在第$a$个位置到第$b$个位置，每个位置加入一个数$c$；\n+ 如果是`2 a b c`形式，表示询问从第$a$个位置到第$b$个位置，第$C$大的数是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P3332](https://www.luogu.org/problemnew/show/P3332)\n\n## 题解\n\n可以树套树。然后基本上就会死在树上。\n\n正解整体二分。\n\n比较模板，就不讲思路了，主要说一说实现。这个地方的区间加数其实和单点加数是一样的，只不过把原来单点修改的树状数组改成区间修改的线段树。\n\n注意，整体二分是按答案二分，每次二分我们的在原区间上处理范围仍然是整个区间，不要搞错成啥的...\n\n还有注意，这里每一层递归的复杂度一定只能与你的正在处理的询问的个数有关！不能带有其他项，所以我们这里归零线段树的时候是一个个减回去，复杂度就是$O(n \\log {n})$。\n\n递归的每层都要处理$n$个操作，一共有$\\log n$层，处理每个询问的时间是$O(\\log n)$，最后的复杂度就是$O(n \\log ^{2} {n})$。\n\n莫名跑的就特别慢...明明我写了$zkw$线段树啊...`BZOJ`莫名$RE$...明明我`luogu`和`codevs`上全$AC$了啊...\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n#define ll long long\n#define mid ((l+r)>>1)\nconst int MAXN = 51000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nstruct ZKW{\n    //区间修改、求和zkw线段树\n    ll sumn[MAXN<<2],addn[MAXN<<2];\n    int M;\n    void init(int n){\n        for(M = 1;M<=n+2;M<<=1);\n    }\n    void update(int l,int r,ll d){\n        int i=1,L=0,R=0;\n        for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1,i<<=1){\n            sumn[l]+=L*d,sumn[r]+=R*d;\n            if(~l&1) addn[l^1]+=d,sumn[l^1]+=d*i,L+=i;\n            if(r&1) addn[r^1]+=d,sumn[r^1]+=d*i,R+=i;\n        }\n        sumn[l]+=L*d,sumn[r]+=R*d;\n        while(l>>=1) sumn[l]+=(L+R)*d;\n    }\n    ll query(int l,int r){\n        ll ans = 0;int i=1,L=0,R=0;\n        for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1,i<<=1){\n            ans+=addn[l]*L,ans+=addn[r]*R;\n            if(~l&1) ans+=sumn[l^1],L+=i;\n            if(r&1) ans+=sumn[r^1],R+=i;\n        }\n        ans+=addn[l]*L,ans+=addn[r]*R;\n        while(l>>=1) ans+=addn[l]*(L+R);\n        return ans;\n    }\n}tree;\n\nstruct Q{\n    int o,ql,qr;\n    ll k;\n    // o == 0 -> update l r val; o == 1 -> query l r k\n    Q(){}\n    Q(int a,int b,int c,ll d):o(a),ql(b),qr(c),k(d){}\n}query[MAXN];\n\nint tl[MAXN],tr[MAXN],ans[MAXN];\n\nvoid solve(int *a,int n,int l,int r){\n    //表示要处理的询问在q[0]->q[n-1]，二分答案范围为[l,r]\n    if(n == 0) return;//一个微小的剪枝\n    if(l == r){\n        //递归边界\n        for(int i = 0;i<n;i++) ans[a[i]] = l;\n        return;\n    }\n    int n1 = 0,n2 = 0;ll sum;\n    for(int i = 0;i<n;i++){\n        Q &q = query[a[i]];\n        if(q.o == 1){\n            //修改如果值大于mid，就应用修改；否则不管\n            if(q.k > mid) tree.update(q.ql,q.qr,1),tr[n2++] = a[i];\n            else tl[n1++] = a[i];\n        }\n        else if(q.o == 2){\n            //查询的结果sum大于k，二分到右边；否则左边\n            sum = tree.query(q.ql,q.qr);\n            if(q.k <= sum) tr[n2++] = a[i];\n            else q.k -= sum,tl[n1++] = a[i];\n        }\n    }\n    //原样减回去\n    for(int i = 0;i<n;i++){\n        Q &q = query[a[i]];\n        if(q.o == 1 && q.k > mid) tree.update(q.ql,q.qr,-1);\n    }\n    memcpy(a,tl,sizeof(int) * n1),memcpy(a+n1,tr,sizeof(int) * n2);\n    //递归二分\n    solve(a,n1,l,mid),solve(a+n1,n2,mid+1,r);\n}\n\nint n,m,t[MAXN];\n\nvoid init(){\n    read(n),read(m);\n    tree.init(n);\n    int op,l,r;ll c;\n    for(int i = 0;i<m;i++){\n        read(op),read(l),read(r),read(c);\n        query[i] = Q(op,l,r,c);\n        t[i] = i;\n    }\n}\n\nvoid solve(){\n    solve(t,m,-n,n);\n    for(int i = 0;i<m;i++){\n        if(query[i].o == 2)\n            print(ans[i]),print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「ZJOI2013」K大数查询-整体二分","published":1,"updated":"2018-06-06T14:15:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mb005pbljr1p4hclox","content":"<p>有$N$个位置，$M$个操作。</p>\n<p>操作有两种：</p>\n<ul>\n<li>如果是<code>1 a b c</code>的形式表示在第$a$个位置到第$b$个位置，每个位置加入一个数$c$；</li>\n<li>如果是<code>2 a b c</code>形式，表示询问从第$a$个位置到第$b$个位置，第$C$大的数是多少。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3332\" target=\"_blank\" rel=\"noopener\">Luogu P3332</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以树套树。然后基本上就会死在树上。</p>\n<p>正解整体二分。</p>\n<p>比较模板，就不讲思路了，主要说一说实现。这个地方的区间加数其实和单点加数是一样的，只不过把原来单点修改的树状数组改成区间修改的线段树。</p>\n<p>注意，整体二分是按答案二分，每次二分我们的在原区间上处理范围仍然是整个区间，不要搞错成啥的…</p>\n<p>还有注意，这里每一层递归的复杂度一定只能与你的正在处理的询问的个数有关！不能带有其他项，所以我们这里归零线段树的时候是一个个减回去，复杂度就是$O(n \\log {n})$。</p>\n<p>递归的每层都要处理$n$个操作，一共有$\\log n$层，处理每个询问的时间是$O(\\log n)$，最后的复杂度就是$O(n \\log ^{2} {n})$。</p>\n<p>莫名跑的就特别慢…明明我写了$zkw$线段树啊…<code>BZOJ</code>莫名$RE$…明明我<code>luogu</code>和<code>codevs</code>上全$AC$了啊…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">51000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ZKW</span>&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//区间修改、求和zkw线段树</span></span><br><span class=\"line\">    ll sumn[MAXN&lt;&lt;<span class=\"number\">2</span>],addn[MAXN&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> M;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(M = <span class=\"number\">1</span>;M&lt;=n+<span class=\"number\">2</span>;M&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,ll d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>,L=<span class=\"number\">0</span>,R=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(l=l+M<span class=\"number\">-1</span>,r=r+M+<span class=\"number\">1</span>;l^r^<span class=\"number\">1</span>;l&gt;&gt;=<span class=\"number\">1</span>,r&gt;&gt;=<span class=\"number\">1</span>,i&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            sumn[l]+=L*d,sumn[r]+=R*d;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~l&amp;<span class=\"number\">1</span>) addn[l^<span class=\"number\">1</span>]+=d,sumn[l^<span class=\"number\">1</span>]+=d*i,L+=i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r&amp;<span class=\"number\">1</span>) addn[r^<span class=\"number\">1</span>]+=d,sumn[r^<span class=\"number\">1</span>]+=d*i,R+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sumn[l]+=L*d,sumn[r]+=R*d;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&gt;&gt;=<span class=\"number\">1</span>) sumn[l]+=(L+R)*d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        ll ans = <span class=\"number\">0</span>;<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>,L=<span class=\"number\">0</span>,R=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(l=l+M<span class=\"number\">-1</span>,r=r+M+<span class=\"number\">1</span>;l^r^<span class=\"number\">1</span>;l&gt;&gt;=<span class=\"number\">1</span>,r&gt;&gt;=<span class=\"number\">1</span>,i&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            ans+=addn[l]*L,ans+=addn[r]*R;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~l&amp;<span class=\"number\">1</span>) ans+=sumn[l^<span class=\"number\">1</span>],L+=i;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r&amp;<span class=\"number\">1</span>) ans+=sumn[r^<span class=\"number\">1</span>],R+=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans+=addn[l]*L,ans+=addn[r]*R;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&gt;&gt;=<span class=\"number\">1</span>) ans+=addn[l]*(L+R);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;tree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Q</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> o,ql,qr;</span><br><span class=\"line\">    ll k;</span><br><span class=\"line\">    <span class=\"comment\">// o == 0 -&gt; update l r val; o == 1 -&gt; query l r k</span></span><br><span class=\"line\">    Q()&#123;&#125;</span><br><span class=\"line\">    Q(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> c,ll d):o(a),ql(b),qr(c),k(d)&#123;&#125;</span><br><span class=\"line\">&#125;query[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tl[MAXN],tr[MAXN],ans[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> *a,<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//表示要处理的询问在q[0]-&gt;q[n-1]，二分答案范围为[l,r]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;<span class=\"comment\">//一个微小的剪枝</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l == r)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归边界</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++) ans[a[i]] = l;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = <span class=\"number\">0</span>,n2 = <span class=\"number\">0</span>;ll sum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        Q &amp;q = query[a[i]];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q.o == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//修改如果值大于mid，就应用修改；否则不管</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.k &gt; mid) tree.update(q.ql,q.qr,<span class=\"number\">1</span>),tr[n2++] = a[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> tl[n1++] = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(q.o == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//查询的结果sum大于k，二分到右边；否则左边</span></span><br><span class=\"line\">            sum = tree.query(q.ql,q.qr);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.k &lt;= sum) tr[n2++] = a[i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> q.k -= sum,tl[n1++] = a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//原样减回去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        Q &amp;q = query[a[i]];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q.o == <span class=\"number\">1</span> &amp;&amp; q.k &gt; mid) tree.update(q.ql,q.qr,<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(a,tl,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n1),<span class=\"built_in\">memcpy</span>(a+n1,tr,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * n2);</span><br><span class=\"line\">    <span class=\"comment\">//递归二分</span></span><br><span class=\"line\">    solve(a,n1,l,mid),solve(a+n1,n2,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,t[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    tree.init(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> op,l,r;ll c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        read(op),read(l),read(r),read(c);</span><br><span class=\"line\">        query[i] = Q(op,l,r,c);</span><br><span class=\"line\">        t[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    solve(t,m,-n,n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(query[i].o == <span class=\"number\">2</span>)</span><br><span class=\"line\">            print(ans[i]),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>有$N$个位置，$M$个操作。</p>\n<p>操作有两种：</p>\n<ul>\n<li>如果是<code>1 a b c</code>的形式表示在第$a$个位置到第$b$个位置，每个位置加入一个数$c$；</li>\n<li>如果是<code>2 a b c</code>形式，表示询问从第$a$个位置到第$b$个位置，第$C$大的数是多少。</li>\n</ul>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P3332\" target=\"_blank\" rel=\"noopener\">Luogu P3332</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>可以树套树。然后基本上就会死在树上。</p>\n<p>正解整体二分。</p>\n<p>比较模板，就不讲思路了，主要说一说实现。这个地方的区间加数其实和单点加数是一样的，只不过把原来单点修改的树状数组改成区间修改的线段树。</p>\n<p>注意，整体二分是按答案二分，每次二分我们的在原区间上处理范围仍然是整个区间，不要搞错成啥的…</p>\n<p>还有注意，这里每一层递归的复杂度一定只能与你的正在处理的询问的个数有关！不能带有其他项，所以我们这里归零线段树的时候是一个个减回去，复杂度就是$O(n \\log {n})$。</p>\n<p>递归的每层都要处理$n$个操作，一共有$\\log n$层，处理每个询问的时间是$O(\\log n)$，最后的复杂度就是$O(n \\log ^{2} {n})$。</p>\n<p>莫名跑的就特别慢…明明我写了$zkw$线段树啊…<code>BZOJ</code>莫名$RE$…明明我<code>luogu</code>和<code>codevs</code>上全$AC$了啊…</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�66-->\n\n</div></div>"},{"title":"「国家集训队」数颜色-带修改莫队","urlname":"count_color","date":"2018-03-31T04:21:42.000Z","visible":null,"_content":"\n\n墨墨购买了一套$N$支彩色画笔（其中有些颜色可能相同）。墨墨会向你发布如下指令：\n\n1. `Q L R`代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。\n\n2. `R P Col` 把第P支画笔替换为颜色$Col$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1903](https://www.luogu.org/problemnew/show/P1903)\n\n## 题解\n\n带修改的莫队裸题。思路可以去{% post_link 莫队算法学习笔记（一） 这篇文章 %}里看。\n\n主要需要注意的就是自加自减时间。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 11000,MAX = 1100000;\n\nint n,m,Q;\nint col[MAXN],re_col[MAXN],re_pos[MAXN],cnum = 1;\nint l = 0,r = 0,x = 0;\n\nint num[MAX],ans = 0;\n\nstruct Query{\n    int id,ql,qr,qx,ans;\n    //运算符重载\n    bool operator < (Query b)const{\n        if(ql/Q != b.ql/Q)\n            return ql/Q < b.ql/Q;\n        if(qr/Q != b.qr/Q) \n            return qr/Q < b.qr/Q;\n        return qx < b.qx;\n    }\n};\n\nbool cmp(Query a,Query b){\n    return a.id < b.id;\n}\n\nvector<Query> query;\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n*2);\n    for(int i = 1;i<=n;i++)\n        read(col[i]);\n    for(int i = 1;i<=m;i++){\n        char op[10];int a,b;\n        read(op);read(a),read(b);\n        if(op[0] == 'Q'){\n            Query w;w.ql = a,w.qr = b,w.qx = cnum-1;\n            w.id = i;query.push_back(w);\n        }\n        else if(op[0] == 'R'){\n            re_pos[cnum] = a,re_col[cnum] = b;\n            cnum++;\n        }\n    }\n    sort(query.begin(),query.end());\n}\n\n//加入第pos个数并更新答案\nvoid add(int pos){\n    if(num[col[pos]]++ == 0)\n        ans++;\n}\n\n//删去第pos个数并更新答案\nvoid del(int pos){\n    if(--num[col[pos]] == 0)\n        ans--;\n}\n\n//进行第times次修改\nvoid change(int times){\n    if(l<=re_pos[times]&& re_pos[times] <= r){\n        if(num[re_col[times]]++ == 0)\n            ans++;\n        if(--num[col[re_pos[times]]] == 0)\n            ans--;\n    }\n    swap(re_col[times],col[re_pos[times]]);\n}\n\nvoid solve(){\n    for(int i = 0;i<query.size();i++){\n        //莫队核心转移\n        Query w = query[i];\n        while(l > w.ql)  add(--l);\n        while(r < w.qr)  add(++r);\n        while(l < w.ql)  del(l++);\n        while(r > w.qr)  del(r--);\n        while(x < w.qx)  change(++x);\n        while(x > w.qx)  change(x--);\n        query[i].ans = ans;\n    }\n    sort(query.begin(),query.end(),cmp);\n    for(int i = 0;i<query.size();i++)\n        print(query[i].ans),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","source":"_posts/「国家集训队」数颜色-带修改莫队.md","raw":"---\ntitle: 「国家集训队」数颜色-带修改莫队\nurlname: count_color \ndate: 2018-03-31 12:21:42\ntags:\n- 题解\n- 莫队\ncategories: OI\nvisible:\n---\n\n\n墨墨购买了一套$N$支彩色画笔（其中有些颜色可能相同）。墨墨会向你发布如下指令：\n\n1. `Q L R`代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。\n\n2. `R P Col` 把第P支画笔替换为颜色$Col$。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P1903](https://www.luogu.org/problemnew/show/P1903)\n\n## 题解\n\n带修改的莫队裸题。思路可以去{% post_link 莫队算法学习笔记（一） 这篇文章 %}里看。\n\n主要需要注意的就是自加自减时间。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\nnamespace fast_io {\n    ...\n}using namespace fast_io;\n\nconst int MAXN = 11000,MAX = 1100000;\n\nint n,m,Q;\nint col[MAXN],re_col[MAXN],re_pos[MAXN],cnum = 1;\nint l = 0,r = 0,x = 0;\n\nint num[MAX],ans = 0;\n\nstruct Query{\n    int id,ql,qr,qx,ans;\n    //运算符重载\n    bool operator < (Query b)const{\n        if(ql/Q != b.ql/Q)\n            return ql/Q < b.ql/Q;\n        if(qr/Q != b.qr/Q) \n            return qr/Q < b.qr/Q;\n        return qx < b.qx;\n    }\n};\n\nbool cmp(Query a,Query b){\n    return a.id < b.id;\n}\n\nvector<Query> query;\n\nvoid init(){\n    read(n),read(m);Q = sqrt(n*2);\n    for(int i = 1;i<=n;i++)\n        read(col[i]);\n    for(int i = 1;i<=m;i++){\n        char op[10];int a,b;\n        read(op);read(a),read(b);\n        if(op[0] == 'Q'){\n            Query w;w.ql = a,w.qr = b,w.qx = cnum-1;\n            w.id = i;query.push_back(w);\n        }\n        else if(op[0] == 'R'){\n            re_pos[cnum] = a,re_col[cnum] = b;\n            cnum++;\n        }\n    }\n    sort(query.begin(),query.end());\n}\n\n//加入第pos个数并更新答案\nvoid add(int pos){\n    if(num[col[pos]]++ == 0)\n        ans++;\n}\n\n//删去第pos个数并更新答案\nvoid del(int pos){\n    if(--num[col[pos]] == 0)\n        ans--;\n}\n\n//进行第times次修改\nvoid change(int times){\n    if(l<=re_pos[times]&& re_pos[times] <= r){\n        if(num[re_col[times]]++ == 0)\n            ans++;\n        if(--num[col[re_pos[times]]] == 0)\n            ans--;\n    }\n    swap(re_col[times],col[re_pos[times]]);\n}\n\nvoid solve(){\n    for(int i = 0;i<query.size();i++){\n        //莫队核心转移\n        Query w = query[i];\n        while(l > w.ql)  add(--l);\n        while(r < w.qr)  add(++r);\n        while(l < w.ql)  del(l++);\n        while(r > w.qr)  del(r--);\n        while(x < w.qx)  change(++x);\n        while(x > w.qx)  change(x--);\n        query[i].ans = ans;\n    }\n    sort(query.begin(),query.end(),cmp);\n    for(int i = 0;i<query.size();i++)\n        print(query[i].ans),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}","slug":"「国家集训队」数颜色-带修改莫队","published":1,"updated":"2018-03-31T04:33:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3md005tbljrg2hgzfux","content":"<p>墨墨购买了一套$N$支彩色画笔（其中有些颜色可能相同）。墨墨会向你发布如下指令：</p>\n<ol>\n<li><p><code>Q L R</code>代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。</p>\n</li>\n<li><p><code>R P Col</code> 把第P支画笔替换为颜色$Col$。</p>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1903\" target=\"_blank\" rel=\"noopener\">Luogu P1903</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>带修改的莫队裸题。思路可以去<a href=\"/20180205-mo-algorithm-1/\" title=\"这篇文章\">这篇文章</a>里看。</p>\n<p>主要需要注意的就是自加自减时间。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">11000</span>,MAX = <span class=\"number\">1100000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,Q;</span><br><span class=\"line\"><span class=\"keyword\">int</span> col[MAXN],re_col[MAXN],re_pos[MAXN],cnum = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> l = <span class=\"number\">0</span>,r = <span class=\"number\">0</span>,x = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> num[MAX],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Query</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> id,ql,qr,qx,ans;</span><br><span class=\"line\">    <span class=\"comment\">//运算符重载</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (Query b)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ql/Q != b.ql/Q)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ql/Q &lt; b.ql/Q;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(qr/Q != b.qr/Q) </span><br><span class=\"line\">            <span class=\"keyword\">return</span> qr/Q &lt; b.qr/Q;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> qx &lt; b.qx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Query a,Query b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.id &lt; b.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;Query&gt; query;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);Q = <span class=\"built_in\">sqrt</span>(n*<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        read(col[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> op[<span class=\"number\">10</span>];<span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">        read(op);read(a),read(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'Q'</span>)&#123;</span><br><span class=\"line\">            Query w;w.ql = a,w.qr = b,w.qx = cnum<span class=\"number\">-1</span>;</span><br><span class=\"line\">            w.id = i;query.push_back(w);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op[<span class=\"number\">0</span>] == <span class=\"string\">'R'</span>)&#123;</span><br><span class=\"line\">            re_pos[cnum] = a,re_col[cnum] = b;</span><br><span class=\"line\">            cnum++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(query.begin(),query.end());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加入第pos个数并更新答案</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num[col[pos]]++ == <span class=\"number\">0</span>)</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删去第pos个数并更新答案</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(--num[col[pos]] == <span class=\"number\">0</span>)</span><br><span class=\"line\">        ans--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//进行第times次修改</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"keyword\">int</span> times)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(l&lt;=re_pos[times]&amp;&amp; re_pos[times] &lt;= r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[re_col[times]]++ == <span class=\"number\">0</span>)</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--num[col[re_pos[times]]] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            ans--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    swap(re_col[times],col[re_pos[times]]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;query.size();i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//莫队核心转移</span></span><br><span class=\"line\">        Query w = query[i];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &gt; w.ql)  add(--l);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &lt; w.qr)  add(++r);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; w.ql)  del(l++);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(r &gt; w.qr)  del(r--);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &lt; w.qx)  change(++x);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(x &gt; w.qx)  change(x--);</span><br><span class=\"line\">        query[i].ans = ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(query.begin(),query.end(),cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;query.size();i++)</span><br><span class=\"line\">        print(query[i].ans),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>","site":{"data":{}},"excerpt":"<p>墨墨购买了一套$N$支彩色画笔（其中有些颜色可能相同）。墨墨会向你发布如下指令：</p>\n<ol>\n<li><p><code>Q L R</code>代表询问你从第$L$支画笔到第$R$支画笔中共有几种不同颜色的画笔。</p>\n</li>\n<li><p><code>R P Col</code> 把第P支画笔替换为颜色$Col$。</p>\n</li>\n</ol>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P1903\" target=\"_blank\" rel=\"noopener\">Luogu P1903</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>带修改的莫队裸题。思路可以去<a href=\"/20180205-mo-algorithm-1/\" title=\"这篇文章\">这篇文章</a>里看。</p>\n<p>主要需要注意的就是自加自减时间。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�67-->\n\n</div></div>"},{"title":"「国家集训队」聪聪可可-点分治","urlname":"clever_and_cute","date":"2018-04-22T05:14:39.000Z","visible":null,"_content":"\n\n有一颗$n$（$n<20000$）个节点的树，每条边都有边权。接下来由聪聪和可可分别随即选一个点，如果两点之间简单路径上的边权和是$3$的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，希望知道对于这张图自己的获胜概率是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2634](https://www.luogu.org/problemnew/show/P2634)\n\n## 题解\n\n点分治比较模版的一道题吧。\n\n树上的路径问题，也可以提示我们点分治。\n\n所以问题转化为：怎么在$O(n)$或者$O(n \\log{n})$的时间内求出过一个点的所有，起点终点不在同一子树中，边权和为$3$的倍数的路径个数。\n\n事实上，我们发现，这个问题不难解决。如果只有经过一个点这个条件，那么就很简单：$dfs$一遍求出这个点到所有点的距离除$3$余数，然后$num[0] \\times num[0] + num[1] \\times num[2] + num[2] \\times num[1]$即为所求。\n\n比较难搞的是第二个条件，也就是我们要求这个路径的起点和终点不在一个子树内。我们可以考虑采用容斥原理。即对每一颗子树分别$dfs$求出$3$个$num'$，然后减去这个子树内过上面根节点的路径个数。这个个数我们上面好像已经求过了，事实上就是$num'[0] \\times num'[0] + num'[1] \\times num'[2] + num'[2] \\times num'[1]$。\n\n所以我们就可以$O(n)$的时间处理完这件事情了。再加上点分治，我们最终的复杂度就是$O(n \\log {n})$。\n\n有一些比较容易错的地方，比如要注意开始的时候$num[0]$要置做$1$，而$num'[0]$就不用。这是比较显然的，然而我还是错了好久...还有就是在加边的时候可以对$3$取模...后面也要不断对$3$取模...要不然会炸。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nll gcd(ll a,ll b){// a < b;\n    return a == 0?b:gcd(b%a,a);\n}\n\nconst int MAXN = 110000;\n\nstruct Edge{\n    int from,to;\n    int len,nex;\n}edge[MAXN];int ecnt = 2;\nint fir[MAXN];\nvoid addedge(int a,int b,int l){\n    edge[ecnt] = (Edge){a,b,l,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,l,fir[b]};\n    fir[b] = ecnt++;\n}\n//----\n\nint n,m;\nint f[MAXN],siz[MAXN],vis[MAXN];\nint rt,sz;\nint num[3],tmp[3];\nll ans = 0;\n\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]); \n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n\nvoid getdeep(int nown,int fa,int d){\n    num[d]++;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v] || v == fa) continue;\n        getdeep(v,nown,(d+l)%3);\n    }\n}\n\nvoid work(int nown){\n    tmp[0] = 1;tmp[1] = tmp[2] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v]) continue;\n        num[0] = num[1] = num[2] = 0;\n        getdeep(v,nown,l);\n        ans -= num[0]*num[0] + 2*num[1]*num[2];\n        tmp[0] += num[0],tmp[1]+=num[1],tmp[2]+=num[2];\n    }\n    ans += tmp[0] * tmp[0] + 2*tmp[1] * tmp[2];\n}\n\nvoid solve(int nown){\n    vis[nown] = 1;\n    work(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];\n        getroot(v,rt);\n        solve(rt);\n    }\n}\n\nvoid init(){\n    scanf(\"%d\",&n);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        scanf(\"%d %d %d\",&a,&b,&c);\n        addedge(a,b,c%3);\n    }\n}\n\nvoid solve(){\n    f[rt = 0] = sz = n;\n    getroot(1,rt);\n    solve(rt);\n    ll ans2 = n*n;\n    printf(\"%lld/%lld\\n\",ans/gcd(ans,ans2),ans2/gcd(ans,ans2));\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}\n\n","source":"_posts/「国家集训队」聪聪可可-点分治.md","raw":"---\ntitle: 「国家集训队」聪聪可可-点分治\nurlname: clever_and_cute\ndate: 2018-04-22 13:14:39\ntags:\n- 点分治\n- 题解\ncategories: OI\nvisible:\n---\n\n\n有一颗$n$（$n<20000$）个节点的树，每条边都有边权。接下来由聪聪和可可分别随即选一个点，如果两点之间简单路径上的边权和是$3$的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，希望知道对于这张图自己的获胜概率是多少。\n\n<!-- more -->\n\n## 链接\n\n[Luogu P2634](https://www.luogu.org/problemnew/show/P2634)\n\n## 题解\n\n点分治比较模版的一道题吧。\n\n树上的路径问题，也可以提示我们点分治。\n\n所以问题转化为：怎么在$O(n)$或者$O(n \\log{n})$的时间内求出过一个点的所有，起点终点不在同一子树中，边权和为$3$的倍数的路径个数。\n\n事实上，我们发现，这个问题不难解决。如果只有经过一个点这个条件，那么就很简单：$dfs$一遍求出这个点到所有点的距离除$3$余数，然后$num[0] \\times num[0] + num[1] \\times num[2] + num[2] \\times num[1]$即为所求。\n\n比较难搞的是第二个条件，也就是我们要求这个路径的起点和终点不在一个子树内。我们可以考虑采用容斥原理。即对每一颗子树分别$dfs$求出$3$个$num'$，然后减去这个子树内过上面根节点的路径个数。这个个数我们上面好像已经求过了，事实上就是$num'[0] \\times num'[0] + num'[1] \\times num'[2] + num'[2] \\times num'[1]$。\n\n所以我们就可以$O(n)$的时间处理完这件事情了。再加上点分治，我们最终的复杂度就是$O(n \\log {n})$。\n\n有一些比较容易错的地方，比如要注意开始的时候$num[0]$要置做$1$，而$num'[0]$就不用。这是比较显然的，然而我还是错了好久...还有就是在加边的时候可以对$3$取模...后面也要不断对$3$取模...要不然会炸。\n\n## 代码\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nll gcd(ll a,ll b){// a < b;\n    return a == 0?b:gcd(b%a,a);\n}\n\nconst int MAXN = 110000;\n\nstruct Edge{\n    int from,to;\n    int len,nex;\n}edge[MAXN];int ecnt = 2;\nint fir[MAXN];\nvoid addedge(int a,int b,int l){\n    edge[ecnt] = (Edge){a,b,l,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,l,fir[b]};\n    fir[b] = ecnt++;\n}\n//----\n\nint n,m;\nint f[MAXN],siz[MAXN],vis[MAXN];\nint rt,sz;\nint num[3],tmp[3];\nll ans = 0;\n\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]); \n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n\nvoid getdeep(int nown,int fa,int d){\n    num[d]++;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v] || v == fa) continue;\n        getdeep(v,nown,(d+l)%3);\n    }\n}\n\nvoid work(int nown){\n    tmp[0] = 1;tmp[1] = tmp[2] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v]) continue;\n        num[0] = num[1] = num[2] = 0;\n        getdeep(v,nown,l);\n        ans -= num[0]*num[0] + 2*num[1]*num[2];\n        tmp[0] += num[0],tmp[1]+=num[1],tmp[2]+=num[2];\n    }\n    ans += tmp[0] * tmp[0] + 2*tmp[1] * tmp[2];\n}\n\nvoid solve(int nown){\n    vis[nown] = 1;\n    work(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];\n        getroot(v,rt);\n        solve(rt);\n    }\n}\n\nvoid init(){\n    scanf(\"%d\",&n);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        scanf(\"%d %d %d\",&a,&b,&c);\n        addedge(a,b,c%3);\n    }\n}\n\nvoid solve(){\n    f[rt = 0] = sz = n;\n    getroot(1,rt);\n    solve(rt);\n    ll ans2 = n*n;\n    printf(\"%lld/%lld\\n\",ans/gcd(ans,ans2),ans2/gcd(ans,ans2));\n}\n\nint main(){\n    init();\n    solve();\n    return 0;\n}\n```\n\n{% endfold %}\n\n","slug":"「国家集训队」聪聪可可-点分治","published":1,"updated":"2018-05-05T14:50:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mf005ubljrjfz8av6i","content":"<p>有一颗$n$（$n&lt;20000$）个节点的树，每条边都有边权。接下来由聪聪和可可分别随即选一个点，如果两点之间简单路径上的边权和是$3$的倍数，则判聪聪赢，否则可可赢。</p>\n<p>聪聪非常爱思考问题，希望知道对于这张图自己的获胜概率是多少。</p>\n<a id=\"more\"></a>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2634\" target=\"_blank\" rel=\"noopener\">Luogu P2634</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>点分治比较模版的一道题吧。</p>\n<p>树上的路径问题，也可以提示我们点分治。</p>\n<p>所以问题转化为：怎么在$O(n)$或者$O(n \\log{n})$的时间内求出过一个点的所有，起点终点不在同一子树中，边权和为$3$的倍数的路径个数。</p>\n<p>事实上，我们发现，这个问题不难解决。如果只有经过一个点这个条件，那么就很简单：$dfs$一遍求出这个点到所有点的距离除$3$余数，然后$num[0] \\times num[0] + num[1] \\times num[2] + num[2] \\times num[1]$即为所求。</p>\n<p>比较难搞的是第二个条件，也就是我们要求这个路径的起点和终点不在一个子树内。我们可以考虑采用容斥原理。即对每一颗子树分别$dfs$求出$3$个$num’$，然后减去这个子树内过上面根节点的路径个数。这个个数我们上面好像已经求过了，事实上就是$num’[0] \\times num’[0] + num’[1] \\times num’[2] + num’[2] \\times num’[1]$。</p>\n<p>所以我们就可以$O(n)$的时间处理完这件事情了。再加上点分治，我们最终的复杂度就是$O(n \\log {n})$。</p>\n<p>有一些比较容易错的地方，比如要注意开始的时候$num[0]$要置做$1$，而$num’[0]$就不用。这是比较显然的，然而我还是错了好久…还有就是在加边的时候可以对$3$取模…后面也要不断对$3$取模…要不然会炸。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">gcd</span><span class=\"params\">(ll a,ll b)</span></span>&#123;<span class=\"comment\">// a &lt; b;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a == <span class=\"number\">0</span>?b:gcd(b%a,a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len,nex;</span><br><span class=\"line\">&#125;edge[MAXN];<span class=\"keyword\">int</span> ecnt = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> fir[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> l)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;a,b,l,fir[a]&#125;;</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;b,a,l,fir[b]&#125;;</span><br><span class=\"line\">    fir[b] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//----</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAXN],siz[MAXN],vis[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> rt,sz;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num[<span class=\"number\">3</span>],tmp[<span class=\"number\">3</span>];</span><br><span class=\"line\">ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getroot</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,f[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v] || v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        getroot(v,nown);</span><br><span class=\"line\">        siz[nown] += siz[v];</span><br><span class=\"line\">        f[nown] = max(f[nown],siz[v]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[nown] = max(f[nown],sz - siz[nown]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[nown] &lt; f[rt]) rt = nown;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getdeep</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    num[d]++;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to,l = edge[nowe].len;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v] || v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        getdeep(v,nown,(d+l)%<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    tmp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;tmp[<span class=\"number\">1</span>] = tmp[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to,l = edge[nowe].len;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        num[<span class=\"number\">0</span>] = num[<span class=\"number\">1</span>] = num[<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        getdeep(v,nown,l);</span><br><span class=\"line\">        ans -= num[<span class=\"number\">0</span>]*num[<span class=\"number\">0</span>] + <span class=\"number\">2</span>*num[<span class=\"number\">1</span>]*num[<span class=\"number\">2</span>];</span><br><span class=\"line\">        tmp[<span class=\"number\">0</span>] += num[<span class=\"number\">0</span>],tmp[<span class=\"number\">1</span>]+=num[<span class=\"number\">1</span>],tmp[<span class=\"number\">2</span>]+=num[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans += tmp[<span class=\"number\">0</span>] * tmp[<span class=\"number\">0</span>] + <span class=\"number\">2</span>*tmp[<span class=\"number\">1</span>] * tmp[<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    vis[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    work(nown);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        f[rt = <span class=\"number\">0</span>] = sz = siz[v];</span><br><span class=\"line\">        getroot(v,rt);</span><br><span class=\"line\">        solve(rt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d %d %d\"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class=\"line\">        addedge(a,b,c%<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    f[rt = <span class=\"number\">0</span>] = sz = n;</span><br><span class=\"line\">    getroot(<span class=\"number\">1</span>,rt);</span><br><span class=\"line\">    solve(rt);</span><br><span class=\"line\">    ll ans2 = n*n;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lld/%lld\\n\"</span>,ans/gcd(ans,ans2),ans2/gcd(ans,ans2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>有一颗$n$（$n&lt;20000$）个节点的树，每条边都有边权。接下来由聪聪和可可分别随即选一个点，如果两点之间简单路径上的边权和是$3$的倍数，则判聪聪赢，否则可可赢。</p>\n<p>聪聪非常爱思考问题，希望知道对于这张图自己的获胜概率是多少。</p>","more":"<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.luogu.org/problemnew/show/P2634\" target=\"_blank\" rel=\"noopener\">Luogu P2634</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>点分治比较模版的一道题吧。</p>\n<p>树上的路径问题，也可以提示我们点分治。</p>\n<p>所以问题转化为：怎么在$O(n)$或者$O(n \\log{n})$的时间内求出过一个点的所有，起点终点不在同一子树中，边权和为$3$的倍数的路径个数。</p>\n<p>事实上，我们发现，这个问题不难解决。如果只有经过一个点这个条件，那么就很简单：$dfs$一遍求出这个点到所有点的距离除$3$余数，然后$num[0] \\times num[0] + num[1] \\times num[2] + num[2] \\times num[1]$即为所求。</p>\n<p>比较难搞的是第二个条件，也就是我们要求这个路径的起点和终点不在一个子树内。我们可以考虑采用容斥原理。即对每一颗子树分别$dfs$求出$3$个$num’$，然后减去这个子树内过上面根节点的路径个数。这个个数我们上面好像已经求过了，事实上就是$num’[0] \\times num’[0] + num’[1] \\times num’[2] + num’[2] \\times num’[1]$。</p>\n<p>所以我们就可以$O(n)$的时间处理完这件事情了。再加上点分治，我们最终的复杂度就是$O(n \\log {n})$。</p>\n<p>有一些比较容易错的地方，比如要注意开始的时候$num[0]$要置做$1$，而$num’[0]$就不用。这是比较显然的，然而我还是错了好久…还有就是在加边的时候可以对$3$取模…后面也要不断对$3$取模…要不然会炸。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�68-->\n\n</div></div>"},{"title":"「摘录」青春设计师-年级范文","urlname":"youth-designer","date":"2018-06-03T13:23:05.000Z","visible":null,"_content":"\n青春真的是一个非常空泛而又令人迷茫的词汇。\n\n<!-- more -->\n\n## 青春设计师\n\n> *文章来自我校年级范文。*\n\n我是一名新晋的青春设计师，为人们设计平行宇宙中另一个自己的青春。等他们到了那里，就能过上自己想要的生活。\n\n网站提示音一响。第一单！我激动的打开信息单：要求栏只写着两个字：完美。\n\n完美的青春是什么样子？我开始构想。\n\n他要生活在温馨的家庭，父亲要严格而不失幽默，为他树立生活中的权威和条框。母亲要慈善贤惠，让他感到世界的温度与和善。他要和父母保持良好的关系。他要在亲子的对话中了解这个世界真实的样子，并学会为人处事的方法，从而形成健全的心理和独立的人格......当我看着自己的设定十分满意时，心中却出现了别的声音：用自己的血肉触碰世界的条框，用自己的方式理解世界，不正是青春的意义吗？我陷入了迷茫，点击了“暂存”。\n\n他要擅长一项体育运动，并从中结交一群朋友，都说“无运动，不青春”，球场上矫健的身影才是青春该有的样子。这是他在青春岁月里竭尽全力的方式。他为了目标——进球得分，挥汗如雨，拼尽全力。结束的哨声即将响起，他第一次体会何谓放手一搏。肌肉的力量，意志的坚定，再加上一点运气，球进！场外女孩子的尖叫划破天空，如赞歌般充斥着他的双耳。他双眼模糊，倒在兄弟的手臂上。那是他第一次站上世界之巅。他尝到了自信和成功的味道...我一遍遍为这美妙的体验鼓掌，而多疑的神经又占据了脑海：在青春年华，我们也会经常犯错啊！但正是在青春时期的不断跌倒和再次爬起，铸就了我们心智的成熟和未来成功的基石。谬赞的浪潮使人膨胀，而膨胀和自负恰是成熟的杀手。他的青春该如何描绘？接连不断的成功，还是令人沮丧的失败？我再次按下“暂存”。\n\n他要在青春年华初尝爱情的甜蜜。从见到那个女孩的第一面起，他的目光就再没离开过她。他对她并无半点杂念，单纯的注视就已经能让他感到幸福。她的一颦一笑，一举一动是那么纯真，澄澈。她就是天使。那个炎热的下午，他用了一节课的时间，终于在桌子下面牵到了她的手。他呆呆地盯着桌上树叶交错斑驳的影子，半个身子都涌上热流。之后的日子里，他们的甜蜜一如初见。二人心有灵犀，琴瑟和鸣，无不羡煞旁人。\n\n我审视这纯粹而完美的爱情，恍惚间像看到一场青春的大梦。激烈的争吵和内心的大雨滂沱何不是青春花园的一部分？争端和误解正是启蒙，带我们走进异性的世界。在人生的雨季，我们修炼爱情，不断成长，不正是青春的幸福吗？两个青春的爱情怎样才算是完美，我有些茫然。\n\n呆坐在电脑前，浏览着刚刚写下的文字，无论怎么修改，我总觉得距离“完美”还差了一点。我盯着要求栏里的“完美”两字，从午后盯到黄昏，甚至拿出放大镜，想通过透镜看出什么来。良久，我终于看出了两个字：\n\n> “遗憾”。\n\n我明白了。\n\n成长即破碎，青春终有遗憾。\n\n我快速的找到“个人履历”一栏，复制，粘贴，发送。\n\n之后，我关掉了网站，再不设计青春。\n\n> *文章来自我校年级范文。如果作者同学对于我擅自的发表有任何意见，我会将文章立刻撤下。*\n\n## 青春\n\n> 以下是我随便乱写的\n\n或许青春永远都不存在所谓“完美”。\n\n我曾经思考过我的过去、现在和未来。\n\n- - -\n\n我的过去，何时回忆起来也不免欢欣。\n\n我的家长，对于我的管教应该说还算是比较严格，小学每天八点半都要上床睡觉，即使到了中考前夕，九点半点之前也必须要在床上躺着。这的确对我有极大的帮助。如果说到学校，其实我对于小学的记忆已经渐渐模糊了，甚至连在哪里上的课都不太记得。但我恐怕一辈子也不能忘记，在那里懵懵懂懂的成长的时光。在那个最纯真的时候，我收获的不止几段最为美丽的友情，更有许多的成长。小的时候每天都坐班车，虽然没有什么人愿意跟我说话，但我也因此在车上读了许多许多的书。或许我现在对人生的许多看法，也是在那几年的班车上获得的。初中，在我当时看来，可以说是侥幸混到了本区最好的初中吧。同学都是很棒的一些人。有的人擅长学习，在学习上给了我许多的帮助；有的人思想深邃，教会我去如何更好的理解这个世界。相对于小学，我倒是更认为初中的老师让我成长更多。无论如何，我的初中生活很快也就结束了。一个懵懂的孩童终于长成一个少年，当然要归功于我亲爱的老师和同学们，还有我的家长。\n\n- - -\n\n我的现在，是一个近乎完美的现在。\n\n不负众望的，我考进了本校的高中。一个三年，接下来的又是一个三年。小学的六年，并没有给我留下什么印象；而中学的六年，则会是人生中不可磨灭的一部分。同学自然十分优秀，老师也是非常有才华，我现在所拥有的一切恐怕是以前连梦都不敢梦的所有。一切一切，都让我一直认为，我的现在，已经是最好的现在了。\n\n- - -\n\n我的未来，大约也会是令人向往的远方。\n\n我所拥有的一切，都在激励着我继续前行。我有负责的家人，给我的奋斗最大的支持；我有热爱的事业，并且我在这上面也获得了无可比拟的成就感；我有深深爱着的人，无论何时都会给我我安慰与鼓励；我有负责任的老师，会给我在学业上一切可能的帮助；我有一群可爱的同学，始终让我在每天放学都能带着微笑回家，不论生活的繁忙与否；而我现在所取得的一切，也告诉我：未来充满着希望。人生中最美好的事情或许也就莫过于，每一天都是怀揣着希望而前行吧。\n\n- - -\n\n当时看到这篇范文，突然就想到了自己。感谢我生命里遇到的所有人，不论是到现在已经相忘，还是依旧相随而行；不论我们之间是至今不渝的友情，还是无法弥补的伤痕，感谢你们让我完全地成长，让我拥有这么一个完美的青春。\n\n鲁迅也说过：“使精神的丝缕还牵着已逝的寂寞的时光，又有什么意义呢。”\n\n虽说青春终有遗憾，但如果这一切都是你爱的人和爱你的人一起为你写就，那么是否遗憾，或许也不那么重要。\n\n你说呢。<!-- 手动 @ 某人 -->\n\n这篇文章写的匆忙，来不及细细打磨，如果有文意疏漏之处，在所难免，请观者原谅。\n","source":"_posts/「摘录」青春设计师-年级范文.md","raw":"---\ntitle: 「摘录」青春设计师-年级范文\nurlname: youth-designer\ndate: 2018-06-03 21:23:05\ntags:\n- 摘录\n- 作文\ncategories: 随笔\nvisible:\n---\n\n青春真的是一个非常空泛而又令人迷茫的词汇。\n\n<!-- more -->\n\n## 青春设计师\n\n> *文章来自我校年级范文。*\n\n我是一名新晋的青春设计师，为人们设计平行宇宙中另一个自己的青春。等他们到了那里，就能过上自己想要的生活。\n\n网站提示音一响。第一单！我激动的打开信息单：要求栏只写着两个字：完美。\n\n完美的青春是什么样子？我开始构想。\n\n他要生活在温馨的家庭，父亲要严格而不失幽默，为他树立生活中的权威和条框。母亲要慈善贤惠，让他感到世界的温度与和善。他要和父母保持良好的关系。他要在亲子的对话中了解这个世界真实的样子，并学会为人处事的方法，从而形成健全的心理和独立的人格......当我看着自己的设定十分满意时，心中却出现了别的声音：用自己的血肉触碰世界的条框，用自己的方式理解世界，不正是青春的意义吗？我陷入了迷茫，点击了“暂存”。\n\n他要擅长一项体育运动，并从中结交一群朋友，都说“无运动，不青春”，球场上矫健的身影才是青春该有的样子。这是他在青春岁月里竭尽全力的方式。他为了目标——进球得分，挥汗如雨，拼尽全力。结束的哨声即将响起，他第一次体会何谓放手一搏。肌肉的力量，意志的坚定，再加上一点运气，球进！场外女孩子的尖叫划破天空，如赞歌般充斥着他的双耳。他双眼模糊，倒在兄弟的手臂上。那是他第一次站上世界之巅。他尝到了自信和成功的味道...我一遍遍为这美妙的体验鼓掌，而多疑的神经又占据了脑海：在青春年华，我们也会经常犯错啊！但正是在青春时期的不断跌倒和再次爬起，铸就了我们心智的成熟和未来成功的基石。谬赞的浪潮使人膨胀，而膨胀和自负恰是成熟的杀手。他的青春该如何描绘？接连不断的成功，还是令人沮丧的失败？我再次按下“暂存”。\n\n他要在青春年华初尝爱情的甜蜜。从见到那个女孩的第一面起，他的目光就再没离开过她。他对她并无半点杂念，单纯的注视就已经能让他感到幸福。她的一颦一笑，一举一动是那么纯真，澄澈。她就是天使。那个炎热的下午，他用了一节课的时间，终于在桌子下面牵到了她的手。他呆呆地盯着桌上树叶交错斑驳的影子，半个身子都涌上热流。之后的日子里，他们的甜蜜一如初见。二人心有灵犀，琴瑟和鸣，无不羡煞旁人。\n\n我审视这纯粹而完美的爱情，恍惚间像看到一场青春的大梦。激烈的争吵和内心的大雨滂沱何不是青春花园的一部分？争端和误解正是启蒙，带我们走进异性的世界。在人生的雨季，我们修炼爱情，不断成长，不正是青春的幸福吗？两个青春的爱情怎样才算是完美，我有些茫然。\n\n呆坐在电脑前，浏览着刚刚写下的文字，无论怎么修改，我总觉得距离“完美”还差了一点。我盯着要求栏里的“完美”两字，从午后盯到黄昏，甚至拿出放大镜，想通过透镜看出什么来。良久，我终于看出了两个字：\n\n> “遗憾”。\n\n我明白了。\n\n成长即破碎，青春终有遗憾。\n\n我快速的找到“个人履历”一栏，复制，粘贴，发送。\n\n之后，我关掉了网站，再不设计青春。\n\n> *文章来自我校年级范文。如果作者同学对于我擅自的发表有任何意见，我会将文章立刻撤下。*\n\n## 青春\n\n> 以下是我随便乱写的\n\n或许青春永远都不存在所谓“完美”。\n\n我曾经思考过我的过去、现在和未来。\n\n- - -\n\n我的过去，何时回忆起来也不免欢欣。\n\n我的家长，对于我的管教应该说还算是比较严格，小学每天八点半都要上床睡觉，即使到了中考前夕，九点半点之前也必须要在床上躺着。这的确对我有极大的帮助。如果说到学校，其实我对于小学的记忆已经渐渐模糊了，甚至连在哪里上的课都不太记得。但我恐怕一辈子也不能忘记，在那里懵懵懂懂的成长的时光。在那个最纯真的时候，我收获的不止几段最为美丽的友情，更有许多的成长。小的时候每天都坐班车，虽然没有什么人愿意跟我说话，但我也因此在车上读了许多许多的书。或许我现在对人生的许多看法，也是在那几年的班车上获得的。初中，在我当时看来，可以说是侥幸混到了本区最好的初中吧。同学都是很棒的一些人。有的人擅长学习，在学习上给了我许多的帮助；有的人思想深邃，教会我去如何更好的理解这个世界。相对于小学，我倒是更认为初中的老师让我成长更多。无论如何，我的初中生活很快也就结束了。一个懵懂的孩童终于长成一个少年，当然要归功于我亲爱的老师和同学们，还有我的家长。\n\n- - -\n\n我的现在，是一个近乎完美的现在。\n\n不负众望的，我考进了本校的高中。一个三年，接下来的又是一个三年。小学的六年，并没有给我留下什么印象；而中学的六年，则会是人生中不可磨灭的一部分。同学自然十分优秀，老师也是非常有才华，我现在所拥有的一切恐怕是以前连梦都不敢梦的所有。一切一切，都让我一直认为，我的现在，已经是最好的现在了。\n\n- - -\n\n我的未来，大约也会是令人向往的远方。\n\n我所拥有的一切，都在激励着我继续前行。我有负责的家人，给我的奋斗最大的支持；我有热爱的事业，并且我在这上面也获得了无可比拟的成就感；我有深深爱着的人，无论何时都会给我我安慰与鼓励；我有负责任的老师，会给我在学业上一切可能的帮助；我有一群可爱的同学，始终让我在每天放学都能带着微笑回家，不论生活的繁忙与否；而我现在所取得的一切，也告诉我：未来充满着希望。人生中最美好的事情或许也就莫过于，每一天都是怀揣着希望而前行吧。\n\n- - -\n\n当时看到这篇范文，突然就想到了自己。感谢我生命里遇到的所有人，不论是到现在已经相忘，还是依旧相随而行；不论我们之间是至今不渝的友情，还是无法弥补的伤痕，感谢你们让我完全地成长，让我拥有这么一个完美的青春。\n\n鲁迅也说过：“使精神的丝缕还牵着已逝的寂寞的时光，又有什么意义呢。”\n\n虽说青春终有遗憾，但如果这一切都是你爱的人和爱你的人一起为你写就，那么是否遗憾，或许也不那么重要。\n\n你说呢。<!-- 手动 @ 某人 -->\n\n这篇文章写的匆忙，来不及细细打磨，如果有文意疏漏之处，在所难免，请观者原谅。\n","slug":"「摘录」青春设计师-年级范文","published":1,"updated":"2018-06-03T14:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mi005xbljrjcs0hav9","content":"<p>青春真的是一个非常空泛而又令人迷茫的词汇。</p>\n<a id=\"more\"></a>\n<h2 id=\"青春设计师\"><a href=\"#青春设计师\" class=\"headerlink\" title=\"青春设计师\"></a>青春设计师</h2><blockquote>\n<p><em>文章来自我校年级范文。</em></p>\n</blockquote>\n<p>我是一名新晋的青春设计师，为人们设计平行宇宙中另一个自己的青春。等他们到了那里，就能过上自己想要的生活。</p>\n<p>网站提示音一响。第一单！我激动的打开信息单：要求栏只写着两个字：完美。</p>\n<p>完美的青春是什么样子？我开始构想。</p>\n<p>他要生活在温馨的家庭，父亲要严格而不失幽默，为他树立生活中的权威和条框。母亲要慈善贤惠，让他感到世界的温度与和善。他要和父母保持良好的关系。他要在亲子的对话中了解这个世界真实的样子，并学会为人处事的方法，从而形成健全的心理和独立的人格……当我看着自己的设定十分满意时，心中却出现了别的声音：用自己的血肉触碰世界的条框，用自己的方式理解世界，不正是青春的意义吗？我陷入了迷茫，点击了“暂存”。</p>\n<p>他要擅长一项体育运动，并从中结交一群朋友，都说“无运动，不青春”，球场上矫健的身影才是青春该有的样子。这是他在青春岁月里竭尽全力的方式。他为了目标——进球得分，挥汗如雨，拼尽全力。结束的哨声即将响起，他第一次体会何谓放手一搏。肌肉的力量，意志的坚定，再加上一点运气，球进！场外女孩子的尖叫划破天空，如赞歌般充斥着他的双耳。他双眼模糊，倒在兄弟的手臂上。那是他第一次站上世界之巅。他尝到了自信和成功的味道…我一遍遍为这美妙的体验鼓掌，而多疑的神经又占据了脑海：在青春年华，我们也会经常犯错啊！但正是在青春时期的不断跌倒和再次爬起，铸就了我们心智的成熟和未来成功的基石。谬赞的浪潮使人膨胀，而膨胀和自负恰是成熟的杀手。他的青春该如何描绘？接连不断的成功，还是令人沮丧的失败？我再次按下“暂存”。</p>\n<p>他要在青春年华初尝爱情的甜蜜。从见到那个女孩的第一面起，他的目光就再没离开过她。他对她并无半点杂念，单纯的注视就已经能让他感到幸福。她的一颦一笑，一举一动是那么纯真，澄澈。她就是天使。那个炎热的下午，他用了一节课的时间，终于在桌子下面牵到了她的手。他呆呆地盯着桌上树叶交错斑驳的影子，半个身子都涌上热流。之后的日子里，他们的甜蜜一如初见。二人心有灵犀，琴瑟和鸣，无不羡煞旁人。</p>\n<p>我审视这纯粹而完美的爱情，恍惚间像看到一场青春的大梦。激烈的争吵和内心的大雨滂沱何不是青春花园的一部分？争端和误解正是启蒙，带我们走进异性的世界。在人生的雨季，我们修炼爱情，不断成长，不正是青春的幸福吗？两个青春的爱情怎样才算是完美，我有些茫然。</p>\n<p>呆坐在电脑前，浏览着刚刚写下的文字，无论怎么修改，我总觉得距离“完美”还差了一点。我盯着要求栏里的“完美”两字，从午后盯到黄昏，甚至拿出放大镜，想通过透镜看出什么来。良久，我终于看出了两个字：</p>\n<blockquote>\n<p>“遗憾”。</p>\n</blockquote>\n<p>我明白了。</p>\n<p>成长即破碎，青春终有遗憾。</p>\n<p>我快速的找到“个人履历”一栏，复制，粘贴，发送。</p>\n<p>之后，我关掉了网站，再不设计青春。</p>\n<blockquote>\n<p><em>文章来自我校年级范文。如果作者同学对于我擅自的发表有任何意见，我会将文章立刻撤下。</em></p>\n</blockquote>\n<h2 id=\"青春\"><a href=\"#青春\" class=\"headerlink\" title=\"青春\"></a>青春</h2><blockquote>\n<p>以下是我随便乱写的</p>\n</blockquote>\n<p>或许青春永远都不存在所谓“完美”。</p>\n<p>我曾经思考过我的过去、现在和未来。</p>\n<hr>\n<p>我的过去，何时回忆起来也不免欢欣。</p>\n<p>我的家长，对于我的管教应该说还算是比较严格，小学每天八点半都要上床睡觉，即使到了中考前夕，九点半点之前也必须要在床上躺着。这的确对我有极大的帮助。如果说到学校，其实我对于小学的记忆已经渐渐模糊了，甚至连在哪里上的课都不太记得。但我恐怕一辈子也不能忘记，在那里懵懵懂懂的成长的时光。在那个最纯真的时候，我收获的不止几段最为美丽的友情，更有许多的成长。小的时候每天都坐班车，虽然没有什么人愿意跟我说话，但我也因此在车上读了许多许多的书。或许我现在对人生的许多看法，也是在那几年的班车上获得的。初中，在我当时看来，可以说是侥幸混到了本区最好的初中吧。同学都是很棒的一些人。有的人擅长学习，在学习上给了我许多的帮助；有的人思想深邃，教会我去如何更好的理解这个世界。相对于小学，我倒是更认为初中的老师让我成长更多。无论如何，我的初中生活很快也就结束了。一个懵懂的孩童终于长成一个少年，当然要归功于我亲爱的老师和同学们，还有我的家长。</p>\n<hr>\n<p>我的现在，是一个近乎完美的现在。</p>\n<p>不负众望的，我考进了本校的高中。一个三年，接下来的又是一个三年。小学的六年，并没有给我留下什么印象；而中学的六年，则会是人生中不可磨灭的一部分。同学自然十分优秀，老师也是非常有才华，我现在所拥有的一切恐怕是以前连梦都不敢梦的所有。一切一切，都让我一直认为，我的现在，已经是最好的现在了。</p>\n<hr>\n<p>我的未来，大约也会是令人向往的远方。</p>\n<p>我所拥有的一切，都在激励着我继续前行。我有负责的家人，给我的奋斗最大的支持；我有热爱的事业，并且我在这上面也获得了无可比拟的成就感；我有深深爱着的人，无论何时都会给我我安慰与鼓励；我有负责任的老师，会给我在学业上一切可能的帮助；我有一群可爱的同学，始终让我在每天放学都能带着微笑回家，不论生活的繁忙与否；而我现在所取得的一切，也告诉我：未来充满着希望。人生中最美好的事情或许也就莫过于，每一天都是怀揣着希望而前行吧。</p>\n<hr>\n<p>当时看到这篇范文，突然就想到了自己。感谢我生命里遇到的所有人，不论是到现在已经相忘，还是依旧相随而行；不论我们之间是至今不渝的友情，还是无法弥补的伤痕，感谢你们让我完全地成长，让我拥有这么一个完美的青春。</p>\n<p>鲁迅也说过：“使精神的丝缕还牵着已逝的寂寞的时光，又有什么意义呢。”</p>\n<p>虽说青春终有遗憾，但如果这一切都是你爱的人和爱你的人一起为你写就，那么是否遗憾，或许也不那么重要。</p>\n<p>你说呢。<!-- 手动 @ 某人 --></p>\n<p>这篇文章写的匆忙，来不及细细打磨，如果有文意疏漏之处，在所难免，请观者原谅。</p>\n","site":{"data":{}},"excerpt":"<p>青春真的是一个非常空泛而又令人迷茫的词汇。</p>","more":"<h2 id=\"青春设计师\"><a href=\"#青春设计师\" class=\"headerlink\" title=\"青春设计师\"></a>青春设计师</h2><blockquote>\n<p><em>文章来自我校年级范文。</em></p>\n</blockquote>\n<p>我是一名新晋的青春设计师，为人们设计平行宇宙中另一个自己的青春。等他们到了那里，就能过上自己想要的生活。</p>\n<p>网站提示音一响。第一单！我激动的打开信息单：要求栏只写着两个字：完美。</p>\n<p>完美的青春是什么样子？我开始构想。</p>\n<p>他要生活在温馨的家庭，父亲要严格而不失幽默，为他树立生活中的权威和条框。母亲要慈善贤惠，让他感到世界的温度与和善。他要和父母保持良好的关系。他要在亲子的对话中了解这个世界真实的样子，并学会为人处事的方法，从而形成健全的心理和独立的人格……当我看着自己的设定十分满意时，心中却出现了别的声音：用自己的血肉触碰世界的条框，用自己的方式理解世界，不正是青春的意义吗？我陷入了迷茫，点击了“暂存”。</p>\n<p>他要擅长一项体育运动，并从中结交一群朋友，都说“无运动，不青春”，球场上矫健的身影才是青春该有的样子。这是他在青春岁月里竭尽全力的方式。他为了目标——进球得分，挥汗如雨，拼尽全力。结束的哨声即将响起，他第一次体会何谓放手一搏。肌肉的力量，意志的坚定，再加上一点运气，球进！场外女孩子的尖叫划破天空，如赞歌般充斥着他的双耳。他双眼模糊，倒在兄弟的手臂上。那是他第一次站上世界之巅。他尝到了自信和成功的味道…我一遍遍为这美妙的体验鼓掌，而多疑的神经又占据了脑海：在青春年华，我们也会经常犯错啊！但正是在青春时期的不断跌倒和再次爬起，铸就了我们心智的成熟和未来成功的基石。谬赞的浪潮使人膨胀，而膨胀和自负恰是成熟的杀手。他的青春该如何描绘？接连不断的成功，还是令人沮丧的失败？我再次按下“暂存”。</p>\n<p>他要在青春年华初尝爱情的甜蜜。从见到那个女孩的第一面起，他的目光就再没离开过她。他对她并无半点杂念，单纯的注视就已经能让他感到幸福。她的一颦一笑，一举一动是那么纯真，澄澈。她就是天使。那个炎热的下午，他用了一节课的时间，终于在桌子下面牵到了她的手。他呆呆地盯着桌上树叶交错斑驳的影子，半个身子都涌上热流。之后的日子里，他们的甜蜜一如初见。二人心有灵犀，琴瑟和鸣，无不羡煞旁人。</p>\n<p>我审视这纯粹而完美的爱情，恍惚间像看到一场青春的大梦。激烈的争吵和内心的大雨滂沱何不是青春花园的一部分？争端和误解正是启蒙，带我们走进异性的世界。在人生的雨季，我们修炼爱情，不断成长，不正是青春的幸福吗？两个青春的爱情怎样才算是完美，我有些茫然。</p>\n<p>呆坐在电脑前，浏览着刚刚写下的文字，无论怎么修改，我总觉得距离“完美”还差了一点。我盯着要求栏里的“完美”两字，从午后盯到黄昏，甚至拿出放大镜，想通过透镜看出什么来。良久，我终于看出了两个字：</p>\n<blockquote>\n<p>“遗憾”。</p>\n</blockquote>\n<p>我明白了。</p>\n<p>成长即破碎，青春终有遗憾。</p>\n<p>我快速的找到“个人履历”一栏，复制，粘贴，发送。</p>\n<p>之后，我关掉了网站，再不设计青春。</p>\n<blockquote>\n<p><em>文章来自我校年级范文。如果作者同学对于我擅自的发表有任何意见，我会将文章立刻撤下。</em></p>\n</blockquote>\n<h2 id=\"青春\"><a href=\"#青春\" class=\"headerlink\" title=\"青春\"></a>青春</h2><blockquote>\n<p>以下是我随便乱写的</p>\n</blockquote>\n<p>或许青春永远都不存在所谓“完美”。</p>\n<p>我曾经思考过我的过去、现在和未来。</p>\n<hr>\n<p>我的过去，何时回忆起来也不免欢欣。</p>\n<p>我的家长，对于我的管教应该说还算是比较严格，小学每天八点半都要上床睡觉，即使到了中考前夕，九点半点之前也必须要在床上躺着。这的确对我有极大的帮助。如果说到学校，其实我对于小学的记忆已经渐渐模糊了，甚至连在哪里上的课都不太记得。但我恐怕一辈子也不能忘记，在那里懵懵懂懂的成长的时光。在那个最纯真的时候，我收获的不止几段最为美丽的友情，更有许多的成长。小的时候每天都坐班车，虽然没有什么人愿意跟我说话，但我也因此在车上读了许多许多的书。或许我现在对人生的许多看法，也是在那几年的班车上获得的。初中，在我当时看来，可以说是侥幸混到了本区最好的初中吧。同学都是很棒的一些人。有的人擅长学习，在学习上给了我许多的帮助；有的人思想深邃，教会我去如何更好的理解这个世界。相对于小学，我倒是更认为初中的老师让我成长更多。无论如何，我的初中生活很快也就结束了。一个懵懂的孩童终于长成一个少年，当然要归功于我亲爱的老师和同学们，还有我的家长。</p>\n<hr>\n<p>我的现在，是一个近乎完美的现在。</p>\n<p>不负众望的，我考进了本校的高中。一个三年，接下来的又是一个三年。小学的六年，并没有给我留下什么印象；而中学的六年，则会是人生中不可磨灭的一部分。同学自然十分优秀，老师也是非常有才华，我现在所拥有的一切恐怕是以前连梦都不敢梦的所有。一切一切，都让我一直认为，我的现在，已经是最好的现在了。</p>\n<hr>\n<p>我的未来，大约也会是令人向往的远方。</p>\n<p>我所拥有的一切，都在激励着我继续前行。我有负责的家人，给我的奋斗最大的支持；我有热爱的事业，并且我在这上面也获得了无可比拟的成就感；我有深深爱着的人，无论何时都会给我我安慰与鼓励；我有负责任的老师，会给我在学业上一切可能的帮助；我有一群可爱的同学，始终让我在每天放学都能带着微笑回家，不论生活的繁忙与否；而我现在所取得的一切，也告诉我：未来充满着希望。人生中最美好的事情或许也就莫过于，每一天都是怀揣着希望而前行吧。</p>\n<hr>\n<p>当时看到这篇范文，突然就想到了自己。感谢我生命里遇到的所有人，不论是到现在已经相忘，还是依旧相随而行；不论我们之间是至今不渝的友情，还是无法弥补的伤痕，感谢你们让我完全地成长，让我拥有这么一个完美的青春。</p>\n<p>鲁迅也说过：“使精神的丝缕还牵着已逝的寂寞的时光，又有什么意义呢。”</p>\n<p>虽说青春终有遗憾，但如果这一切都是你爱的人和爱你的人一起为你写就，那么是否遗憾，或许也不那么重要。</p>\n<p>你说呢。<!-- 手动 @ 某人 --></p>\n<p>这篇文章写的匆忙，来不及细细打磨，如果有文意疏漏之处，在所难免，请观者原谅。</p>"},{"title":"「梦想」","urlname":"dream","date":"2018-06-15T14:38:55.000Z","visible":null,"_content":"\n什么是梦想呢...\n<!-- more -->\n\n## 序\n\n有的时候，总会有人问我：“你有梦想吗？”我向来是最烦这种问题的，所以往往搪塞一句回去：“没有。我就是条没有梦想的咸鱼。”\n\n最近写完作文，再去细细回想，或许我也曾有过梦，只不过大约是忘记了吧。\n\n## 梦·想\n\n### 一\n\n我不怎么做梦。我自认为我是一个非常现实的人，现实到不会幻想，现实到总会否定自己，现实到不会做梦。\n\n某人就不一样。如果说我是个现实主义的人，那么我觉得这位的生活里，更多的是些许浪漫主义的情怀和洒脱。某人的梦，就比我的有趣的多了。\n\n但我也有平衡现实主义的特点。对于我来说，只要不是特别大的事情，所有的上一天的不快在睡一觉之后，大多都是会忘掉的，长此以往，显得我的性格也就比较随和，不易生气了吧。\n\n但我忘掉的恐怕也包括梦吧。\n\n### 二\n\n感觉不论什么时候，如果你问我：“你以后想干什么啊？”我恐怕都会稍稍思考一会，然后遗憾的说道：“我不知道啊。”\n\n的确，我从来都不知道我想要去做什么，我人生的意义是什么。或许我在小时候小小的高床上也曾经思考过，但一切都好像已经远去了。\n\n最近我似乎又思考出了一个冠冕堂皇的借口，来抵御这些询问：“生而为生。”这个借口一出，终于摆脱了无尽的询问：懂得的人知道这是一个无关紧要的借口，不懂得人觉得这是一个无关紧要的玩笑。\n\n于是，所有人似乎都觉得这件事情无关紧要了。\n\n### 三\n\n渐渐的，也没有时间让我去思考了。\n\n生活越来越烦躁了。越来越多的事情，让我简直腾不出手来。明天要考试了，今天得赶快复习；明天要上课了，今天要稍微预习一下；明天要讲新算法了，现在还不会。\n\n总有那么多的事，在每一个方面堵住你的丝丝缕缕的梦，让你不得不回到沉重的桌前。无时无刻，身边萦绕着的都是嘈杂与烦乱的声音，督促着你上进，督促着你在一条无尽的独木桥上越走，越走，越远。\n\n有什么可以去想的呢...只不过勉强能让自己不在这木桥上摔下去，摔得遍体鳞伤，摔得无处可归。\n\n你问我什么是「梦」，什么是「想」？\n\n我不知道。\n\n### 四\n\n小时候的梦想总是易碎的。我梦想着考年级第一，享受无边的夸耀；我梦想着什么东西一学就会，却无数次倍遭打击；我梦想着有一天能够买下家门口的一大片空地，可十多年过去，覆盖其上的仍然是一片荒芜。\n\n我也不断的问自己：什么才是我真正想要的梦想？我究竟能做到什么？\n\n或许，我们大部分人，都是这苍茫世界中的一粒草芥吧。世界不会以你的意志为转移，你也很难去改变或者世界，甚至是你家门口的一片空地。我们所能做的，恐怕也只是活好自己，让自己活好，让你所有希望能够好好活着的人活好。除此之外，我们，不过是漫天大雪中被风无力裹挟着的一片雪花，只能打着转，被风吹着，到一个不知道什么的地方吧。\n\n然而活着，这恐怕也不容易呢。\n\n所以啊，我就在想我应该为什么而活着。但或许我心里早已有了答案吧。我不知道我从哪里得来的这个结论，也不知道任何有关的过程。\n\n趁现在能开心的活着，做人多天真一点，去追寻自己内心想要的吧。\n\n已经逝去的梦，就让它成为美好的回忆；还在手心的梦，就将它捧好，祈愿它永不离去。\n\n![](2333.jpg)\n\n### 一点更多的话\n\n最近我终于明白，哪有那么多梦想。\n\n你的阶级，你的身份，你的人生在此刻之前的每一秒，都让你的某些梦想，或大或小，无声的坠地。\n\n有的人，他们或出身显赫，或一世豪门。他们生来，就已经跨过了温饱、小康，这种在中国社会里还没有完全普及的生活。他们可以有梦想。他们如果今天想要干些什么，自会有人在明天，把所有他想要的，搬上桌去。\n\n但其实，人们中的大部分，和他们，追求的所谓「梦想」，恐怕都不是一样的东西，甚至不在一个层次上。他们中有的人可以想着去改变世界，因为就算改变不了这个世界，他也能一辈子活在父辈的荫护之下。而对于大多数人，如果世界没有被你改变，那么，你就会被这个世界毁灭。\n\n你应该去市井逛逛。看看那些在建筑工地上的工人，看看他们黝黑的肌肤，看看那些住在不到十平米的地下室里面的人。他们的奋斗，很多恐怕也都是为了晚上的一顿饭，为了能够在这个世界上拥有一些最基本的权利吧。\n\n> 時間永是流駛，街市依舊太平。\n\n百年前的工人就在社会的底层，而如今，仍然如此。那是什么人代替了土豪、地主、资本家和官僚阶级呢？\n\n不管是谁，我相信，他们肯定是有梦想的。\n\n### 最后\n\n我还很天真，这是毫无疑问的。就像我现在看三年前的作文一样，三年后再来看这里，恐怕也会认为这不过是无病的牢骚，令人恶心。\n\n但不论如何吧，这也是一点点微小的思想。虽然肯定十分的幼稚，但我想，以后再看到的时候，多少也会有那么一点点的启示吧。\n\n> Stay simple. Stay naïve.\n\n*应某人要求，写成这样一篇小文，以聊寄微情。*\n\n## 你的「梦想」？\n\n> 某人的一篇「梦想」\n\n我从未想过在这里遇到她。她身上的文字，是应该让人经历了风沙的洗礼，怀着朝圣的心匍匐着翻过沙丘才能细细拜读，绝不是在这冰冷的玻璃柜里，与耶稣的画像和法老的木乃伊为邻，赤裸着暴露在游人迷茫的眼睛下，企盼着故人匆匆走过时的一瞥。我心里涌起一阵不平，一个强烈的愿望如热风一样席卷而来，把我带回一百年前的中国。\n\n沙丘上浮出三个人影，一个骑在马上，另两个一前一后地跟着。走在前的牵着马，身材瘦高。后面的垂着手小步跟着，扮成道士模样。正是他们了。\n\n马背上的外国人首先看到了我，他的面露戒备，稍稍拉紧了缰绳。“斯坦因！”三人应声而停，牵马的买办向我微微欠腰，眼神里却满是厌恶。“你我在这不毛之地相见定是有缘了。您既知道我们老板斯坦因先生的大名，相必对我们老板此行的高尚目的也有所耳闻。这马上所载皆是贵重之物，我等归京心切不便耽搁，见谅。”“等等。”我上前一步。“蒋孝琬，斯坦因不懂中文你大可不必对我说这冠冕堂皇之话。”他的脸突然拉下来：“不知您有何贵干。”“你我二人，还有王道士。”我看向他时他怕得只不断作揖念着“无量观”“我们三个都是中国人，这马上载的都是中国的宝物。你只告诉斯坦因我是在此等他来保他过沙漠的向导，机会一到我们就把斯坦因身上的枪拿过来，逼他和我们回去，把这些经书全放回藏经洞。他孤身在外不得不信任你，这事一定能成。”“您这是要置我于不义之地啊。”“不义？我是让您免做历史的罪人，被子孙万世唾弃！”“我只区区一个平民，流传千古倒是我的运气呢。只是拿了人的钱就得帮人做事，买卖定了就再无反悔的余地。”\n\n“他给了你多少钱。”我转向王道士。“大人念佛心虔，给了小道30英镑。”30英镑...千百年来大师们的智慧结晶只值30英镑！“你为什么不把这发现告诉朝廷，大清的国库里绝不止有30英磅啊！”“哼”蒋孝琬冷笑一声“朝廷的钱都去给老佛爷办寿了。上交了朝廷，沿途押韵的官员谁不从中抽利？先就把好东西挑光了。况且这朝廷也不稳固了，一路上到处都是军阀。这书要是落到他们手里，哼，肯定是撕了擦屁股...要我说，只有洋人靠的住…”\n\n他的声音渐渐远了，烟霭下只剩落寞的我。神游归来，梦想破灭，面对着这一屋子的展品，我突然感到很自卑。历史的厚重压的我喘不过气。我不知道一个人的错误，需要多少后人来弥补。或者是否因为史书上只留下这一两个犯错的人的名字，我们就让他们来顶替一个民族的罪过。不愿再想了，只希望以后的人们不再在异国的博物馆里经受这梦想破灭的悲哀。\n\n> 太强啦！","source":"_posts/「梦想」.md","raw":"---\ntitle: 「梦想」\nurlname: dream\ndate: 2018-06-15 22:38:55\ntags:\ncategories: 随笔\nvisible:\n---\n\n什么是梦想呢...\n<!-- more -->\n\n## 序\n\n有的时候，总会有人问我：“你有梦想吗？”我向来是最烦这种问题的，所以往往搪塞一句回去：“没有。我就是条没有梦想的咸鱼。”\n\n最近写完作文，再去细细回想，或许我也曾有过梦，只不过大约是忘记了吧。\n\n## 梦·想\n\n### 一\n\n我不怎么做梦。我自认为我是一个非常现实的人，现实到不会幻想，现实到总会否定自己，现实到不会做梦。\n\n某人就不一样。如果说我是个现实主义的人，那么我觉得这位的生活里，更多的是些许浪漫主义的情怀和洒脱。某人的梦，就比我的有趣的多了。\n\n但我也有平衡现实主义的特点。对于我来说，只要不是特别大的事情，所有的上一天的不快在睡一觉之后，大多都是会忘掉的，长此以往，显得我的性格也就比较随和，不易生气了吧。\n\n但我忘掉的恐怕也包括梦吧。\n\n### 二\n\n感觉不论什么时候，如果你问我：“你以后想干什么啊？”我恐怕都会稍稍思考一会，然后遗憾的说道：“我不知道啊。”\n\n的确，我从来都不知道我想要去做什么，我人生的意义是什么。或许我在小时候小小的高床上也曾经思考过，但一切都好像已经远去了。\n\n最近我似乎又思考出了一个冠冕堂皇的借口，来抵御这些询问：“生而为生。”这个借口一出，终于摆脱了无尽的询问：懂得的人知道这是一个无关紧要的借口，不懂得人觉得这是一个无关紧要的玩笑。\n\n于是，所有人似乎都觉得这件事情无关紧要了。\n\n### 三\n\n渐渐的，也没有时间让我去思考了。\n\n生活越来越烦躁了。越来越多的事情，让我简直腾不出手来。明天要考试了，今天得赶快复习；明天要上课了，今天要稍微预习一下；明天要讲新算法了，现在还不会。\n\n总有那么多的事，在每一个方面堵住你的丝丝缕缕的梦，让你不得不回到沉重的桌前。无时无刻，身边萦绕着的都是嘈杂与烦乱的声音，督促着你上进，督促着你在一条无尽的独木桥上越走，越走，越远。\n\n有什么可以去想的呢...只不过勉强能让自己不在这木桥上摔下去，摔得遍体鳞伤，摔得无处可归。\n\n你问我什么是「梦」，什么是「想」？\n\n我不知道。\n\n### 四\n\n小时候的梦想总是易碎的。我梦想着考年级第一，享受无边的夸耀；我梦想着什么东西一学就会，却无数次倍遭打击；我梦想着有一天能够买下家门口的一大片空地，可十多年过去，覆盖其上的仍然是一片荒芜。\n\n我也不断的问自己：什么才是我真正想要的梦想？我究竟能做到什么？\n\n或许，我们大部分人，都是这苍茫世界中的一粒草芥吧。世界不会以你的意志为转移，你也很难去改变或者世界，甚至是你家门口的一片空地。我们所能做的，恐怕也只是活好自己，让自己活好，让你所有希望能够好好活着的人活好。除此之外，我们，不过是漫天大雪中被风无力裹挟着的一片雪花，只能打着转，被风吹着，到一个不知道什么的地方吧。\n\n然而活着，这恐怕也不容易呢。\n\n所以啊，我就在想我应该为什么而活着。但或许我心里早已有了答案吧。我不知道我从哪里得来的这个结论，也不知道任何有关的过程。\n\n趁现在能开心的活着，做人多天真一点，去追寻自己内心想要的吧。\n\n已经逝去的梦，就让它成为美好的回忆；还在手心的梦，就将它捧好，祈愿它永不离去。\n\n![](2333.jpg)\n\n### 一点更多的话\n\n最近我终于明白，哪有那么多梦想。\n\n你的阶级，你的身份，你的人生在此刻之前的每一秒，都让你的某些梦想，或大或小，无声的坠地。\n\n有的人，他们或出身显赫，或一世豪门。他们生来，就已经跨过了温饱、小康，这种在中国社会里还没有完全普及的生活。他们可以有梦想。他们如果今天想要干些什么，自会有人在明天，把所有他想要的，搬上桌去。\n\n但其实，人们中的大部分，和他们，追求的所谓「梦想」，恐怕都不是一样的东西，甚至不在一个层次上。他们中有的人可以想着去改变世界，因为就算改变不了这个世界，他也能一辈子活在父辈的荫护之下。而对于大多数人，如果世界没有被你改变，那么，你就会被这个世界毁灭。\n\n你应该去市井逛逛。看看那些在建筑工地上的工人，看看他们黝黑的肌肤，看看那些住在不到十平米的地下室里面的人。他们的奋斗，很多恐怕也都是为了晚上的一顿饭，为了能够在这个世界上拥有一些最基本的权利吧。\n\n> 時間永是流駛，街市依舊太平。\n\n百年前的工人就在社会的底层，而如今，仍然如此。那是什么人代替了土豪、地主、资本家和官僚阶级呢？\n\n不管是谁，我相信，他们肯定是有梦想的。\n\n### 最后\n\n我还很天真，这是毫无疑问的。就像我现在看三年前的作文一样，三年后再来看这里，恐怕也会认为这不过是无病的牢骚，令人恶心。\n\n但不论如何吧，这也是一点点微小的思想。虽然肯定十分的幼稚，但我想，以后再看到的时候，多少也会有那么一点点的启示吧。\n\n> Stay simple. Stay naïve.\n\n*应某人要求，写成这样一篇小文，以聊寄微情。*\n\n## 你的「梦想」？\n\n> 某人的一篇「梦想」\n\n我从未想过在这里遇到她。她身上的文字，是应该让人经历了风沙的洗礼，怀着朝圣的心匍匐着翻过沙丘才能细细拜读，绝不是在这冰冷的玻璃柜里，与耶稣的画像和法老的木乃伊为邻，赤裸着暴露在游人迷茫的眼睛下，企盼着故人匆匆走过时的一瞥。我心里涌起一阵不平，一个强烈的愿望如热风一样席卷而来，把我带回一百年前的中国。\n\n沙丘上浮出三个人影，一个骑在马上，另两个一前一后地跟着。走在前的牵着马，身材瘦高。后面的垂着手小步跟着，扮成道士模样。正是他们了。\n\n马背上的外国人首先看到了我，他的面露戒备，稍稍拉紧了缰绳。“斯坦因！”三人应声而停，牵马的买办向我微微欠腰，眼神里却满是厌恶。“你我在这不毛之地相见定是有缘了。您既知道我们老板斯坦因先生的大名，相必对我们老板此行的高尚目的也有所耳闻。这马上所载皆是贵重之物，我等归京心切不便耽搁，见谅。”“等等。”我上前一步。“蒋孝琬，斯坦因不懂中文你大可不必对我说这冠冕堂皇之话。”他的脸突然拉下来：“不知您有何贵干。”“你我二人，还有王道士。”我看向他时他怕得只不断作揖念着“无量观”“我们三个都是中国人，这马上载的都是中国的宝物。你只告诉斯坦因我是在此等他来保他过沙漠的向导，机会一到我们就把斯坦因身上的枪拿过来，逼他和我们回去，把这些经书全放回藏经洞。他孤身在外不得不信任你，这事一定能成。”“您这是要置我于不义之地啊。”“不义？我是让您免做历史的罪人，被子孙万世唾弃！”“我只区区一个平民，流传千古倒是我的运气呢。只是拿了人的钱就得帮人做事，买卖定了就再无反悔的余地。”\n\n“他给了你多少钱。”我转向王道士。“大人念佛心虔，给了小道30英镑。”30英镑...千百年来大师们的智慧结晶只值30英镑！“你为什么不把这发现告诉朝廷，大清的国库里绝不止有30英磅啊！”“哼”蒋孝琬冷笑一声“朝廷的钱都去给老佛爷办寿了。上交了朝廷，沿途押韵的官员谁不从中抽利？先就把好东西挑光了。况且这朝廷也不稳固了，一路上到处都是军阀。这书要是落到他们手里，哼，肯定是撕了擦屁股...要我说，只有洋人靠的住…”\n\n他的声音渐渐远了，烟霭下只剩落寞的我。神游归来，梦想破灭，面对着这一屋子的展品，我突然感到很自卑。历史的厚重压的我喘不过气。我不知道一个人的错误，需要多少后人来弥补。或者是否因为史书上只留下这一两个犯错的人的名字，我们就让他们来顶替一个民族的罪过。不愿再想了，只希望以后的人们不再在异国的博物馆里经受这梦想破灭的悲哀。\n\n> 太强啦！","slug":"「梦想」","published":1,"updated":"2018-06-15T14:48:05.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mj0060bljr8d002swd","content":"<p>什么是梦想呢…<br><a id=\"more\"></a></p>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>有的时候，总会有人问我：“你有梦想吗？”我向来是最烦这种问题的，所以往往搪塞一句回去：“没有。我就是条没有梦想的咸鱼。”</p>\n<p>最近写完作文，再去细细回想，或许我也曾有过梦，只不过大约是忘记了吧。</p>\n<h2 id=\"梦·想\"><a href=\"#梦·想\" class=\"headerlink\" title=\"梦·想\"></a>梦·想</h2><h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>我不怎么做梦。我自认为我是一个非常现实的人，现实到不会幻想，现实到总会否定自己，现实到不会做梦。</p>\n<p>某人就不一样。如果说我是个现实主义的人，那么我觉得这位的生活里，更多的是些许浪漫主义的情怀和洒脱。某人的梦，就比我的有趣的多了。</p>\n<p>但我也有平衡现实主义的特点。对于我来说，只要不是特别大的事情，所有的上一天的不快在睡一觉之后，大多都是会忘掉的，长此以往，显得我的性格也就比较随和，不易生气了吧。</p>\n<p>但我忘掉的恐怕也包括梦吧。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>感觉不论什么时候，如果你问我：“你以后想干什么啊？”我恐怕都会稍稍思考一会，然后遗憾的说道：“我不知道啊。”</p>\n<p>的确，我从来都不知道我想要去做什么，我人生的意义是什么。或许我在小时候小小的高床上也曾经思考过，但一切都好像已经远去了。</p>\n<p>最近我似乎又思考出了一个冠冕堂皇的借口，来抵御这些询问：“生而为生。”这个借口一出，终于摆脱了无尽的询问：懂得的人知道这是一个无关紧要的借口，不懂得人觉得这是一个无关紧要的玩笑。</p>\n<p>于是，所有人似乎都觉得这件事情无关紧要了。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>渐渐的，也没有时间让我去思考了。</p>\n<p>生活越来越烦躁了。越来越多的事情，让我简直腾不出手来。明天要考试了，今天得赶快复习；明天要上课了，今天要稍微预习一下；明天要讲新算法了，现在还不会。</p>\n<p>总有那么多的事，在每一个方面堵住你的丝丝缕缕的梦，让你不得不回到沉重的桌前。无时无刻，身边萦绕着的都是嘈杂与烦乱的声音，督促着你上进，督促着你在一条无尽的独木桥上越走，越走，越远。</p>\n<p>有什么可以去想的呢…只不过勉强能让自己不在这木桥上摔下去，摔得遍体鳞伤，摔得无处可归。</p>\n<p>你问我什么是「梦」，什么是「想」？</p>\n<p>我不知道。</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>小时候的梦想总是易碎的。我梦想着考年级第一，享受无边的夸耀；我梦想着什么东西一学就会，却无数次倍遭打击；我梦想着有一天能够买下家门口的一大片空地，可十多年过去，覆盖其上的仍然是一片荒芜。</p>\n<p>我也不断的问自己：什么才是我真正想要的梦想？我究竟能做到什么？</p>\n<p>或许，我们大部分人，都是这苍茫世界中的一粒草芥吧。世界不会以你的意志为转移，你也很难去改变或者世界，甚至是你家门口的一片空地。我们所能做的，恐怕也只是活好自己，让自己活好，让你所有希望能够好好活着的人活好。除此之外，我们，不过是漫天大雪中被风无力裹挟着的一片雪花，只能打着转，被风吹着，到一个不知道什么的地方吧。</p>\n<p>然而活着，这恐怕也不容易呢。</p>\n<p>所以啊，我就在想我应该为什么而活着。但或许我心里早已有了答案吧。我不知道我从哪里得来的这个结论，也不知道任何有关的过程。</p>\n<p>趁现在能开心的活着，做人多天真一点，去追寻自己内心想要的吧。</p>\n<p>已经逝去的梦，就让它成为美好的回忆；还在手心的梦，就将它捧好，祈愿它永不离去。</p>\n<p><img src=\"2333.jpg\" alt=\"\"></p>\n<h3 id=\"一点更多的话\"><a href=\"#一点更多的话\" class=\"headerlink\" title=\"一点更多的话\"></a>一点更多的话</h3><p>最近我终于明白，哪有那么多梦想。</p>\n<p>你的阶级，你的身份，你的人生在此刻之前的每一秒，都让你的某些梦想，或大或小，无声的坠地。</p>\n<p>有的人，他们或出身显赫，或一世豪门。他们生来，就已经跨过了温饱、小康，这种在中国社会里还没有完全普及的生活。他们可以有梦想。他们如果今天想要干些什么，自会有人在明天，把所有他想要的，搬上桌去。</p>\n<p>但其实，人们中的大部分，和他们，追求的所谓「梦想」，恐怕都不是一样的东西，甚至不在一个层次上。他们中有的人可以想着去改变世界，因为就算改变不了这个世界，他也能一辈子活在父辈的荫护之下。而对于大多数人，如果世界没有被你改变，那么，你就会被这个世界毁灭。</p>\n<p>你应该去市井逛逛。看看那些在建筑工地上的工人，看看他们黝黑的肌肤，看看那些住在不到十平米的地下室里面的人。他们的奋斗，很多恐怕也都是为了晚上的一顿饭，为了能够在这个世界上拥有一些最基本的权利吧。</p>\n<blockquote>\n<p>時間永是流駛，街市依舊太平。</p>\n</blockquote>\n<p>百年前的工人就在社会的底层，而如今，仍然如此。那是什么人代替了土豪、地主、资本家和官僚阶级呢？</p>\n<p>不管是谁，我相信，他们肯定是有梦想的。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>我还很天真，这是毫无疑问的。就像我现在看三年前的作文一样，三年后再来看这里，恐怕也会认为这不过是无病的牢骚，令人恶心。</p>\n<p>但不论如何吧，这也是一点点微小的思想。虽然肯定十分的幼稚，但我想，以后再看到的时候，多少也会有那么一点点的启示吧。</p>\n<blockquote>\n<p>Stay simple. Stay naïve.</p>\n</blockquote>\n<p><em>应某人要求，写成这样一篇小文，以聊寄微情。</em></p>\n<h2 id=\"你的「梦想」？\"><a href=\"#你的「梦想」？\" class=\"headerlink\" title=\"你的「梦想」？\"></a>你的「梦想」？</h2><blockquote>\n<p>某人的一篇「梦想」</p>\n</blockquote>\n<p>我从未想过在这里遇到她。她身上的文字，是应该让人经历了风沙的洗礼，怀着朝圣的心匍匐着翻过沙丘才能细细拜读，绝不是在这冰冷的玻璃柜里，与耶稣的画像和法老的木乃伊为邻，赤裸着暴露在游人迷茫的眼睛下，企盼着故人匆匆走过时的一瞥。我心里涌起一阵不平，一个强烈的愿望如热风一样席卷而来，把我带回一百年前的中国。</p>\n<p>沙丘上浮出三个人影，一个骑在马上，另两个一前一后地跟着。走在前的牵着马，身材瘦高。后面的垂着手小步跟着，扮成道士模样。正是他们了。</p>\n<p>马背上的外国人首先看到了我，他的面露戒备，稍稍拉紧了缰绳。“斯坦因！”三人应声而停，牵马的买办向我微微欠腰，眼神里却满是厌恶。“你我在这不毛之地相见定是有缘了。您既知道我们老板斯坦因先生的大名，相必对我们老板此行的高尚目的也有所耳闻。这马上所载皆是贵重之物，我等归京心切不便耽搁，见谅。”“等等。”我上前一步。“蒋孝琬，斯坦因不懂中文你大可不必对我说这冠冕堂皇之话。”他的脸突然拉下来：“不知您有何贵干。”“你我二人，还有王道士。”我看向他时他怕得只不断作揖念着“无量观”“我们三个都是中国人，这马上载的都是中国的宝物。你只告诉斯坦因我是在此等他来保他过沙漠的向导，机会一到我们就把斯坦因身上的枪拿过来，逼他和我们回去，把这些经书全放回藏经洞。他孤身在外不得不信任你，这事一定能成。”“您这是要置我于不义之地啊。”“不义？我是让您免做历史的罪人，被子孙万世唾弃！”“我只区区一个平民，流传千古倒是我的运气呢。只是拿了人的钱就得帮人做事，买卖定了就再无反悔的余地。”</p>\n<p>“他给了你多少钱。”我转向王道士。“大人念佛心虔，给了小道30英镑。”30英镑…千百年来大师们的智慧结晶只值30英镑！“你为什么不把这发现告诉朝廷，大清的国库里绝不止有30英磅啊！”“哼”蒋孝琬冷笑一声“朝廷的钱都去给老佛爷办寿了。上交了朝廷，沿途押韵的官员谁不从中抽利？先就把好东西挑光了。况且这朝廷也不稳固了，一路上到处都是军阀。这书要是落到他们手里，哼，肯定是撕了擦屁股…要我说，只有洋人靠的住…”</p>\n<p>他的声音渐渐远了，烟霭下只剩落寞的我。神游归来，梦想破灭，面对着这一屋子的展品，我突然感到很自卑。历史的厚重压的我喘不过气。我不知道一个人的错误，需要多少后人来弥补。或者是否因为史书上只留下这一两个犯错的人的名字，我们就让他们来顶替一个民族的罪过。不愿再想了，只希望以后的人们不再在异国的博物馆里经受这梦想破灭的悲哀。</p>\n<blockquote>\n<p>太强啦！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>什么是梦想呢…<br>","more":"</p>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>有的时候，总会有人问我：“你有梦想吗？”我向来是最烦这种问题的，所以往往搪塞一句回去：“没有。我就是条没有梦想的咸鱼。”</p>\n<p>最近写完作文，再去细细回想，或许我也曾有过梦，只不过大约是忘记了吧。</p>\n<h2 id=\"梦·想\"><a href=\"#梦·想\" class=\"headerlink\" title=\"梦·想\"></a>梦·想</h2><h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>我不怎么做梦。我自认为我是一个非常现实的人，现实到不会幻想，现实到总会否定自己，现实到不会做梦。</p>\n<p>某人就不一样。如果说我是个现实主义的人，那么我觉得这位的生活里，更多的是些许浪漫主义的情怀和洒脱。某人的梦，就比我的有趣的多了。</p>\n<p>但我也有平衡现实主义的特点。对于我来说，只要不是特别大的事情，所有的上一天的不快在睡一觉之后，大多都是会忘掉的，长此以往，显得我的性格也就比较随和，不易生气了吧。</p>\n<p>但我忘掉的恐怕也包括梦吧。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>感觉不论什么时候，如果你问我：“你以后想干什么啊？”我恐怕都会稍稍思考一会，然后遗憾的说道：“我不知道啊。”</p>\n<p>的确，我从来都不知道我想要去做什么，我人生的意义是什么。或许我在小时候小小的高床上也曾经思考过，但一切都好像已经远去了。</p>\n<p>最近我似乎又思考出了一个冠冕堂皇的借口，来抵御这些询问：“生而为生。”这个借口一出，终于摆脱了无尽的询问：懂得的人知道这是一个无关紧要的借口，不懂得人觉得这是一个无关紧要的玩笑。</p>\n<p>于是，所有人似乎都觉得这件事情无关紧要了。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>渐渐的，也没有时间让我去思考了。</p>\n<p>生活越来越烦躁了。越来越多的事情，让我简直腾不出手来。明天要考试了，今天得赶快复习；明天要上课了，今天要稍微预习一下；明天要讲新算法了，现在还不会。</p>\n<p>总有那么多的事，在每一个方面堵住你的丝丝缕缕的梦，让你不得不回到沉重的桌前。无时无刻，身边萦绕着的都是嘈杂与烦乱的声音，督促着你上进，督促着你在一条无尽的独木桥上越走，越走，越远。</p>\n<p>有什么可以去想的呢…只不过勉强能让自己不在这木桥上摔下去，摔得遍体鳞伤，摔得无处可归。</p>\n<p>你问我什么是「梦」，什么是「想」？</p>\n<p>我不知道。</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>小时候的梦想总是易碎的。我梦想着考年级第一，享受无边的夸耀；我梦想着什么东西一学就会，却无数次倍遭打击；我梦想着有一天能够买下家门口的一大片空地，可十多年过去，覆盖其上的仍然是一片荒芜。</p>\n<p>我也不断的问自己：什么才是我真正想要的梦想？我究竟能做到什么？</p>\n<p>或许，我们大部分人，都是这苍茫世界中的一粒草芥吧。世界不会以你的意志为转移，你也很难去改变或者世界，甚至是你家门口的一片空地。我们所能做的，恐怕也只是活好自己，让自己活好，让你所有希望能够好好活着的人活好。除此之外，我们，不过是漫天大雪中被风无力裹挟着的一片雪花，只能打着转，被风吹着，到一个不知道什么的地方吧。</p>\n<p>然而活着，这恐怕也不容易呢。</p>\n<p>所以啊，我就在想我应该为什么而活着。但或许我心里早已有了答案吧。我不知道我从哪里得来的这个结论，也不知道任何有关的过程。</p>\n<p>趁现在能开心的活着，做人多天真一点，去追寻自己内心想要的吧。</p>\n<p>已经逝去的梦，就让它成为美好的回忆；还在手心的梦，就将它捧好，祈愿它永不离去。</p>\n<p><img src=\"2333.jpg\" alt=\"\"></p>\n<h3 id=\"一点更多的话\"><a href=\"#一点更多的话\" class=\"headerlink\" title=\"一点更多的话\"></a>一点更多的话</h3><p>最近我终于明白，哪有那么多梦想。</p>\n<p>你的阶级，你的身份，你的人生在此刻之前的每一秒，都让你的某些梦想，或大或小，无声的坠地。</p>\n<p>有的人，他们或出身显赫，或一世豪门。他们生来，就已经跨过了温饱、小康，这种在中国社会里还没有完全普及的生活。他们可以有梦想。他们如果今天想要干些什么，自会有人在明天，把所有他想要的，搬上桌去。</p>\n<p>但其实，人们中的大部分，和他们，追求的所谓「梦想」，恐怕都不是一样的东西，甚至不在一个层次上。他们中有的人可以想着去改变世界，因为就算改变不了这个世界，他也能一辈子活在父辈的荫护之下。而对于大多数人，如果世界没有被你改变，那么，你就会被这个世界毁灭。</p>\n<p>你应该去市井逛逛。看看那些在建筑工地上的工人，看看他们黝黑的肌肤，看看那些住在不到十平米的地下室里面的人。他们的奋斗，很多恐怕也都是为了晚上的一顿饭，为了能够在这个世界上拥有一些最基本的权利吧。</p>\n<blockquote>\n<p>時間永是流駛，街市依舊太平。</p>\n</blockquote>\n<p>百年前的工人就在社会的底层，而如今，仍然如此。那是什么人代替了土豪、地主、资本家和官僚阶级呢？</p>\n<p>不管是谁，我相信，他们肯定是有梦想的。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>我还很天真，这是毫无疑问的。就像我现在看三年前的作文一样，三年后再来看这里，恐怕也会认为这不过是无病的牢骚，令人恶心。</p>\n<p>但不论如何吧，这也是一点点微小的思想。虽然肯定十分的幼稚，但我想，以后再看到的时候，多少也会有那么一点点的启示吧。</p>\n<blockquote>\n<p>Stay simple. Stay naïve.</p>\n</blockquote>\n<p><em>应某人要求，写成这样一篇小文，以聊寄微情。</em></p>\n<h2 id=\"你的「梦想」？\"><a href=\"#你的「梦想」？\" class=\"headerlink\" title=\"你的「梦想」？\"></a>你的「梦想」？</h2><blockquote>\n<p>某人的一篇「梦想」</p>\n</blockquote>\n<p>我从未想过在这里遇到她。她身上的文字，是应该让人经历了风沙的洗礼，怀着朝圣的心匍匐着翻过沙丘才能细细拜读，绝不是在这冰冷的玻璃柜里，与耶稣的画像和法老的木乃伊为邻，赤裸着暴露在游人迷茫的眼睛下，企盼着故人匆匆走过时的一瞥。我心里涌起一阵不平，一个强烈的愿望如热风一样席卷而来，把我带回一百年前的中国。</p>\n<p>沙丘上浮出三个人影，一个骑在马上，另两个一前一后地跟着。走在前的牵着马，身材瘦高。后面的垂着手小步跟着，扮成道士模样。正是他们了。</p>\n<p>马背上的外国人首先看到了我，他的面露戒备，稍稍拉紧了缰绳。“斯坦因！”三人应声而停，牵马的买办向我微微欠腰，眼神里却满是厌恶。“你我在这不毛之地相见定是有缘了。您既知道我们老板斯坦因先生的大名，相必对我们老板此行的高尚目的也有所耳闻。这马上所载皆是贵重之物，我等归京心切不便耽搁，见谅。”“等等。”我上前一步。“蒋孝琬，斯坦因不懂中文你大可不必对我说这冠冕堂皇之话。”他的脸突然拉下来：“不知您有何贵干。”“你我二人，还有王道士。”我看向他时他怕得只不断作揖念着“无量观”“我们三个都是中国人，这马上载的都是中国的宝物。你只告诉斯坦因我是在此等他来保他过沙漠的向导，机会一到我们就把斯坦因身上的枪拿过来，逼他和我们回去，把这些经书全放回藏经洞。他孤身在外不得不信任你，这事一定能成。”“您这是要置我于不义之地啊。”“不义？我是让您免做历史的罪人，被子孙万世唾弃！”“我只区区一个平民，流传千古倒是我的运气呢。只是拿了人的钱就得帮人做事，买卖定了就再无反悔的余地。”</p>\n<p>“他给了你多少钱。”我转向王道士。“大人念佛心虔，给了小道30英镑。”30英镑…千百年来大师们的智慧结晶只值30英镑！“你为什么不把这发现告诉朝廷，大清的国库里绝不止有30英磅啊！”“哼”蒋孝琬冷笑一声“朝廷的钱都去给老佛爷办寿了。上交了朝廷，沿途押韵的官员谁不从中抽利？先就把好东西挑光了。况且这朝廷也不稳固了，一路上到处都是军阀。这书要是落到他们手里，哼，肯定是撕了擦屁股…要我说，只有洋人靠的住…”</p>\n<p>他的声音渐渐远了，烟霭下只剩落寞的我。神游归来，梦想破灭，面对着这一屋子的展品，我突然感到很自卑。历史的厚重压的我喘不过气。我不知道一个人的错误，需要多少后人来弥补。或者是否因为史书上只留下这一两个犯错的人的名字，我们就让他们来顶替一个民族的罪过。不愿再想了，只希望以后的人们不再在异国的博物馆里经受这梦想破灭的悲哀。</p>\n<blockquote>\n<p>太强啦！</p>\n</blockquote>"},{"title":"「模板」陌上花开-CDQ分治+树状数组","urlname":"flowers","date":"2018-06-06T11:16:30.000Z","visible":null,"_content":"\n有$n$朵花,每朵花有三个属性:花形($s$)、颜色($c$)、气味($m$)，用三个整数表示。显然，两朵花可能有同样的属性。\n\n定义一朵花$A$比另一朵花$B$要美丽，当且仅$S_a\\geq S_b$,$C_a\\geq C_b$,$M_a \\geq M_b$。定义一朵花的等级是它拥有的美丽能超过的花的数量。\n\n求出每个等级的花的数量。\n\n<!-- more -->\n\n> 陌上花开，可缓缓归矣。\n\n## 链接\n\n[BZOJ 3262](https://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n[Luogu P3810](https://www.luogu.org/problemnew/show/P3810)\n\n## 题解\n\n这道题还有一个名字叫「三维偏序」，题面如下：\n\n> 有 $n$ 个元素，第 $i$ 个元素有 $a_i$ 、$b_i$ 、$c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \\leq a_i$ 且 $b_j \\leq b_i$ 且 $c_j \\leq c_i$ 的 $j$ 的数量。\n>\n> 对于$d \\in [0, n)$，求$f(i) = d$的数量\n\n我在这里使用上面的题面。（虽然是一样的。\n\n这是一道三维偏序的模版题。很多一些二维的问题经过转化也可以变成三维偏序的类似问题，套用排序+CDQ分治+BIT来解决。\n\n假设所有的$(a,b,c)$互不相同。\n\n- - -\n\n第一维：排序\n\n按照$a$的大小排序从新编号$1 -> n$，排序完成后就可以发现对于第$i$个元素，满足条件的元素只存在于$[1,i-1]$中。问题转化为：在$[1,i-1]$中有多少个满足$b_i \\geq b_j$ 且 $c_i \\geq c_j$的元素。\n\n这个问题其实就是二维数点。因为$b$乱序添加，所以不能离线解决，可以用树套树在线解决。\n\n但是呢，我们用$CDQ$，就可以化动态为静态。\n\n- - -\n\n第二维：$CDQ$分治\n\n什么是$CDQ$分治呢？在这里就是一个类似归并排序的东西，因为我们要统计的是小于一个数的个数。\n\n事实上在这里，我们对于每一个元素$i$，都将其看成同样内容的一次询问和一次修改。\n\n我们在解决一个询问的区间$[L,R]$时，我们**只需要累计这个区间里左半部分的修改对右半部分的查询的贡献**就可以了。正确性不太显然，跟树状数组类似，查询时能够涵盖$[1,i-1]区间。\n\n第三维也可以接着用$CDQ$分治，那就真的是归并排序了。就像归并统计逆序对似的，我们在第三维按$c$进行归并排序。只需要多维护一个标记，标记在上一维里面其属于左区间还是右区间，来决定在归并时是否累及答案。\n\n- - -\n\n第三维：树状数组\n\n第三维有更方便的做法，也就是用树状数组。\n\n第二维中，我们只需要将左侧的$c$按照$b$在归并中的顺序加入树状数组，然后归并加入右侧元素的时候查询比$c$小的数累积答案，最后得到的就是在左半区间所有b比它小，而且$c$也比它小的数的个数。\n\n- - -\n\n相同元素怎么处理？\n\n在改之前强行累积一下就可以了，把后面的数对于前面的贡献给预先加上去就可以了。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nconst int MAXN = 210000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nnamespace BIT{\n    int sumn[MAXN];\n    int lowbit(int x){return x & (-x);}\n    void add(int x,int d){\n        for(;x <= k;x += lowbit(x))\n            sumn[x] += d;\n    }\n    int query(int x){\n        int ans = 0;\n        for(;x >= 1;x -= lowbit(x))\n            ans += sumn[x];\n        return ans;\n    }\n}\n\n\nstruct Q{\n    int a,b,c;\n    Q(){}\n    Q(int x,int y,int z):a(x),b(y),c(z){}\n    bool operator < (Q w)const{\n        if(a != w.a) return a < w.a;\n        if(b != w.b) return b < w.b;\n        else         return c < w.c;\n    }\n    bool operator == (Q w)const{\n        return a == w.a && b == w.b && c == w.c;\n    }\n}q[MAXN];\n\nbool judge(int x,int y){\n    // 用于第二维的归并判断\n    if(q[x].b!=q[y].b)\n        return q[x].b < q[y].b;//比较两数的c\n    if(q[x].c!=q[y].c)\n        return q[x].c < q[y].c;//比较两数的c\n    else\n        return x < y;//最后比较两数的id\n}\n\nint d[MAXN],ans[MAXN],tt[MAXN];\n\nint tmp[MAXN];\n\nint tot,l,r;\n\nvoid CDQ(int *t,int num,int depth = 0){\n    //t[0] -> t[num-1] (num个元素） \n    if(num == 1) return;\n    int mid = num/2;\n    CDQ(t,mid,depth+1),CDQ(t+mid,num-mid,depth+1);\n    // 递归分治问题\n    for(tot = 0,l = 0,r = mid;l < mid && r < num;tot++){\n        //归并过程，统计左半区间对右半区间的贡献\n        //如果在左区间，就把其当作修改，更新树状数组\n        //如果在右区间，就把其当作查询，查询树状数组，更新答案\n        if(judge(t[l],t[r]))\n            BIT::add(q[t[l]].c,1),tmp[tot] = t[l++];\n        else\n            ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot] = t[r++];\n    }\n    //剩余的归并\n    while(l < mid)\n        BIT::add(q[t[l]].c,1),tmp[tot++] = t[l++];\n    while(r < num)\n        ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot++] = t[r++];\n    for(int i = 0;i<mid;i++) BIT::add(q[t[i]].c,-1);//清空树状数组\n    memcpy(t,tmp,sizeof(int) * num);//拷贝数组\n}\n\nvoid init(){\n    read(n),read(k);\n    int a,b,c;\n    for(int i = 1;i<=n;i++){\n        read(a),read(b),read(c);\n        q[i] = Q(a,b,c);\n    }\n}\n\nvoid solve(){\n    sort(q+1,q+n+1);\n    for(int i = n;i>=1;--i){\n        // 累计相同元素的贡献\n        if(q[i] == q[i+1])\n            ans[i] = ans[i+1] + 1;\n        tt[i] = i;\n    }\n    CDQ(tt+1,n);\n    for(int i = 1;i<=n;i++)\n        ++d[ans[i]];\n    for(int i = 0;i<n;i++)\n        print(d[i]),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n} \n```\n{% endfold %}\n\n\n\n","source":"_posts/「模板」陌上花开-CDQ分治-树状数组.md","raw":"---\ntitle: 「模板」陌上花开-CDQ分治+树状数组\nurlname: flowers\ndate: 2018-06-06 19:16:30\ntags:\n- 题解\n- CDQ分治\n- 树状数组\n- 模板\ncategories: OI\nvisible:\n---\n\n有$n$朵花,每朵花有三个属性:花形($s$)、颜色($c$)、气味($m$)，用三个整数表示。显然，两朵花可能有同样的属性。\n\n定义一朵花$A$比另一朵花$B$要美丽，当且仅$S_a\\geq S_b$,$C_a\\geq C_b$,$M_a \\geq M_b$。定义一朵花的等级是它拥有的美丽能超过的花的数量。\n\n求出每个等级的花的数量。\n\n<!-- more -->\n\n> 陌上花开，可缓缓归矣。\n\n## 链接\n\n[BZOJ 3262](https://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n[Luogu P3810](https://www.luogu.org/problemnew/show/P3810)\n\n## 题解\n\n这道题还有一个名字叫「三维偏序」，题面如下：\n\n> 有 $n$ 个元素，第 $i$ 个元素有 $a_i$ 、$b_i$ 、$c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \\leq a_i$ 且 $b_j \\leq b_i$ 且 $c_j \\leq c_i$ 的 $j$ 的数量。\n>\n> 对于$d \\in [0, n)$，求$f(i) = d$的数量\n\n我在这里使用上面的题面。（虽然是一样的。\n\n这是一道三维偏序的模版题。很多一些二维的问题经过转化也可以变成三维偏序的类似问题，套用排序+CDQ分治+BIT来解决。\n\n假设所有的$(a,b,c)$互不相同。\n\n- - -\n\n第一维：排序\n\n按照$a$的大小排序从新编号$1 -> n$，排序完成后就可以发现对于第$i$个元素，满足条件的元素只存在于$[1,i-1]$中。问题转化为：在$[1,i-1]$中有多少个满足$b_i \\geq b_j$ 且 $c_i \\geq c_j$的元素。\n\n这个问题其实就是二维数点。因为$b$乱序添加，所以不能离线解决，可以用树套树在线解决。\n\n但是呢，我们用$CDQ$，就可以化动态为静态。\n\n- - -\n\n第二维：$CDQ$分治\n\n什么是$CDQ$分治呢？在这里就是一个类似归并排序的东西，因为我们要统计的是小于一个数的个数。\n\n事实上在这里，我们对于每一个元素$i$，都将其看成同样内容的一次询问和一次修改。\n\n我们在解决一个询问的区间$[L,R]$时，我们**只需要累计这个区间里左半部分的修改对右半部分的查询的贡献**就可以了。正确性不太显然，跟树状数组类似，查询时能够涵盖$[1,i-1]区间。\n\n第三维也可以接着用$CDQ$分治，那就真的是归并排序了。就像归并统计逆序对似的，我们在第三维按$c$进行归并排序。只需要多维护一个标记，标记在上一维里面其属于左区间还是右区间，来决定在归并时是否累及答案。\n\n- - -\n\n第三维：树状数组\n\n第三维有更方便的做法，也就是用树状数组。\n\n第二维中，我们只需要将左侧的$c$按照$b$在归并中的顺序加入树状数组，然后归并加入右侧元素的时候查询比$c$小的数累积答案，最后得到的就是在左半区间所有b比它小，而且$c$也比它小的数的个数。\n\n- - -\n\n相同元素怎么处理？\n\n在改之前强行累积一下就可以了，把后面的数对于前面的贡献给预先加上去就可以了。\n\n## 代码\n\n{% fold %}\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k;\nconst int MAXN = 210000;\n\nnamespace fast_io{\n    //...\n}using namespace fast_io;\n\nnamespace BIT{\n    int sumn[MAXN];\n    int lowbit(int x){return x & (-x);}\n    void add(int x,int d){\n        for(;x <= k;x += lowbit(x))\n            sumn[x] += d;\n    }\n    int query(int x){\n        int ans = 0;\n        for(;x >= 1;x -= lowbit(x))\n            ans += sumn[x];\n        return ans;\n    }\n}\n\n\nstruct Q{\n    int a,b,c;\n    Q(){}\n    Q(int x,int y,int z):a(x),b(y),c(z){}\n    bool operator < (Q w)const{\n        if(a != w.a) return a < w.a;\n        if(b != w.b) return b < w.b;\n        else         return c < w.c;\n    }\n    bool operator == (Q w)const{\n        return a == w.a && b == w.b && c == w.c;\n    }\n}q[MAXN];\n\nbool judge(int x,int y){\n    // 用于第二维的归并判断\n    if(q[x].b!=q[y].b)\n        return q[x].b < q[y].b;//比较两数的c\n    if(q[x].c!=q[y].c)\n        return q[x].c < q[y].c;//比较两数的c\n    else\n        return x < y;//最后比较两数的id\n}\n\nint d[MAXN],ans[MAXN],tt[MAXN];\n\nint tmp[MAXN];\n\nint tot,l,r;\n\nvoid CDQ(int *t,int num,int depth = 0){\n    //t[0] -> t[num-1] (num个元素） \n    if(num == 1) return;\n    int mid = num/2;\n    CDQ(t,mid,depth+1),CDQ(t+mid,num-mid,depth+1);\n    // 递归分治问题\n    for(tot = 0,l = 0,r = mid;l < mid && r < num;tot++){\n        //归并过程，统计左半区间对右半区间的贡献\n        //如果在左区间，就把其当作修改，更新树状数组\n        //如果在右区间，就把其当作查询，查询树状数组，更新答案\n        if(judge(t[l],t[r]))\n            BIT::add(q[t[l]].c,1),tmp[tot] = t[l++];\n        else\n            ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot] = t[r++];\n    }\n    //剩余的归并\n    while(l < mid)\n        BIT::add(q[t[l]].c,1),tmp[tot++] = t[l++];\n    while(r < num)\n        ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot++] = t[r++];\n    for(int i = 0;i<mid;i++) BIT::add(q[t[i]].c,-1);//清空树状数组\n    memcpy(t,tmp,sizeof(int) * num);//拷贝数组\n}\n\nvoid init(){\n    read(n),read(k);\n    int a,b,c;\n    for(int i = 1;i<=n;i++){\n        read(a),read(b),read(c);\n        q[i] = Q(a,b,c);\n    }\n}\n\nvoid solve(){\n    sort(q+1,q+n+1);\n    for(int i = n;i>=1;--i){\n        // 累计相同元素的贡献\n        if(q[i] == q[i+1])\n            ans[i] = ans[i+1] + 1;\n        tt[i] = i;\n    }\n    CDQ(tt+1,n);\n    for(int i = 1;i<=n;i++)\n        ++d[ans[i]];\n    for(int i = 0;i<n;i++)\n        print(d[i]),print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n} \n```\n{% endfold %}\n\n\n\n","slug":"「模板」陌上花开-CDQ分治-树状数组","published":1,"updated":"2018-06-06T13:07:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3ml0064bljrjebgntz4","content":"<p>有$n$朵花,每朵花有三个属性:花形($s$)、颜色($c$)、气味($m$)，用三个整数表示。显然，两朵花可能有同样的属性。</p>\n<p>定义一朵花$A$比另一朵花$B$要美丽，当且仅$S_a\\geq S_b$,$C_a\\geq C_b$,$M_a \\geq M_b$。定义一朵花的等级是它拥有的美丽能超过的花的数量。</p>\n<p>求出每个等级的花的数量。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>陌上花开，可缓缓归矣。</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3262\" target=\"_blank\" rel=\"noopener\">BZOJ 3262</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P3810\" target=\"_blank\" rel=\"noopener\">Luogu P3810</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这道题还有一个名字叫「三维偏序」，题面如下：</p>\n<blockquote>\n<p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$ 、$b_i$ 、$c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \\leq a_i$ 且 $b_j \\leq b_i$ 且 $c_j \\leq c_i$ 的 $j$ 的数量。</p>\n<p>对于$d \\in [0, n)$，求$f(i) = d$的数量</p>\n</blockquote>\n<p>我在这里使用上面的题面。（虽然是一样的。</p>\n<p>这是一道三维偏序的模版题。很多一些二维的问题经过转化也可以变成三维偏序的类似问题，套用排序+CDQ分治+BIT来解决。</p>\n<p>假设所有的$(a,b,c)$互不相同。</p>\n<hr>\n<p>第一维：排序</p>\n<p>按照$a$的大小排序从新编号$1 -&gt; n$，排序完成后就可以发现对于第$i$个元素，满足条件的元素只存在于$[1,i-1]$中。问题转化为：在$[1,i-1]$中有多少个满足$b_i \\geq b_j$ 且 $c_i \\geq c_j$的元素。</p>\n<p>这个问题其实就是二维数点。因为$b$乱序添加，所以不能离线解决，可以用树套树在线解决。</p>\n<p>但是呢，我们用$CDQ$，就可以化动态为静态。</p>\n<hr>\n<p>第二维：$CDQ$分治</p>\n<p>什么是$CDQ$分治呢？在这里就是一个类似归并排序的东西，因为我们要统计的是小于一个数的个数。</p>\n<p>事实上在这里，我们对于每一个元素$i$，都将其看成同样内容的一次询问和一次修改。</p>\n<p>我们在解决一个询问的区间$[L,R]$时，我们<strong>只需要累计这个区间里左半部分的修改对右半部分的查询的贡献</strong>就可以了。正确性不太显然，跟树状数组类似，查询时能够涵盖$[1,i-1]区间。</p>\n<p>第三维也可以接着用$CDQ$分治，那就真的是归并排序了。就像归并统计逆序对似的，我们在第三维按$c$进行归并排序。只需要多维护一个标记，标记在上一维里面其属于左区间还是右区间，来决定在归并时是否累及答案。</p>\n<hr>\n<p>第三维：树状数组</p>\n<p>第三维有更方便的做法，也就是用树状数组。</p>\n<p>第二维中，我们只需要将左侧的$c$按照$b$在归并中的顺序加入树状数组，然后归并加入右侧元素的时候查询比$c$小的数累积答案，最后得到的就是在左半区间所有b比它小，而且$c$也比它小的数的个数。</p>\n<hr>\n<p>相同元素怎么处理？</p>\n<p>在改之前强行累积一下就可以了，把后面的数对于前面的贡献给预先加上去就可以了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">210000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> BIT&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sumn[MAXN];</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;<span class=\"keyword\">return</span> x &amp; (-x);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;x &lt;= k;x += lowbit(x))</span><br><span class=\"line\">            sumn[x] += d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;x &gt;= <span class=\"number\">1</span>;x -= lowbit(x))</span><br><span class=\"line\">            ans += sumn[x];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Q</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    Q()&#123;&#125;</span><br><span class=\"line\">    Q(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> z):a(x),b(y),c(z)&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (Q w)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a != w.a) <span class=\"keyword\">return</span> a &lt; w.a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b != w.b) <span class=\"keyword\">return</span> b &lt; w.b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>         <span class=\"keyword\">return</span> c &lt; w.c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> == (Q w)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a == w.a &amp;&amp; b == w.b &amp;&amp; c == w.c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;q[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">judge</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于第二维的归并判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q[x].b!=q[y].b)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q[x].b &lt; q[y].b;<span class=\"comment\">//比较两数的c</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(q[x].c!=q[y].c)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> q[x].c &lt; q[y].c;<span class=\"comment\">//比较两数的c</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x &lt; y;<span class=\"comment\">//最后比较两数的id</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> d[MAXN],ans[MAXN],tt[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tot,l,r;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CDQ</span><span class=\"params\">(<span class=\"keyword\">int</span> *t,<span class=\"keyword\">int</span> num,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//t[0] -&gt; t[num-1] (num个元素） </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num == <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = num/<span class=\"number\">2</span>;</span><br><span class=\"line\">    CDQ(t,mid,depth+<span class=\"number\">1</span>),CDQ(t+mid,num-mid,depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 递归分治问题</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(tot = <span class=\"number\">0</span>,l = <span class=\"number\">0</span>,r = mid;l &lt; mid &amp;&amp; r &lt; num;tot++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//归并过程，统计左半区间对右半区间的贡献</span></span><br><span class=\"line\">        <span class=\"comment\">//如果在左区间，就把其当作修改，更新树状数组</span></span><br><span class=\"line\">        <span class=\"comment\">//如果在右区间，就把其当作查询，查询树状数组，更新答案</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(judge(t[l],t[r]))</span><br><span class=\"line\">            BIT::add(q[t[l]].c,<span class=\"number\">1</span>),tmp[tot] = t[l++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot] = t[r++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//剩余的归并</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt; mid)</span><br><span class=\"line\">        BIT::add(q[t[l]].c,<span class=\"number\">1</span>),tmp[tot++] = t[l++];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r &lt; num)</span><br><span class=\"line\">        ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot++] = t[r++];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;mid;i++) BIT::add(q[t[i]].c,<span class=\"number\">-1</span>);<span class=\"comment\">//清空树状数组</span></span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(t,tmp,<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) * num);<span class=\"comment\">//拷贝数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(k);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        q[i] = Q(a,b,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    sort(q+<span class=\"number\">1</span>,q+n+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = n;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 累计相同元素的贡献</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(q[i] == q[i+<span class=\"number\">1</span>])</span><br><span class=\"line\">            ans[i] = ans[i+<span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        tt[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CDQ(tt+<span class=\"number\">1</span>,n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        ++d[ans[i]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        print(d[i]),print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>有$n$朵花,每朵花有三个属性:花形($s$)、颜色($c$)、气味($m$)，用三个整数表示。显然，两朵花可能有同样的属性。</p>\n<p>定义一朵花$A$比另一朵花$B$要美丽，当且仅$S_a\\geq S_b$,$C_a\\geq C_b$,$M_a \\geq M_b$。定义一朵花的等级是它拥有的美丽能超过的花的数量。</p>\n<p>求出每个等级的花的数量。</p>","more":"<blockquote>\n<p>陌上花开，可缓缓归矣。</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"https://www.lydsy.com/JudgeOnline/problem.php?id=3262\" target=\"_blank\" rel=\"noopener\">BZOJ 3262</a></p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P3810\" target=\"_blank\" rel=\"noopener\">Luogu P3810</a></p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>这道题还有一个名字叫「三维偏序」，题面如下：</p>\n<blockquote>\n<p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$ 、$b_i$ 、$c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \\leq a_i$ 且 $b_j \\leq b_i$ 且 $c_j \\leq c_i$ 的 $j$ 的数量。</p>\n<p>对于$d \\in [0, n)$，求$f(i) = d$的数量</p>\n</blockquote>\n<p>我在这里使用上面的题面。（虽然是一样的。</p>\n<p>这是一道三维偏序的模版题。很多一些二维的问题经过转化也可以变成三维偏序的类似问题，套用排序+CDQ分治+BIT来解决。</p>\n<p>假设所有的$(a,b,c)$互不相同。</p>\n<hr>\n<p>第一维：排序</p>\n<p>按照$a$的大小排序从新编号$1 -&gt; n$，排序完成后就可以发现对于第$i$个元素，满足条件的元素只存在于$[1,i-1]$中。问题转化为：在$[1,i-1]$中有多少个满足$b_i \\geq b_j$ 且 $c_i \\geq c_j$的元素。</p>\n<p>这个问题其实就是二维数点。因为$b$乱序添加，所以不能离线解决，可以用树套树在线解决。</p>\n<p>但是呢，我们用$CDQ$，就可以化动态为静态。</p>\n<hr>\n<p>第二维：$CDQ$分治</p>\n<p>什么是$CDQ$分治呢？在这里就是一个类似归并排序的东西，因为我们要统计的是小于一个数的个数。</p>\n<p>事实上在这里，我们对于每一个元素$i$，都将其看成同样内容的一次询问和一次修改。</p>\n<p>我们在解决一个询问的区间$[L,R]$时，我们<strong>只需要累计这个区间里左半部分的修改对右半部分的查询的贡献</strong>就可以了。正确性不太显然，跟树状数组类似，查询时能够涵盖$[1,i-1]区间。</p>\n<p>第三维也可以接着用$CDQ$分治，那就真的是归并排序了。就像归并统计逆序对似的，我们在第三维按$c$进行归并排序。只需要多维护一个标记，标记在上一维里面其属于左区间还是右区间，来决定在归并时是否累及答案。</p>\n<hr>\n<p>第三维：树状数组</p>\n<p>第三维有更方便的做法，也就是用树状数组。</p>\n<p>第二维中，我们只需要将左侧的$c$按照$b$在归并中的顺序加入树状数组，然后归并加入右侧元素的时候查询比$c$小的数累积答案，最后得到的就是在左半区间所有b比它小，而且$c$也比它小的数的个数。</p>\n<hr>\n<p>相同元素怎么处理？</p>\n<p>在改之前强行累积一下就可以了，把后面的数对于前面的贡献给预先加上去就可以了。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�69-->\n\n</div></div>"},{"title":"「红楼一梦」","urlname":"A-dream-of-Red-Mansions","date":"2018-02-17T14:40:12.000Z","visible":null,"_content":"\n最近在做红楼的总结，莫名的也就想来写上两句。\n\n<!-- more -->\n[葬花吟-双笙](https://music.163.com/#/song?id=447076173)\n\n怎么说呢。红楼梦这本书，越读越令人悲伤。至六十三回以后，便已无心漫卷，至七十八回以后，也就不想再读下去。\n\n要依我来见，六十二回即是红楼女儿绝唱，最后一次齐聚的宴欢，最后一次惬意的愉悦。湘云醉卧石上，竟让我恍惚觉得，一切还在半年以前，还在那个春天。\n\n但世事不复啊。自此以后，大观园中也只剩下了潇湘之悲戚，蘅芜之孤冷。司琴、入画、四儿、芳官、晴雯也一个个离开这如梦似幻的大观园，旧时的欢宴已经不存。贾母月圆夜宴，老人的心里，也知道一切恐也再难挽回，不如「人多些」，好聚好散。\n\n是啊。盛筵难久，万事终有离散的一天。\n\n- - -\n\n要说读到五十余回，就已经有万千心绪。不知何时，许多原本只能在贾府边缘的许多小人物，竟也如此多在书中出现。似乎从那时往后，红楼一梦已经不再是儿女的情长，不是单纯的情娱与风月，而是家族的凝着血泪的真史。\n\n女孩，男孩们梦中的生活，怎么可能持久呢。红楼一题早就告诉你，这不过是「真事隐」，不过是「假语存」，不过是「温柔乡里的一场梦幻处」。殊不知，时年从十八回的元宵到六十回的春日，不过是一年轮回。但一年，一年也太长了。所有的事情，都变化了许多。\n\n>「女孩子在没出嫁前像是一枚珍珠，而出嫁之后就变成了鱼眼珠一般」。\n\n红楼梦就在小姐们出嫁时戛然而止了。君不见王夫人的爽利，君不见贾母的风华，君不见宝钗小时的淘气。但时间呵，也许不曾带走什么，但却一定带给了他们无法抗拒的改变。\n\n不知道是不是在这个年龄，总会有意无意的把自己往主角的位置里带入，而这样也就更能体会到那种心有悲伤而不能语。\n\n>「眼看他起朱楼， 眼看他宴宾客， 眼看他楼塌了。」\n\n就像这样吧。\n\n如果让我来选，我希望时间能够永远停在那一年的春夏。\n停在并头读西厢。\n停在葬花绝世吟。\n停在海棠诗社起。\n停在那虚幻而又美好，朦胧而又恬美的梦里。\n\n动情真的是，令人沉迷，也令人癫狂。\n\n「假作真时真亦假；无为有处有还无。」「身后有余忘缩手，眼前无路想回头」\n\n情也许就是这样吧。\n\n\n![这里应该有一张图](lindaiyu.jpg)\n*来源：[Pixiv](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=29681666)*\n","source":"_posts/「红楼一梦」.md","raw":"---\ntitle: 「红楼一梦」\nurlname: A-dream-of-Red-Mansions\ndate: 2018-02-17 22:40:12\ntags:\ncategories: 随笔\nvisible:\n---\n\n最近在做红楼的总结，莫名的也就想来写上两句。\n\n<!-- more -->\n[葬花吟-双笙](https://music.163.com/#/song?id=447076173)\n\n怎么说呢。红楼梦这本书，越读越令人悲伤。至六十三回以后，便已无心漫卷，至七十八回以后，也就不想再读下去。\n\n要依我来见，六十二回即是红楼女儿绝唱，最后一次齐聚的宴欢，最后一次惬意的愉悦。湘云醉卧石上，竟让我恍惚觉得，一切还在半年以前，还在那个春天。\n\n但世事不复啊。自此以后，大观园中也只剩下了潇湘之悲戚，蘅芜之孤冷。司琴、入画、四儿、芳官、晴雯也一个个离开这如梦似幻的大观园，旧时的欢宴已经不存。贾母月圆夜宴，老人的心里，也知道一切恐也再难挽回，不如「人多些」，好聚好散。\n\n是啊。盛筵难久，万事终有离散的一天。\n\n- - -\n\n要说读到五十余回，就已经有万千心绪。不知何时，许多原本只能在贾府边缘的许多小人物，竟也如此多在书中出现。似乎从那时往后，红楼一梦已经不再是儿女的情长，不是单纯的情娱与风月，而是家族的凝着血泪的真史。\n\n女孩，男孩们梦中的生活，怎么可能持久呢。红楼一题早就告诉你，这不过是「真事隐」，不过是「假语存」，不过是「温柔乡里的一场梦幻处」。殊不知，时年从十八回的元宵到六十回的春日，不过是一年轮回。但一年，一年也太长了。所有的事情，都变化了许多。\n\n>「女孩子在没出嫁前像是一枚珍珠，而出嫁之后就变成了鱼眼珠一般」。\n\n红楼梦就在小姐们出嫁时戛然而止了。君不见王夫人的爽利，君不见贾母的风华，君不见宝钗小时的淘气。但时间呵，也许不曾带走什么，但却一定带给了他们无法抗拒的改变。\n\n不知道是不是在这个年龄，总会有意无意的把自己往主角的位置里带入，而这样也就更能体会到那种心有悲伤而不能语。\n\n>「眼看他起朱楼， 眼看他宴宾客， 眼看他楼塌了。」\n\n就像这样吧。\n\n如果让我来选，我希望时间能够永远停在那一年的春夏。\n停在并头读西厢。\n停在葬花绝世吟。\n停在海棠诗社起。\n停在那虚幻而又美好，朦胧而又恬美的梦里。\n\n动情真的是，令人沉迷，也令人癫狂。\n\n「假作真时真亦假；无为有处有还无。」「身后有余忘缩手，眼前无路想回头」\n\n情也许就是这样吧。\n\n\n![这里应该有一张图](lindaiyu.jpg)\n*来源：[Pixiv](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=29681666)*\n","slug":"「红楼一梦」","published":1,"updated":"2018-03-03T13:02:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mo0067bljrcuz30fgn","content":"<p>最近在做红楼的总结，莫名的也就想来写上两句。</p>\n<a id=\"more\"></a>\n<p><a href=\"https://music.163.com/#/song?id=447076173\" target=\"_blank\" rel=\"noopener\">葬花吟-双笙</a></p>\n<p>怎么说呢。红楼梦这本书，越读越令人悲伤。至六十三回以后，便已无心漫卷，至七十八回以后，也就不想再读下去。</p>\n<p>要依我来见，六十二回即是红楼女儿绝唱，最后一次齐聚的宴欢，最后一次惬意的愉悦。湘云醉卧石上，竟让我恍惚觉得，一切还在半年以前，还在那个春天。</p>\n<p>但世事不复啊。自此以后，大观园中也只剩下了潇湘之悲戚，蘅芜之孤冷。司琴、入画、四儿、芳官、晴雯也一个个离开这如梦似幻的大观园，旧时的欢宴已经不存。贾母月圆夜宴，老人的心里，也知道一切恐也再难挽回，不如「人多些」，好聚好散。</p>\n<p>是啊。盛筵难久，万事终有离散的一天。</p>\n<hr>\n<p>要说读到五十余回，就已经有万千心绪。不知何时，许多原本只能在贾府边缘的许多小人物，竟也如此多在书中出现。似乎从那时往后，红楼一梦已经不再是儿女的情长，不是单纯的情娱与风月，而是家族的凝着血泪的真史。</p>\n<p>女孩，男孩们梦中的生活，怎么可能持久呢。红楼一题早就告诉你，这不过是「真事隐」，不过是「假语存」，不过是「温柔乡里的一场梦幻处」。殊不知，时年从十八回的元宵到六十回的春日，不过是一年轮回。但一年，一年也太长了。所有的事情，都变化了许多。</p>\n<blockquote>\n<p>「女孩子在没出嫁前像是一枚珍珠，而出嫁之后就变成了鱼眼珠一般」。</p>\n</blockquote>\n<p>红楼梦就在小姐们出嫁时戛然而止了。君不见王夫人的爽利，君不见贾母的风华，君不见宝钗小时的淘气。但时间呵，也许不曾带走什么，但却一定带给了他们无法抗拒的改变。</p>\n<p>不知道是不是在这个年龄，总会有意无意的把自己往主角的位置里带入，而这样也就更能体会到那种心有悲伤而不能语。</p>\n<blockquote>\n<p>「眼看他起朱楼， 眼看他宴宾客， 眼看他楼塌了。」</p>\n</blockquote>\n<p>就像这样吧。</p>\n<p>如果让我来选，我希望时间能够永远停在那一年的春夏。<br>停在并头读西厢。<br>停在葬花绝世吟。<br>停在海棠诗社起。<br>停在那虚幻而又美好，朦胧而又恬美的梦里。</p>\n<p>动情真的是，令人沉迷，也令人癫狂。</p>\n<p>「假作真时真亦假；无为有处有还无。」「身后有余忘缩手，眼前无路想回头」</p>\n<p>情也许就是这样吧。</p>\n<p><img src=\"lindaiyu.jpg\" alt=\"这里应该有一张图\"><br><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=29681666\" target=\"_blank\" rel=\"noopener\">Pixiv</a></em></p>\n","site":{"data":{}},"excerpt":"<p>最近在做红楼的总结，莫名的也就想来写上两句。</p>","more":"<p><a href=\"https://music.163.com/#/song?id=447076173\" target=\"_blank\" rel=\"noopener\">葬花吟-双笙</a></p>\n<p>怎么说呢。红楼梦这本书，越读越令人悲伤。至六十三回以后，便已无心漫卷，至七十八回以后，也就不想再读下去。</p>\n<p>要依我来见，六十二回即是红楼女儿绝唱，最后一次齐聚的宴欢，最后一次惬意的愉悦。湘云醉卧石上，竟让我恍惚觉得，一切还在半年以前，还在那个春天。</p>\n<p>但世事不复啊。自此以后，大观园中也只剩下了潇湘之悲戚，蘅芜之孤冷。司琴、入画、四儿、芳官、晴雯也一个个离开这如梦似幻的大观园，旧时的欢宴已经不存。贾母月圆夜宴，老人的心里，也知道一切恐也再难挽回，不如「人多些」，好聚好散。</p>\n<p>是啊。盛筵难久，万事终有离散的一天。</p>\n<hr>\n<p>要说读到五十余回，就已经有万千心绪。不知何时，许多原本只能在贾府边缘的许多小人物，竟也如此多在书中出现。似乎从那时往后，红楼一梦已经不再是儿女的情长，不是单纯的情娱与风月，而是家族的凝着血泪的真史。</p>\n<p>女孩，男孩们梦中的生活，怎么可能持久呢。红楼一题早就告诉你，这不过是「真事隐」，不过是「假语存」，不过是「温柔乡里的一场梦幻处」。殊不知，时年从十八回的元宵到六十回的春日，不过是一年轮回。但一年，一年也太长了。所有的事情，都变化了许多。</p>\n<blockquote>\n<p>「女孩子在没出嫁前像是一枚珍珠，而出嫁之后就变成了鱼眼珠一般」。</p>\n</blockquote>\n<p>红楼梦就在小姐们出嫁时戛然而止了。君不见王夫人的爽利，君不见贾母的风华，君不见宝钗小时的淘气。但时间呵，也许不曾带走什么，但却一定带给了他们无法抗拒的改变。</p>\n<p>不知道是不是在这个年龄，总会有意无意的把自己往主角的位置里带入，而这样也就更能体会到那种心有悲伤而不能语。</p>\n<blockquote>\n<p>「眼看他起朱楼， 眼看他宴宾客， 眼看他楼塌了。」</p>\n</blockquote>\n<p>就像这样吧。</p>\n<p>如果让我来选，我希望时间能够永远停在那一年的春夏。<br>停在并头读西厢。<br>停在葬花绝世吟。<br>停在海棠诗社起。<br>停在那虚幻而又美好，朦胧而又恬美的梦里。</p>\n<p>动情真的是，令人沉迷，也令人癫狂。</p>\n<p>「假作真时真亦假；无为有处有还无。」「身后有余忘缩手，眼前无路想回头」</p>\n<p>情也许就是这样吧。</p>\n<p><img src=\"lindaiyu.jpg\" alt=\"这里应该有一张图\"><br><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=29681666\" target=\"_blank\" rel=\"noopener\">Pixiv</a></em></p>"},{"title":"冬令营旅游记","date":"2018-01-25T10:38:19.000Z","visible":null,"urlname":"bjwc2018-trip","_content":"\n今年冬天，去了趟北京冬令营旅游。\n<!-- more -->\n其实本就没有抱着什么信心。NOIP只考了二等奖，好多提高组的基础知识都没有学完。但还是义无反顾的去了。也许早就知道会是这个样子。\n\n## Day1\n\n![](1.jpg)\n冬令营在北师大附中。虽然是去过的地方，然而还是十分迷茫的找啊找。第一天主要是颁奖仪式等等。第一次体会到如坐针毡的感觉。深刻的觉得，旁边的人哪个都好像那么巨，而自己，却是那么蒟蒻。生怕做错哪怕一点事情，而同班的OIer却还没有来冬令营。万幸，找到了几个看着还比较眼熟的，果然是同学。\n\n下午是胡伟栋老师的课，讲的是深搜。\n“这也许是某些人冬令营唯一能听懂的一节课。”或许就是我吧。讲的的确不难，而且还是蛮有趣的。果然很厉害呢。\n\n## Day2\n\n第一次考试。\n看到题瞬间懵逼。一道题都不会做呢。只好随便写了几个暴力骗分，发了条pyq之后就开始玩跳一跳。坐在我旁边的貌似是小学六年级。不得不感叹，年轻真好。如果能来五年冬令营还进不了省队，说什么我都不相信。祝他有光明的前途吧。\n\n下午开始讲题。\n首先看了看程序，40／400。被std十倍杀。不过也很正常。\n这天下午的讲课似乎还比较友善，好像主要讲了贪心和归纳的思想。我个人认为讲的还是不错的，我也忍住了，没有睡着。讲的例题我竟然也能听懂。不容易。\n![](2.jpg)\n\n## Day3\n\n第二天考试。\n\n还是一道题都不会。依旧是，暴力骗分然后就玩跳一跳。我现在也依然认为，如果冬令营再多几天，没准我的跳一跳水平还能有长足的进步。\n\n考完试才知道，第一道题原来只是有技巧的打表。果然还是too naive呢。不过同来的两位同学也没能做出后面的题，还是有了一点心理安慰的呢。不过最后只考了20分。扎心。\n\n下午讲的是国家集训队自选题。其实我都不记得讲的是什么了。只记得也是好难。无奈只好打起了世征。居然打过了一个征服。噫......\n\n回家居然水过了Treap，值得庆贺。\n\n## Day4\n\n第三天考试。今天竟然恍惚的以为自己做出来了一道贪心。然而我还是太天真。std竟是什么我都没有听说过的费用流。不过勉强骗到了30分还是50分。后面几道题接着无穷骗分，跳一跳。最后居然骗上了100分。不错不错。\n\n下午好像讲的是国家集训队的自选题。实在实在好难。听着听着实在听不懂，于是开始学上午考到的KMP。然而写了好久还没有写对。最后到家再写还是没有写对。最后发现把一个int数组不小心开成了char。我大概是个傻子吧。\n\n回家不知道为什么脑子抽风了，稀里糊涂的总共坐了四趟公交才到家。坐了好久都没坐过的无轨电车。终于体会到在冷风中瑟瑟发抖的等公交车的感觉。诶。回到家都一个半小时了。\n\n\n## Day5\n最后一天考试。\n\n一看到题，就觉得可以暴力打表。然并卵。调一个暴力程序调了一个小时才终于调对。然后打表两分钟。啧啧啧。后面第二道题最后半个小时才开始写，写了个暴力打表。然而最后只打到30分都不到。据说还有人查OEIS的？？？我怎么没想到？？？非常有趣。学习了一个新技能。最后一道题好像颇为吐槽。反正我也不会做。\n\n下午讲高精度，我也没听，也只是记得巨佬1300多行的高精度膜版。终于把第三道线段树的题给出完了。下午回家去坐了特4，一路坐着回家很excited。啧啧啧。\n\n\n## 啧啧\n![](3.jpg)\n\n总结一下吧。去了趟冬令营，考了四天试，得分250/1400。啧啧。某d姓人大概考了1000分吧。差距固然存在，也就告诉了我前进该向何方，到了什么程度才能算强者吧。\n\n和某人晚上谈论了一下。某人这一段时间好像经常听我的感慨吧，谢谢你。还吐槽了我的“强弱”标准。但的确是，每进入一个阶段，总会觉得自己很弱，而强者遥不可及。但尤其在我认真对待的OI里，目标的无望却真的有些让人绝望。OI在高考里不会考到，选择了这项，那是真的真的喜欢。但似乎真的有点晚了。\n\n省一看起来不像是难事，可省队，实在是遥不可及。\n\n如果不进队，那么竞赛好像用处也不是很大。可我毕竟选择它，除了竞赛，更多的也是喜欢吧。\n\n我永远都不会认输的。\n\n明年，再来。\n\n![](4.jpg)\n","source":"_posts/冬令营旅游记.md","raw":"---\ntitle: 冬令营旅游记\ndate: 2018-01-25 18:38:19\ntags:\n- 冬令营\ncategories: OI\nvisible:\nurlname: bjwc2018-trip\n---\n\n今年冬天，去了趟北京冬令营旅游。\n<!-- more -->\n其实本就没有抱着什么信心。NOIP只考了二等奖，好多提高组的基础知识都没有学完。但还是义无反顾的去了。也许早就知道会是这个样子。\n\n## Day1\n\n![](1.jpg)\n冬令营在北师大附中。虽然是去过的地方，然而还是十分迷茫的找啊找。第一天主要是颁奖仪式等等。第一次体会到如坐针毡的感觉。深刻的觉得，旁边的人哪个都好像那么巨，而自己，却是那么蒟蒻。生怕做错哪怕一点事情，而同班的OIer却还没有来冬令营。万幸，找到了几个看着还比较眼熟的，果然是同学。\n\n下午是胡伟栋老师的课，讲的是深搜。\n“这也许是某些人冬令营唯一能听懂的一节课。”或许就是我吧。讲的的确不难，而且还是蛮有趣的。果然很厉害呢。\n\n## Day2\n\n第一次考试。\n看到题瞬间懵逼。一道题都不会做呢。只好随便写了几个暴力骗分，发了条pyq之后就开始玩跳一跳。坐在我旁边的貌似是小学六年级。不得不感叹，年轻真好。如果能来五年冬令营还进不了省队，说什么我都不相信。祝他有光明的前途吧。\n\n下午开始讲题。\n首先看了看程序，40／400。被std十倍杀。不过也很正常。\n这天下午的讲课似乎还比较友善，好像主要讲了贪心和归纳的思想。我个人认为讲的还是不错的，我也忍住了，没有睡着。讲的例题我竟然也能听懂。不容易。\n![](2.jpg)\n\n## Day3\n\n第二天考试。\n\n还是一道题都不会。依旧是，暴力骗分然后就玩跳一跳。我现在也依然认为，如果冬令营再多几天，没准我的跳一跳水平还能有长足的进步。\n\n考完试才知道，第一道题原来只是有技巧的打表。果然还是too naive呢。不过同来的两位同学也没能做出后面的题，还是有了一点心理安慰的呢。不过最后只考了20分。扎心。\n\n下午讲的是国家集训队自选题。其实我都不记得讲的是什么了。只记得也是好难。无奈只好打起了世征。居然打过了一个征服。噫......\n\n回家居然水过了Treap，值得庆贺。\n\n## Day4\n\n第三天考试。今天竟然恍惚的以为自己做出来了一道贪心。然而我还是太天真。std竟是什么我都没有听说过的费用流。不过勉强骗到了30分还是50分。后面几道题接着无穷骗分，跳一跳。最后居然骗上了100分。不错不错。\n\n下午好像讲的是国家集训队的自选题。实在实在好难。听着听着实在听不懂，于是开始学上午考到的KMP。然而写了好久还没有写对。最后到家再写还是没有写对。最后发现把一个int数组不小心开成了char。我大概是个傻子吧。\n\n回家不知道为什么脑子抽风了，稀里糊涂的总共坐了四趟公交才到家。坐了好久都没坐过的无轨电车。终于体会到在冷风中瑟瑟发抖的等公交车的感觉。诶。回到家都一个半小时了。\n\n\n## Day5\n最后一天考试。\n\n一看到题，就觉得可以暴力打表。然并卵。调一个暴力程序调了一个小时才终于调对。然后打表两分钟。啧啧啧。后面第二道题最后半个小时才开始写，写了个暴力打表。然而最后只打到30分都不到。据说还有人查OEIS的？？？我怎么没想到？？？非常有趣。学习了一个新技能。最后一道题好像颇为吐槽。反正我也不会做。\n\n下午讲高精度，我也没听，也只是记得巨佬1300多行的高精度膜版。终于把第三道线段树的题给出完了。下午回家去坐了特4，一路坐着回家很excited。啧啧啧。\n\n\n## 啧啧\n![](3.jpg)\n\n总结一下吧。去了趟冬令营，考了四天试，得分250/1400。啧啧。某d姓人大概考了1000分吧。差距固然存在，也就告诉了我前进该向何方，到了什么程度才能算强者吧。\n\n和某人晚上谈论了一下。某人这一段时间好像经常听我的感慨吧，谢谢你。还吐槽了我的“强弱”标准。但的确是，每进入一个阶段，总会觉得自己很弱，而强者遥不可及。但尤其在我认真对待的OI里，目标的无望却真的有些让人绝望。OI在高考里不会考到，选择了这项，那是真的真的喜欢。但似乎真的有点晚了。\n\n省一看起来不像是难事，可省队，实在是遥不可及。\n\n如果不进队，那么竞赛好像用处也不是很大。可我毕竟选择它，除了竞赛，更多的也是喜欢吧。\n\n我永远都不会认输的。\n\n明年，再来。\n\n![](4.jpg)\n","slug":"冬令营旅游记","published":1,"updated":"2018-04-15T14:38:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mq006abljrpumvkeod","content":"<p>今年冬天，去了趟北京冬令营旅游。<br><a id=\"more\"></a><br>其实本就没有抱着什么信心。NOIP只考了二等奖，好多提高组的基础知识都没有学完。但还是义无反顾的去了。也许早就知道会是这个样子。</p>\n<h2 id=\"Day1\"><a href=\"#Day1\" class=\"headerlink\" title=\"Day1\"></a>Day1</h2><p><img src=\"1.jpg\" alt=\"\"><br>冬令营在北师大附中。虽然是去过的地方，然而还是十分迷茫的找啊找。第一天主要是颁奖仪式等等。第一次体会到如坐针毡的感觉。深刻的觉得，旁边的人哪个都好像那么巨，而自己，却是那么蒟蒻。生怕做错哪怕一点事情，而同班的OIer却还没有来冬令营。万幸，找到了几个看着还比较眼熟的，果然是同学。</p>\n<p>下午是胡伟栋老师的课，讲的是深搜。<br>“这也许是某些人冬令营唯一能听懂的一节课。”或许就是我吧。讲的的确不难，而且还是蛮有趣的。果然很厉害呢。</p>\n<h2 id=\"Day2\"><a href=\"#Day2\" class=\"headerlink\" title=\"Day2\"></a>Day2</h2><p>第一次考试。<br>看到题瞬间懵逼。一道题都不会做呢。只好随便写了几个暴力骗分，发了条pyq之后就开始玩跳一跳。坐在我旁边的貌似是小学六年级。不得不感叹，年轻真好。如果能来五年冬令营还进不了省队，说什么我都不相信。祝他有光明的前途吧。</p>\n<p>下午开始讲题。<br>首先看了看程序，40／400。被std十倍杀。不过也很正常。<br>这天下午的讲课似乎还比较友善，好像主要讲了贪心和归纳的思想。我个人认为讲的还是不错的，我也忍住了，没有睡着。讲的例题我竟然也能听懂。不容易。<br><img src=\"2.jpg\" alt=\"\"></p>\n<h2 id=\"Day3\"><a href=\"#Day3\" class=\"headerlink\" title=\"Day3\"></a>Day3</h2><p>第二天考试。</p>\n<p>还是一道题都不会。依旧是，暴力骗分然后就玩跳一跳。我现在也依然认为，如果冬令营再多几天，没准我的跳一跳水平还能有长足的进步。</p>\n<p>考完试才知道，第一道题原来只是有技巧的打表。果然还是too naive呢。不过同来的两位同学也没能做出后面的题，还是有了一点心理安慰的呢。不过最后只考了20分。扎心。</p>\n<p>下午讲的是国家集训队自选题。其实我都不记得讲的是什么了。只记得也是好难。无奈只好打起了世征。居然打过了一个征服。噫……</p>\n<p>回家居然水过了Treap，值得庆贺。</p>\n<h2 id=\"Day4\"><a href=\"#Day4\" class=\"headerlink\" title=\"Day4\"></a>Day4</h2><p>第三天考试。今天竟然恍惚的以为自己做出来了一道贪心。然而我还是太天真。std竟是什么我都没有听说过的费用流。不过勉强骗到了30分还是50分。后面几道题接着无穷骗分，跳一跳。最后居然骗上了100分。不错不错。</p>\n<p>下午好像讲的是国家集训队的自选题。实在实在好难。听着听着实在听不懂，于是开始学上午考到的KMP。然而写了好久还没有写对。最后到家再写还是没有写对。最后发现把一个int数组不小心开成了char。我大概是个傻子吧。</p>\n<p>回家不知道为什么脑子抽风了，稀里糊涂的总共坐了四趟公交才到家。坐了好久都没坐过的无轨电车。终于体会到在冷风中瑟瑟发抖的等公交车的感觉。诶。回到家都一个半小时了。</p>\n<h2 id=\"Day5\"><a href=\"#Day5\" class=\"headerlink\" title=\"Day5\"></a>Day5</h2><p>最后一天考试。</p>\n<p>一看到题，就觉得可以暴力打表。然并卵。调一个暴力程序调了一个小时才终于调对。然后打表两分钟。啧啧啧。后面第二道题最后半个小时才开始写，写了个暴力打表。然而最后只打到30分都不到。据说还有人查OEIS的？？？我怎么没想到？？？非常有趣。学习了一个新技能。最后一道题好像颇为吐槽。反正我也不会做。</p>\n<p>下午讲高精度，我也没听，也只是记得巨佬1300多行的高精度膜版。终于把第三道线段树的题给出完了。下午回家去坐了特4，一路坐着回家很excited。啧啧啧。</p>\n<h2 id=\"啧啧\"><a href=\"#啧啧\" class=\"headerlink\" title=\"啧啧\"></a>啧啧</h2><p><img src=\"3.jpg\" alt=\"\"></p>\n<p>总结一下吧。去了趟冬令营，考了四天试，得分250/1400。啧啧。某d姓人大概考了1000分吧。差距固然存在，也就告诉了我前进该向何方，到了什么程度才能算强者吧。</p>\n<p>和某人晚上谈论了一下。某人这一段时间好像经常听我的感慨吧，谢谢你。还吐槽了我的“强弱”标准。但的确是，每进入一个阶段，总会觉得自己很弱，而强者遥不可及。但尤其在我认真对待的OI里，目标的无望却真的有些让人绝望。OI在高考里不会考到，选择了这项，那是真的真的喜欢。但似乎真的有点晚了。</p>\n<p>省一看起来不像是难事，可省队，实在是遥不可及。</p>\n<p>如果不进队，那么竞赛好像用处也不是很大。可我毕竟选择它，除了竞赛，更多的也是喜欢吧。</p>\n<p>我永远都不会认输的。</p>\n<p>明年，再来。</p>\n<p><img src=\"4.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>今年冬天，去了趟北京冬令营旅游。<br>","more":"<br>其实本就没有抱着什么信心。NOIP只考了二等奖，好多提高组的基础知识都没有学完。但还是义无反顾的去了。也许早就知道会是这个样子。</p>\n<h2 id=\"Day1\"><a href=\"#Day1\" class=\"headerlink\" title=\"Day1\"></a>Day1</h2><p><img src=\"1.jpg\" alt=\"\"><br>冬令营在北师大附中。虽然是去过的地方，然而还是十分迷茫的找啊找。第一天主要是颁奖仪式等等。第一次体会到如坐针毡的感觉。深刻的觉得，旁边的人哪个都好像那么巨，而自己，却是那么蒟蒻。生怕做错哪怕一点事情，而同班的OIer却还没有来冬令营。万幸，找到了几个看着还比较眼熟的，果然是同学。</p>\n<p>下午是胡伟栋老师的课，讲的是深搜。<br>“这也许是某些人冬令营唯一能听懂的一节课。”或许就是我吧。讲的的确不难，而且还是蛮有趣的。果然很厉害呢。</p>\n<h2 id=\"Day2\"><a href=\"#Day2\" class=\"headerlink\" title=\"Day2\"></a>Day2</h2><p>第一次考试。<br>看到题瞬间懵逼。一道题都不会做呢。只好随便写了几个暴力骗分，发了条pyq之后就开始玩跳一跳。坐在我旁边的貌似是小学六年级。不得不感叹，年轻真好。如果能来五年冬令营还进不了省队，说什么我都不相信。祝他有光明的前途吧。</p>\n<p>下午开始讲题。<br>首先看了看程序，40／400。被std十倍杀。不过也很正常。<br>这天下午的讲课似乎还比较友善，好像主要讲了贪心和归纳的思想。我个人认为讲的还是不错的，我也忍住了，没有睡着。讲的例题我竟然也能听懂。不容易。<br><img src=\"2.jpg\" alt=\"\"></p>\n<h2 id=\"Day3\"><a href=\"#Day3\" class=\"headerlink\" title=\"Day3\"></a>Day3</h2><p>第二天考试。</p>\n<p>还是一道题都不会。依旧是，暴力骗分然后就玩跳一跳。我现在也依然认为，如果冬令营再多几天，没准我的跳一跳水平还能有长足的进步。</p>\n<p>考完试才知道，第一道题原来只是有技巧的打表。果然还是too naive呢。不过同来的两位同学也没能做出后面的题，还是有了一点心理安慰的呢。不过最后只考了20分。扎心。</p>\n<p>下午讲的是国家集训队自选题。其实我都不记得讲的是什么了。只记得也是好难。无奈只好打起了世征。居然打过了一个征服。噫……</p>\n<p>回家居然水过了Treap，值得庆贺。</p>\n<h2 id=\"Day4\"><a href=\"#Day4\" class=\"headerlink\" title=\"Day4\"></a>Day4</h2><p>第三天考试。今天竟然恍惚的以为自己做出来了一道贪心。然而我还是太天真。std竟是什么我都没有听说过的费用流。不过勉强骗到了30分还是50分。后面几道题接着无穷骗分，跳一跳。最后居然骗上了100分。不错不错。</p>\n<p>下午好像讲的是国家集训队的自选题。实在实在好难。听着听着实在听不懂，于是开始学上午考到的KMP。然而写了好久还没有写对。最后到家再写还是没有写对。最后发现把一个int数组不小心开成了char。我大概是个傻子吧。</p>\n<p>回家不知道为什么脑子抽风了，稀里糊涂的总共坐了四趟公交才到家。坐了好久都没坐过的无轨电车。终于体会到在冷风中瑟瑟发抖的等公交车的感觉。诶。回到家都一个半小时了。</p>\n<h2 id=\"Day5\"><a href=\"#Day5\" class=\"headerlink\" title=\"Day5\"></a>Day5</h2><p>最后一天考试。</p>\n<p>一看到题，就觉得可以暴力打表。然并卵。调一个暴力程序调了一个小时才终于调对。然后打表两分钟。啧啧啧。后面第二道题最后半个小时才开始写，写了个暴力打表。然而最后只打到30分都不到。据说还有人查OEIS的？？？我怎么没想到？？？非常有趣。学习了一个新技能。最后一道题好像颇为吐槽。反正我也不会做。</p>\n<p>下午讲高精度，我也没听，也只是记得巨佬1300多行的高精度膜版。终于把第三道线段树的题给出完了。下午回家去坐了特4，一路坐着回家很excited。啧啧啧。</p>\n<h2 id=\"啧啧\"><a href=\"#啧啧\" class=\"headerlink\" title=\"啧啧\"></a>啧啧</h2><p><img src=\"3.jpg\" alt=\"\"></p>\n<p>总结一下吧。去了趟冬令营，考了四天试，得分250/1400。啧啧。某d姓人大概考了1000分吧。差距固然存在，也就告诉了我前进该向何方，到了什么程度才能算强者吧。</p>\n<p>和某人晚上谈论了一下。某人这一段时间好像经常听我的感慨吧，谢谢你。还吐槽了我的“强弱”标准。但的确是，每进入一个阶段，总会觉得自己很弱，而强者遥不可及。但尤其在我认真对待的OI里，目标的无望却真的有些让人绝望。OI在高考里不会考到，选择了这项，那是真的真的喜欢。但似乎真的有点晚了。</p>\n<p>省一看起来不像是难事，可省队，实在是遥不可及。</p>\n<p>如果不进队，那么竞赛好像用处也不是很大。可我毕竟选择它，除了竞赛，更多的也是喜欢吧。</p>\n<p>我永远都不会认输的。</p>\n<p>明年，再来。</p>\n<p><img src=\"4.jpg\" alt=\"\"></p>"},{"title":"可持久化线段树学习笔记","urlname":"prSegTree-note","date":"2018-05-24T12:37:53.000Z","visible":null,"_content":"\n可持久化线段树，是一种可以进行可持久化操作的线段树，具有优越的时间复杂度。\n\n<!-- more -->\n\n## 线段树\n\n相信看这篇文章的人很熟悉什么是线段树了，就不在这里胡扯了。\n\n![](segtree.png)\n\n如上就是线段树的基本结构。\n\n## 可持久化？\n\n简单来说，可持久化就是能够在修改的时候，保留下原来的数据结构的样子的一种数据结构。比如说，对于上图，如果线段树维护的是区间和，这个时候我们要修改某个数的大小，就会使一条链上的信息全部改变，并且我们失去了这次修改之前的线段树的信息。\n\n那么对于线段树来说，怎么样才能做到可持久化呢？\n\n### 可持久化的思路\n\n假设这个线段树维护的是区间和。\n\n一种非常简单的思路：为了维护修改之前的信息，每次修改我重新建一棵线段树不就好了？？？但是如果仔细想一想，建一棵线段树的时间复杂度是O(n)，空间复杂度O(n)，如果有n次修改，最后的时间复杂度O(n^2)，空间复杂度也是O(n^2)，GG。\n\n![](segtree1.png)\n\n观察上图，显然可以**发现单点修改会改变的只会有这一条链上的节点的值**，所以我们就会自然想到，能不能只维护这一条链呢？\n\n![](segtree2.png)\n\n但是单独维护一条链很傻，而且很多线段树上的操作进行起来也很复杂。所以可以把这条链嵌到线段树上，比如我们修改位置4，那么修改出来的链就是红色节点，而我们也需要把它其他的地方连到原来的线段树上。\n\n这个时候，我们就发现只要我们掌握着根结点，我们就可以当所有其他线段树都是不存在的一样，做普通线段树的查询操作。\n\n主要的可持久化操作的思想大概如上。总结来说的话，就是只更改需要更改的部分，其他的不管它，保持树形结构完整性就可以了。其他的可持久化数据结构如可持久化Trie树和平衡树，思想都是类似的。\n\n分析一下的话，上例子里总共有m次修改的话，每次修改创建出的新节点都是一条完整的长度为O(\\log n)的链，每次修改或者查询，时间复杂度都是O(\\log{n})。最后空间复杂度是O(n \\log{n})，时间复杂度也是O(n \\log{n})。\n\n### 具体实现\n\n具体来说，可持久化数据结构一般推荐用数组模拟指针来实现。首先是因为数组的代码写起来很短很快，其次还有就是指针的大小目前一般是8字节，比一个整数大了一倍，在一些题目中可能被卡内存。\n\n对于可持久化线段树来说，实现跟普通线段树有微小的一点不同。（废话\n\n首先，在节点的数目上，我们需要开n\\log n数目的节点，**这个很容易忘记**。我们还需要显性的记录每个节点的左儿子和右儿子，和一些其他你要维护的信息。\n\n在修改操作上，有一些不同。\n\n具体来说如下：\n\n1. 复制原来节点，成为一个新的当前节点\n2. 往需要更改的位置（左／右儿子）更新\n\n这里的修改中的原来节点就是原来同一个位置的节点，而需要新建一个节点，所以这个地方当前节点需要传一个引用，具体到后面可以看一看代码，理解的会更好。\n\n查询操作就一模一样啦。\n\n## 应用\n\n非常强大。\n\n### 可持久化数组、并查集\n\n可持久化数组可以说是最简单的应用了。就是一个模板，套上就好。\n\n### 主席树\n\n#### 静态第k大问题\n\n#### 动态第k大问题\n\n#### 树上第k大、维护值域\n\n### 其他奇怪应用\n\n## 例题\n\nTBD。","source":"_posts/可持久化线段树学习笔记.md","raw":"---\ntitle: 可持久化线段树学习笔记\nurlname: prSegTree-note\ndate: 2018-05-24 20:37:53\ntags:\n- 笔记\n- 可持久化线段树\n- 主席树\n- 数据结构\ncategories: OI\nvisible:\n---\n\n可持久化线段树，是一种可以进行可持久化操作的线段树，具有优越的时间复杂度。\n\n<!-- more -->\n\n## 线段树\n\n相信看这篇文章的人很熟悉什么是线段树了，就不在这里胡扯了。\n\n![](segtree.png)\n\n如上就是线段树的基本结构。\n\n## 可持久化？\n\n简单来说，可持久化就是能够在修改的时候，保留下原来的数据结构的样子的一种数据结构。比如说，对于上图，如果线段树维护的是区间和，这个时候我们要修改某个数的大小，就会使一条链上的信息全部改变，并且我们失去了这次修改之前的线段树的信息。\n\n那么对于线段树来说，怎么样才能做到可持久化呢？\n\n### 可持久化的思路\n\n假设这个线段树维护的是区间和。\n\n一种非常简单的思路：为了维护修改之前的信息，每次修改我重新建一棵线段树不就好了？？？但是如果仔细想一想，建一棵线段树的时间复杂度是O(n)，空间复杂度O(n)，如果有n次修改，最后的时间复杂度O(n^2)，空间复杂度也是O(n^2)，GG。\n\n![](segtree1.png)\n\n观察上图，显然可以**发现单点修改会改变的只会有这一条链上的节点的值**，所以我们就会自然想到，能不能只维护这一条链呢？\n\n![](segtree2.png)\n\n但是单独维护一条链很傻，而且很多线段树上的操作进行起来也很复杂。所以可以把这条链嵌到线段树上，比如我们修改位置4，那么修改出来的链就是红色节点，而我们也需要把它其他的地方连到原来的线段树上。\n\n这个时候，我们就发现只要我们掌握着根结点，我们就可以当所有其他线段树都是不存在的一样，做普通线段树的查询操作。\n\n主要的可持久化操作的思想大概如上。总结来说的话，就是只更改需要更改的部分，其他的不管它，保持树形结构完整性就可以了。其他的可持久化数据结构如可持久化Trie树和平衡树，思想都是类似的。\n\n分析一下的话，上例子里总共有m次修改的话，每次修改创建出的新节点都是一条完整的长度为O(\\log n)的链，每次修改或者查询，时间复杂度都是O(\\log{n})。最后空间复杂度是O(n \\log{n})，时间复杂度也是O(n \\log{n})。\n\n### 具体实现\n\n具体来说，可持久化数据结构一般推荐用数组模拟指针来实现。首先是因为数组的代码写起来很短很快，其次还有就是指针的大小目前一般是8字节，比一个整数大了一倍，在一些题目中可能被卡内存。\n\n对于可持久化线段树来说，实现跟普通线段树有微小的一点不同。（废话\n\n首先，在节点的数目上，我们需要开n\\log n数目的节点，**这个很容易忘记**。我们还需要显性的记录每个节点的左儿子和右儿子，和一些其他你要维护的信息。\n\n在修改操作上，有一些不同。\n\n具体来说如下：\n\n1. 复制原来节点，成为一个新的当前节点\n2. 往需要更改的位置（左／右儿子）更新\n\n这里的修改中的原来节点就是原来同一个位置的节点，而需要新建一个节点，所以这个地方当前节点需要传一个引用，具体到后面可以看一看代码，理解的会更好。\n\n查询操作就一模一样啦。\n\n## 应用\n\n非常强大。\n\n### 可持久化数组、并查集\n\n可持久化数组可以说是最简单的应用了。就是一个模板，套上就好。\n\n### 主席树\n\n#### 静态第k大问题\n\n#### 动态第k大问题\n\n#### 树上第k大、维护值域\n\n### 其他奇怪应用\n\n## 例题\n\nTBD。","slug":"可持久化线段树学习笔记","published":1,"updated":"2018-06-07T15:05:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mr006cbljrxxlhlgo8","content":"<p>可持久化线段树，是一种可以进行可持久化操作的线段树，具有优越的时间复杂度。</p>\n<a id=\"more\"></a>\n<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><p>相信看这篇文章的人很熟悉什么是线段树了，就不在这里胡扯了。</p>\n<p><img src=\"segtree.png\" alt=\"\"></p>\n<p>如上就是线段树的基本结构。</p>\n<h2 id=\"可持久化？\"><a href=\"#可持久化？\" class=\"headerlink\" title=\"可持久化？\"></a>可持久化？</h2><p>简单来说，可持久化就是能够在修改的时候，保留下原来的数据结构的样子的一种数据结构。比如说，对于上图，如果线段树维护的是区间和，这个时候我们要修改某个数的大小，就会使一条链上的信息全部改变，并且我们失去了这次修改之前的线段树的信息。</p>\n<p>那么对于线段树来说，怎么样才能做到可持久化呢？</p>\n<h3 id=\"可持久化的思路\"><a href=\"#可持久化的思路\" class=\"headerlink\" title=\"可持久化的思路\"></a>可持久化的思路</h3><p>假设这个线段树维护的是区间和。</p>\n<p>一种非常简单的思路：为了维护修改之前的信息，每次修改我重新建一棵线段树不就好了？？？但是如果仔细想一想，建一棵线段树的时间复杂度是O(n)，空间复杂度O(n)，如果有n次修改，最后的时间复杂度O(n^2)，空间复杂度也是O(n^2)，GG。</p>\n<p><img src=\"segtree1.png\" alt=\"\"></p>\n<p>观察上图，显然可以<strong>发现单点修改会改变的只会有这一条链上的节点的值</strong>，所以我们就会自然想到，能不能只维护这一条链呢？</p>\n<p><img src=\"segtree2.png\" alt=\"\"></p>\n<p>但是单独维护一条链很傻，而且很多线段树上的操作进行起来也很复杂。所以可以把这条链嵌到线段树上，比如我们修改位置4，那么修改出来的链就是红色节点，而我们也需要把它其他的地方连到原来的线段树上。</p>\n<p>这个时候，我们就发现只要我们掌握着根结点，我们就可以当所有其他线段树都是不存在的一样，做普通线段树的查询操作。</p>\n<p>主要的可持久化操作的思想大概如上。总结来说的话，就是只更改需要更改的部分，其他的不管它，保持树形结构完整性就可以了。其他的可持久化数据结构如可持久化Trie树和平衡树，思想都是类似的。</p>\n<p>分析一下的话，上例子里总共有m次修改的话，每次修改创建出的新节点都是一条完整的长度为O(\\log n)的链，每次修改或者查询，时间复杂度都是O(\\log{n})。最后空间复杂度是O(n \\log{n})，时间复杂度也是O(n \\log{n})。</p>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>具体来说，可持久化数据结构一般推荐用数组模拟指针来实现。首先是因为数组的代码写起来很短很快，其次还有就是指针的大小目前一般是8字节，比一个整数大了一倍，在一些题目中可能被卡内存。</p>\n<p>对于可持久化线段树来说，实现跟普通线段树有微小的一点不同。（废话</p>\n<p>首先，在节点的数目上，我们需要开n\\log n数目的节点，<strong>这个很容易忘记</strong>。我们还需要显性的记录每个节点的左儿子和右儿子，和一些其他你要维护的信息。</p>\n<p>在修改操作上，有一些不同。</p>\n<p>具体来说如下：</p>\n<ol>\n<li>复制原来节点，成为一个新的当前节点</li>\n<li>往需要更改的位置（左／右儿子）更新</li>\n</ol>\n<p>这里的修改中的原来节点就是原来同一个位置的节点，而需要新建一个节点，所以这个地方当前节点需要传一个引用，具体到后面可以看一看代码，理解的会更好。</p>\n<p>查询操作就一模一样啦。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>非常强大。</p>\n<h3 id=\"可持久化数组、并查集\"><a href=\"#可持久化数组、并查集\" class=\"headerlink\" title=\"可持久化数组、并查集\"></a>可持久化数组、并查集</h3><p>可持久化数组可以说是最简单的应用了。就是一个模板，套上就好。</p>\n<h3 id=\"主席树\"><a href=\"#主席树\" class=\"headerlink\" title=\"主席树\"></a>主席树</h3><h4 id=\"静态第k大问题\"><a href=\"#静态第k大问题\" class=\"headerlink\" title=\"静态第k大问题\"></a>静态第k大问题</h4><h4 id=\"动态第k大问题\"><a href=\"#动态第k大问题\" class=\"headerlink\" title=\"动态第k大问题\"></a>动态第k大问题</h4><h4 id=\"树上第k大、维护值域\"><a href=\"#树上第k大、维护值域\" class=\"headerlink\" title=\"树上第k大、维护值域\"></a>树上第k大、维护值域</h4><h3 id=\"其他奇怪应用\"><a href=\"#其他奇怪应用\" class=\"headerlink\" title=\"其他奇怪应用\"></a>其他奇怪应用</h3><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>TBD。</p>\n","site":{"data":{}},"excerpt":"<p>可持久化线段树，是一种可以进行可持久化操作的线段树，具有优越的时间复杂度。</p>","more":"<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><p>相信看这篇文章的人很熟悉什么是线段树了，就不在这里胡扯了。</p>\n<p><img src=\"segtree.png\" alt=\"\"></p>\n<p>如上就是线段树的基本结构。</p>\n<h2 id=\"可持久化？\"><a href=\"#可持久化？\" class=\"headerlink\" title=\"可持久化？\"></a>可持久化？</h2><p>简单来说，可持久化就是能够在修改的时候，保留下原来的数据结构的样子的一种数据结构。比如说，对于上图，如果线段树维护的是区间和，这个时候我们要修改某个数的大小，就会使一条链上的信息全部改变，并且我们失去了这次修改之前的线段树的信息。</p>\n<p>那么对于线段树来说，怎么样才能做到可持久化呢？</p>\n<h3 id=\"可持久化的思路\"><a href=\"#可持久化的思路\" class=\"headerlink\" title=\"可持久化的思路\"></a>可持久化的思路</h3><p>假设这个线段树维护的是区间和。</p>\n<p>一种非常简单的思路：为了维护修改之前的信息，每次修改我重新建一棵线段树不就好了？？？但是如果仔细想一想，建一棵线段树的时间复杂度是O(n)，空间复杂度O(n)，如果有n次修改，最后的时间复杂度O(n^2)，空间复杂度也是O(n^2)，GG。</p>\n<p><img src=\"segtree1.png\" alt=\"\"></p>\n<p>观察上图，显然可以<strong>发现单点修改会改变的只会有这一条链上的节点的值</strong>，所以我们就会自然想到，能不能只维护这一条链呢？</p>\n<p><img src=\"segtree2.png\" alt=\"\"></p>\n<p>但是单独维护一条链很傻，而且很多线段树上的操作进行起来也很复杂。所以可以把这条链嵌到线段树上，比如我们修改位置4，那么修改出来的链就是红色节点，而我们也需要把它其他的地方连到原来的线段树上。</p>\n<p>这个时候，我们就发现只要我们掌握着根结点，我们就可以当所有其他线段树都是不存在的一样，做普通线段树的查询操作。</p>\n<p>主要的可持久化操作的思想大概如上。总结来说的话，就是只更改需要更改的部分，其他的不管它，保持树形结构完整性就可以了。其他的可持久化数据结构如可持久化Trie树和平衡树，思想都是类似的。</p>\n<p>分析一下的话，上例子里总共有m次修改的话，每次修改创建出的新节点都是一条完整的长度为O(\\log n)的链，每次修改或者查询，时间复杂度都是O(\\log{n})。最后空间复杂度是O(n \\log{n})，时间复杂度也是O(n \\log{n})。</p>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>具体来说，可持久化数据结构一般推荐用数组模拟指针来实现。首先是因为数组的代码写起来很短很快，其次还有就是指针的大小目前一般是8字节，比一个整数大了一倍，在一些题目中可能被卡内存。</p>\n<p>对于可持久化线段树来说，实现跟普通线段树有微小的一点不同。（废话</p>\n<p>首先，在节点的数目上，我们需要开n\\log n数目的节点，<strong>这个很容易忘记</strong>。我们还需要显性的记录每个节点的左儿子和右儿子，和一些其他你要维护的信息。</p>\n<p>在修改操作上，有一些不同。</p>\n<p>具体来说如下：</p>\n<ol>\n<li>复制原来节点，成为一个新的当前节点</li>\n<li>往需要更改的位置（左／右儿子）更新</li>\n</ol>\n<p>这里的修改中的原来节点就是原来同一个位置的节点，而需要新建一个节点，所以这个地方当前节点需要传一个引用，具体到后面可以看一看代码，理解的会更好。</p>\n<p>查询操作就一模一样啦。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><p>非常强大。</p>\n<h3 id=\"可持久化数组、并查集\"><a href=\"#可持久化数组、并查集\" class=\"headerlink\" title=\"可持久化数组、并查集\"></a>可持久化数组、并查集</h3><p>可持久化数组可以说是最简单的应用了。就是一个模板，套上就好。</p>\n<h3 id=\"主席树\"><a href=\"#主席树\" class=\"headerlink\" title=\"主席树\"></a>主席树</h3><h4 id=\"静态第k大问题\"><a href=\"#静态第k大问题\" class=\"headerlink\" title=\"静态第k大问题\"></a>静态第k大问题</h4><h4 id=\"动态第k大问题\"><a href=\"#动态第k大问题\" class=\"headerlink\" title=\"动态第k大问题\"></a>动态第k大问题</h4><h4 id=\"树上第k大、维护值域\"><a href=\"#树上第k大、维护值域\" class=\"headerlink\" title=\"树上第k大、维护值域\"></a>树上第k大、维护值域</h4><h3 id=\"其他奇怪应用\"><a href=\"#其他奇怪应用\" class=\"headerlink\" title=\"其他奇怪应用\"></a>其他奇怪应用</h3><h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p>TBD。</p>"},{"title":"新高考？不过是换一种套路的折磨","urlname":"gaokao","date":"2018-05-24T14:57:35.000Z","visible":null,"_content":"\n北京市从2020年高考起，将全面铺开新高考“3+3”改革。\n\n> 2018年5月30日，选科即将来临。\n\n不管从哪个角度来说，新高考的改革都不是减负，而是换一种套路的折磨。\n\n<!-- more -->\n\nupd：2018.6.2\n\n曾经在这里写了很多。但现在想想，还是有点过分天真了。\n\n学校有它的打算，而人心则是各异。\n\n如今尘埃落定，一切留待两年后去评说。\n\n而我既然选择了远方，就应在后五个月，更加奋勇而前行。\n","source":"_posts/新高考？不过是换一种套路的折磨.md","raw":"---\ntitle: 新高考？不过是换一种套路的折磨\nurlname: gaokao\ndate: 2018-05-24 22:57:35\ntags:\ncategories: 随笔\nvisible:\n---\n\n北京市从2020年高考起，将全面铺开新高考“3+3”改革。\n\n> 2018年5月30日，选科即将来临。\n\n不管从哪个角度来说，新高考的改革都不是减负，而是换一种套路的折磨。\n\n<!-- more -->\n\nupd：2018.6.2\n\n曾经在这里写了很多。但现在想想，还是有点过分天真了。\n\n学校有它的打算，而人心则是各异。\n\n如今尘埃落定，一切留待两年后去评说。\n\n而我既然选择了远方，就应在后五个月，更加奋勇而前行。\n","slug":"新高考？不过是换一种套路的折磨","published":1,"updated":"2018-06-02T14:25:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mt006fbljrstxwbr7e","content":"<p>北京市从2020年高考起，将全面铺开新高考“3+3”改革。</p>\n<blockquote>\n<p>2018年5月30日，选科即将来临。</p>\n</blockquote>\n<p>不管从哪个角度来说，新高考的改革都不是减负，而是换一种套路的折磨。</p>\n<a id=\"more\"></a>\n<p>upd：2018.6.2</p>\n<p>曾经在这里写了很多。但现在想想，还是有点过分天真了。</p>\n<p>学校有它的打算，而人心则是各异。</p>\n<p>如今尘埃落定，一切留待两年后去评说。</p>\n<p>而我既然选择了远方，就应在后五个月，更加奋勇而前行。</p>\n","site":{"data":{}},"excerpt":"<p>北京市从2020年高考起，将全面铺开新高考“3+3”改革。</p>\n<blockquote>\n<p>2018年5月30日，选科即将来临。</p>\n</blockquote>\n<p>不管从哪个角度来说，新高考的改革都不是减负，而是换一种套路的折磨。</p>","more":"<p>upd：2018.6.2</p>\n<p>曾经在这里写了很多。但现在想想，还是有点过分天真了。</p>\n<p>学校有它的打算，而人心则是各异。</p>\n<p>如今尘埃落定，一切留待两年后去评说。</p>\n<p>而我既然选择了远方，就应在后五个月，更加奋勇而前行。</p>"},{"title":"日常颓废","date":"2017-12-05T12:51:27.000Z","urlname":20171205,"_content":"\n## 颓...颓废？？？\n<!-- more -->\n\n啧啧。今天真的来写一写吧。明天也许是周三了吧（捂脸），久违的统练就要来了呢。\n\n但一不小心就又开始了日常颓废。先是生物练习册错一大堆，数学练习册错一大堆。看了看背后正在落灰的算法导论。不是很令人开心的一天。\n不过今天达成了一个成就，把同桌成功拉去打了一会乒乓球。非常的有趣。\n\n愿明天生物统练不爆炸。\n","source":"_posts/日常颓废.md","raw":"---\ntitle: 日常颓废\ndate: 2017-12-05 20:51:27\ncategories: 日常\nurlname: 20171205\n---\n\n## 颓...颓废？？？\n<!-- more -->\n\n啧啧。今天真的来写一写吧。明天也许是周三了吧（捂脸），久违的统练就要来了呢。\n\n但一不小心就又开始了日常颓废。先是生物练习册错一大堆，数学练习册错一大堆。看了看背后正在落灰的算法导论。不是很令人开心的一天。\n不过今天达成了一个成就，把同桌成功拉去打了一会乒乓球。非常的有趣。\n\n愿明天生物统练不爆炸。\n","slug":"日常颓废","published":1,"updated":"2018-03-03T13:02:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mu006hbljrl6o8m74n","content":"<h2 id=\"颓…颓废？？？\"><a href=\"#颓…颓废？？？\" class=\"headerlink\" title=\"颓…颓废？？？\"></a>颓…颓废？？？</h2><a id=\"more\"></a>\n<p>啧啧。今天真的来写一写吧。明天也许是周三了吧（捂脸），久违的统练就要来了呢。</p>\n<p>但一不小心就又开始了日常颓废。先是生物练习册错一大堆，数学练习册错一大堆。看了看背后正在落灰的算法导论。不是很令人开心的一天。<br>不过今天达成了一个成就，把同桌成功拉去打了一会乒乓球。非常的有趣。</p>\n<p>愿明天生物统练不爆炸。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"颓…颓废？？？\"><a href=\"#颓…颓废？？？\" class=\"headerlink\" title=\"颓…颓废？？？\"></a>颓…颓废？？？</h2>","more":"<p>啧啧。今天真的来写一写吧。明天也许是周三了吧（捂脸），久违的统练就要来了呢。</p>\n<p>但一不小心就又开始了日常颓废。先是生物练习册错一大堆，数学练习册错一大堆。看了看背后正在落灰的算法导论。不是很令人开心的一天。<br>不过今天达成了一个成就，把同桌成功拉去打了一会乒乓球。非常的有趣。</p>\n<p>愿明天生物统练不爆炸。</p>"},{"title":"测试一下","date":"2017-12-04T11:51:00.000Z","urlname":"test","_content":"## 第一篇文章\n\n或许这就是我的第一篇文章了？？？\n<!--more-->\n\n瞎搞一番果然颇有乐趣哈哈哈哈.以后不定期更新题解和算法什么乱七八糟的{% spoiler 没准也有我的吐槽哈哈哈。%}\n","source":"_posts/测试一下.md","raw":"---\ntitle: 测试一下\ndate: 2017-12-04 19:51:00\ncategories:\nurlname: test\n---\n## 第一篇文章\n\n或许这就是我的第一篇文章了？？？\n<!--more-->\n\n瞎搞一番果然颇有乐趣哈哈哈哈.以后不定期更新题解和算法什么乱七八糟的{% spoiler 没准也有我的吐槽哈哈哈。%}\n","slug":"测试一下","published":1,"updated":"2018-03-03T13:02:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3mw006kbljr7df6scq6","content":"<h2 id=\"&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\"><a href=\"#&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\" class=\"headerlink\" title=\"&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\"></a>&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;</h2><p>&#x6216;&#x8BB8;&#x8FD9;&#x5C31;&#x662F;&#x6211;&#x7684;&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x4E86;&#xFF1F;&#xFF1F;&#xFF1F;<br><a id=\"more\"></a></p>\n<p>&#x778E;&#x641E;&#x4E00;&#x756A;&#x679C;&#x7136;&#x9887;&#x6709;&#x4E50;&#x8DA3;&#x54C8;&#x54C8;&#x54C8;&#x54C8;.&#x4EE5;&#x540E;&#x4E0D;&#x5B9A;&#x671F;&#x66F4;&#x65B0;&#x9898;&#x89E3;&#x548C;&#x7B97;&#x6CD5;&#x4EC0;&#x4E48;&#x4E71;&#x4E03;&#x516B;&#x7CDF;&#x7684;<span class=\"spoiler\">&#x6CA1;&#x51C6;&#x4E5F;&#x6709;&#x6211;&#x7684;&#x5410;&#x69FD;&#x54C8;&#x54C8;&#x54C8;&#x3002;\n</span></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\"><a href=\"#&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\" class=\"headerlink\" title=\"&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;\"></a>&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;</h2><p>&#x6216;&#x8BB8;&#x8FD9;&#x5C31;&#x662F;&#x6211;&#x7684;&#x7B2C;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x4E86;&#xFF1F;&#xFF1F;&#xFF1F;<br>","more":"</p>\n<p>&#x778E;&#x641E;&#x4E00;&#x756A;&#x679C;&#x7136;&#x9887;&#x6709;&#x4E50;&#x8DA3;&#x54C8;&#x54C8;&#x54C8;&#x54C8;.&#x4EE5;&#x540E;&#x4E0D;&#x5B9A;&#x671F;&#x66F4;&#x65B0;&#x9898;&#x89E3;&#x548C;&#x7B97;&#x6CD5;&#x4EC0;&#x4E48;&#x4E71;&#x4E03;&#x516B;&#x7CDF;&#x7684;<span class=\"spoiler\">&#x6CA1;&#x51C6;&#x4E5F;&#x6709;&#x6211;&#x7684;&#x5410;&#x69FD;&#x54C8;&#x54C8;&#x54C8;&#x3002;\n</span></p>"},{"title":"点分治学习笔记","urlname":"point-DC-notes","date":"2018-04-22T05:14:04.000Z","visible":null,"_content":"\n\n点分治是一种主要在树上的分治，可以在解决一些树上特定条件的路径的问题。其复杂度与大部分分治类似，大概是$O(K \\; \\log{n})$（$K$为除分治步骤之外的时间复杂度的多项式）。\n\n<!-- more -->\n\n## 简介\n\n点分治感性的来说，其实就需要考虑一件事情：如何把树上路径问题转换成过根结点的路径问题。\n\n**定理:树上所有的路径可以分为过根结点的路径和不过根结点的路径。**\n\n对于根结点来说，我们处理完过根结点的路径，剩下所有的路径都不会过根结点了。所以我们可以把根节点和与根结点相连的边均删掉，然后对于新产生的子树，剩下的路径应该都在其中，就可以对子树进行分治处理。\n\n## 实现\n\n主要是三个函数：`solve`，`work`，`getroot`。\n\n### `solve`\n\nsolve函数，也就是主要函数，是一个递归解决问题的过程。\n\n每一次都先把这个点标记成已经访问过，然后对于这个点去寻找\n\n代码如下：\n\n```cpp\nvoid solve(int nown){\n    work(nown);\n    vis[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];//初始化rt\n        getroot(v,rt);//找到该子树的重心\n        solve(rt);//递归解决问题\n    }\n}\n```\n\n### `work`\n\n`work`函数就是完成对于当前的子树中所有过根的节点的处理。这个函数没有具体的样子，因题而异。\n\n照我目前的理解，主要的思路就是：dfs，想办法拼起来两条同时过根节点而且端点不在一个子树里面的节点。\n\n### `getroot`\n\n首先，为了保证我们分出去的子树的规模尽量的一致，我们每次都需要把当前的树的重心作为根节点，然后完成上段所述的事情。\n\n在这里，寻找重心其实就是找哪个点作根的时候剩下的最大子树的大小最小...代码如下：\n\n```cpp\n//vis==1 代表已经处理过（不在当前子树中）\n//f[nown] 储存这个点作根时剩下的最大子树的大小\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]);\n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n```\n\n不是很难。\n\n## 代码\n\n以[Luogu P3806](https://www.luogu.org/problemnew/show/P3806) 为例。\n（其实这个题...比模版还是要多一些的...复杂度是 $O(n \\log{n} \\log{n})$\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 110000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nstruct Edge{\n    int from,to;\n    int len,nex;\n}edge[MAXN];\nint ecnt = 1;int fir[MAXN];\nvoid addedge(int a,int b,int l){\n    edge[ecnt] = (Edge){a,b,l,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,l,fir[b]};\n    fir[b] = ecnt++;\n}\n//-----\nint n,m,q[MAXN],ans[MAXN];\n//-----\nint f[MAXN],vis[MAXN],siz[MAXN];\nint rt,sz;\n\nstruct node{\n    int d,f;\n    bool operator < (node a)const{\n        return d < a.d;\n    }\n}dep[MAXN];\nint num;\n\nint search(int d){\n    int b = 1,e = num;\n    while(e!=b){\n        int mid = (b+e)>>1;\n        if(dep[mid].d >= d) e = mid;\n        else b = mid + 1;\n    }\n    return b;\n}\n\n//-----\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]);\n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n\nvoid dfs(int nown,int fa,int wh,int d){\n    dep[++num] = (node){d,wh};\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v] || v == fa) continue;\n        dfs(v,nown,wh,d+l);\n    }\n}\n\nvoid work(int nown){\n    num = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v]) continue;\n        dfs(v,nown,v,l);\n    }\n    dep[++num] = (node){0,0};\n    sort(dep+1,dep+num+1);\n    //二分查找 并判断对于每个ans是否有符合的答案\n    for(int i = 1;i<=m;i++){\n        if(ans[i]) continue;\n        int l = 1;\n        while(l < num && dep[l].d + dep[num].d < q[i])\n            l++;\n        while(l < num && 2*dep[l].d < q[i]){\n            if(ans[i]) break;\n            int t = q[i]-dep[l].d,r = search(t);\n            while(r <= num && dep[r].d == t && dep[l].f == dep[r].f)\n                r++;\n            ans[i] |= (dep[r].d == t);\n            l++;\n        }\n    }\n}\n\nvoid solve(int nown){\n    vis[nown] = 1;\n    work(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];\n        getroot(v,rt);\n        solve(rt);\n    }\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n    for(int i = 1;i<=m;i++)\n        read(q[i]);\n}\n\nvoid solve(){\n    f[rt = 0] = sz = n;\n    getroot(1,rt);\n    solve(rt);\n    for(int i = 1;i<=m;i++){\n        if(ans[i]) print('A'),print('Y'),print('E');\n        else print('N'),print('A'),print('Y');\n        print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n\n## 例题\n\n{% post_link 「国家集训队」聪聪可可-点分治 [国家集训队]聪聪可可 %}\n\n[[Luogu P2664]树上游戏](https://www.luogu.org/problemnew/show/P2664)\n\n","source":"_posts/点分治学习笔记.md","raw":"---\ntitle: 点分治学习笔记\nurlname: point-DC-notes\ndate: 2018-04-22 13:14:04\ntags:\n- 笔记\n- 点分治\n- 树形结构\ncategories: OI\nvisible:\n---\n\n\n点分治是一种主要在树上的分治，可以在解决一些树上特定条件的路径的问题。其复杂度与大部分分治类似，大概是$O(K \\; \\log{n})$（$K$为除分治步骤之外的时间复杂度的多项式）。\n\n<!-- more -->\n\n## 简介\n\n点分治感性的来说，其实就需要考虑一件事情：如何把树上路径问题转换成过根结点的路径问题。\n\n**定理:树上所有的路径可以分为过根结点的路径和不过根结点的路径。**\n\n对于根结点来说，我们处理完过根结点的路径，剩下所有的路径都不会过根结点了。所以我们可以把根节点和与根结点相连的边均删掉，然后对于新产生的子树，剩下的路径应该都在其中，就可以对子树进行分治处理。\n\n## 实现\n\n主要是三个函数：`solve`，`work`，`getroot`。\n\n### `solve`\n\nsolve函数，也就是主要函数，是一个递归解决问题的过程。\n\n每一次都先把这个点标记成已经访问过，然后对于这个点去寻找\n\n代码如下：\n\n```cpp\nvoid solve(int nown){\n    work(nown);\n    vis[nown] = 1;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];//初始化rt\n        getroot(v,rt);//找到该子树的重心\n        solve(rt);//递归解决问题\n    }\n}\n```\n\n### `work`\n\n`work`函数就是完成对于当前的子树中所有过根的节点的处理。这个函数没有具体的样子，因题而异。\n\n照我目前的理解，主要的思路就是：dfs，想办法拼起来两条同时过根节点而且端点不在一个子树里面的节点。\n\n### `getroot`\n\n首先，为了保证我们分出去的子树的规模尽量的一致，我们每次都需要把当前的树的重心作为根节点，然后完成上段所述的事情。\n\n在这里，寻找重心其实就是找哪个点作根的时候剩下的最大子树的大小最小...代码如下：\n\n```cpp\n//vis==1 代表已经处理过（不在当前子树中）\n//f[nown] 储存这个点作根时剩下的最大子树的大小\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]);\n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n```\n\n不是很难。\n\n## 代码\n\n以[Luogu P3806](https://www.luogu.org/problemnew/show/P3806) 为例。\n（其实这个题...比模版还是要多一些的...复杂度是 $O(n \\log{n} \\log{n})$\n\n{% fold %}\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int MAXN = 110000;\n\nnamespace fast_io {\n    //...\n}using namespace fast_io;\n\nstruct Edge{\n    int from,to;\n    int len,nex;\n}edge[MAXN];\nint ecnt = 1;int fir[MAXN];\nvoid addedge(int a,int b,int l){\n    edge[ecnt] = (Edge){a,b,l,fir[a]};\n    fir[a] = ecnt++;\n    edge[ecnt] = (Edge){b,a,l,fir[b]};\n    fir[b] = ecnt++;\n}\n//-----\nint n,m,q[MAXN],ans[MAXN];\n//-----\nint f[MAXN],vis[MAXN],siz[MAXN];\nint rt,sz;\n\nstruct node{\n    int d,f;\n    bool operator < (node a)const{\n        return d < a.d;\n    }\n}dep[MAXN];\nint num;\n\nint search(int d){\n    int b = 1,e = num;\n    while(e!=b){\n        int mid = (b+e)>>1;\n        if(dep[mid].d >= d) e = mid;\n        else b = mid + 1;\n    }\n    return b;\n}\n\n//-----\nvoid getroot(int nown,int fa){\n    siz[nown] = 1,f[nown] = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v] || v == fa) continue;\n        getroot(v,nown);\n        siz[nown] += siz[v];\n        f[nown] = max(f[nown],siz[v]);\n    }\n    f[nown] = max(f[nown],sz - siz[nown]);\n    if(f[nown] < f[rt]) rt = nown;\n}\n\nvoid dfs(int nown,int fa,int wh,int d){\n    dep[++num] = (node){d,wh};\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v] || v == fa) continue;\n        dfs(v,nown,wh,d+l);\n    }\n}\n\nvoid work(int nown){\n    num = 0;\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to,l = edge[nowe].len;\n        if(vis[v]) continue;\n        dfs(v,nown,v,l);\n    }\n    dep[++num] = (node){0,0};\n    sort(dep+1,dep+num+1);\n    //二分查找 并判断对于每个ans是否有符合的答案\n    for(int i = 1;i<=m;i++){\n        if(ans[i]) continue;\n        int l = 1;\n        while(l < num && dep[l].d + dep[num].d < q[i])\n            l++;\n        while(l < num && 2*dep[l].d < q[i]){\n            if(ans[i]) break;\n            int t = q[i]-dep[l].d,r = search(t);\n            while(r <= num && dep[r].d == t && dep[l].f == dep[r].f)\n                r++;\n            ans[i] |= (dep[r].d == t);\n            l++;\n        }\n    }\n}\n\nvoid solve(int nown){\n    vis[nown] = 1;\n    work(nown);\n    for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){\n        int v = edge[nowe].to;\n        if(vis[v]) continue;\n        f[rt = 0] = sz = siz[v];\n        getroot(v,rt);\n        solve(rt);\n    }\n}\n\nvoid init(){\n    read(n),read(m);\n    int a,b,c;\n    for(int i = 1;i<=n-1;i++){\n        read(a),read(b),read(c);\n        addedge(a,b,c);\n    }\n    for(int i = 1;i<=m;i++)\n        read(q[i]);\n}\n\nvoid solve(){\n    f[rt = 0] = sz = n;\n    getroot(1,rt);\n    solve(rt);\n    for(int i = 1;i<=m;i++){\n        if(ans[i]) print('A'),print('Y'),print('E');\n        else print('N'),print('A'),print('Y');\n        print('\\n');\n    }\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n\n{% endfold %}\n\n## 例题\n\n{% post_link 「国家集训队」聪聪可可-点分治 [国家集训队]聪聪可可 %}\n\n[[Luogu P2664]树上游戏](https://www.luogu.org/problemnew/show/P2664)\n\n","slug":"点分治学习笔记","published":1,"updated":"2018-06-18T03:28:40.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3my006obljrx8gq43ef","content":"<p>点分治是一种主要在树上的分治，可以在解决一些树上特定条件的路径的问题。其复杂度与大部分分治类似，大概是$O(K \\; \\log{n})$（$K$为除分治步骤之外的时间复杂度的多项式）。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>点分治感性的来说，其实就需要考虑一件事情：如何把树上路径问题转换成过根结点的路径问题。</p>\n<p><strong>定理:树上所有的路径可以分为过根结点的路径和不过根结点的路径。</strong></p>\n<p>对于根结点来说，我们处理完过根结点的路径，剩下所有的路径都不会过根结点了。所以我们可以把根节点和与根结点相连的边均删掉，然后对于新产生的子树，剩下的路径应该都在其中，就可以对子树进行分治处理。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>主要是三个函数：<code>solve</code>，<code>work</code>，<code>getroot</code>。</p>\n<h3 id=\"solve\"><a href=\"#solve\" class=\"headerlink\" title=\"solve\"></a><code>solve</code></h3><p>solve函数，也就是主要函数，是一个递归解决问题的过程。</p>\n<p>每一次都先把这个点标记成已经访问过，然后对于这个点去寻找</p>\n<p>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    work(nown);</span><br><span class=\"line\">    vis[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        f[rt = <span class=\"number\">0</span>] = sz = siz[v];<span class=\"comment\">//初始化rt</span></span><br><span class=\"line\">        getroot(v,rt);<span class=\"comment\">//找到该子树的重心</span></span><br><span class=\"line\">        solve(rt);<span class=\"comment\">//递归解决问题</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"work\"><a href=\"#work\" class=\"headerlink\" title=\"work\"></a><code>work</code></h3><p><code>work</code>函数就是完成对于当前的子树中所有过根的节点的处理。这个函数没有具体的样子，因题而异。</p>\n<p>照我目前的理解，主要的思路就是：dfs，想办法拼起来两条同时过根节点而且端点不在一个子树里面的节点。</p>\n<h3 id=\"getroot\"><a href=\"#getroot\" class=\"headerlink\" title=\"getroot\"></a><code>getroot</code></h3><p>首先，为了保证我们分出去的子树的规模尽量的一致，我们每次都需要把当前的树的重心作为根节点，然后完成上段所述的事情。</p>\n<p>在这里，寻找重心其实就是找哪个点作根的时候剩下的最大子树的大小最小…代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//vis==1 代表已经处理过（不在当前子树中）</span></span><br><span class=\"line\"><span class=\"comment\">//f[nown] 储存这个点作根时剩下的最大子树的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getroot</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,f[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v] || v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        getroot(v,nown);</span><br><span class=\"line\">        siz[nown] += siz[v];</span><br><span class=\"line\">        f[nown] = max(f[nown],siz[v]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[nown] = max(f[nown],sz - siz[nown]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[nown] &lt; f[rt]) rt = nown;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不是很难。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3806\" target=\"_blank\" rel=\"noopener\">Luogu P3806</a> 为例。<br>（其实这个题…比模版还是要多一些的…复杂度是 $O(n \\log{n} \\log{n})$</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">110000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> from,to;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len,nex;</span><br><span class=\"line\">&#125;edge[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ecnt = <span class=\"number\">1</span>;<span class=\"keyword\">int</span> fir[MAXN];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b,<span class=\"keyword\">int</span> l)</span></span>&#123;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;a,b,l,fir[a]&#125;;</span><br><span class=\"line\">    fir[a] = ecnt++;</span><br><span class=\"line\">    edge[ecnt] = (Edge)&#123;b,a,l,fir[b]&#125;;</span><br><span class=\"line\">    fir[b] = ecnt++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//-----</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,q[MAXN],ans[MAXN];</span><br><span class=\"line\"><span class=\"comment\">//-----</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAXN],vis[MAXN],siz[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> rt,sz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> d,f;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (node a)<span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> d &lt; a.d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;dep[MAXN];</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">1</span>,e = num;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(e!=b)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (b+e)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dep[mid].d &gt;= d) e = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> b = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//-----</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getroot</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">    siz[nown] = <span class=\"number\">1</span>,f[nown] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v] || v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        getroot(v,nown);</span><br><span class=\"line\">        siz[nown] += siz[v];</span><br><span class=\"line\">        f[nown] = max(f[nown],siz[v]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    f[nown] = max(f[nown],sz - siz[nown]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f[nown] &lt; f[rt]) rt = nown;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> nown,<span class=\"keyword\">int</span> fa,<span class=\"keyword\">int</span> wh,<span class=\"keyword\">int</span> d)</span></span>&#123;</span><br><span class=\"line\">    dep[++num] = (node)&#123;d,wh&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to,l = edge[nowe].len;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v] || v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs(v,nown,wh,d+l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to,l = edge[nowe].len;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        dfs(v,nown,v,l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dep[++num] = (node)&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    sort(dep+<span class=\"number\">1</span>,dep+num+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//二分查找 并判断对于每个ans是否有符合的答案</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; num &amp;&amp; dep[l].d + dep[num].d &lt; q[i])</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; num &amp;&amp; <span class=\"number\">2</span>*dep[l].d &lt; q[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> t = q[i]-dep[l].d,r = search(t);</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(r &lt;= num &amp;&amp; dep[r].d == t &amp;&amp; dep[l].f == dep[r].f)</span><br><span class=\"line\">                r++;</span><br><span class=\"line\">            ans[i] |= (dep[r].d == t);</span><br><span class=\"line\">            l++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> nown)</span></span>&#123;</span><br><span class=\"line\">    vis[nown] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    work(nown);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> nowe = fir[nown];nowe;nowe = edge[nowe].nex)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> v = edge[nowe].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        f[rt = <span class=\"number\">0</span>] = sz = siz[v];</span><br><span class=\"line\">        getroot(v,rt);</span><br><span class=\"line\">        solve(rt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(m);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b,c;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">        read(a),read(b),read(c);</span><br><span class=\"line\">        addedge(a,b,c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        read(q[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    f[rt = <span class=\"number\">0</span>] = sz = n;</span><br><span class=\"line\">    getroot(<span class=\"number\">1</span>,rt);</span><br><span class=\"line\">    solve(rt);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ans[i]) print(<span class=\"string\">'A'</span>),print(<span class=\"string\">'Y'</span>),print(<span class=\"string\">'E'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> print(<span class=\"string\">'N'</span>),print(<span class=\"string\">'A'</span>),print(<span class=\"string\">'Y'</span>);</span><br><span class=\"line\">        print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180422-clever_and_cute/\" title=\"[国家集训队]聪聪可可\">[国家集训队]聪聪可可</a>\n<p><a href=\"https://www.luogu.org/problemnew/show/P2664\" target=\"_blank\" rel=\"noopener\">[Luogu P2664]树上游戏</a></p>\n","site":{"data":{}},"excerpt":"<p>点分治是一种主要在树上的分治，可以在解决一些树上特定条件的路径的问题。其复杂度与大部分分治类似，大概是$O(K \\; \\log{n})$（$K$为除分治步骤之外的时间复杂度的多项式）。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>点分治感性的来说，其实就需要考虑一件事情：如何把树上路径问题转换成过根结点的路径问题。</p>\n<p><strong>定理:树上所有的路径可以分为过根结点的路径和不过根结点的路径。</strong></p>\n<p>对于根结点来说，我们处理完过根结点的路径，剩下所有的路径都不会过根结点了。所以我们可以把根节点和与根结点相连的边均删掉，然后对于新产生的子树，剩下的路径应该都在其中，就可以对子树进行分治处理。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>主要是三个函数：<code>solve</code>，<code>work</code>，<code>getroot</code>。</p>\n<h3 id=\"solve\"><a href=\"#solve\" class=\"headerlink\" title=\"solve\"></a><code>solve</code></h3><p>solve函数，也就是主要函数，是一个递归解决问题的过程。</p>\n<p>每一次都先把这个点标记成已经访问过，然后对于这个点去寻找</p>\n<p>代码如下：</p>\n<!--�70-->\n<h3 id=\"work\"><a href=\"#work\" class=\"headerlink\" title=\"work\"></a><code>work</code></h3><p><code>work</code>函数就是完成对于当前的子树中所有过根的节点的处理。这个函数没有具体的样子，因题而异。</p>\n<p>照我目前的理解，主要的思路就是：dfs，想办法拼起来两条同时过根节点而且端点不在一个子树里面的节点。</p>\n<h3 id=\"getroot\"><a href=\"#getroot\" class=\"headerlink\" title=\"getroot\"></a><code>getroot</code></h3><p>首先，为了保证我们分出去的子树的规模尽量的一致，我们每次都需要把当前的树的重心作为根节点，然后完成上段所述的事情。</p>\n<p>在这里，寻找重心其实就是找哪个点作根的时候剩下的最大子树的大小最小…代码如下：</p>\n<!--�71-->\n<p>不是很难。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>以<a href=\"https://www.luogu.org/problemnew/show/P3806\" target=\"_blank\" rel=\"noopener\">Luogu P3806</a> 为例。<br>（其实这个题…比模版还是要多一些的…复杂度是 $O(n \\log{n} \\log{n})$</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�72-->\n\n</div></div>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180422-clever_and_cute/\" title=\"[国家集训队]聪聪可可\">[国家集训队]聪聪可可</a>\n<p><a href=\"https://www.luogu.org/problemnew/show/P2664\" target=\"_blank\" rel=\"noopener\">[Luogu P2664]树上游戏</a></p>"},{"title":"考试前要看的东西","date":"2018-01-28T02:38:30.000Z","visible":null,"urlname":"notes-for-test","_content":"\nOI考试前最好来看一看...\n<!--more-->\n\n会不断的补充。\n\n### 考前\n+ 带好需要的东西\n    + 笔\n    + 纸\n    + 水\n    + 吃的\n    + 适量的衣服\n+ 复习以下膜版\n    + 线段树\n    + 平衡树\n    + dp\n        - ...\n    + 数学\n    + 网络流&费用流\n    + 缩点\n    + 字符串相关\n    + ......（来日补充\n+ 早点睡\n+ 吃点好的\n\n### 考中\n\n+ 思路放开\n+ 不要鄙视暴力\n+ 不要给自己太大压力\n+ 多喝水\n+ 多上厕所（学习d姓大神\n+ 遇到不会做的题目时的checklist：\n    + 看下数据范围和题目要求 尝试对算法入座\n    + 先敲个30分左右的暴力\n    + 仔细回顾一遍学过的所有数据结构如上面所列\n    + 没准可以打个表？？\n    + 评估一下思考的代价和不做的代价\n    + 后面的题如果有思路可以先做\n    + 不要慌\n    + 再做不出来去玩局初级扫雷平静一下\n+ 写暴力对拍\n    - update: 对拍...要写程序拍...\n+ 最后检查**两遍**文件输入输出\n    - update: 还是三遍吧\n+ 除非一点都不会 不能不写\n\n### 考后\n\n+ 吃顿好的。\n+ 拉个人出去玩。\n+ 再吃顿好的。\n+ 忘掉比赛。\n","source":"_posts/考试前要看的东西.md","raw":"---\ntitle: 考试前要看的东西\ndate: 2018-01-28 10:38:30\ntags:\ncategories: OI\nvisible:\nurlname: notes-for-test\n---\n\nOI考试前最好来看一看...\n<!--more-->\n\n会不断的补充。\n\n### 考前\n+ 带好需要的东西\n    + 笔\n    + 纸\n    + 水\n    + 吃的\n    + 适量的衣服\n+ 复习以下膜版\n    + 线段树\n    + 平衡树\n    + dp\n        - ...\n    + 数学\n    + 网络流&费用流\n    + 缩点\n    + 字符串相关\n    + ......（来日补充\n+ 早点睡\n+ 吃点好的\n\n### 考中\n\n+ 思路放开\n+ 不要鄙视暴力\n+ 不要给自己太大压力\n+ 多喝水\n+ 多上厕所（学习d姓大神\n+ 遇到不会做的题目时的checklist：\n    + 看下数据范围和题目要求 尝试对算法入座\n    + 先敲个30分左右的暴力\n    + 仔细回顾一遍学过的所有数据结构如上面所列\n    + 没准可以打个表？？\n    + 评估一下思考的代价和不做的代价\n    + 后面的题如果有思路可以先做\n    + 不要慌\n    + 再做不出来去玩局初级扫雷平静一下\n+ 写暴力对拍\n    - update: 对拍...要写程序拍...\n+ 最后检查**两遍**文件输入输出\n    - update: 还是三遍吧\n+ 除非一点都不会 不能不写\n\n### 考后\n\n+ 吃顿好的。\n+ 拉个人出去玩。\n+ 再吃顿好的。\n+ 忘掉比赛。\n","slug":"考试前要看的东西","published":1,"updated":"2018-04-26T03:07:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3n0006sbljruwennz65","content":"<p>OI考试前最好来看一看…<br><a id=\"more\"></a></p>\n<p>会不断的补充。</p>\n<h3 id=\"考前\"><a href=\"#考前\" class=\"headerlink\" title=\"考前\"></a>考前</h3><ul>\n<li>带好需要的东西<ul>\n<li>笔</li>\n<li>纸</li>\n<li>水</li>\n<li>吃的</li>\n<li>适量的衣服</li>\n</ul>\n</li>\n<li>复习以下膜版<ul>\n<li>线段树</li>\n<li>平衡树</li>\n<li>dp<ul>\n<li>…</li>\n</ul>\n</li>\n<li>数学</li>\n<li>网络流&amp;费用流</li>\n<li>缩点</li>\n<li>字符串相关</li>\n<li>……（来日补充</li>\n</ul>\n</li>\n<li>早点睡</li>\n<li>吃点好的</li>\n</ul>\n<h3 id=\"考中\"><a href=\"#考中\" class=\"headerlink\" title=\"考中\"></a>考中</h3><ul>\n<li>思路放开</li>\n<li>不要鄙视暴力</li>\n<li>不要给自己太大压力</li>\n<li>多喝水</li>\n<li>多上厕所（学习d姓大神</li>\n<li>遇到不会做的题目时的checklist：<ul>\n<li>看下数据范围和题目要求 尝试对算法入座</li>\n<li>先敲个30分左右的暴力</li>\n<li>仔细回顾一遍学过的所有数据结构如上面所列</li>\n<li>没准可以打个表？？</li>\n<li>评估一下思考的代价和不做的代价</li>\n<li>后面的题如果有思路可以先做</li>\n<li>不要慌</li>\n<li>再做不出来去玩局初级扫雷平静一下</li>\n</ul>\n</li>\n<li>写暴力对拍<ul>\n<li>update: 对拍…要写程序拍…</li>\n</ul>\n</li>\n<li>最后检查<strong>两遍</strong>文件输入输出<ul>\n<li>update: 还是三遍吧</li>\n</ul>\n</li>\n<li>除非一点都不会 不能不写</li>\n</ul>\n<h3 id=\"考后\"><a href=\"#考后\" class=\"headerlink\" title=\"考后\"></a>考后</h3><ul>\n<li>吃顿好的。</li>\n<li>拉个人出去玩。</li>\n<li>再吃顿好的。</li>\n<li>忘掉比赛。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>OI考试前最好来看一看…<br>","more":"</p>\n<p>会不断的补充。</p>\n<h3 id=\"考前\"><a href=\"#考前\" class=\"headerlink\" title=\"考前\"></a>考前</h3><ul>\n<li>带好需要的东西<ul>\n<li>笔</li>\n<li>纸</li>\n<li>水</li>\n<li>吃的</li>\n<li>适量的衣服</li>\n</ul>\n</li>\n<li>复习以下膜版<ul>\n<li>线段树</li>\n<li>平衡树</li>\n<li>dp<ul>\n<li>…</li>\n</ul>\n</li>\n<li>数学</li>\n<li>网络流&amp;费用流</li>\n<li>缩点</li>\n<li>字符串相关</li>\n<li>……（来日补充</li>\n</ul>\n</li>\n<li>早点睡</li>\n<li>吃点好的</li>\n</ul>\n<h3 id=\"考中\"><a href=\"#考中\" class=\"headerlink\" title=\"考中\"></a>考中</h3><ul>\n<li>思路放开</li>\n<li>不要鄙视暴力</li>\n<li>不要给自己太大压力</li>\n<li>多喝水</li>\n<li>多上厕所（学习d姓大神</li>\n<li>遇到不会做的题目时的checklist：<ul>\n<li>看下数据范围和题目要求 尝试对算法入座</li>\n<li>先敲个30分左右的暴力</li>\n<li>仔细回顾一遍学过的所有数据结构如上面所列</li>\n<li>没准可以打个表？？</li>\n<li>评估一下思考的代价和不做的代价</li>\n<li>后面的题如果有思路可以先做</li>\n<li>不要慌</li>\n<li>再做不出来去玩局初级扫雷平静一下</li>\n</ul>\n</li>\n<li>写暴力对拍<ul>\n<li>update: 对拍…要写程序拍…</li>\n</ul>\n</li>\n<li>最后检查<strong>两遍</strong>文件输入输出<ul>\n<li>update: 还是三遍吧</li>\n</ul>\n</li>\n<li>除非一点都不会 不能不写</li>\n</ul>\n<h3 id=\"考后\"><a href=\"#考后\" class=\"headerlink\" title=\"考后\"></a>考后</h3><ul>\n<li>吃顿好的。</li>\n<li>拉个人出去玩。</li>\n<li>再吃顿好的。</li>\n<li>忘掉比赛。</li>\n</ul>"},{"title":"莫队算法学习笔记（一）","urlname":"mo-algorithm-1","date":"2018-02-05T11:54:29.000Z","visible":null,"_content":"\n这篇\b主要介绍在序列上的无修改以及带修改的离线莫队算法。\n\n<!-- more -->\n## 简介\n\n莫队算法是一个充满着暴力美学的算法。\n\n莫队算法主要是用来解决一些离线无修改的区间查询问题，实现起来相比比较的简单。而莫队算法的主要用在线段树等数据结构无法在很短时间内实现区间信息合并的情况。\n\n## 莫队算法\n\n### 核心思想\n\n首先莫队算法的使用情景在上面已经提及。那么接下来让我们以一个实例来理解莫队算法。\n\n> 有一个正整数序列$A$，$m$次询问在$[l,r]$区间内有多少个不同的数。(HH的项链)\n\n一般来说，我们会想到使用线段树，但这种情况下，我们并不能很快（比如$O(1)$ ）的完成两个区间信息的合并，所以说线段树在这里是起不了作用的。\n\n- - -\n\n但是，我们注意到，如果采用适当的方法，我们可以在常数时间内由$[l,r]$区间得到$[l-1,r]$和$[l,r+1]$的信息，只需要记录一下这个数出现的次数，然后增加的时候判一下是否为空即可。同理，略加思考，我们也可以发现从$[l,r]$区间得到$[l+1,r]$和$[l,r-1]$的信息的方法。\n\n所以如果我们直接对左端点排序，然后暴力转移的话，那么这个算法的时间复杂度在最坏情况下是$O(n^2)$的。\n\n- - -\n\n这个时候就要用莫队的思想来简化这个时间复杂度。\n\n我们注意到，在$O(n^2)$算法中，每一次的左右端点最坏要移动$n$次。能不能想一个办法，让这个移动次数变小呢？如果通过某种方法排序后，能够使得某些**相邻**的查询移动变小，那么我们可以优化时间复杂度。但同时注意到，优化了一个移动的同时，会导致那些被排除出上文提到的**相邻**的查询之间的移动变大一些。所以事实上我们是在寻求一个平衡。\n\n我们可以采用分块的办法。假设我们的分块大小是$Q$,那么应该一共有$\\frac{n}{Q}$个块。**分块之后，按照左端点所在的块的序号为第一关键字，右端点的位置为第二关键字排序**。这句话很重要，其实就是莫队的核心实现吧。\n\n然后，暴力转移。\n\n- - - \n\n然后可以注意到，不论是在同一个块内的移动，还是跨块的移动，左端点最多转移的次数是在$Q$的级别的，一共$m$次查询，那么总共转移$mQ$次。而右端点的移动，在一个块内的时候，由于肯定是单调递增，所以每查询过一个块，左端点转移$n$次，一共有$\\frac{n}{Q}$个块，所以右端点的移动总共就是$\\frac{n^2}{Q}$次。\n\n总共合起来，时间复杂度就是$O(T\\times(\\frac{n^2}{Q}+mQ))$，T为一次状态转移的时间。利用一些~~基础~~复杂的数学知识，可以发现当$Q = \\sqrt{n}$的时候，这个式子的值最小，是$O(T\\times(m+n)\\sqrt{n})$，这也就是基础莫队算法的时间复杂度。不过在具体实现中，精确的$\\sqrt{n}$\b未必就是最快的，有可能需要乘个常数啥的。不过大致是吧。\n\n### 具体实现\n\n\b莫队的实现超级简单。\b不过我因为我太蒻了，开始还是没有想明白。其实就是先扩大，后缩小，一个一个暴力转移。\n\n代码如下。\n\n```cpp\n//ql,qr 为查询区间，l,r为当前区间\n//add 和 del 是自定义的转移函数\n//注意自增自减的时间\nwhile(ql<l)\n    add(--l);\nwhile(r<qr)\n    add(++r);\nwhile(l<ql)\n    del(l++);\nwhile(qr<r)\n    del(r--);\n```\n\n超级简单吧！\n\n值的一提的是，在我去北京冬令营的时候，台上的神犇说：\n\n> 莫队的卡常有个小技巧：你奇数的右端点正序排，偶数的右端点逆序排，就可以压掉一半的常数了！\n\n听起来很有道理，但我没有试过。\n\n### 例题\n\n{%post_link 「SDOI2009」HH的项链-莫队or树状数组 「SDOI2009」HH的项链  %}\n\n[国家集训队]小Z的袜子 （题解待补\n\n## 带修改莫队算法\n\n待修改的莫队就是可以支持一些简单的修改的莫队算法。\n\n### 核心思想\n\n基本上与前面的基础算法类似。假设这里的修改有$t$次。这里的排序一般是**分块之后，按照左端点所在的块的序号为第一关键字，右端点所在的块的序号为第二关键字，更改的次数为第三关键字排序。**\n\n这里我们取分块的大小为$n^{\\frac{2}{3}}$，那么有$n^{\\frac{1}{3}}$个块，可以算出算法的时间复杂度是$O(T \\times n^{\\frac{5}{3}})$。（然而并不太懂怎么推出来这个的...哪位巨佬知道请教一下 非常感谢\n\n### 具体实现\n\n类似，不写了。\n\n```cpp\n//一段时间复杂度为O(n^5/3)的代码。\n```\n\n需要注意，如果单点修改有一个小技巧，就是每次不是更改成待更改数，而是swap当前数和待更改数，这样就可以简单的做更改了。\n\n### 例题\n\n{%post_link 「国家集训队」数颜色-带修改莫队 「国家集训队」数颜色  %}\n","source":"_posts/莫队算法学习笔记（一）.md","raw":"---\ntitle: 莫队算法学习笔记（一）\nurlname: mo-algorithm-1\ndate: 2018-02-05 19:54:29\ntags:\n- 莫队\n- 笔记\n- 模板\ncategories: OI\nvisible:\n---\n\n这篇\b主要介绍在序列上的无修改以及带修改的离线莫队算法。\n\n<!-- more -->\n## 简介\n\n莫队算法是一个充满着暴力美学的算法。\n\n莫队算法主要是用来解决一些离线无修改的区间查询问题，实现起来相比比较的简单。而莫队算法的主要用在线段树等数据结构无法在很短时间内实现区间信息合并的情况。\n\n## 莫队算法\n\n### 核心思想\n\n首先莫队算法的使用情景在上面已经提及。那么接下来让我们以一个实例来理解莫队算法。\n\n> 有一个正整数序列$A$，$m$次询问在$[l,r]$区间内有多少个不同的数。(HH的项链)\n\n一般来说，我们会想到使用线段树，但这种情况下，我们并不能很快（比如$O(1)$ ）的完成两个区间信息的合并，所以说线段树在这里是起不了作用的。\n\n- - -\n\n但是，我们注意到，如果采用适当的方法，我们可以在常数时间内由$[l,r]$区间得到$[l-1,r]$和$[l,r+1]$的信息，只需要记录一下这个数出现的次数，然后增加的时候判一下是否为空即可。同理，略加思考，我们也可以发现从$[l,r]$区间得到$[l+1,r]$和$[l,r-1]$的信息的方法。\n\n所以如果我们直接对左端点排序，然后暴力转移的话，那么这个算法的时间复杂度在最坏情况下是$O(n^2)$的。\n\n- - -\n\n这个时候就要用莫队的思想来简化这个时间复杂度。\n\n我们注意到，在$O(n^2)$算法中，每一次的左右端点最坏要移动$n$次。能不能想一个办法，让这个移动次数变小呢？如果通过某种方法排序后，能够使得某些**相邻**的查询移动变小，那么我们可以优化时间复杂度。但同时注意到，优化了一个移动的同时，会导致那些被排除出上文提到的**相邻**的查询之间的移动变大一些。所以事实上我们是在寻求一个平衡。\n\n我们可以采用分块的办法。假设我们的分块大小是$Q$,那么应该一共有$\\frac{n}{Q}$个块。**分块之后，按照左端点所在的块的序号为第一关键字，右端点的位置为第二关键字排序**。这句话很重要，其实就是莫队的核心实现吧。\n\n然后，暴力转移。\n\n- - - \n\n然后可以注意到，不论是在同一个块内的移动，还是跨块的移动，左端点最多转移的次数是在$Q$的级别的，一共$m$次查询，那么总共转移$mQ$次。而右端点的移动，在一个块内的时候，由于肯定是单调递增，所以每查询过一个块，左端点转移$n$次，一共有$\\frac{n}{Q}$个块，所以右端点的移动总共就是$\\frac{n^2}{Q}$次。\n\n总共合起来，时间复杂度就是$O(T\\times(\\frac{n^2}{Q}+mQ))$，T为一次状态转移的时间。利用一些~~基础~~复杂的数学知识，可以发现当$Q = \\sqrt{n}$的时候，这个式子的值最小，是$O(T\\times(m+n)\\sqrt{n})$，这也就是基础莫队算法的时间复杂度。不过在具体实现中，精确的$\\sqrt{n}$\b未必就是最快的，有可能需要乘个常数啥的。不过大致是吧。\n\n### 具体实现\n\n\b莫队的实现超级简单。\b不过我因为我太蒻了，开始还是没有想明白。其实就是先扩大，后缩小，一个一个暴力转移。\n\n代码如下。\n\n```cpp\n//ql,qr 为查询区间，l,r为当前区间\n//add 和 del 是自定义的转移函数\n//注意自增自减的时间\nwhile(ql<l)\n    add(--l);\nwhile(r<qr)\n    add(++r);\nwhile(l<ql)\n    del(l++);\nwhile(qr<r)\n    del(r--);\n```\n\n超级简单吧！\n\n值的一提的是，在我去北京冬令营的时候，台上的神犇说：\n\n> 莫队的卡常有个小技巧：你奇数的右端点正序排，偶数的右端点逆序排，就可以压掉一半的常数了！\n\n听起来很有道理，但我没有试过。\n\n### 例题\n\n{%post_link 「SDOI2009」HH的项链-莫队or树状数组 「SDOI2009」HH的项链  %}\n\n[国家集训队]小Z的袜子 （题解待补\n\n## 带修改莫队算法\n\n待修改的莫队就是可以支持一些简单的修改的莫队算法。\n\n### 核心思想\n\n基本上与前面的基础算法类似。假设这里的修改有$t$次。这里的排序一般是**分块之后，按照左端点所在的块的序号为第一关键字，右端点所在的块的序号为第二关键字，更改的次数为第三关键字排序。**\n\n这里我们取分块的大小为$n^{\\frac{2}{3}}$，那么有$n^{\\frac{1}{3}}$个块，可以算出算法的时间复杂度是$O(T \\times n^{\\frac{5}{3}})$。（然而并不太懂怎么推出来这个的...哪位巨佬知道请教一下 非常感谢\n\n### 具体实现\n\n类似，不写了。\n\n```cpp\n//一段时间复杂度为O(n^5/3)的代码。\n```\n\n需要注意，如果单点修改有一个小技巧，就是每次不是更改成待更改数，而是swap当前数和待更改数，这样就可以简单的做更改了。\n\n### 例题\n\n{%post_link 「国家集训队」数颜色-带修改莫队 「国家集训队」数颜色  %}\n","slug":"莫队算法学习笔记（一）","published":1,"updated":"2018-03-31T04:29:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3n1006ubljrp4jed8qz","content":"<p>这篇\b主要介绍在序列上的无修改以及带修改的离线莫队算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>莫队算法是一个充满着暴力美学的算法。</p>\n<p>莫队算法主要是用来解决一些离线无修改的区间查询问题，实现起来相比比较的简单。而莫队算法的主要用在线段树等数据结构无法在很短时间内实现区间信息合并的情况。</p>\n<h2 id=\"莫队算法\"><a href=\"#莫队算法\" class=\"headerlink\" title=\"莫队算法\"></a>莫队算法</h2><h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>首先莫队算法的使用情景在上面已经提及。那么接下来让我们以一个实例来理解莫队算法。</p>\n<blockquote>\n<p>有一个正整数序列$A$，$m$次询问在$[l,r]$区间内有多少个不同的数。(HH的项链)</p>\n</blockquote>\n<p>一般来说，我们会想到使用线段树，但这种情况下，我们并不能很快（比如$O(1)$ ）的完成两个区间信息的合并，所以说线段树在这里是起不了作用的。</p>\n<hr>\n<p>但是，我们注意到，如果采用适当的方法，我们可以在常数时间内由$[l,r]$区间得到$[l-1,r]$和$[l,r+1]$的信息，只需要记录一下这个数出现的次数，然后增加的时候判一下是否为空即可。同理，略加思考，我们也可以发现从$[l,r]$区间得到$[l+1,r]$和$[l,r-1]$的信息的方法。</p>\n<p>所以如果我们直接对左端点排序，然后暴力转移的话，那么这个算法的时间复杂度在最坏情况下是$O(n^2)$的。</p>\n<hr>\n<p>这个时候就要用莫队的思想来简化这个时间复杂度。</p>\n<p>我们注意到，在$O(n^2)$算法中，每一次的左右端点最坏要移动$n$次。能不能想一个办法，让这个移动次数变小呢？如果通过某种方法排序后，能够使得某些<strong>相邻</strong>的查询移动变小，那么我们可以优化时间复杂度。但同时注意到，优化了一个移动的同时，会导致那些被排除出上文提到的<strong>相邻</strong>的查询之间的移动变大一些。所以事实上我们是在寻求一个平衡。</p>\n<p>我们可以采用分块的办法。假设我们的分块大小是$Q$,那么应该一共有$\\frac{n}{Q}$个块。<strong>分块之后，按照左端点所在的块的序号为第一关键字，右端点的位置为第二关键字排序</strong>。这句话很重要，其实就是莫队的核心实现吧。</p>\n<p>然后，暴力转移。</p>\n<hr>\n<p>然后可以注意到，不论是在同一个块内的移动，还是跨块的移动，左端点最多转移的次数是在$Q$的级别的，一共$m$次查询，那么总共转移$mQ$次。而右端点的移动，在一个块内的时候，由于肯定是单调递增，所以每查询过一个块，左端点转移$n$次，一共有$\\frac{n}{Q}$个块，所以右端点的移动总共就是$\\frac{n^2}{Q}$次。</p>\n<p>总共合起来，时间复杂度就是$O(T\\times(\\frac{n^2}{Q}+mQ))$，T为一次状态转移的时间。利用一些<del>基础</del>复杂的数学知识，可以发现当$Q = \\sqrt{n}$的时候，这个式子的值最小，是$O(T\\times(m+n)\\sqrt{n})$，这也就是基础莫队算法的时间复杂度。不过在具体实现中，精确的$\\sqrt{n}$\b未必就是最快的，有可能需要乘个常数啥的。不过大致是吧。</p>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>\b莫队的实现超级简单。\b不过我因为我太蒻了，开始还是没有想明白。其实就是先扩大，后缩小，一个一个暴力转移。</p>\n<p>代码如下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ql,qr 为查询区间，l,r为当前区间</span></span><br><span class=\"line\"><span class=\"comment\">//add 和 del 是自定义的转移函数</span></span><br><span class=\"line\"><span class=\"comment\">//注意自增自减的时间</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(ql&lt;l)</span><br><span class=\"line\">    add(--l);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(r&lt;qr)</span><br><span class=\"line\">    add(++r);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(l&lt;ql)</span><br><span class=\"line\">    del(l++);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(qr&lt;r)</span><br><span class=\"line\">    del(r--);</span><br></pre></td></tr></table></figure>\n<p>超级简单吧！</p>\n<p>值的一提的是，在我去北京冬令营的时候，台上的神犇说：</p>\n<blockquote>\n<p>莫队的卡常有个小技巧：你奇数的右端点正序排，偶数的右端点逆序排，就可以压掉一半的常数了！</p>\n</blockquote>\n<p>听起来很有道理，但我没有试过。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><a href=\"/20180205-sdoi2009-necklace/\" title=\"「SDOI2009」HH的项链\">「SDOI2009」HH的项链</a>\n<p>[国家集训队]小Z的袜子 （题解待补</p>\n<h2 id=\"带修改莫队算法\"><a href=\"#带修改莫队算法\" class=\"headerlink\" title=\"带修改莫队算法\"></a>带修改莫队算法</h2><p>待修改的莫队就是可以支持一些简单的修改的莫队算法。</p>\n<h3 id=\"核心思想-1\"><a href=\"#核心思想-1\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>基本上与前面的基础算法类似。假设这里的修改有$t$次。这里的排序一般是<strong>分块之后，按照左端点所在的块的序号为第一关键字，右端点所在的块的序号为第二关键字，更改的次数为第三关键字排序。</strong></p>\n<p>这里我们取分块的大小为$n^{\\frac{2}{3}}$，那么有$n^{\\frac{1}{3}}$个块，可以算出算法的时间复杂度是$O(T \\times n^{\\frac{5}{3}})$。（然而并不太懂怎么推出来这个的…哪位巨佬知道请教一下 非常感谢</p>\n<h3 id=\"具体实现-1\"><a href=\"#具体实现-1\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>类似，不写了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一段时间复杂度为O(n^5/3)的代码。</span></span><br></pre></td></tr></table></figure>\n<p>需要注意，如果单点修改有一个小技巧，就是每次不是更改成待更改数，而是swap当前数和待更改数，这样就可以简单的做更改了。</p>\n<h3 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h3><a href=\"/20180331-count_color/\" title=\"「国家集训队」数颜色\">「国家集训队」数颜色</a>\n","site":{"data":{}},"excerpt":"<p>这篇\b主要介绍在序列上的无修改以及带修改的离线莫队算法。</p>","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>莫队算法是一个充满着暴力美学的算法。</p>\n<p>莫队算法主要是用来解决一些离线无修改的区间查询问题，实现起来相比比较的简单。而莫队算法的主要用在线段树等数据结构无法在很短时间内实现区间信息合并的情况。</p>\n<h2 id=\"莫队算法\"><a href=\"#莫队算法\" class=\"headerlink\" title=\"莫队算法\"></a>莫队算法</h2><h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>首先莫队算法的使用情景在上面已经提及。那么接下来让我们以一个实例来理解莫队算法。</p>\n<blockquote>\n<p>有一个正整数序列$A$，$m$次询问在$[l,r]$区间内有多少个不同的数。(HH的项链)</p>\n</blockquote>\n<p>一般来说，我们会想到使用线段树，但这种情况下，我们并不能很快（比如$O(1)$ ）的完成两个区间信息的合并，所以说线段树在这里是起不了作用的。</p>\n<hr>\n<p>但是，我们注意到，如果采用适当的方法，我们可以在常数时间内由$[l,r]$区间得到$[l-1,r]$和$[l,r+1]$的信息，只需要记录一下这个数出现的次数，然后增加的时候判一下是否为空即可。同理，略加思考，我们也可以发现从$[l,r]$区间得到$[l+1,r]$和$[l,r-1]$的信息的方法。</p>\n<p>所以如果我们直接对左端点排序，然后暴力转移的话，那么这个算法的时间复杂度在最坏情况下是$O(n^2)$的。</p>\n<hr>\n<p>这个时候就要用莫队的思想来简化这个时间复杂度。</p>\n<p>我们注意到，在$O(n^2)$算法中，每一次的左右端点最坏要移动$n$次。能不能想一个办法，让这个移动次数变小呢？如果通过某种方法排序后，能够使得某些<strong>相邻</strong>的查询移动变小，那么我们可以优化时间复杂度。但同时注意到，优化了一个移动的同时，会导致那些被排除出上文提到的<strong>相邻</strong>的查询之间的移动变大一些。所以事实上我们是在寻求一个平衡。</p>\n<p>我们可以采用分块的办法。假设我们的分块大小是$Q$,那么应该一共有$\\frac{n}{Q}$个块。<strong>分块之后，按照左端点所在的块的序号为第一关键字，右端点的位置为第二关键字排序</strong>。这句话很重要，其实就是莫队的核心实现吧。</p>\n<p>然后，暴力转移。</p>\n<hr>\n<p>然后可以注意到，不论是在同一个块内的移动，还是跨块的移动，左端点最多转移的次数是在$Q$的级别的，一共$m$次查询，那么总共转移$mQ$次。而右端点的移动，在一个块内的时候，由于肯定是单调递增，所以每查询过一个块，左端点转移$n$次，一共有$\\frac{n}{Q}$个块，所以右端点的移动总共就是$\\frac{n^2}{Q}$次。</p>\n<p>总共合起来，时间复杂度就是$O(T\\times(\\frac{n^2}{Q}+mQ))$，T为一次状态转移的时间。利用一些<del>基础</del>复杂的数学知识，可以发现当$Q = \\sqrt{n}$的时候，这个式子的值最小，是$O(T\\times(m+n)\\sqrt{n})$，这也就是基础莫队算法的时间复杂度。不过在具体实现中，精确的$\\sqrt{n}$\b未必就是最快的，有可能需要乘个常数啥的。不过大致是吧。</p>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>\b莫队的实现超级简单。\b不过我因为我太蒻了，开始还是没有想明白。其实就是先扩大，后缩小，一个一个暴力转移。</p>\n<p>代码如下。</p>\n<!--�73-->\n<p>超级简单吧！</p>\n<p>值的一提的是，在我去北京冬令营的时候，台上的神犇说：</p>\n<blockquote>\n<p>莫队的卡常有个小技巧：你奇数的右端点正序排，偶数的右端点逆序排，就可以压掉一半的常数了！</p>\n</blockquote>\n<p>听起来很有道理，但我没有试过。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><a href=\"/20180205-sdoi2009-necklace/\" title=\"「SDOI2009」HH的项链\">「SDOI2009」HH的项链</a>\n<p>[国家集训队]小Z的袜子 （题解待补</p>\n<h2 id=\"带修改莫队算法\"><a href=\"#带修改莫队算法\" class=\"headerlink\" title=\"带修改莫队算法\"></a>带修改莫队算法</h2><p>待修改的莫队就是可以支持一些简单的修改的莫队算法。</p>\n<h3 id=\"核心思想-1\"><a href=\"#核心思想-1\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>基本上与前面的基础算法类似。假设这里的修改有$t$次。这里的排序一般是<strong>分块之后，按照左端点所在的块的序号为第一关键字，右端点所在的块的序号为第二关键字，更改的次数为第三关键字排序。</strong></p>\n<p>这里我们取分块的大小为$n^{\\frac{2}{3}}$，那么有$n^{\\frac{1}{3}}$个块，可以算出算法的时间复杂度是$O(T \\times n^{\\frac{5}{3}})$。（然而并不太懂怎么推出来这个的…哪位巨佬知道请教一下 非常感谢</p>\n<h3 id=\"具体实现-1\"><a href=\"#具体实现-1\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>类似，不写了。</p>\n<!--�74-->\n<p>需要注意，如果单点修改有一个小技巧，就是每次不是更改成待更改数，而是swap当前数和待更改数，这样就可以简单的做更改了。</p>\n<h3 id=\"例题-1\"><a href=\"#例题-1\" class=\"headerlink\" title=\"例题\"></a>例题</h3><a href=\"/20180331-count_color/\" title=\"「国家集训队」数颜色\">「国家集训队」数颜色</a>"},{"title":"衡水中学游记","urlname":"hs-trip","date":"2018-04-29T14:31:08.000Z","visible":null,"_content":"\n> 衡水市，2017年常住人口446.0万人，GDP1550.1亿元，人均GDP3.47万元，衡水市教育局预算支出68644.4万元。\n\n> 北京市海淀区，2017年常住人口348.0万人，GDP5915.3亿元，人均GDP17.00万元，海淀区教育委员会预算支出1038648.0万元。\n\nX大附中，高中在校生约3000人，一本率近100%，清北录取人数119人。\n\n河北衡水中学，在校生约10000人，一本率超过85%，清北录取人数175人。\n\n<!-- more -->\n\n## 写在前面\n\n\b\b\b2018年4月29日，我去衡水参观了衡水中学的开放日。参观的时间和内容都不是很充分，\b我作为一个知名“素质教育”学校的学生，\b某些事情上的观点有可能并不准确和正确。如有这些情况，可以留言告知，我会酌情删改。\n\n## 引子\n\n2018年4月29日，河北省衡水市。晴，18-31摄氏度。\n\n驱车五个小时，终于从北京到达了衡水。\n\n总是说要出北京去见见世面，去观察那些不是那么熟悉的地方，所以一看到衡中开放日，就暗暗下定决心，要去这所只在新闻里听闻过的学校。以至于后面几天听说清华的校庆可以去观礼，也仍然去了衡水。甚至就在去之前的一天，还跟同学开玩笑说：“您去清华签约，我只能去衡水复读了。”\n\n早上的路程说不上顺利。六点钟就从北京出发，一路目睹了许多追尾车祸，最后竟11点才到了衡中门口。\n\n下了车，就拿好东西，向衡中的大门缓缓走去。那时正是中午，天气很热，天空上也没有一点的浮云，穿上短袖也感到少许闷热。突然间，衡中的大门就出现了在眼前。\n\n![](gate.jpg)\n\n*衡水中学正校门：酷似首都师范大学*\n\n从停车处走到校门的路上，一路的景象也让我不禁唏嘘。一条笔直的大道，路旁的店铺则大多与教育有关，甚至还有在地上摆了一地高中教材和五三的小贩。脚下的道路虽然已经硬化，但是仍然不甚平整。在大门口，停满了各种各样的电动车和三轮车，车上撑着遮阳伞的小摊贩也举目可见。如果你不说这里是衡水中学，那么我一定会把这个一个省最强，乃至全国最强的中学之一的学校当作一个普通十八线小县城的一所普通的高中。\n\n然而这是衡水中学。\n\n![](booklet.jpg)\n\n*\b图：证明确实去过*\n\n## 校园\n\n\b衡中的校园，其实并不和X大附中的\b校园\b\b的格局有什么多大的区别。但相比于\bX大附中，衡中的校园显得更大一些。\n\n### 0x01\n\n进门的左手边就是一门大炮和一个小湖。\n\n![](cannon.jpg)\n\n*\b图：神奇的加农炮*\n\n不止左手边是一门大炮，右手边就是一台62坦克。果然是又红又专啊！到处都是关于十九大和\b今年的人大换届的展板\b，政治觉悟实在是高！\n\n![](tank.jpg)\n![](airplane.jpg)\n\n*图：62式坦克 初教6\b教练机*\n\n- - -\n\n一直羡慕校园里有水的学校，比如101。如果一个学校\b里面有活水，那么这所学校的气氛，就一定不会死气沉沉，在其中\b学习一定会是充满愉快的。遇到什么困难，去看看\b\b澄澈的水面，总是会让人觉得人生是充满希望的。但我想人大的一勺之池大约是不算在其中的。\n\n![](lake.jpg)\n\n*图：衡中湖*\n\n### 0x02\n\n\b\b走到最里面，就是\b衡中的操场了。\n\n![](playground.jpg)\n\n*图：操场及标语*\n\n全世界的操场都是差不多的\b样子。不过我还是要说...你X大附中每年几个亿的经费能不能修个草皮？？？\b全世界的草皮都不知道比破校好到哪里去了。\n\n有点特色的就是标语。开始还没什么。站在操场的中央，越读越觉得有趣。没有看到跑操的示范，也不好再说些\b什么，这个章节就简短一些了。\n\n- - -\n\n![](play_basketball.jpg)\n\n*\b图：衡水中学的学生正在打篮球*\n\n这张图也让我印象很深刻。衡中的\b学生，再怎么样，也还可以是学生的嘛。\n\n### 0x03\n\n往外走的路上，在树梢的枝头瞟见\b高三\b(or高二？)的教学楼上有着一面几乎分毫不差的大钟。\n\n![](clock.jpg)\n\n*图：教学楼上的钟*\n\n或许这也是衡中的几乎变态的时间规划的体现吧。刚看到觉得有些意外，但渐渐地也觉得\b这些东西，也不是什么坏的东西啊。\n- - -\n趁着\b家长会偷偷溜进了高一的教室。接下来这一段大概是全文我感觉最有意思的\b地方了。\n\n\b我现在也正是高一，所以大约对下高一的学习\b进度大约是件非常有趣的事情。\n\n![](rank.jpg)\n\n*图：公开贴在楼道的\b周测\b（或者期中考试）排名*\n\n毋庸置疑，衡中，尤其其实验班的确是一个学习\b氛围非常浓厚的地方。也许并不是所有人都想去学习，\b不停的学习，但这样学习的环境的确是很难在县城高中里获得的。\n\n就算在我的同学里面，\b\b\b\b我恐怕也是少数几个还对初三\b的月考抱有好感的人。这种学习的氛围，对自己学习方面实力的提升，我还是很喜欢的。\n\n- - -\n\n还有就是教室。它的教室较我们现在使用的楼来看，还是稍大一些。但是，就是这些稍大一些的\b教室，竟然\b盛下了几乎两倍于\b我们一个\b\b教室的人。\n\n![](classroom.jpg)\n\n*图：高一的教室，可以\b看到\b三个，乃至四个人同桌\b情况*\n\n不敢想象啊。我们的教室，\b坐下40\b个人就已经很拥挤。70个人真的是难以令人想象。\b每个人的座位下，都有一个箱子，盛着或许是书，或许是卷子。\n\n这就是\b中国最厉害的高中的教室。\n\n- - -\n![](screen.jpg)\n\n*图：每个班门口都配有的\b电子触摸屏幕*\n\n即使教室比较破旧，可是\b电教什么的却不差什么。像这样的\b\b屏幕，每个班都有一块。在楼道里还有自动售货机，真是不知道比我们高到哪里去了。\b\n\n\b在教学楼里，人来人往，学生拿着自己的东西，家长和学生一起。我去的仅仅是高一的教室。这里的高一\b，感觉\b比我校的高三还要累上许多。\n\n看看我拥有的条件，很惭愧，但我也\b无能为力。\b我妄想着以笔为刃，然而\b我确实也只是一个普通的高中生。我比他们所拥有的一切好的多\b，不是靠我，而是靠我的\b父母。这不应是他们可悲之处，是国家之可悲啊。\b\n\n### 0x04\n\n从教室里面走出来，家长会已近结束，上午还在学校的学生们也要回家度过两天半（或者一天半？）的五一假期了。\n\n开放日结束，我也只好走出校门。突然就看到\b右手边，有一个学生，\b坐在那种拉货的三轮车上，\b整个三轮车的其他位置全都被行李占满。这一切突然撞入\b眼帘，不经意间也撞入心坎。\n\n\b商量好去哪里吃中午饭，一家人就开着车前往目的地。\b天气很热，车的\b座椅经过半个\b上午的炙烤都有点发烫。进车关门，\b空调的声音一时\b喧闹起来。我坐在后排，百无聊赖的看着\b\b窗外\b有些枯黄的天空。\n\n\b街上\b满都是刚放学的衡中的学生，以及骑着各种\b电动车\b接他们回去的家长们。车内的温度渐渐降下来了。看着窗外，想着上午\b所见的一切，刚要有些感慨，\b突然就看到\b那个坐在电动车上的女生再次出现在了我的视野里。我坐在凉爽的\b私家车的车座座上，而她却只能坐在三轮车那或许滚烫的金属板子上。\b\b\b\b\b我可以去餐馆\b吹着空调舒舒服服\b的吃上一顿然后写一篇游记，\b她或许只能吃完简朴的饭食接着去写作业。\n\n当这些差距真真的摆在面前——用语文的话说“形成鲜明对比”，或许才是真正能体会到百味辛酸的时候。\n\n- - -\n\n感慨万千。我看着那位同学背后的四个字 **“追求卓越”** ，\b一时凝神，不知道该说些什么好。\n\n诚然，以\b\b衡水中学为代表的一系列超级中学的跑操、近乎\b军训的日常时间表，还有严苛的\b各种纪律，的确是\b一种对于人的特性的磨灭。\n\n但请你放下身位，真的放下你所拥有的一切去思考：\n\n> 你是一个四线城市的\b\b普通人家的孩子。你的爸妈并不具有很高的文化素养，家庭的物质条件也不算富裕。你渴望更大的世界，渴望走出小小的\b县城。你能怎么做呢？\n\n**衡水中学不可能像X大附中一样。** \b整个衡水市，给\b总共十几所的小学，\b中学，\b\b专科学校的教育资金只有6个亿。而光X大附中一所学校，每年从X大能拿到的资金就有3个多亿。怎么比？X大附中的学生，\b绝大多数的父母都是\b高级知识分子，\b家境怎么着也能算得上殷实。怎么比？\n\n衡中所能\b做的，是给那些想走出去的学生，一个**公平的舞台**，\b一个\b**完整的机会**。一个普通的学生，如果他本身有强烈的愿望想要学习，\b想要提升自己，想要\b到达更高的\b\b平台；那么除了衡中，\b在一个小小的地级市，还有什么学校能提供给他想要的平台和机遇？既然如此，那\b外人所诋毁的衡中的一切，\b对于\b他，又算得了什么呢？\n\n其实衡水中学更像是一个**\b中国\b教育的矛盾的集中体**。人人都知道素质教育好，人人都在媒体上抨击应试教育。可是就算以素质教育闻名的X大附中，一位老师也这么说：“这节课我教你的不是\b素质教育。我们该应试的\b时候\b就得应试。”只要你还处在平民的层次，应试仍然是阶级可能的上升途径中不能避开的一件事。\b国情在此，如果连衡水中学这样，能给贫苦孩子提供上升机会的平台都要去推翻，那\b这些人的\b嘴脸简直是卑鄙。\n\n虽然衡水中学这样的模式的确是一种当前国情下的最优解，但是\b不能否认，衡水中学还是需要去批判的。诸如衡水中学、毛坦厂中学的出现，根本还是因为**教育资源的极为不均**，这终究不是我们想看到的，我们这一代人\b也需要去拼搏奋斗的\b去改变。\n\n- - -\n\n还有最后一点。那位同学，我衷心的祝你好运。\b愿你能够考上\b心仪的大学，过上满意的生活。愿阶级不再能成为你的枷锁，你的\b人生能摆脱\b这层\b近乎无解的\b桎梏。\n\n愿你\b安好。\n\n![](final.jpg)\n\n*来源：[Dear Earth](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58898030)*\n\n## 写在最后\n\n如果我有机会，其实我愿意在这所学校里生活上一个月，体验一下北京以外的生活。老是呆在\b北京，恐怕总会把人生看的\b过于简单。\b在那里，恐怕才是中国意义上比较普遍的人生的样子。\n\n但恐怕并我不会去\b衡中，有机会能去的\b时候也并不想去\b如此去为自己拼搏了。\n\n*写于2018年4月30日。*","source":"_posts/衡水中学游记.md","raw":"---\ntitle: 衡水中学游记\nurlname: hs-trip\ndate: 2018-04-29 22:31:08\ntags:\ncategories: 随笔\nvisible:\n---\n\n> 衡水市，2017年常住人口446.0万人，GDP1550.1亿元，人均GDP3.47万元，衡水市教育局预算支出68644.4万元。\n\n> 北京市海淀区，2017年常住人口348.0万人，GDP5915.3亿元，人均GDP17.00万元，海淀区教育委员会预算支出1038648.0万元。\n\nX大附中，高中在校生约3000人，一本率近100%，清北录取人数119人。\n\n河北衡水中学，在校生约10000人，一本率超过85%，清北录取人数175人。\n\n<!-- more -->\n\n## 写在前面\n\n\b\b\b2018年4月29日，我去衡水参观了衡水中学的开放日。参观的时间和内容都不是很充分，\b我作为一个知名“素质教育”学校的学生，\b某些事情上的观点有可能并不准确和正确。如有这些情况，可以留言告知，我会酌情删改。\n\n## 引子\n\n2018年4月29日，河北省衡水市。晴，18-31摄氏度。\n\n驱车五个小时，终于从北京到达了衡水。\n\n总是说要出北京去见见世面，去观察那些不是那么熟悉的地方，所以一看到衡中开放日，就暗暗下定决心，要去这所只在新闻里听闻过的学校。以至于后面几天听说清华的校庆可以去观礼，也仍然去了衡水。甚至就在去之前的一天，还跟同学开玩笑说：“您去清华签约，我只能去衡水复读了。”\n\n早上的路程说不上顺利。六点钟就从北京出发，一路目睹了许多追尾车祸，最后竟11点才到了衡中门口。\n\n下了车，就拿好东西，向衡中的大门缓缓走去。那时正是中午，天气很热，天空上也没有一点的浮云，穿上短袖也感到少许闷热。突然间，衡中的大门就出现了在眼前。\n\n![](gate.jpg)\n\n*衡水中学正校门：酷似首都师范大学*\n\n从停车处走到校门的路上，一路的景象也让我不禁唏嘘。一条笔直的大道，路旁的店铺则大多与教育有关，甚至还有在地上摆了一地高中教材和五三的小贩。脚下的道路虽然已经硬化，但是仍然不甚平整。在大门口，停满了各种各样的电动车和三轮车，车上撑着遮阳伞的小摊贩也举目可见。如果你不说这里是衡水中学，那么我一定会把这个一个省最强，乃至全国最强的中学之一的学校当作一个普通十八线小县城的一所普通的高中。\n\n然而这是衡水中学。\n\n![](booklet.jpg)\n\n*\b图：证明确实去过*\n\n## 校园\n\n\b衡中的校园，其实并不和X大附中的\b校园\b\b的格局有什么多大的区别。但相比于\bX大附中，衡中的校园显得更大一些。\n\n### 0x01\n\n进门的左手边就是一门大炮和一个小湖。\n\n![](cannon.jpg)\n\n*\b图：神奇的加农炮*\n\n不止左手边是一门大炮，右手边就是一台62坦克。果然是又红又专啊！到处都是关于十九大和\b今年的人大换届的展板\b，政治觉悟实在是高！\n\n![](tank.jpg)\n![](airplane.jpg)\n\n*图：62式坦克 初教6\b教练机*\n\n- - -\n\n一直羡慕校园里有水的学校，比如101。如果一个学校\b里面有活水，那么这所学校的气氛，就一定不会死气沉沉，在其中\b学习一定会是充满愉快的。遇到什么困难，去看看\b\b澄澈的水面，总是会让人觉得人生是充满希望的。但我想人大的一勺之池大约是不算在其中的。\n\n![](lake.jpg)\n\n*图：衡中湖*\n\n### 0x02\n\n\b\b走到最里面，就是\b衡中的操场了。\n\n![](playground.jpg)\n\n*图：操场及标语*\n\n全世界的操场都是差不多的\b样子。不过我还是要说...你X大附中每年几个亿的经费能不能修个草皮？？？\b全世界的草皮都不知道比破校好到哪里去了。\n\n有点特色的就是标语。开始还没什么。站在操场的中央，越读越觉得有趣。没有看到跑操的示范，也不好再说些\b什么，这个章节就简短一些了。\n\n- - -\n\n![](play_basketball.jpg)\n\n*\b图：衡水中学的学生正在打篮球*\n\n这张图也让我印象很深刻。衡中的\b学生，再怎么样，也还可以是学生的嘛。\n\n### 0x03\n\n往外走的路上，在树梢的枝头瞟见\b高三\b(or高二？)的教学楼上有着一面几乎分毫不差的大钟。\n\n![](clock.jpg)\n\n*图：教学楼上的钟*\n\n或许这也是衡中的几乎变态的时间规划的体现吧。刚看到觉得有些意外，但渐渐地也觉得\b这些东西，也不是什么坏的东西啊。\n- - -\n趁着\b家长会偷偷溜进了高一的教室。接下来这一段大概是全文我感觉最有意思的\b地方了。\n\n\b我现在也正是高一，所以大约对下高一的学习\b进度大约是件非常有趣的事情。\n\n![](rank.jpg)\n\n*图：公开贴在楼道的\b周测\b（或者期中考试）排名*\n\n毋庸置疑，衡中，尤其其实验班的确是一个学习\b氛围非常浓厚的地方。也许并不是所有人都想去学习，\b不停的学习，但这样学习的环境的确是很难在县城高中里获得的。\n\n就算在我的同学里面，\b\b\b\b我恐怕也是少数几个还对初三\b的月考抱有好感的人。这种学习的氛围，对自己学习方面实力的提升，我还是很喜欢的。\n\n- - -\n\n还有就是教室。它的教室较我们现在使用的楼来看，还是稍大一些。但是，就是这些稍大一些的\b教室，竟然\b盛下了几乎两倍于\b我们一个\b\b教室的人。\n\n![](classroom.jpg)\n\n*图：高一的教室，可以\b看到\b三个，乃至四个人同桌\b情况*\n\n不敢想象啊。我们的教室，\b坐下40\b个人就已经很拥挤。70个人真的是难以令人想象。\b每个人的座位下，都有一个箱子，盛着或许是书，或许是卷子。\n\n这就是\b中国最厉害的高中的教室。\n\n- - -\n![](screen.jpg)\n\n*图：每个班门口都配有的\b电子触摸屏幕*\n\n即使教室比较破旧，可是\b电教什么的却不差什么。像这样的\b\b屏幕，每个班都有一块。在楼道里还有自动售货机，真是不知道比我们高到哪里去了。\b\n\n\b在教学楼里，人来人往，学生拿着自己的东西，家长和学生一起。我去的仅仅是高一的教室。这里的高一\b，感觉\b比我校的高三还要累上许多。\n\n看看我拥有的条件，很惭愧，但我也\b无能为力。\b我妄想着以笔为刃，然而\b我确实也只是一个普通的高中生。我比他们所拥有的一切好的多\b，不是靠我，而是靠我的\b父母。这不应是他们可悲之处，是国家之可悲啊。\b\n\n### 0x04\n\n从教室里面走出来，家长会已近结束，上午还在学校的学生们也要回家度过两天半（或者一天半？）的五一假期了。\n\n开放日结束，我也只好走出校门。突然就看到\b右手边，有一个学生，\b坐在那种拉货的三轮车上，\b整个三轮车的其他位置全都被行李占满。这一切突然撞入\b眼帘，不经意间也撞入心坎。\n\n\b商量好去哪里吃中午饭，一家人就开着车前往目的地。\b天气很热，车的\b座椅经过半个\b上午的炙烤都有点发烫。进车关门，\b空调的声音一时\b喧闹起来。我坐在后排，百无聊赖的看着\b\b窗外\b有些枯黄的天空。\n\n\b街上\b满都是刚放学的衡中的学生，以及骑着各种\b电动车\b接他们回去的家长们。车内的温度渐渐降下来了。看着窗外，想着上午\b所见的一切，刚要有些感慨，\b突然就看到\b那个坐在电动车上的女生再次出现在了我的视野里。我坐在凉爽的\b私家车的车座座上，而她却只能坐在三轮车那或许滚烫的金属板子上。\b\b\b\b\b我可以去餐馆\b吹着空调舒舒服服\b的吃上一顿然后写一篇游记，\b她或许只能吃完简朴的饭食接着去写作业。\n\n当这些差距真真的摆在面前——用语文的话说“形成鲜明对比”，或许才是真正能体会到百味辛酸的时候。\n\n- - -\n\n感慨万千。我看着那位同学背后的四个字 **“追求卓越”** ，\b一时凝神，不知道该说些什么好。\n\n诚然，以\b\b衡水中学为代表的一系列超级中学的跑操、近乎\b军训的日常时间表，还有严苛的\b各种纪律，的确是\b一种对于人的特性的磨灭。\n\n但请你放下身位，真的放下你所拥有的一切去思考：\n\n> 你是一个四线城市的\b\b普通人家的孩子。你的爸妈并不具有很高的文化素养，家庭的物质条件也不算富裕。你渴望更大的世界，渴望走出小小的\b县城。你能怎么做呢？\n\n**衡水中学不可能像X大附中一样。** \b整个衡水市，给\b总共十几所的小学，\b中学，\b\b专科学校的教育资金只有6个亿。而光X大附中一所学校，每年从X大能拿到的资金就有3个多亿。怎么比？X大附中的学生，\b绝大多数的父母都是\b高级知识分子，\b家境怎么着也能算得上殷实。怎么比？\n\n衡中所能\b做的，是给那些想走出去的学生，一个**公平的舞台**，\b一个\b**完整的机会**。一个普通的学生，如果他本身有强烈的愿望想要学习，\b想要提升自己，想要\b到达更高的\b\b平台；那么除了衡中，\b在一个小小的地级市，还有什么学校能提供给他想要的平台和机遇？既然如此，那\b外人所诋毁的衡中的一切，\b对于\b他，又算得了什么呢？\n\n其实衡水中学更像是一个**\b中国\b教育的矛盾的集中体**。人人都知道素质教育好，人人都在媒体上抨击应试教育。可是就算以素质教育闻名的X大附中，一位老师也这么说：“这节课我教你的不是\b素质教育。我们该应试的\b时候\b就得应试。”只要你还处在平民的层次，应试仍然是阶级可能的上升途径中不能避开的一件事。\b国情在此，如果连衡水中学这样，能给贫苦孩子提供上升机会的平台都要去推翻，那\b这些人的\b嘴脸简直是卑鄙。\n\n虽然衡水中学这样的模式的确是一种当前国情下的最优解，但是\b不能否认，衡水中学还是需要去批判的。诸如衡水中学、毛坦厂中学的出现，根本还是因为**教育资源的极为不均**，这终究不是我们想看到的，我们这一代人\b也需要去拼搏奋斗的\b去改变。\n\n- - -\n\n还有最后一点。那位同学，我衷心的祝你好运。\b愿你能够考上\b心仪的大学，过上满意的生活。愿阶级不再能成为你的枷锁，你的\b人生能摆脱\b这层\b近乎无解的\b桎梏。\n\n愿你\b安好。\n\n![](final.jpg)\n\n*来源：[Dear Earth](https://www.pixiv.net/member_illust.php?mode=medium&illust_id=58898030)*\n\n## 写在最后\n\n如果我有机会，其实我愿意在这所学校里生活上一个月，体验一下北京以外的生活。老是呆在\b北京，恐怕总会把人生看的\b过于简单。\b在那里，恐怕才是中国意义上比较普遍的人生的样子。\n\n但恐怕并我不会去\b衡中，有机会能去的\b时候也并不想去\b如此去为自己拼搏了。\n\n*写于2018年4月30日。*","slug":"衡水中学游记","published":1,"updated":"2018-04-30T09:11:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3n3006xbljrwdqoonoo","content":"<blockquote>\n<p>衡水市，2017年常住人口446.0万人，GDP1550.1亿元，人均GDP3.47万元，衡水市教育局预算支出68644.4万元。</p>\n</blockquote>\n<blockquote>\n<p>北京市海淀区，2017年常住人口348.0万人，GDP5915.3亿元，人均GDP17.00万元，海淀区教育委员会预算支出1038648.0万元。</p>\n</blockquote>\n<p>X大附中，高中在校生约3000人，一本率近100%，清北录取人数119人。</p>\n<p>河北衡水中学，在校生约10000人，一本率超过85%，清北录取人数175人。</p>\n<a id=\"more\"></a>\n<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>\b\b\b2018年4月29日，我去衡水参观了衡水中学的开放日。参观的时间和内容都不是很充分，\b我作为一个知名“素质教育”学校的学生，\b某些事情上的观点有可能并不准确和正确。如有这些情况，可以留言告知，我会酌情删改。</p>\n<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>2018年4月29日，河北省衡水市。晴，18-31摄氏度。</p>\n<p>驱车五个小时，终于从北京到达了衡水。</p>\n<p>总是说要出北京去见见世面，去观察那些不是那么熟悉的地方，所以一看到衡中开放日，就暗暗下定决心，要去这所只在新闻里听闻过的学校。以至于后面几天听说清华的校庆可以去观礼，也仍然去了衡水。甚至就在去之前的一天，还跟同学开玩笑说：“您去清华签约，我只能去衡水复读了。”</p>\n<p>早上的路程说不上顺利。六点钟就从北京出发，一路目睹了许多追尾车祸，最后竟11点才到了衡中门口。</p>\n<p>下了车，就拿好东西，向衡中的大门缓缓走去。那时正是中午，天气很热，天空上也没有一点的浮云，穿上短袖也感到少许闷热。突然间，衡中的大门就出现了在眼前。</p>\n<p><img src=\"gate.jpg\" alt=\"\"></p>\n<p><em>衡水中学正校门：酷似首都师范大学</em></p>\n<p>从停车处走到校门的路上，一路的景象也让我不禁唏嘘。一条笔直的大道，路旁的店铺则大多与教育有关，甚至还有在地上摆了一地高中教材和五三的小贩。脚下的道路虽然已经硬化，但是仍然不甚平整。在大门口，停满了各种各样的电动车和三轮车，车上撑着遮阳伞的小摊贩也举目可见。如果你不说这里是衡水中学，那么我一定会把这个一个省最强，乃至全国最强的中学之一的学校当作一个普通十八线小县城的一所普通的高中。</p>\n<p>然而这是衡水中学。</p>\n<p><img src=\"booklet.jpg\" alt=\"\"></p>\n<p><em>\b图：证明确实去过</em></p>\n<h2 id=\"校园\"><a href=\"#校园\" class=\"headerlink\" title=\"校园\"></a>校园</h2><p>\b衡中的校园，其实并不和X大附中的\b校园\b\b的格局有什么多大的区别。但相比于\bX大附中，衡中的校园显得更大一些。</p>\n<h3 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h3><p>进门的左手边就是一门大炮和一个小湖。</p>\n<p><img src=\"cannon.jpg\" alt=\"\"></p>\n<p><em>\b图：神奇的加农炮</em></p>\n<p>不止左手边是一门大炮，右手边就是一台62坦克。果然是又红又专啊！到处都是关于十九大和\b今年的人大换届的展板\b，政治觉悟实在是高！</p>\n<p><img src=\"tank.jpg\" alt=\"\"><br><img src=\"airplane.jpg\" alt=\"\"></p>\n<p><em>图：62式坦克 初教6\b教练机</em></p>\n<hr>\n<p>一直羡慕校园里有水的学校，比如101。如果一个学校\b里面有活水，那么这所学校的气氛，就一定不会死气沉沉，在其中\b学习一定会是充满愉快的。遇到什么困难，去看看\b\b澄澈的水面，总是会让人觉得人生是充满希望的。但我想人大的一勺之池大约是不算在其中的。</p>\n<p><img src=\"lake.jpg\" alt=\"\"></p>\n<p><em>图：衡中湖</em></p>\n<h3 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h3><p>\b\b走到最里面，就是\b衡中的操场了。</p>\n<p><img src=\"playground.jpg\" alt=\"\"></p>\n<p><em>图：操场及标语</em></p>\n<p>全世界的操场都是差不多的\b样子。不过我还是要说…你X大附中每年几个亿的经费能不能修个草皮？？？\b全世界的草皮都不知道比破校好到哪里去了。</p>\n<p>有点特色的就是标语。开始还没什么。站在操场的中央，越读越觉得有趣。没有看到跑操的示范，也不好再说些\b什么，这个章节就简短一些了。</p>\n<hr>\n<p><img src=\"play_basketball.jpg\" alt=\"\"></p>\n<p><em>\b图：衡水中学的学生正在打篮球</em></p>\n<p>这张图也让我印象很深刻。衡中的\b学生，再怎么样，也还可以是学生的嘛。</p>\n<h3 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h3><p>往外走的路上，在树梢的枝头瞟见\b高三\b(or高二？)的教学楼上有着一面几乎分毫不差的大钟。</p>\n<p><img src=\"clock.jpg\" alt=\"\"></p>\n<p><em>图：教学楼上的钟</em></p>\n<p>或许这也是衡中的几乎变态的时间规划的体现吧。刚看到觉得有些意外，但渐渐地也觉得\b这些东西，也不是什么坏的东西啊。</p>\n<hr>\n<p>趁着\b家长会偷偷溜进了高一的教室。接下来这一段大概是全文我感觉最有意思的\b地方了。</p>\n<p>\b我现在也正是高一，所以大约对下高一的学习\b进度大约是件非常有趣的事情。</p>\n<p><img src=\"rank.jpg\" alt=\"\"></p>\n<p><em>图：公开贴在楼道的\b周测\b（或者期中考试）排名</em></p>\n<p>毋庸置疑，衡中，尤其其实验班的确是一个学习\b氛围非常浓厚的地方。也许并不是所有人都想去学习，\b不停的学习，但这样学习的环境的确是很难在县城高中里获得的。</p>\n<p>就算在我的同学里面，\b\b\b\b我恐怕也是少数几个还对初三\b的月考抱有好感的人。这种学习的氛围，对自己学习方面实力的提升，我还是很喜欢的。</p>\n<hr>\n<p>还有就是教室。它的教室较我们现在使用的楼来看，还是稍大一些。但是，就是这些稍大一些的\b教室，竟然\b盛下了几乎两倍于\b我们一个\b\b教室的人。</p>\n<p><img src=\"classroom.jpg\" alt=\"\"></p>\n<p><em>图：高一的教室，可以\b看到\b三个，乃至四个人同桌\b情况</em></p>\n<p>不敢想象啊。我们的教室，\b坐下40\b个人就已经很拥挤。70个人真的是难以令人想象。\b每个人的座位下，都有一个箱子，盛着或许是书，或许是卷子。</p>\n<p>这就是\b中国最厉害的高中的教室。</p>\n<hr>\n<p><img src=\"screen.jpg\" alt=\"\"></p>\n<p><em>图：每个班门口都配有的\b电子触摸屏幕</em></p>\n<p>即使教室比较破旧，可是\b电教什么的却不差什么。像这样的\b\b屏幕，每个班都有一块。在楼道里还有自动售货机，真是不知道比我们高到哪里去了。\b</p>\n<p>\b在教学楼里，人来人往，学生拿着自己的东西，家长和学生一起。我去的仅仅是高一的教室。这里的高一\b，感觉\b比我校的高三还要累上许多。</p>\n<p>看看我拥有的条件，很惭愧，但我也\b无能为力。\b我妄想着以笔为刃，然而\b我确实也只是一个普通的高中生。我比他们所拥有的一切好的多\b，不是靠我，而是靠我的\b父母。这不应是他们可悲之处，是国家之可悲啊。\b</p>\n<h3 id=\"0x04\"><a href=\"#0x04\" class=\"headerlink\" title=\"0x04\"></a>0x04</h3><p>从教室里面走出来，家长会已近结束，上午还在学校的学生们也要回家度过两天半（或者一天半？）的五一假期了。</p>\n<p>开放日结束，我也只好走出校门。突然就看到\b右手边，有一个学生，\b坐在那种拉货的三轮车上，\b整个三轮车的其他位置全都被行李占满。这一切突然撞入\b眼帘，不经意间也撞入心坎。</p>\n<p>\b商量好去哪里吃中午饭，一家人就开着车前往目的地。\b天气很热，车的\b座椅经过半个\b上午的炙烤都有点发烫。进车关门，\b空调的声音一时\b喧闹起来。我坐在后排，百无聊赖的看着\b\b窗外\b有些枯黄的天空。</p>\n<p>\b街上\b满都是刚放学的衡中的学生，以及骑着各种\b电动车\b接他们回去的家长们。车内的温度渐渐降下来了。看着窗外，想着上午\b所见的一切，刚要有些感慨，\b突然就看到\b那个坐在电动车上的女生再次出现在了我的视野里。我坐在凉爽的\b私家车的车座座上，而她却只能坐在三轮车那或许滚烫的金属板子上。\b\b\b\b\b我可以去餐馆\b吹着空调舒舒服服\b的吃上一顿然后写一篇游记，\b她或许只能吃完简朴的饭食接着去写作业。</p>\n<p>当这些差距真真的摆在面前——用语文的话说“形成鲜明对比”，或许才是真正能体会到百味辛酸的时候。</p>\n<hr>\n<p>感慨万千。我看着那位同学背后的四个字 <strong>“追求卓越”</strong> ，\b一时凝神，不知道该说些什么好。</p>\n<p>诚然，以\b\b衡水中学为代表的一系列超级中学的跑操、近乎\b军训的日常时间表，还有严苛的\b各种纪律，的确是\b一种对于人的特性的磨灭。</p>\n<p>但请你放下身位，真的放下你所拥有的一切去思考：</p>\n<blockquote>\n<p>你是一个四线城市的\b\b普通人家的孩子。你的爸妈并不具有很高的文化素养，家庭的物质条件也不算富裕。你渴望更大的世界，渴望走出小小的\b县城。你能怎么做呢？</p>\n</blockquote>\n<p><strong>衡水中学不可能像X大附中一样。</strong> \b整个衡水市，给\b总共十几所的小学，\b中学，\b\b专科学校的教育资金只有6个亿。而光X大附中一所学校，每年从X大能拿到的资金就有3个多亿。怎么比？X大附中的学生，\b绝大多数的父母都是\b高级知识分子，\b家境怎么着也能算得上殷实。怎么比？</p>\n<p>衡中所能\b做的，是给那些想走出去的学生，一个<strong>公平的舞台</strong>，\b一个\b<strong>完整的机会</strong>。一个普通的学生，如果他本身有强烈的愿望想要学习，\b想要提升自己，想要\b到达更高的\b\b平台；那么除了衡中，\b在一个小小的地级市，还有什么学校能提供给他想要的平台和机遇？既然如此，那\b外人所诋毁的衡中的一切，\b对于\b他，又算得了什么呢？</p>\n<p>其实衡水中学更像是一个<strong>\b中国\b教育的矛盾的集中体</strong>。人人都知道素质教育好，人人都在媒体上抨击应试教育。可是就算以素质教育闻名的X大附中，一位老师也这么说：“这节课我教你的不是\b素质教育。我们该应试的\b时候\b就得应试。”只要你还处在平民的层次，应试仍然是阶级可能的上升途径中不能避开的一件事。\b国情在此，如果连衡水中学这样，能给贫苦孩子提供上升机会的平台都要去推翻，那\b这些人的\b嘴脸简直是卑鄙。</p>\n<p>虽然衡水中学这样的模式的确是一种当前国情下的最优解，但是\b不能否认，衡水中学还是需要去批判的。诸如衡水中学、毛坦厂中学的出现，根本还是因为<strong>教育资源的极为不均</strong>，这终究不是我们想看到的，我们这一代人\b也需要去拼搏奋斗的\b去改变。</p>\n<hr>\n<p>还有最后一点。那位同学，我衷心的祝你好运。\b愿你能够考上\b心仪的大学，过上满意的生活。愿阶级不再能成为你的枷锁，你的\b人生能摆脱\b这层\b近乎无解的\b桎梏。</p>\n<p>愿你\b安好。</p>\n<p><img src=\"final.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=58898030\" target=\"_blank\" rel=\"noopener\">Dear Earth</a></em></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>如果我有机会，其实我愿意在这所学校里生活上一个月，体验一下北京以外的生活。老是呆在\b北京，恐怕总会把人生看的\b过于简单。\b在那里，恐怕才是中国意义上比较普遍的人生的样子。</p>\n<p>但恐怕并我不会去\b衡中，有机会能去的\b时候也并不想去\b如此去为自己拼搏了。</p>\n<p><em>写于2018年4月30日。</em></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>衡水市，2017年常住人口446.0万人，GDP1550.1亿元，人均GDP3.47万元，衡水市教育局预算支出68644.4万元。</p>\n</blockquote>\n<blockquote>\n<p>北京市海淀区，2017年常住人口348.0万人，GDP5915.3亿元，人均GDP17.00万元，海淀区教育委员会预算支出1038648.0万元。</p>\n</blockquote>\n<p>X大附中，高中在校生约3000人，一本率近100%，清北录取人数119人。</p>\n<p>河北衡水中学，在校生约10000人，一本率超过85%，清北录取人数175人。</p>","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>\b\b\b2018年4月29日，我去衡水参观了衡水中学的开放日。参观的时间和内容都不是很充分，\b我作为一个知名“素质教育”学校的学生，\b某些事情上的观点有可能并不准确和正确。如有这些情况，可以留言告知，我会酌情删改。</p>\n<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>2018年4月29日，河北省衡水市。晴，18-31摄氏度。</p>\n<p>驱车五个小时，终于从北京到达了衡水。</p>\n<p>总是说要出北京去见见世面，去观察那些不是那么熟悉的地方，所以一看到衡中开放日，就暗暗下定决心，要去这所只在新闻里听闻过的学校。以至于后面几天听说清华的校庆可以去观礼，也仍然去了衡水。甚至就在去之前的一天，还跟同学开玩笑说：“您去清华签约，我只能去衡水复读了。”</p>\n<p>早上的路程说不上顺利。六点钟就从北京出发，一路目睹了许多追尾车祸，最后竟11点才到了衡中门口。</p>\n<p>下了车，就拿好东西，向衡中的大门缓缓走去。那时正是中午，天气很热，天空上也没有一点的浮云，穿上短袖也感到少许闷热。突然间，衡中的大门就出现了在眼前。</p>\n<p><img src=\"gate.jpg\" alt=\"\"></p>\n<p><em>衡水中学正校门：酷似首都师范大学</em></p>\n<p>从停车处走到校门的路上，一路的景象也让我不禁唏嘘。一条笔直的大道，路旁的店铺则大多与教育有关，甚至还有在地上摆了一地高中教材和五三的小贩。脚下的道路虽然已经硬化，但是仍然不甚平整。在大门口，停满了各种各样的电动车和三轮车，车上撑着遮阳伞的小摊贩也举目可见。如果你不说这里是衡水中学，那么我一定会把这个一个省最强，乃至全国最强的中学之一的学校当作一个普通十八线小县城的一所普通的高中。</p>\n<p>然而这是衡水中学。</p>\n<p><img src=\"booklet.jpg\" alt=\"\"></p>\n<p><em>\b图：证明确实去过</em></p>\n<h2 id=\"校园\"><a href=\"#校园\" class=\"headerlink\" title=\"校园\"></a>校园</h2><p>\b衡中的校园，其实并不和X大附中的\b校园\b\b的格局有什么多大的区别。但相比于\bX大附中，衡中的校园显得更大一些。</p>\n<h3 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"></a>0x01</h3><p>进门的左手边就是一门大炮和一个小湖。</p>\n<p><img src=\"cannon.jpg\" alt=\"\"></p>\n<p><em>\b图：神奇的加农炮</em></p>\n<p>不止左手边是一门大炮，右手边就是一台62坦克。果然是又红又专啊！到处都是关于十九大和\b今年的人大换届的展板\b，政治觉悟实在是高！</p>\n<p><img src=\"tank.jpg\" alt=\"\"><br><img src=\"airplane.jpg\" alt=\"\"></p>\n<p><em>图：62式坦克 初教6\b教练机</em></p>\n<hr>\n<p>一直羡慕校园里有水的学校，比如101。如果一个学校\b里面有活水，那么这所学校的气氛，就一定不会死气沉沉，在其中\b学习一定会是充满愉快的。遇到什么困难，去看看\b\b澄澈的水面，总是会让人觉得人生是充满希望的。但我想人大的一勺之池大约是不算在其中的。</p>\n<p><img src=\"lake.jpg\" alt=\"\"></p>\n<p><em>图：衡中湖</em></p>\n<h3 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"></a>0x02</h3><p>\b\b走到最里面，就是\b衡中的操场了。</p>\n<p><img src=\"playground.jpg\" alt=\"\"></p>\n<p><em>图：操场及标语</em></p>\n<p>全世界的操场都是差不多的\b样子。不过我还是要说…你X大附中每年几个亿的经费能不能修个草皮？？？\b全世界的草皮都不知道比破校好到哪里去了。</p>\n<p>有点特色的就是标语。开始还没什么。站在操场的中央，越读越觉得有趣。没有看到跑操的示范，也不好再说些\b什么，这个章节就简短一些了。</p>\n<hr>\n<p><img src=\"play_basketball.jpg\" alt=\"\"></p>\n<p><em>\b图：衡水中学的学生正在打篮球</em></p>\n<p>这张图也让我印象很深刻。衡中的\b学生，再怎么样，也还可以是学生的嘛。</p>\n<h3 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"></a>0x03</h3><p>往外走的路上，在树梢的枝头瞟见\b高三\b(or高二？)的教学楼上有着一面几乎分毫不差的大钟。</p>\n<p><img src=\"clock.jpg\" alt=\"\"></p>\n<p><em>图：教学楼上的钟</em></p>\n<p>或许这也是衡中的几乎变态的时间规划的体现吧。刚看到觉得有些意外，但渐渐地也觉得\b这些东西，也不是什么坏的东西啊。</p>\n<hr>\n<p>趁着\b家长会偷偷溜进了高一的教室。接下来这一段大概是全文我感觉最有意思的\b地方了。</p>\n<p>\b我现在也正是高一，所以大约对下高一的学习\b进度大约是件非常有趣的事情。</p>\n<p><img src=\"rank.jpg\" alt=\"\"></p>\n<p><em>图：公开贴在楼道的\b周测\b（或者期中考试）排名</em></p>\n<p>毋庸置疑，衡中，尤其其实验班的确是一个学习\b氛围非常浓厚的地方。也许并不是所有人都想去学习，\b不停的学习，但这样学习的环境的确是很难在县城高中里获得的。</p>\n<p>就算在我的同学里面，\b\b\b\b我恐怕也是少数几个还对初三\b的月考抱有好感的人。这种学习的氛围，对自己学习方面实力的提升，我还是很喜欢的。</p>\n<hr>\n<p>还有就是教室。它的教室较我们现在使用的楼来看，还是稍大一些。但是，就是这些稍大一些的\b教室，竟然\b盛下了几乎两倍于\b我们一个\b\b教室的人。</p>\n<p><img src=\"classroom.jpg\" alt=\"\"></p>\n<p><em>图：高一的教室，可以\b看到\b三个，乃至四个人同桌\b情况</em></p>\n<p>不敢想象啊。我们的教室，\b坐下40\b个人就已经很拥挤。70个人真的是难以令人想象。\b每个人的座位下，都有一个箱子，盛着或许是书，或许是卷子。</p>\n<p>这就是\b中国最厉害的高中的教室。</p>\n<hr>\n<p><img src=\"screen.jpg\" alt=\"\"></p>\n<p><em>图：每个班门口都配有的\b电子触摸屏幕</em></p>\n<p>即使教室比较破旧，可是\b电教什么的却不差什么。像这样的\b\b屏幕，每个班都有一块。在楼道里还有自动售货机，真是不知道比我们高到哪里去了。\b</p>\n<p>\b在教学楼里，人来人往，学生拿着自己的东西，家长和学生一起。我去的仅仅是高一的教室。这里的高一\b，感觉\b比我校的高三还要累上许多。</p>\n<p>看看我拥有的条件，很惭愧，但我也\b无能为力。\b我妄想着以笔为刃，然而\b我确实也只是一个普通的高中生。我比他们所拥有的一切好的多\b，不是靠我，而是靠我的\b父母。这不应是他们可悲之处，是国家之可悲啊。\b</p>\n<h3 id=\"0x04\"><a href=\"#0x04\" class=\"headerlink\" title=\"0x04\"></a>0x04</h3><p>从教室里面走出来，家长会已近结束，上午还在学校的学生们也要回家度过两天半（或者一天半？）的五一假期了。</p>\n<p>开放日结束，我也只好走出校门。突然就看到\b右手边，有一个学生，\b坐在那种拉货的三轮车上，\b整个三轮车的其他位置全都被行李占满。这一切突然撞入\b眼帘，不经意间也撞入心坎。</p>\n<p>\b商量好去哪里吃中午饭，一家人就开着车前往目的地。\b天气很热，车的\b座椅经过半个\b上午的炙烤都有点发烫。进车关门，\b空调的声音一时\b喧闹起来。我坐在后排，百无聊赖的看着\b\b窗外\b有些枯黄的天空。</p>\n<p>\b街上\b满都是刚放学的衡中的学生，以及骑着各种\b电动车\b接他们回去的家长们。车内的温度渐渐降下来了。看着窗外，想着上午\b所见的一切，刚要有些感慨，\b突然就看到\b那个坐在电动车上的女生再次出现在了我的视野里。我坐在凉爽的\b私家车的车座座上，而她却只能坐在三轮车那或许滚烫的金属板子上。\b\b\b\b\b我可以去餐馆\b吹着空调舒舒服服\b的吃上一顿然后写一篇游记，\b她或许只能吃完简朴的饭食接着去写作业。</p>\n<p>当这些差距真真的摆在面前——用语文的话说“形成鲜明对比”，或许才是真正能体会到百味辛酸的时候。</p>\n<hr>\n<p>感慨万千。我看着那位同学背后的四个字 <strong>“追求卓越”</strong> ，\b一时凝神，不知道该说些什么好。</p>\n<p>诚然，以\b\b衡水中学为代表的一系列超级中学的跑操、近乎\b军训的日常时间表，还有严苛的\b各种纪律，的确是\b一种对于人的特性的磨灭。</p>\n<p>但请你放下身位，真的放下你所拥有的一切去思考：</p>\n<blockquote>\n<p>你是一个四线城市的\b\b普通人家的孩子。你的爸妈并不具有很高的文化素养，家庭的物质条件也不算富裕。你渴望更大的世界，渴望走出小小的\b县城。你能怎么做呢？</p>\n</blockquote>\n<p><strong>衡水中学不可能像X大附中一样。</strong> \b整个衡水市，给\b总共十几所的小学，\b中学，\b\b专科学校的教育资金只有6个亿。而光X大附中一所学校，每年从X大能拿到的资金就有3个多亿。怎么比？X大附中的学生，\b绝大多数的父母都是\b高级知识分子，\b家境怎么着也能算得上殷实。怎么比？</p>\n<p>衡中所能\b做的，是给那些想走出去的学生，一个<strong>公平的舞台</strong>，\b一个\b<strong>完整的机会</strong>。一个普通的学生，如果他本身有强烈的愿望想要学习，\b想要提升自己，想要\b到达更高的\b\b平台；那么除了衡中，\b在一个小小的地级市，还有什么学校能提供给他想要的平台和机遇？既然如此，那\b外人所诋毁的衡中的一切，\b对于\b他，又算得了什么呢？</p>\n<p>其实衡水中学更像是一个<strong>\b中国\b教育的矛盾的集中体</strong>。人人都知道素质教育好，人人都在媒体上抨击应试教育。可是就算以素质教育闻名的X大附中，一位老师也这么说：“这节课我教你的不是\b素质教育。我们该应试的\b时候\b就得应试。”只要你还处在平民的层次，应试仍然是阶级可能的上升途径中不能避开的一件事。\b国情在此，如果连衡水中学这样，能给贫苦孩子提供上升机会的平台都要去推翻，那\b这些人的\b嘴脸简直是卑鄙。</p>\n<p>虽然衡水中学这样的模式的确是一种当前国情下的最优解，但是\b不能否认，衡水中学还是需要去批判的。诸如衡水中学、毛坦厂中学的出现，根本还是因为<strong>教育资源的极为不均</strong>，这终究不是我们想看到的，我们这一代人\b也需要去拼搏奋斗的\b去改变。</p>\n<hr>\n<p>还有最后一点。那位同学，我衷心的祝你好运。\b愿你能够考上\b心仪的大学，过上满意的生活。愿阶级不再能成为你的枷锁，你的\b人生能摆脱\b这层\b近乎无解的\b桎梏。</p>\n<p>愿你\b安好。</p>\n<p><img src=\"final.jpg\" alt=\"\"></p>\n<p><em>来源：<a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=58898030\" target=\"_blank\" rel=\"noopener\">Dear Earth</a></em></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>如果我有机会，其实我愿意在这所学校里生活上一个月，体验一下北京以外的生活。老是呆在\b北京，恐怕总会把人生看的\b过于简单。\b在那里，恐怕才是中国意义上比较普遍的人生的样子。</p>\n<p>但恐怕并我不会去\b衡中，有机会能去的\b时候也并不想去\b如此去为自己拼搏了。</p>\n<p><em>写于2018年4月30日。</em></p>"},{"title":"[转载]达拉崩吧-OI版","date":"2017-12-16T06:55:42.000Z","visible":null,"urlname":"dalabengba-oi","_content":"\n## 原文地址：[点此查看](https://www.luogu.org/discuss/show?postid=29677)\n\n很久很久以前 算法突然出现\n\n带来导论 带走了智商又消失不见\n<!-- more -->\n\n编程十分危险 世间谁最勇敢\n\n一位懵逼儿赶来 大声喊\n\n我要写出最高的树 打出最大的表\n\n搜进最深的递归 把AC带回到面前\n\n老师非常高兴 忙问他的技能\n\n年轻人想了想 他说\n\n老师我会 非确定性有穷状态决策自动机\n\n再来一次 非确定性有穷状态决策自动机\n\n是不是 非确定性有穷状态决策自动机\n\n对对是 非确定性有穷状态决策自动机\n\n懵逼无名少年 捧着算法导论\n\n带着大家的希望 从学校里出发\n\n战胜BUG来袭 获得调试神技\n\n无数代码见证 他慢慢升级\n\n偏远论坛角落 参与所有话题\n\n一路排序 伴随指引前路的单链表\n\n进入决赛考场 比赛和可怕难题\n\n少年打开IDE 难题道\n\n我是 Floyd区间DP均衡红黑树\n\n再来一次 Floyd区间DP均衡红黑树\n\n是不是 Kruskal一维DP二叉排序树\n\n不对是 Floyd区间DP均衡红黑树\n\n于是 非确定性有限状态决策自动机\n\n打出 深度搜索模拟枚举单源最短路\n\n应用 拓扑排序Trie结构Polya定律\n\n套入 Dijkasta联通分量BellmanFord\n\n最后 非确定性有限状态决策自动机\n\n他使用了 IO优化树链剖分输出random\n\n调用了 矩阵速幂虚二叉树行列式消元\n\n完成了 凸包扫描后缀数组网络最大流\n\n老师听说 非确定性有限状态决策自动机\n\n他忘了写 #include<stdio> freopen\n\n就让 非确定性有限状态决策自动机\n\n全手写 map/set稳定婚姻KMP实现\n\n啦啦 懵逼少年 敲着键盘 Ctrl+V来几遍\n\n他发明了一个算法 也在天天渐渐复杂\n\n为了避免以后麻烦 算法叫做暴力法\n\n它的全名十分难念 我不想说一遍\n\n","source":"_posts/转载-达拉崩吧OI版.md","raw":"---\ntitle: '[转载]达拉崩吧-OI版'\ndate: 2017-12-16 14:55:42\ntags: 歌曲\ncategories: OI\nvisible:\nurlname: dalabengba-oi\n---\n\n## 原文地址：[点此查看](https://www.luogu.org/discuss/show?postid=29677)\n\n很久很久以前 算法突然出现\n\n带来导论 带走了智商又消失不见\n<!-- more -->\n\n编程十分危险 世间谁最勇敢\n\n一位懵逼儿赶来 大声喊\n\n我要写出最高的树 打出最大的表\n\n搜进最深的递归 把AC带回到面前\n\n老师非常高兴 忙问他的技能\n\n年轻人想了想 他说\n\n老师我会 非确定性有穷状态决策自动机\n\n再来一次 非确定性有穷状态决策自动机\n\n是不是 非确定性有穷状态决策自动机\n\n对对是 非确定性有穷状态决策自动机\n\n懵逼无名少年 捧着算法导论\n\n带着大家的希望 从学校里出发\n\n战胜BUG来袭 获得调试神技\n\n无数代码见证 他慢慢升级\n\n偏远论坛角落 参与所有话题\n\n一路排序 伴随指引前路的单链表\n\n进入决赛考场 比赛和可怕难题\n\n少年打开IDE 难题道\n\n我是 Floyd区间DP均衡红黑树\n\n再来一次 Floyd区间DP均衡红黑树\n\n是不是 Kruskal一维DP二叉排序树\n\n不对是 Floyd区间DP均衡红黑树\n\n于是 非确定性有限状态决策自动机\n\n打出 深度搜索模拟枚举单源最短路\n\n应用 拓扑排序Trie结构Polya定律\n\n套入 Dijkasta联通分量BellmanFord\n\n最后 非确定性有限状态决策自动机\n\n他使用了 IO优化树链剖分输出random\n\n调用了 矩阵速幂虚二叉树行列式消元\n\n完成了 凸包扫描后缀数组网络最大流\n\n老师听说 非确定性有限状态决策自动机\n\n他忘了写 #include<stdio> freopen\n\n就让 非确定性有限状态决策自动机\n\n全手写 map/set稳定婚姻KMP实现\n\n啦啦 懵逼少年 敲着键盘 Ctrl+V来几遍\n\n他发明了一个算法 也在天天渐渐复杂\n\n为了避免以后麻烦 算法叫做暴力法\n\n它的全名十分难念 我不想说一遍\n\n","slug":"转载-达拉崩吧OI版","published":1,"updated":"2018-03-03T13:02:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3n5006zbljruvt8grt5","content":"<h2 id=\"原文地址：点此查看\"><a href=\"#原文地址：点此查看\" class=\"headerlink\" title=\"原文地址：点此查看\"></a>原文地址：<a href=\"https://www.luogu.org/discuss/show?postid=29677\" target=\"_blank\" rel=\"noopener\">点此查看</a></h2><p>很久很久以前 算法突然出现</p>\n<p>带来导论 带走了智商又消失不见<br><a id=\"more\"></a></p>\n<p>编程十分危险 世间谁最勇敢</p>\n<p>一位懵逼儿赶来 大声喊</p>\n<p>我要写出最高的树 打出最大的表</p>\n<p>搜进最深的递归 把AC带回到面前</p>\n<p>老师非常高兴 忙问他的技能</p>\n<p>年轻人想了想 他说</p>\n<p>老师我会 非确定性有穷状态决策自动机</p>\n<p>再来一次 非确定性有穷状态决策自动机</p>\n<p>是不是 非确定性有穷状态决策自动机</p>\n<p>对对是 非确定性有穷状态决策自动机</p>\n<p>懵逼无名少年 捧着算法导论</p>\n<p>带着大家的希望 从学校里出发</p>\n<p>战胜BUG来袭 获得调试神技</p>\n<p>无数代码见证 他慢慢升级</p>\n<p>偏远论坛角落 参与所有话题</p>\n<p>一路排序 伴随指引前路的单链表</p>\n<p>进入决赛考场 比赛和可怕难题</p>\n<p>少年打开IDE 难题道</p>\n<p>我是 Floyd区间DP均衡红黑树</p>\n<p>再来一次 Floyd区间DP均衡红黑树</p>\n<p>是不是 Kruskal一维DP二叉排序树</p>\n<p>不对是 Floyd区间DP均衡红黑树</p>\n<p>于是 非确定性有限状态决策自动机</p>\n<p>打出 深度搜索模拟枚举单源最短路</p>\n<p>应用 拓扑排序Trie结构Polya定律</p>\n<p>套入 Dijkasta联通分量BellmanFord</p>\n<p>最后 非确定性有限状态决策自动机</p>\n<p>他使用了 IO优化树链剖分输出random</p>\n<p>调用了 矩阵速幂虚二叉树行列式消元</p>\n<p>完成了 凸包扫描后缀数组网络最大流</p>\n<p>老师听说 非确定性有限状态决策自动机</p>\n<p>他忘了写 #include<stdio> freopen</stdio></p>\n<p>就让 非确定性有限状态决策自动机</p>\n<p>全手写 map/set稳定婚姻KMP实现</p>\n<p>啦啦 懵逼少年 敲着键盘 Ctrl+V来几遍</p>\n<p>他发明了一个算法 也在天天渐渐复杂</p>\n<p>为了避免以后麻烦 算法叫做暴力法</p>\n<p>它的全名十分难念 我不想说一遍</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"原文地址：点此查看\"><a href=\"#原文地址：点此查看\" class=\"headerlink\" title=\"原文地址：点此查看\"></a>原文地址：<a href=\"https://www.luogu.org/discuss/show?postid=29677\" target=\"_blank\" rel=\"noopener\">点此查看</a></h2><p>很久很久以前 算法突然出现</p>\n<p>带来导论 带走了智商又消失不见<br>","more":"</p>\n<p>编程十分危险 世间谁最勇敢</p>\n<p>一位懵逼儿赶来 大声喊</p>\n<p>我要写出最高的树 打出最大的表</p>\n<p>搜进最深的递归 把AC带回到面前</p>\n<p>老师非常高兴 忙问他的技能</p>\n<p>年轻人想了想 他说</p>\n<p>老师我会 非确定性有穷状态决策自动机</p>\n<p>再来一次 非确定性有穷状态决策自动机</p>\n<p>是不是 非确定性有穷状态决策自动机</p>\n<p>对对是 非确定性有穷状态决策自动机</p>\n<p>懵逼无名少年 捧着算法导论</p>\n<p>带着大家的希望 从学校里出发</p>\n<p>战胜BUG来袭 获得调试神技</p>\n<p>无数代码见证 他慢慢升级</p>\n<p>偏远论坛角落 参与所有话题</p>\n<p>一路排序 伴随指引前路的单链表</p>\n<p>进入决赛考场 比赛和可怕难题</p>\n<p>少年打开IDE 难题道</p>\n<p>我是 Floyd区间DP均衡红黑树</p>\n<p>再来一次 Floyd区间DP均衡红黑树</p>\n<p>是不是 Kruskal一维DP二叉排序树</p>\n<p>不对是 Floyd区间DP均衡红黑树</p>\n<p>于是 非确定性有限状态决策自动机</p>\n<p>打出 深度搜索模拟枚举单源最短路</p>\n<p>应用 拓扑排序Trie结构Polya定律</p>\n<p>套入 Dijkasta联通分量BellmanFord</p>\n<p>最后 非确定性有限状态决策自动机</p>\n<p>他使用了 IO优化树链剖分输出random</p>\n<p>调用了 矩阵速幂虚二叉树行列式消元</p>\n<p>完成了 凸包扫描后缀数组网络最大流</p>\n<p>老师听说 非确定性有限状态决策自动机</p>\n<p>他忘了写 #include<stdio> freopen</stdio></p>\n<p>就让 非确定性有限状态决策自动机</p>\n<p>全手写 map/set稳定婚姻KMP实现</p>\n<p>啦啦 懵逼少年 敲着键盘 Ctrl+V来几遍</p>\n<p>他发明了一个算法 也在天天渐渐复杂</p>\n<p>为了避免以后麻烦 算法叫做暴力法</p>\n<p>它的全名十分难念 我不想说一遍</p>"},{"title":"输入输出优化模板","urlname":"IO-optimize","date":"2018-02-23T14:15:32.000Z","visible":null,"_content":"\n输入输出模板替代普通读写方式，可以在一定程度上加快程序运行速度。\n\n<!-- more -->\n依赖库`stdio.h` 和 `ctype.h`。\n\n```cpp\n#include <cstdio>\n#include <cctype>\n\nnamespace fast_io {\n    inline char read(){\n\t\t//return getchar();\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x){\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x+(x<<2))<<1) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    inline void read(char *a){\n        static char c = read();\n        while(c!= -1&&(c == ' '||c!='\\r'||c =='\\n'))\n            c = read();\n        while(c!= -1&&c!=' '&&c!='\\r'&&c!='\\n')\n            *a++ = c,c = read();\n        *a = 0;\n    }\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c){\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x){\n        static int buf[30], cnt;\n        if (x == 0)\n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void print(char *a){\n        while(*a) print(*a++);\n    }\n    inline void flush(){\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(int &x){\n        scanf(\"%d\",&x);\n    }\n    inline void print(int x){\n        printf(\"%d\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}//using namespace normal_io;\n\nint main(){\n    int x;\n    read(x);\n    print(x);\n    flush();\n    return 0;\n}\n```\n\n## short版\n\nupdate at 20180405\n\n```cpp\n#include <cstdio>\n#include <cctype>\n\nnamespace fast_io {\n    inline char read(){static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;}\n    inline void read(int &x){static bool iosig;static char c;for (iosig=false,c=read();!isdigit(c);c=read()){if(c=='-')iosig=true;if(c==-1)return;}for(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');if(iosig)x=-x;}\n    inline void read(char *a){static char c = read();while(c!=-1&&(c==' '||c=='\\n'||c=='\\r'))c=read();while(c!=-1&&c!='\\r'&&c!=' '&&c!='\\n') *a++=c,c=read();*a=0;}\n    const int OUT_LEN=1000000;char obuf[OUT_LEN],*ooh=obuf;\n    inline void print(char c){if(ooh==obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;*ooh++ = c;}\n    inline void print(int x){static int buf[30],cnt;if(x==0)print('0');else{if(x<0)print('-'),x=-x;for(cnt=0;x;x/=10)buf[++cnt]=x%10+48;while (cnt) print((char)buf[cnt--]);}}\n    inline void print(char *a){while(*a) print(*a++);}\n    inline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){return getchar();}\n    inline void read(int &x){scanf(\"%d\",&x);}\n    inline void print(int x){printf(\"%d\",x);}\n    inline void print(char x){putchar(x);}\n    inline void flush(){return;}\n}//using namespace normal_io;\n\nint main(){\n    int x;\n    read(x);\n    print(x);\n    flush();\n    return 0;\n}\n```\n\n","source":"_posts/输入输出优化模板.md","raw":"---\ntitle: 输入输出优化模板\nurlname: IO-optimize\ndate: 2018-02-23 22:15:32\ntags:\n- 模板\ncategories: OI\nvisible:\n---\n\n输入输出模板替代普通读写方式，可以在一定程度上加快程序运行速度。\n\n<!-- more -->\n依赖库`stdio.h` 和 `ctype.h`。\n\n```cpp\n#include <cstdio>\n#include <cctype>\n\nnamespace fast_io {\n    inline char read(){\n\t\t//return getchar();\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++;\n    }\n    inline void read(int &x){\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = ((x+(x<<2))<<1) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    inline void read(char *a){\n        static char c = read();\n        while(c!= -1&&(c == ' '||c!='\\r'||c =='\\n'))\n            c = read();\n        while(c!= -1&&c!=' '&&c!='\\r'&&c!='\\n')\n            *a++ = c,c = read();\n        *a = 0;\n    }\n    const int OUT_LEN = 1000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c){\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x){\n        static int buf[30], cnt;\n        if (x == 0)\n            print('0');\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void print(char *a){\n        while(*a) print(*a++);\n    }\n    inline void flush(){\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){\n        return getchar();\n    }\n    inline void read(int &x){\n        scanf(\"%d\",&x);\n    }\n    inline void print(int x){\n        printf(\"%d\",x);\n    }\n    inline void print(char x){\n        putchar(x);\n    }\n    inline void flush(){\n        return;\n    }\n}//using namespace normal_io;\n\nint main(){\n    int x;\n    read(x);\n    print(x);\n    flush();\n    return 0;\n}\n```\n\n## short版\n\nupdate at 20180405\n\n```cpp\n#include <cstdio>\n#include <cctype>\n\nnamespace fast_io {\n    inline char read(){static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;}\n    inline void read(int &x){static bool iosig;static char c;for (iosig=false,c=read();!isdigit(c);c=read()){if(c=='-')iosig=true;if(c==-1)return;}for(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');if(iosig)x=-x;}\n    inline void read(char *a){static char c = read();while(c!=-1&&(c==' '||c=='\\n'||c=='\\r'))c=read();while(c!=-1&&c!='\\r'&&c!=' '&&c!='\\n') *a++=c,c=read();*a=0;}\n    const int OUT_LEN=1000000;char obuf[OUT_LEN],*ooh=obuf;\n    inline void print(char c){if(ooh==obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;*ooh++ = c;}\n    inline void print(int x){static int buf[30],cnt;if(x==0)print('0');else{if(x<0)print('-'),x=-x;for(cnt=0;x;x/=10)buf[++cnt]=x%10+48;while (cnt) print((char)buf[cnt--]);}}\n    inline void print(char *a){while(*a) print(*a++);}\n    inline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}using namespace fast_io;\n\nnamespace normal_io{\n    inline char read(){return getchar();}\n    inline void read(int &x){scanf(\"%d\",&x);}\n    inline void print(int x){printf(\"%d\",x);}\n    inline void print(char x){putchar(x);}\n    inline void flush(){return;}\n}//using namespace normal_io;\n\nint main(){\n    int x;\n    read(x);\n    print(x);\n    flush();\n    return 0;\n}\n```\n\n","slug":"输入输出优化模板","published":1,"updated":"2018-04-05T10:28:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3n90071bljrh1oreyn6","content":"<p>输入输出模板替代普通读写方式，可以在一定程度上加快程序运行速度。</p>\n<a id=\"more\"></a>\n<p>依赖库<code>stdio.h</code> 和 <code>ctype.h</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//return getchar();</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN], *s, *t;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s==t?(((t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>))== s)?<span class=\"number\">-1</span>:*s++) : *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (iosig = <span class=\"literal\">false</span>, c = read(); !<span class=\"built_in\">isdigit</span>(c); c = read()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">'-'</span>) iosig = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (x = <span class=\"number\">0</span>; <span class=\"built_in\">isdigit</span>(c); c = read())</span><br><span class=\"line\">            x = ((x+(x&lt;&lt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>) + (c ^ <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iosig) x = -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c = read();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c!= <span class=\"number\">-1</span>&amp;&amp;(c == <span class=\"string\">' '</span>||c!=<span class=\"string\">'\\r'</span>||c ==<span class=\"string\">'\\n'</span>))</span><br><span class=\"line\">            c = read();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(c!= <span class=\"number\">-1</span>&amp;&amp;c!=<span class=\"string\">' '</span>&amp;&amp;c!=<span class=\"string\">'\\r'</span>&amp;&amp;c!=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            *a++ = c,c = read();</span><br><span class=\"line\">        *a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ooh == obuf + OUT_LEN) fwrite(obuf, <span class=\"number\">1</span>, OUT_LEN, <span class=\"built_in\">stdout</span>), ooh = obuf;</span><br><span class=\"line\">        *ooh++ = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> buf[<span class=\"number\">30</span>], cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>)</span><br><span class=\"line\">            print(<span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) print(<span class=\"string\">'-'</span>), x = -x;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (cnt = <span class=\"number\">0</span>; x; x /= <span class=\"number\">10</span>) buf[++cnt] = x % <span class=\"number\">10</span> + <span class=\"number\">48</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt) print((<span class=\"keyword\">char</span>)buf[cnt--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(*a) print(*a++);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        fwrite(obuf, <span class=\"number\">1</span>, ooh - obuf, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> normal_io&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//using namespace normal_io;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    read(x);</span><br><span class=\"line\">    print(x);</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"short版\"><a href=\"#short版\" class=\"headerlink\" title=\"short版\"></a>short版</h2><p>update at 20180405</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_io &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN=<span class=\"number\">1000000</span>;<span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN],*s,*t;<span class=\"keyword\">return</span> s==t?(((t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>))==s)?<span class=\"number\">-1</span>:*s++) : *s++;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;<span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;<span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;<span class=\"keyword\">for</span> (iosig=<span class=\"literal\">false</span>,c=read();!<span class=\"built_in\">isdigit</span>(c);c=read())&#123;<span class=\"keyword\">if</span>(c==<span class=\"string\">'-'</span>)iosig=<span class=\"literal\">true</span>;<span class=\"keyword\">if</span>(c==<span class=\"number\">-1</span>)<span class=\"keyword\">return</span>;&#125;<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;<span class=\"built_in\">isdigit</span>(c);c=read())x=((x+(x&lt;&lt;<span class=\"number\">2</span>))&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"string\">'0'</span>);<span class=\"keyword\">if</span>(iosig)x=-x;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;<span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c = read();<span class=\"keyword\">while</span>(c!=<span class=\"number\">-1</span>&amp;&amp;(c==<span class=\"string\">' '</span>||c==<span class=\"string\">'\\n'</span>||c==<span class=\"string\">'\\r'</span>))c=read();<span class=\"keyword\">while</span>(c!=<span class=\"number\">-1</span>&amp;&amp;c!=<span class=\"string\">'\\r'</span>&amp;&amp;c!=<span class=\"string\">' '</span>&amp;&amp;c!=<span class=\"string\">'\\n'</span>) *a++=c,c=read();*a=<span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN=<span class=\"number\">1000000</span>;<span class=\"keyword\">char</span> obuf[OUT_LEN],*ooh=obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;<span class=\"keyword\">if</span>(ooh==obuf+OUT_LEN) fwrite(obuf,<span class=\"number\">1</span>,OUT_LEN,<span class=\"built_in\">stdout</span>),ooh=obuf;*ooh++ = c;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;<span class=\"keyword\">static</span> <span class=\"keyword\">int</span> buf[<span class=\"number\">30</span>],cnt;<span class=\"keyword\">if</span>(x==<span class=\"number\">0</span>)print(<span class=\"string\">'0'</span>);<span class=\"keyword\">else</span>&#123;<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)print(<span class=\"string\">'-'</span>),x=-x;<span class=\"keyword\">for</span>(cnt=<span class=\"number\">0</span>;x;x/=<span class=\"number\">10</span>)buf[++cnt]=x%<span class=\"number\">10</span>+<span class=\"number\">48</span>;<span class=\"keyword\">while</span> (cnt) print((<span class=\"keyword\">char</span>)buf[cnt--]);&#125;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> *a)</span></span>&#123;<span class=\"keyword\">while</span>(*a) print(*a++);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;fwrite(obuf,<span class=\"number\">1</span>,ooh-obuf,<span class=\"built_in\">stdout</span>);&#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_io;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> normal_io&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> getchar();&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span></span>&#123;<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;x);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span></span>&#123;<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,x);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> x)</span></span>&#123;<span class=\"built_in\">putchar</span>(x);&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//using namespace normal_io;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    read(x);</span><br><span class=\"line\">    print(x);</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>输入输出模板替代普通读写方式，可以在一定程度上加快程序运行速度。</p>","more":"<p>依赖库<code>stdio.h</code> 和 <code>ctype.h</code>。</p>\n<!--�75-->\n<h2 id=\"short版\"><a href=\"#short版\" class=\"headerlink\" title=\"short版\"></a>short版</h2><p>update at 20180405</p>\n<!--�76-->"},{"title":"非旋Treap学习笔记","urlname":"nonerotatingtreap-notes","date":"2018-02-17T11:45:17.000Z","visible":null,"_content":"\n非旋$Treap$，是一种不基于旋转的平衡树。它基于$Treap$的树堆思想，并且能够高效的完成某些对区间的操作，而且灵活性比较高。它也可以进行可持久化的操作。\n\n<!-- more -->\n\n{%post_link Treap学习笔记 这篇文章 %}，介绍了基于旋转的$Treap$的基本概念等等，在这里不再赘述。\n\n## 代码简述\n\n这里以[这道题](https://www.luogu.org/problemnew/show/P3391)题作为模板。\n\n### 节点的定义\n\n```cpp\nstruct node_t{\n    int val,p,size;\n    // val 是数值，p 是优先级，size 是当前节点代表的区间的大小\n    bool rev;\n    node_t *son[2],**null;\n    //下放标记\n    void pushdown(){\n        if(this == *null) return;\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    //更新节点\n    void pushup(){\n        if(this == *null) return;\n        size = son[0]->size + son[1]->size + 1;\n    }\n    //反转以当前节点为父节点所代表的区间\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        rev^=1;\n    }\n};\n```\n这里的代码很简单，不作赘述。\n\n不过有一点要说的。这里的双重指针`**null`的目的主要是让这里的节点能够快速的判断是否这个节点是下面平衡树的`null`节点。\n\n### Treap结构体定义 & 初始化函数\n\n```cpp\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN];\n    //tmp 和 stack 数组都是为了后面的$O(n)$建树做准备\n    node_t *root,*null;\n    int cnt;\n    fhqtreap(){\n        cnt = 0;\n        srand(time(NULL));\n        newnode(null);\n        null->p = MAX;\n        root = null;\n        null->size = 0;\n    }\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[cnt++];//分配内存\n        r->val = val;r->size = 1;\n        r->son[0] = r->son[1] = null;\n        r->rev = 0;//置0\n        r->null = &null;\n        r->p = rand();\n    }\n```\n\n初始化也没有什么难点。主要需要注意：**null的size应当为0，优先级应当是最大的。**\n\n### 建树\n\n```cpp\n    void read_tree(int n){\n        //把节点全部扔到tmp里面去\n        for(int i = 1;i<=n;i++)\n            newnode(tmp[i],i);\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);stack[0]->p = -MAX;\n        //需要保证超级根能呆在最上面\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;// r 是待添加节点\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();//这里需要pushup！因为应当保证下面是一个合法的treap;\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;// 出栈\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;//把r链接到链上\n            stack[nowp+1]->son[0] = pre;//把下面的链连到r的左儿子\n            top = nowp+2;//更新栈内元素\n        }\n        while(top) stack[--top]->pushup();//更新\n        return stack[0]->son[1];//返回根节点\n    }\n```\n\n这里比较复杂。简单来说就是一个[笛卡尔树](https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802)的构造。\n\n这样做的主要好处是可以在$O(n)$之内完成建树。在这里给出一个链接：[Sengxian's Blog](https://blog.sengxian.com/algorithms/treap#%E5%BB%BA%E6%A0%91),我觉得这位神犇讲的比较通俗易懂。\n\n其实我们也可以通过一个简单的方式在$O(n \\log {n})$的时间内完成建树，就是一个一个的插入进去。但这样真的，很慢。\n\n- - -\n\n主要步骤如下：\n\n这里对于 $\\text{p}$ 而言，我们构造小根堆。\n我们将一个节点表示为：$(\\text{key}, \\text{p})$。首先将所有节点按照 $\\text{key}$ 从小到大排序。*在这里，\b就是我们的序列顺序。*\n\n引入一个栈，栈底存放一个元素 $(-\\infty, -\\infty)$，表示超级根，这样保证它总在最上面，他的右儿子即为我们真正的树根。这个栈，维护了笛卡尔树最右边的一条链上面的元素。*（始终往右的一条链）*\n\n从前往后遍历 $(\\text{key}, \\text{p})$：\n\n>对于每一个 $(\\text{key}\\_i, \\text{p}\\_i)$，从栈中找出（从栈顶往栈底遍历）第一个$p$小于等于 $\\text{p}\\_i$ 的元素 $j$。\n\n>将 $j$ 之上即 $\\text{p} > \\text{p}\\_o$ 的点全部弹出。\n\n>我们在这里记$j$的右子节点为$pre$。在树中，将 $pre$ 挂在 $j$ 的左子树上，将 $r$ 挂在原来 $j$ 的右子树的位置。\n\n可以证明这个构造的时间复杂度是$O(n)$。\n\n*以上关于笛卡尔树的介绍转载自Sengxian的Blog，略有改写。*\n\n### 分裂\n\n```cpp\n//分裂为两颗子树，左子树的大小为lsize\nvoid split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n    if(r == null){//边界\n        ls = null;rs = null;\n        return;\n    }\n    r->pushdown();//很重要！\n    if(r->son[0]->size + 1 <= lsize){\n        ls = r;\n        split(r->son[1],lsize - r->son[0]->size - 1,ls->son[1],rs);\n    }\n    else{\n        rs = r;\n        split(r->son[0],lsize,ls,rs->son[0]);\n    }\n    ls->pushup();rs->pushup();\n}\n```\n\n看起来很难，但其实很简单。\n\n我们面临的只有一个问题：**当前节点属于左子树还是右子树？**\n\n判定标准一般是数值大小或者排名来决定的。\n\n> 如果我们判定当前根节点属于分裂后左子树，那么根节点的左子树就一定属于分裂后的左子树，那么我们只需要关心根节点的右子树属于分裂后那颗子树了，然后这个就可以递归下去了；判定属于分裂后的右子树是同理的。\n\n代码也没有什么注意事项。可以证明，分裂的时间复杂度是$O(\\log {n})$。\n\n### 合并\n\n```cpp\nnode_t *merge(node_t *ls,node_t *rs){\n    if(ls == null) return rs;\n    if(rs == null) return ls;\n    // 边界\n    if(ls->p < rs->p){\n        ls->pushdown(); //需要pushdown！\n        ls->son[1] = merge(ls->son[1],rs);\n        ls->pushup();//需要pushup！\n        return ls;\n    }\n    else{\n        rs->pushdown();//需要pushdown！\n        rs->son[0] = merge(ls,rs->son[0]);\n        rs->pushup();//需要pushup！\n        return rs;\n    }\n}\n```\n\n这个和分裂也是类似的。\n\n我们的主要任务变成了判断：**左子树右子树的根节点哪个应该放在总树的根节点？**\n\n判断的依据十分显然。就是两个根节点的优先值。结合上面的分裂，我们也可以发现这里的递归规律：\n\n> 如果合并后根节点是左子树的根节点，那么我们就可以把整个左子树的左子树保留下来，从而把左子树的右子树和右子树一起合并到左子树的右子树，然后左子树就可以作为返回的节点了。右子树同理。\n\n可以证明，合并的时间复杂度也是$O(\\log {n})$。\n\n### split to three\n\n```cpp\n//ls是左子树的size，rs是中间子树的size\nvoid split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n    node_t *m1;\n    split(root,ls,l,m1);\n    split(m1,ms,m,r);\n}\n```\n太简单了，不说这个。\n\n### 区间翻转\n\n```cpp\n//这里使用的是左边和右边的边界\nvoid reverse(int lb,int rb){\n    node_t *l,*m,*r;\n    split(lb-1,rb-lb+1,l,m,r);\n    m->reverse();  \n    root = merge(l,merge(m,r));\n}\n```\n\n也不太想说。主要就是要注意一点。我们在这里，要保证打过标记以后，这个节点的信息已然正确。这个在其他的例题里会比较令人舒服，可以减少一些$pushdown$。\n\n虽然这道题只有区间翻转，但是其他的区间操作也可以同理完成。$Splay$能做的，非旋$Treap$都能做，而且他还可以进行持久化，这是$Splay$比不了的。（然而我并不会写\n\n\n## 完整代码\n\n{% fold %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 510000;\nconst int MAX = 2147483647;\n\n/*以下为输入输出优化*/\nnamespace fast_IO {\n    inline char read() {\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),*s++:*s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = (x << 1) + (x << 3) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    const int OUT_LEN = 10000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if (x == 0) {\n            print('0');\n        }\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_IO;\n/*以上为输入输出优化*/\n\n\nint k,n;\n\nstruct node_t{\n    int val,p,size;\n    bool rev;\n    node_t *son[2],**null;\n    void pushdown(){\n        if(this == *null) return;\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    void pushup(){\n        if(this == *null) return;\n        size = son[0]->size + son[1]->size + 1;\n    }\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        rev^=1;\n    }\n};\n\n\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN];\n    node_t *root,*null;\n    int cnt,tot;\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[cnt++];\n        r->val = val;r->size = 1;\n        r->son[0] = r->son[1] = null;r->rev = 0;\n        r->null = &null;\n        r->p = rand();\n    }\n    fhqtreap(){\n        cnt = 0;\n        srand(time(NULL));\n        newnode(null);\n        null->p = MAX;\n        root = null;\n        null->size = 0;\n    }\n    void read_tree(int n){\n        for(int i = 1;i<=n;i++)\n            newnode(tmp[i],i);\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);\n        stack[0]->p = -MAX;\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;\n            stack[nowp+1]->son[0] = pre;\n            top = nowp+2;\n        }\n        while(top) stack[--top]->pushup();\n        return stack[0]->son[1];\n    }\n    void split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n        if(r == null){\n            ls = null;rs = null;\n            return;\n        }\n        r->pushdown();\n        if(r->son[0]->size + 1 <= lsize){\n            ls = r;\n            split(r->son[1],lsize - r->son[0]->size - 1,ls->son[1],rs);\n        }\n        else{\n            rs = r;\n            split(r->son[0],lsize,ls,rs->son[0]);\n        }\n        ls->pushup();rs->pushup();\n    }\n    node_t *merge(node_t *ls,node_t *rs){\n        if(ls == null) return rs;\n        if(rs == null) return ls;\n        if(ls->p < rs->p){\n            ls->pushdown();\n            ls->son[1] = merge(ls->son[1],rs);\n            ls->pushup();\n            return ls;\n        }\n        else{\n            rs->pushdown();\n            rs->son[0] = merge(ls,rs->son[0]);\n            rs->pushup();\n            return rs;\n        }\n    }\n    void split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n        node_t *m1;\n        split(root,ls,l,m1);\n        split(m1,ms,m,r);\n    }\n    void reverse(int lb,int rb){\n        node_t *l,*m,*r;\n        split(lb-1,rb-lb+1,l,m,r);\n        m->reverse();  \n        root = merge(l,merge(m,r));\n    }\n    void output(node_t *r,int *a){\n        if(r == null) return;\n        r->pushdown();\n        output(r->son[0],a);\n        a[r->son[0]->size] = r->val;\n        output(r->son[1],a + r->son[0]->size+1);\n    }\n    void print(node_t *r = NULL,int depth = 0){\n        if(r == NULL) r = root;\n        if(r == null) return;\n        print(r->son[0],depth+1);\n        \n        for(int i = 0;i<depth;i++) putchar(' ');\n        printf(\"val:%d p:%d size:%d son:%d %d rev?:%d\\n\",r->val,r->p,r->size,r->son[0] != null,r->son[1] != null,r->rev);\n\n        print(r->son[1],depth+1);\n        return;\n    }\n};\n\nfhqtreap w;\n\nint ans[MAXN];\n\nvoid init(){\n    read(n),read(k);\n    w.root = w.build(n);\n}\n\nvoid solve(){\n    int a,b;\n    for(int i = 1;i<=k;i++){\n        read(a),read(b);\n        w.reverse(a,b);\n    }\n    w.output(w.root,ans);\n    for(int i = 0;i<n;i++){\n        print(ans[i]);print(' ');\n    }\n    print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n\n这种$Treap$还有一个别名，叫做$FHQ Treap$，好像是因为这个的发明者是我校神犇范浩强吧（并不清楚。\n\n## 例题\n\n{% post_link 「NOI2005」维护数列-非旋Treap 「NOI2005」维护数列 %}\n\n## 一些参考\n\n这里有一些讲非旋转$Treap$的博客：\n\n[Sengxian's Blog](https://blog.sengxian.com/algorithms/treap)\n\n[xehoth's Blog](https://blog.xehoth.cc/NoneRotatingTreap/)\n\n[Memphis's Blog](http://memphis.is-programmer.com/posts/46317.html)\n","source":"_posts/非旋Treap学习笔记.md","raw":"---\ntitle: 非旋Treap学习笔记\nurlname: nonerotatingtreap-notes\ndate: 2018-02-17 19:45:17\ntags:\n- Treap\n- 平衡树\n- 数据结构\n- 笔记\ncategories:\n- OI\nvisible:\n---\n\n非旋$Treap$，是一种不基于旋转的平衡树。它基于$Treap$的树堆思想，并且能够高效的完成某些对区间的操作，而且灵活性比较高。它也可以进行可持久化的操作。\n\n<!-- more -->\n\n{%post_link Treap学习笔记 这篇文章 %}，介绍了基于旋转的$Treap$的基本概念等等，在这里不再赘述。\n\n## 代码简述\n\n这里以[这道题](https://www.luogu.org/problemnew/show/P3391)题作为模板。\n\n### 节点的定义\n\n```cpp\nstruct node_t{\n    int val,p,size;\n    // val 是数值，p 是优先级，size 是当前节点代表的区间的大小\n    bool rev;\n    node_t *son[2],**null;\n    //下放标记\n    void pushdown(){\n        if(this == *null) return;\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    //更新节点\n    void pushup(){\n        if(this == *null) return;\n        size = son[0]->size + son[1]->size + 1;\n    }\n    //反转以当前节点为父节点所代表的区间\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        rev^=1;\n    }\n};\n```\n这里的代码很简单，不作赘述。\n\n不过有一点要说的。这里的双重指针`**null`的目的主要是让这里的节点能够快速的判断是否这个节点是下面平衡树的`null`节点。\n\n### Treap结构体定义 & 初始化函数\n\n```cpp\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN];\n    //tmp 和 stack 数组都是为了后面的$O(n)$建树做准备\n    node_t *root,*null;\n    int cnt;\n    fhqtreap(){\n        cnt = 0;\n        srand(time(NULL));\n        newnode(null);\n        null->p = MAX;\n        root = null;\n        null->size = 0;\n    }\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[cnt++];//分配内存\n        r->val = val;r->size = 1;\n        r->son[0] = r->son[1] = null;\n        r->rev = 0;//置0\n        r->null = &null;\n        r->p = rand();\n    }\n```\n\n初始化也没有什么难点。主要需要注意：**null的size应当为0，优先级应当是最大的。**\n\n### 建树\n\n```cpp\n    void read_tree(int n){\n        //把节点全部扔到tmp里面去\n        for(int i = 1;i<=n;i++)\n            newnode(tmp[i],i);\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);stack[0]->p = -MAX;\n        //需要保证超级根能呆在最上面\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;// r 是待添加节点\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();//这里需要pushup！因为应当保证下面是一个合法的treap;\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;// 出栈\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;//把r链接到链上\n            stack[nowp+1]->son[0] = pre;//把下面的链连到r的左儿子\n            top = nowp+2;//更新栈内元素\n        }\n        while(top) stack[--top]->pushup();//更新\n        return stack[0]->son[1];//返回根节点\n    }\n```\n\n这里比较复杂。简单来说就是一个[笛卡尔树](https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802)的构造。\n\n这样做的主要好处是可以在$O(n)$之内完成建树。在这里给出一个链接：[Sengxian's Blog](https://blog.sengxian.com/algorithms/treap#%E5%BB%BA%E6%A0%91),我觉得这位神犇讲的比较通俗易懂。\n\n其实我们也可以通过一个简单的方式在$O(n \\log {n})$的时间内完成建树，就是一个一个的插入进去。但这样真的，很慢。\n\n- - -\n\n主要步骤如下：\n\n这里对于 $\\text{p}$ 而言，我们构造小根堆。\n我们将一个节点表示为：$(\\text{key}, \\text{p})$。首先将所有节点按照 $\\text{key}$ 从小到大排序。*在这里，\b就是我们的序列顺序。*\n\n引入一个栈，栈底存放一个元素 $(-\\infty, -\\infty)$，表示超级根，这样保证它总在最上面，他的右儿子即为我们真正的树根。这个栈，维护了笛卡尔树最右边的一条链上面的元素。*（始终往右的一条链）*\n\n从前往后遍历 $(\\text{key}, \\text{p})$：\n\n>对于每一个 $(\\text{key}\\_i, \\text{p}\\_i)$，从栈中找出（从栈顶往栈底遍历）第一个$p$小于等于 $\\text{p}\\_i$ 的元素 $j$。\n\n>将 $j$ 之上即 $\\text{p} > \\text{p}\\_o$ 的点全部弹出。\n\n>我们在这里记$j$的右子节点为$pre$。在树中，将 $pre$ 挂在 $j$ 的左子树上，将 $r$ 挂在原来 $j$ 的右子树的位置。\n\n可以证明这个构造的时间复杂度是$O(n)$。\n\n*以上关于笛卡尔树的介绍转载自Sengxian的Blog，略有改写。*\n\n### 分裂\n\n```cpp\n//分裂为两颗子树，左子树的大小为lsize\nvoid split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n    if(r == null){//边界\n        ls = null;rs = null;\n        return;\n    }\n    r->pushdown();//很重要！\n    if(r->son[0]->size + 1 <= lsize){\n        ls = r;\n        split(r->son[1],lsize - r->son[0]->size - 1,ls->son[1],rs);\n    }\n    else{\n        rs = r;\n        split(r->son[0],lsize,ls,rs->son[0]);\n    }\n    ls->pushup();rs->pushup();\n}\n```\n\n看起来很难，但其实很简单。\n\n我们面临的只有一个问题：**当前节点属于左子树还是右子树？**\n\n判定标准一般是数值大小或者排名来决定的。\n\n> 如果我们判定当前根节点属于分裂后左子树，那么根节点的左子树就一定属于分裂后的左子树，那么我们只需要关心根节点的右子树属于分裂后那颗子树了，然后这个就可以递归下去了；判定属于分裂后的右子树是同理的。\n\n代码也没有什么注意事项。可以证明，分裂的时间复杂度是$O(\\log {n})$。\n\n### 合并\n\n```cpp\nnode_t *merge(node_t *ls,node_t *rs){\n    if(ls == null) return rs;\n    if(rs == null) return ls;\n    // 边界\n    if(ls->p < rs->p){\n        ls->pushdown(); //需要pushdown！\n        ls->son[1] = merge(ls->son[1],rs);\n        ls->pushup();//需要pushup！\n        return ls;\n    }\n    else{\n        rs->pushdown();//需要pushdown！\n        rs->son[0] = merge(ls,rs->son[0]);\n        rs->pushup();//需要pushup！\n        return rs;\n    }\n}\n```\n\n这个和分裂也是类似的。\n\n我们的主要任务变成了判断：**左子树右子树的根节点哪个应该放在总树的根节点？**\n\n判断的依据十分显然。就是两个根节点的优先值。结合上面的分裂，我们也可以发现这里的递归规律：\n\n> 如果合并后根节点是左子树的根节点，那么我们就可以把整个左子树的左子树保留下来，从而把左子树的右子树和右子树一起合并到左子树的右子树，然后左子树就可以作为返回的节点了。右子树同理。\n\n可以证明，合并的时间复杂度也是$O(\\log {n})$。\n\n### split to three\n\n```cpp\n//ls是左子树的size，rs是中间子树的size\nvoid split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n    node_t *m1;\n    split(root,ls,l,m1);\n    split(m1,ms,m,r);\n}\n```\n太简单了，不说这个。\n\n### 区间翻转\n\n```cpp\n//这里使用的是左边和右边的边界\nvoid reverse(int lb,int rb){\n    node_t *l,*m,*r;\n    split(lb-1,rb-lb+1,l,m,r);\n    m->reverse();  \n    root = merge(l,merge(m,r));\n}\n```\n\n也不太想说。主要就是要注意一点。我们在这里，要保证打过标记以后，这个节点的信息已然正确。这个在其他的例题里会比较令人舒服，可以减少一些$pushdown$。\n\n虽然这道题只有区间翻转，但是其他的区间操作也可以同理完成。$Splay$能做的，非旋$Treap$都能做，而且他还可以进行持久化，这是$Splay$比不了的。（然而我并不会写\n\n\n## 完整代码\n\n{% fold %}\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 510000;\nconst int MAX = 2147483647;\n\n/*以下为输入输出优化*/\nnamespace fast_IO {\n    inline char read() {\n        static const int IN_LEN = 1000000;\n        static char buf[IN_LEN], *s, *t;\n        return s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),*s++:*s++;\n    }\n    inline void read(int &x) {\n        static bool iosig;\n        static char c;\n        for (iosig = false, c = read(); !isdigit(c); c = read()) {\n            if (c == '-') iosig = true;\n            if (c == -1) return;\n        }\n        for (x = 0; isdigit(c); c = read())\n            x = (x << 1) + (x << 3) + (c ^ '0');\n        if (iosig) x = -x;\n    }\n    const int OUT_LEN = 10000000;\n    char obuf[OUT_LEN], *ooh = obuf;\n    inline void print(char c) {\n        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;\n        *ooh++ = c;\n    }\n    inline void print(int x) {\n        static int buf[30], cnt;\n        if (x == 0) {\n            print('0');\n        }\n        else {\n            if (x < 0) print('-'), x = -x;\n            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;\n            while (cnt) print((char)buf[cnt--]);\n        }\n    }\n    inline void flush() {\n        fwrite(obuf, 1, ooh - obuf, stdout);\n    }\n}using namespace fast_IO;\n/*以上为输入输出优化*/\n\n\nint k,n;\n\nstruct node_t{\n    int val,p,size;\n    bool rev;\n    node_t *son[2],**null;\n    void pushdown(){\n        if(this == *null) return;\n        if(rev) {\n            son[0]->reverse(),son[1]->reverse();\n            rev = 0;\n        }\n    }\n    void pushup(){\n        if(this == *null) return;\n        size = son[0]->size + son[1]->size + 1;\n    }\n    void reverse(){\n        if(this == *null) return;\n        swap(son[0],son[1]);\n        rev^=1;\n    }\n};\n\n\nstruct fhqtreap{\n    node_t pool[MAXN],*tmp[MAXN],*stack[MAXN];\n    node_t *root,*null;\n    int cnt,tot;\n    void newnode(node_t *&r,int val = 0){\n        r = &pool[cnt++];\n        r->val = val;r->size = 1;\n        r->son[0] = r->son[1] = null;r->rev = 0;\n        r->null = &null;\n        r->p = rand();\n    }\n    fhqtreap(){\n        cnt = 0;\n        srand(time(NULL));\n        newnode(null);\n        null->p = MAX;\n        root = null;\n        null->size = 0;\n    }\n    void read_tree(int n){\n        for(int i = 1;i<=n;i++)\n            newnode(tmp[i],i);\n    }\n    node_t *build(int n){\n        read_tree(n);\n        int top = 1;\n        newnode(stack[0],-MAX);\n        stack[0]->p = -MAX;\n        for(int i = 1;i<=n;i++){\n            int nowp = top - 1;\n            node_t *r = tmp[i],*pre = null;\n            while(stack[nowp]->p > r -> p){\n                stack[nowp]->pushup();\n                pre = stack[nowp];\n                stack[nowp] = null;\n                nowp--;\n            }\n            stack[nowp+1] = stack[nowp]->son[1] = r;\n            stack[nowp+1]->son[0] = pre;\n            top = nowp+2;\n        }\n        while(top) stack[--top]->pushup();\n        return stack[0]->son[1];\n    }\n    void split(node_t *r,int lsize,node_t *&ls,node_t *&rs){\n        if(r == null){\n            ls = null;rs = null;\n            return;\n        }\n        r->pushdown();\n        if(r->son[0]->size + 1 <= lsize){\n            ls = r;\n            split(r->son[1],lsize - r->son[0]->size - 1,ls->son[1],rs);\n        }\n        else{\n            rs = r;\n            split(r->son[0],lsize,ls,rs->son[0]);\n        }\n        ls->pushup();rs->pushup();\n    }\n    node_t *merge(node_t *ls,node_t *rs){\n        if(ls == null) return rs;\n        if(rs == null) return ls;\n        if(ls->p < rs->p){\n            ls->pushdown();\n            ls->son[1] = merge(ls->son[1],rs);\n            ls->pushup();\n            return ls;\n        }\n        else{\n            rs->pushdown();\n            rs->son[0] = merge(ls,rs->son[0]);\n            rs->pushup();\n            return rs;\n        }\n    }\n    void split(int ls,int ms,node_t *&l,node_t *&m,node_t *&r){\n        node_t *m1;\n        split(root,ls,l,m1);\n        split(m1,ms,m,r);\n    }\n    void reverse(int lb,int rb){\n        node_t *l,*m,*r;\n        split(lb-1,rb-lb+1,l,m,r);\n        m->reverse();  \n        root = merge(l,merge(m,r));\n    }\n    void output(node_t *r,int *a){\n        if(r == null) return;\n        r->pushdown();\n        output(r->son[0],a);\n        a[r->son[0]->size] = r->val;\n        output(r->son[1],a + r->son[0]->size+1);\n    }\n    void print(node_t *r = NULL,int depth = 0){\n        if(r == NULL) r = root;\n        if(r == null) return;\n        print(r->son[0],depth+1);\n        \n        for(int i = 0;i<depth;i++) putchar(' ');\n        printf(\"val:%d p:%d size:%d son:%d %d rev?:%d\\n\",r->val,r->p,r->size,r->son[0] != null,r->son[1] != null,r->rev);\n\n        print(r->son[1],depth+1);\n        return;\n    }\n};\n\nfhqtreap w;\n\nint ans[MAXN];\n\nvoid init(){\n    read(n),read(k);\n    w.root = w.build(n);\n}\n\nvoid solve(){\n    int a,b;\n    for(int i = 1;i<=k;i++){\n        read(a),read(b);\n        w.reverse(a,b);\n    }\n    w.output(w.root,ans);\n    for(int i = 0;i<n;i++){\n        print(ans[i]);print(' ');\n    }\n    print('\\n');\n}\n\nint main(){\n    init();\n    solve();\n    flush();\n    return 0;\n}\n```\n{% endfold %}\n\n这种$Treap$还有一个别名，叫做$FHQ Treap$，好像是因为这个的发明者是我校神犇范浩强吧（并不清楚。\n\n## 例题\n\n{% post_link 「NOI2005」维护数列-非旋Treap 「NOI2005」维护数列 %}\n\n## 一些参考\n\n这里有一些讲非旋转$Treap$的博客：\n\n[Sengxian's Blog](https://blog.sengxian.com/algorithms/treap)\n\n[xehoth's Blog](https://blog.xehoth.cc/NoneRotatingTreap/)\n\n[Memphis's Blog](http://memphis.is-programmer.com/posts/46317.html)\n","slug":"非旋Treap学习笔记","published":1,"updated":"2018-03-14T14:22:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3nc0074bljr7h6pglfq","content":"<p>非旋$Treap$，是一种不基于旋转的平衡树。它基于$Treap$的树堆思想，并且能够高效的完成某些对区间的操作，而且灵活性比较高。它也可以进行可持久化的操作。</p>\n<a id=\"more\"></a>\n<a href=\"/20180130-treap-notes/\" title=\"这篇文章\">这篇文章</a>，介绍了基于旋转的$Treap$的基本概念等等，在这里不再赘述。<br><br>## 代码简述<br><br>这里以<a href=\"https://www.luogu.org/problemnew/show/P3391\" target=\"_blank\" rel=\"noopener\">这道题</a>题作为模板。<br><br>### 节点的定义<br><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val,p,size;</span><br><span class=\"line\">    <span class=\"comment\">// val 是数值，p 是优先级，size 是当前节点代表的区间的大小</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>],**null;</span><br><span class=\"line\">    <span class=\"comment\">//下放标记</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev) &#123;</span><br><span class=\"line\">            son[<span class=\"number\">0</span>]-&gt;reverse(),son[<span class=\"number\">1</span>]-&gt;reverse();</span><br><span class=\"line\">            rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//更新节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        size = son[<span class=\"number\">0</span>]-&gt;size + son[<span class=\"number\">1</span>]-&gt;size + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//反转以当前节点为父节点所代表的区间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(son[<span class=\"number\">0</span>],son[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        rev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里的代码很简单，不作赘述。</p>\n<p>不过有一点要说的。这里的双重指针<code>**null</code>的目的主要是让这里的节点能够快速的判断是否这个节点是下面平衡树的<code>null</code>节点。</p>\n<h3 id=\"Treap结构体定义-amp-初始化函数\"><a href=\"#Treap结构体定义-amp-初始化函数\" class=\"headerlink\" title=\"Treap结构体定义 &amp; 初始化函数\"></a>Treap结构体定义 &amp; 初始化函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fhqtreap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[MAXN],*tmp[MAXN],*<span class=\"built_in\">stack</span>[MAXN];</span><br><span class=\"line\">    <span class=\"comment\">//tmp 和 stack 数组都是为了后面的$O(n)$建树做准备</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *root,*null;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt;</span><br><span class=\"line\">    fhqtreap()&#123;</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">        newnode(null);</span><br><span class=\"line\">        null-&gt;p = MAX;</span><br><span class=\"line\">        root = null;</span><br><span class=\"line\">        null-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> val = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        r = &amp;pool[cnt++];<span class=\"comment\">//分配内存</span></span><br><span class=\"line\">        r-&gt;val = val;r-&gt;size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;</span><br><span class=\"line\">        r-&gt;rev = <span class=\"number\">0</span>;<span class=\"comment\">//置0</span></span><br><span class=\"line\">        r-&gt;null = &amp;null;</span><br><span class=\"line\">        r-&gt;p = rand();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>初始化也没有什么难点。主要需要注意：<strong>null的size应当为0，优先级应当是最大的。</strong></p>\n<h3 id=\"建树\"><a href=\"#建树\" class=\"headerlink\" title=\"建树\"></a>建树</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把节点全部扔到tmp里面去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        newnode(tmp[i],i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">node_t</span> *build(<span class=\"keyword\">int</span> n)&#123;</span><br><span class=\"line\">    read_tree(n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> top = <span class=\"number\">1</span>;</span><br><span class=\"line\">    newnode(<span class=\"built_in\">stack</span>[<span class=\"number\">0</span>],-MAX);<span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;p = -MAX;</span><br><span class=\"line\">    <span class=\"comment\">//需要保证超级根能呆在最上面</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nowp = top - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *r = tmp[i],*pre = null;<span class=\"comment\">// r 是待添加节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"built_in\">stack</span>[nowp]-&gt;p &gt; r -&gt; p)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp]-&gt;pushup();<span class=\"comment\">//这里需要pushup！因为应当保证下面是一个合法的treap;</span></span><br><span class=\"line\">            pre = <span class=\"built_in\">stack</span>[nowp];</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp] = null;</span><br><span class=\"line\">            nowp--;<span class=\"comment\">// 出栈</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>] = <span class=\"built_in\">stack</span>[nowp]-&gt;son[<span class=\"number\">1</span>] = r;<span class=\"comment\">//把r链接到链上</span></span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>]-&gt;son[<span class=\"number\">0</span>] = pre;<span class=\"comment\">//把下面的链连到r的左儿子</span></span><br><span class=\"line\">        top = nowp+<span class=\"number\">2</span>;<span class=\"comment\">//更新栈内元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top) <span class=\"built_in\">stack</span>[--top]-&gt;pushup();<span class=\"comment\">//更新</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;son[<span class=\"number\">1</span>];<span class=\"comment\">//返回根节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里比较复杂。简单来说就是一个<a href=\"https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802\" target=\"_blank\" rel=\"noopener\">笛卡尔树</a>的构造。</p>\n<p>这样做的主要好处是可以在$O(n)$之内完成建树。在这里给出一个链接：<a href=\"https://blog.sengxian.com/algorithms/treap#%E5%BB%BA%E6%A0%91\" target=\"_blank\" rel=\"noopener\">Sengxian’s Blog</a>,我觉得这位神犇讲的比较通俗易懂。</p>\n<p>其实我们也可以通过一个简单的方式在$O(n \\log {n})$的时间内完成建树，就是一个一个的插入进去。但这样真的，很慢。</p>\n<hr>\n<p>主要步骤如下：</p>\n<p>这里对于 $\\text{p}$ 而言，我们构造小根堆。<br>我们将一个节点表示为：$(\\text{key}, \\text{p})$。首先将所有节点按照 $\\text{key}$ 从小到大排序。<em>在这里，\b就是我们的序列顺序。</em></p>\n<p>引入一个栈，栈底存放一个元素 $(-\\infty, -\\infty)$，表示超级根，这样保证它总在最上面，他的右儿子即为我们真正的树根。这个栈，维护了笛卡尔树最右边的一条链上面的元素。<em>（始终往右的一条链）</em></p>\n<p>从前往后遍历 $(\\text{key}, \\text{p})$：</p>\n<blockquote>\n<p>对于每一个 $(\\text{key}_i, \\text{p}_i)$，从栈中找出（从栈顶往栈底遍历）第一个$p$小于等于 $\\text{p}_i$ 的元素 $j$。</p>\n</blockquote>\n<blockquote>\n<p>将 $j$ 之上即 $\\text{p} &gt; \\text{p}_o$ 的点全部弹出。</p>\n</blockquote>\n<blockquote>\n<p>我们在这里记$j$的右子节点为$pre$。在树中，将 $pre$ 挂在 $j$ 的左子树上，将 $r$ 挂在原来 $j$ 的右子树的位置。</p>\n</blockquote>\n<p>可以证明这个构造的时间复杂度是$O(n)$。</p>\n<p><em>以上关于笛卡尔树的介绍转载自Sengxian的Blog，略有改写。</em></p>\n<h3 id=\"分裂\"><a href=\"#分裂\" class=\"headerlink\" title=\"分裂\"></a>分裂</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分裂为两颗子树，左子树的大小为lsize</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> lsize,<span class=\"keyword\">node_t</span> *&amp;ls,<span class=\"keyword\">node_t</span> *&amp;rs)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r == null)&#123;<span class=\"comment\">//边界</span></span><br><span class=\"line\">        ls = null;rs = null;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    r-&gt;pushdown();<span class=\"comment\">//很重要！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>]-&gt;size + <span class=\"number\">1</span> &lt;= lsize)&#123;</span><br><span class=\"line\">        ls = r;</span><br><span class=\"line\">        split(r-&gt;son[<span class=\"number\">1</span>],lsize - r-&gt;son[<span class=\"number\">0</span>]-&gt;size - <span class=\"number\">1</span>,ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        rs = r;</span><br><span class=\"line\">        split(r-&gt;son[<span class=\"number\">0</span>],lsize,ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ls-&gt;pushup();rs-&gt;pushup();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看起来很难，但其实很简单。</p>\n<p>我们面临的只有一个问题：<strong>当前节点属于左子树还是右子树？</strong></p>\n<p>判定标准一般是数值大小或者排名来决定的。</p>\n<blockquote>\n<p>如果我们判定当前根节点属于分裂后左子树，那么根节点的左子树就一定属于分裂后的左子树，那么我们只需要关心根节点的右子树属于分裂后那颗子树了，然后这个就可以递归下去了；判定属于分裂后的右子树是同理的。</p>\n</blockquote>\n<p>代码也没有什么注意事项。可以证明，分裂的时间复杂度是$O(\\log {n})$。</p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">node_t</span> *merge(<span class=\"keyword\">node_t</span> *ls,<span class=\"keyword\">node_t</span> *rs)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ls == null) <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(rs == null) <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">    <span class=\"comment\">// 边界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ls-&gt;p &lt; rs-&gt;p)&#123;</span><br><span class=\"line\">        ls-&gt;pushdown(); <span class=\"comment\">//需要pushdown！</span></span><br><span class=\"line\">        ls-&gt;son[<span class=\"number\">1</span>] = merge(ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">        ls-&gt;pushup();<span class=\"comment\">//需要pushup！</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        rs-&gt;pushdown();<span class=\"comment\">//需要pushdown！</span></span><br><span class=\"line\">        rs-&gt;son[<span class=\"number\">0</span>] = merge(ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        rs-&gt;pushup();<span class=\"comment\">//需要pushup！</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个和分裂也是类似的。</p>\n<p>我们的主要任务变成了判断：<strong>左子树右子树的根节点哪个应该放在总树的根节点？</strong></p>\n<p>判断的依据十分显然。就是两个根节点的优先值。结合上面的分裂，我们也可以发现这里的递归规律：</p>\n<blockquote>\n<p>如果合并后根节点是左子树的根节点，那么我们就可以把整个左子树的左子树保留下来，从而把左子树的右子树和右子树一起合并到左子树的右子树，然后左子树就可以作为返回的节点了。右子树同理。</p>\n</blockquote>\n<p>可以证明，合并的时间复杂度也是$O(\\log {n})$。</p>\n<h3 id=\"split-to-three\"><a href=\"#split-to-three\" class=\"headerlink\" title=\"split to three\"></a>split to three</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ls是左子树的size，rs是中间子树的size</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> ls,<span class=\"keyword\">int</span> ms,<span class=\"keyword\">node_t</span> *&amp;l,<span class=\"keyword\">node_t</span> *&amp;m,<span class=\"keyword\">node_t</span> *&amp;r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *m1;</span><br><span class=\"line\">    split(root,ls,l,m1);</span><br><span class=\"line\">    split(m1,ms,m,r);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>太简单了，不说这个。</p>\n<h3 id=\"区间翻转\"><a href=\"#区间翻转\" class=\"headerlink\" title=\"区间翻转\"></a>区间翻转</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里使用的是左边和右边的边界</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> rb)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *l,*m,*r;</span><br><span class=\"line\">    split(lb<span class=\"number\">-1</span>,rb-lb+<span class=\"number\">1</span>,l,m,r);</span><br><span class=\"line\">    m-&gt;reverse();  </span><br><span class=\"line\">    root = merge(l,merge(m,r));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也不太想说。主要就是要注意一点。我们在这里，要保证打过标记以后，这个节点的信息已然正确。这个在其他的例题里会比较令人舒服，可以减少一些$pushdown$。</p>\n<p>虽然这道题只有区间翻转，但是其他的区间操作也可以同理完成。$Splay$能做的，非旋$Treap$都能做，而且他还可以进行持久化，这是$Splay$比不了的。（然而我并不会写</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAXN = <span class=\"number\">510000</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2147483647</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*以下为输入输出优化*/</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> fast_IO &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">read</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> IN_LEN = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[IN_LEN], *s, *t;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s==t?t=(s=buf)+fread(buf,<span class=\"number\">1</span>,IN_LEN,<span class=\"built_in\">stdin</span>),*s++:*s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> iosig;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (iosig = <span class=\"literal\">false</span>, c = read(); !<span class=\"built_in\">isdigit</span>(c); c = read()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">'-'</span>) iosig = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (x = <span class=\"number\">0</span>; <span class=\"built_in\">isdigit</span>(c); c = read())</span><br><span class=\"line\">            x = (x &lt;&lt; <span class=\"number\">1</span>) + (x &lt;&lt; <span class=\"number\">3</span>) + (c ^ <span class=\"string\">'0'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (iosig) x = -x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> OUT_LEN = <span class=\"number\">10000000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> obuf[OUT_LEN], *ooh = obuf;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ooh == obuf + OUT_LEN) fwrite(obuf, <span class=\"number\">1</span>, OUT_LEN, <span class=\"built_in\">stdout</span>), ooh = obuf;</span><br><span class=\"line\">        *ooh++ = c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> buf[<span class=\"number\">30</span>], cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            print(<span class=\"string\">'0'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span>) print(<span class=\"string\">'-'</span>), x = -x;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (cnt = <span class=\"number\">0</span>; x; x /= <span class=\"number\">10</span>) buf[++cnt] = x % <span class=\"number\">10</span> + <span class=\"number\">48</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cnt) print((<span class=\"keyword\">char</span>)buf[cnt--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">flush</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        fwrite(obuf, <span class=\"number\">1</span>, ooh - obuf, <span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> fast_IO;</span><br><span class=\"line\"><span class=\"comment\">/*以上为输入输出优化*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> k,n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node_t</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val,p,size;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> rev;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *son[<span class=\"number\">2</span>],**null;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rev) &#123;</span><br><span class=\"line\">            son[<span class=\"number\">0</span>]-&gt;reverse(),son[<span class=\"number\">1</span>]-&gt;reverse();</span><br><span class=\"line\">            rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pushup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        size = son[<span class=\"number\">0</span>]-&gt;size + son[<span class=\"number\">1</span>]-&gt;size + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> == *null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        swap(son[<span class=\"number\">0</span>],son[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        rev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">fhqtreap</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> pool[MAXN],*tmp[MAXN],*<span class=\"built_in\">stack</span>[MAXN];</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *root,*null;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cnt,tot;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">newnode</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *&amp;r,<span class=\"keyword\">int</span> val = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        r = &amp;pool[cnt++];</span><br><span class=\"line\">        r-&gt;val = val;r-&gt;size = <span class=\"number\">1</span>;</span><br><span class=\"line\">        r-&gt;son[<span class=\"number\">0</span>] = r-&gt;son[<span class=\"number\">1</span>] = null;r-&gt;rev = <span class=\"number\">0</span>;</span><br><span class=\"line\">        r-&gt;null = &amp;null;</span><br><span class=\"line\">        r-&gt;p = rand();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fhqtreap()&#123;</span><br><span class=\"line\">        cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">        newnode(null);</span><br><span class=\"line\">        null-&gt;p = MAX;</span><br><span class=\"line\">        root = null;</span><br><span class=\"line\">        null-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read_tree</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            newnode(tmp[i],i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *build(<span class=\"keyword\">int</span> n)&#123;</span><br><span class=\"line\">        read_tree(n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> top = <span class=\"number\">1</span>;</span><br><span class=\"line\">        newnode(<span class=\"built_in\">stack</span>[<span class=\"number\">0</span>],-MAX);</span><br><span class=\"line\">        <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;p = -MAX;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nowp = top - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">node_t</span> *r = tmp[i],*pre = null;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"built_in\">stack</span>[nowp]-&gt;p &gt; r -&gt; p)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[nowp]-&gt;pushup();</span><br><span class=\"line\">                pre = <span class=\"built_in\">stack</span>[nowp];</span><br><span class=\"line\">                <span class=\"built_in\">stack</span>[nowp] = null;</span><br><span class=\"line\">                nowp--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>] = <span class=\"built_in\">stack</span>[nowp]-&gt;son[<span class=\"number\">1</span>] = r;</span><br><span class=\"line\">            <span class=\"built_in\">stack</span>[nowp+<span class=\"number\">1</span>]-&gt;son[<span class=\"number\">0</span>] = pre;</span><br><span class=\"line\">            top = nowp+<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(top) <span class=\"built_in\">stack</span>[--top]-&gt;pushup();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">stack</span>[<span class=\"number\">0</span>]-&gt;son[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> lsize,<span class=\"keyword\">node_t</span> *&amp;ls,<span class=\"keyword\">node_t</span> *&amp;rs)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null)&#123;</span><br><span class=\"line\">            ls = null;rs = null;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r-&gt;pushdown();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r-&gt;son[<span class=\"number\">0</span>]-&gt;size + <span class=\"number\">1</span> &lt;= lsize)&#123;</span><br><span class=\"line\">            ls = r;</span><br><span class=\"line\">            split(r-&gt;son[<span class=\"number\">1</span>],lsize - r-&gt;son[<span class=\"number\">0</span>]-&gt;size - <span class=\"number\">1</span>,ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            rs = r;</span><br><span class=\"line\">            split(r-&gt;son[<span class=\"number\">0</span>],lsize,ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ls-&gt;pushup();rs-&gt;pushup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">node_t</span> *merge(<span class=\"keyword\">node_t</span> *ls,<span class=\"keyword\">node_t</span> *rs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ls == null) <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rs == null) <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ls-&gt;p &lt; rs-&gt;p)&#123;</span><br><span class=\"line\">            ls-&gt;pushdown();</span><br><span class=\"line\">            ls-&gt;son[<span class=\"number\">1</span>] = merge(ls-&gt;son[<span class=\"number\">1</span>],rs);</span><br><span class=\"line\">            ls-&gt;pushup();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ls;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            rs-&gt;pushdown();</span><br><span class=\"line\">            rs-&gt;son[<span class=\"number\">0</span>] = merge(ls,rs-&gt;son[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            rs-&gt;pushup();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> ls,<span class=\"keyword\">int</span> ms,<span class=\"keyword\">node_t</span> *&amp;l,<span class=\"keyword\">node_t</span> *&amp;m,<span class=\"keyword\">node_t</span> *&amp;r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *m1;</span><br><span class=\"line\">        split(root,ls,l,m1);</span><br><span class=\"line\">        split(m1,ms,m,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> lb,<span class=\"keyword\">int</span> rb)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">node_t</span> *l,*m,*r;</span><br><span class=\"line\">        split(lb<span class=\"number\">-1</span>,rb-lb+<span class=\"number\">1</span>,l,m,r);</span><br><span class=\"line\">        m-&gt;reverse();  </span><br><span class=\"line\">        root = merge(l,merge(m,r));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r,<span class=\"keyword\">int</span> *a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        r-&gt;pushdown();</span><br><span class=\"line\">        output(r-&gt;son[<span class=\"number\">0</span>],a);</span><br><span class=\"line\">        a[r-&gt;son[<span class=\"number\">0</span>]-&gt;size] = r-&gt;val;</span><br><span class=\"line\">        output(r-&gt;son[<span class=\"number\">1</span>],a + r-&gt;son[<span class=\"number\">0</span>]-&gt;size+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">node_t</span> *r = <span class=\"literal\">NULL</span>,<span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == <span class=\"literal\">NULL</span>) r = root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(r == null) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        print(r-&gt;son[<span class=\"number\">0</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;depth;i++) <span class=\"built_in\">putchar</span>(<span class=\"string\">' '</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"val:%d p:%d size:%d son:%d %d rev?:%d\\n\"</span>,r-&gt;val,r-&gt;p,r-&gt;size,r-&gt;son[<span class=\"number\">0</span>] != null,r-&gt;son[<span class=\"number\">1</span>] != null,r-&gt;rev);</span><br><span class=\"line\"></span><br><span class=\"line\">        print(r-&gt;son[<span class=\"number\">1</span>],depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fhqtreap w;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    read(n),read(k);</span><br><span class=\"line\">    w.root = w.build(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">        read(a),read(b);</span><br><span class=\"line\">        w.reverse(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    w.output(w.root,ans);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        print(ans[i]);print(<span class=\"string\">' '</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    solve();</span><br><span class=\"line\">    flush();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>这种$Treap$还有一个别名，叫做$FHQ Treap$，好像是因为这个的发明者是我校神犇范浩强吧（并不清楚。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180217-noi2005-sequence/\" title=\"「NOI2005」维护数列\">「NOI2005」维护数列</a>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p>这里有一些讲非旋转$Treap$的博客：</p>\n<p><a href=\"https://blog.sengxian.com/algorithms/treap\" target=\"_blank\" rel=\"noopener\">Sengxian’s Blog</a></p>\n<p><a href=\"https://blog.xehoth.cc/NoneRotatingTreap/\" target=\"_blank\" rel=\"noopener\">xehoth’s Blog</a></p>\n<p><a href=\"http://memphis.is-programmer.com/posts/46317.html\" target=\"_blank\" rel=\"noopener\">Memphis’s Blog</a></p>\n","site":{"data":{}},"excerpt":"<p>非旋$Treap$，是一种不基于旋转的平衡树。它基于$Treap$的树堆思想，并且能够高效的完成某些对区间的操作，而且灵活性比较高。它也可以进行可持久化的操作。</p>","more":"<a href=\"/20180130-treap-notes/\" title=\"这篇文章\">这篇文章</a>，介绍了基于旋转的$Treap$的基本概念等等，在这里不再赘述。<br><br>## 代码简述<br><br>这里以<a href=\"https://www.luogu.org/problemnew/show/P3391\" target=\"_blank\" rel=\"noopener\">这道题</a>题作为模板。<br><br>### 节点的定义<br><br><!--�77-->\n<p>这里的代码很简单，不作赘述。</p>\n<p>不过有一点要说的。这里的双重指针<code>**null</code>的目的主要是让这里的节点能够快速的判断是否这个节点是下面平衡树的<code>null</code>节点。</p>\n<h3 id=\"Treap结构体定义-amp-初始化函数\"><a href=\"#Treap结构体定义-amp-初始化函数\" class=\"headerlink\" title=\"Treap结构体定义 &amp; 初始化函数\"></a>Treap结构体定义 &amp; 初始化函数</h3><!--�78-->\n<p>初始化也没有什么难点。主要需要注意：<strong>null的size应当为0，优先级应当是最大的。</strong></p>\n<h3 id=\"建树\"><a href=\"#建树\" class=\"headerlink\" title=\"建树\"></a>建树</h3><!--�79-->\n<p>这里比较复杂。简单来说就是一个<a href=\"https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802\" target=\"_blank\" rel=\"noopener\">笛卡尔树</a>的构造。</p>\n<p>这样做的主要好处是可以在$O(n)$之内完成建树。在这里给出一个链接：<a href=\"https://blog.sengxian.com/algorithms/treap#%E5%BB%BA%E6%A0%91\" target=\"_blank\" rel=\"noopener\">Sengxian’s Blog</a>,我觉得这位神犇讲的比较通俗易懂。</p>\n<p>其实我们也可以通过一个简单的方式在$O(n \\log {n})$的时间内完成建树，就是一个一个的插入进去。但这样真的，很慢。</p>\n<hr>\n<p>主要步骤如下：</p>\n<p>这里对于 $\\text{p}$ 而言，我们构造小根堆。<br>我们将一个节点表示为：$(\\text{key}, \\text{p})$。首先将所有节点按照 $\\text{key}$ 从小到大排序。<em>在这里，\b就是我们的序列顺序。</em></p>\n<p>引入一个栈，栈底存放一个元素 $(-\\infty, -\\infty)$，表示超级根，这样保证它总在最上面，他的右儿子即为我们真正的树根。这个栈，维护了笛卡尔树最右边的一条链上面的元素。<em>（始终往右的一条链）</em></p>\n<p>从前往后遍历 $(\\text{key}, \\text{p})$：</p>\n<blockquote>\n<p>对于每一个 $(\\text{key}_i, \\text{p}_i)$，从栈中找出（从栈顶往栈底遍历）第一个$p$小于等于 $\\text{p}_i$ 的元素 $j$。</p>\n</blockquote>\n<blockquote>\n<p>将 $j$ 之上即 $\\text{p} &gt; \\text{p}_o$ 的点全部弹出。</p>\n</blockquote>\n<blockquote>\n<p>我们在这里记$j$的右子节点为$pre$。在树中，将 $pre$ 挂在 $j$ 的左子树上，将 $r$ 挂在原来 $j$ 的右子树的位置。</p>\n</blockquote>\n<p>可以证明这个构造的时间复杂度是$O(n)$。</p>\n<p><em>以上关于笛卡尔树的介绍转载自Sengxian的Blog，略有改写。</em></p>\n<h3 id=\"分裂\"><a href=\"#分裂\" class=\"headerlink\" title=\"分裂\"></a>分裂</h3><!--�80-->\n<p>看起来很难，但其实很简单。</p>\n<p>我们面临的只有一个问题：<strong>当前节点属于左子树还是右子树？</strong></p>\n<p>判定标准一般是数值大小或者排名来决定的。</p>\n<blockquote>\n<p>如果我们判定当前根节点属于分裂后左子树，那么根节点的左子树就一定属于分裂后的左子树，那么我们只需要关心根节点的右子树属于分裂后那颗子树了，然后这个就可以递归下去了；判定属于分裂后的右子树是同理的。</p>\n</blockquote>\n<p>代码也没有什么注意事项。可以证明，分裂的时间复杂度是$O(\\log {n})$。</p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><!--�81-->\n<p>这个和分裂也是类似的。</p>\n<p>我们的主要任务变成了判断：<strong>左子树右子树的根节点哪个应该放在总树的根节点？</strong></p>\n<p>判断的依据十分显然。就是两个根节点的优先值。结合上面的分裂，我们也可以发现这里的递归规律：</p>\n<blockquote>\n<p>如果合并后根节点是左子树的根节点，那么我们就可以把整个左子树的左子树保留下来，从而把左子树的右子树和右子树一起合并到左子树的右子树，然后左子树就可以作为返回的节点了。右子树同理。</p>\n</blockquote>\n<p>可以证明，合并的时间复杂度也是$O(\\log {n})$。</p>\n<h3 id=\"split-to-three\"><a href=\"#split-to-three\" class=\"headerlink\" title=\"split to three\"></a>split to three</h3><!--�82-->\n<p>太简单了，不说这个。</p>\n<h3 id=\"区间翻转\"><a href=\"#区间翻转\" class=\"headerlink\" title=\"区间翻转\"></a>区间翻转</h3><!--�83-->\n<p>也不太想说。主要就是要注意一点。我们在这里，要保证打过标记以后，这个节点的信息已然正确。这个在其他的例题里会比较令人舒服，可以减少一些$pushdown$。</p>\n<p>虽然这道题只有区间翻转，但是其他的区间操作也可以同理完成。$Splay$能做的，非旋$Treap$都能做，而且他还可以进行持久化，这是$Splay$比不了的。（然而我并不会写</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><div><div class=\"fold_hider\"><div class=\"close hider_title\">点击切换显示状态</div></div><div class=\"fold\">\n<!--�84-->\n\n</div></div>\n<p>这种$Treap$还有一个别名，叫做$FHQ Treap$，好像是因为这个的发明者是我校神犇范浩强吧（并不清楚。</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><a href=\"/20180217-noi2005-sequence/\" title=\"「NOI2005」维护数列\">「NOI2005」维护数列</a>\n<h2 id=\"一些参考\"><a href=\"#一些参考\" class=\"headerlink\" title=\"一些参考\"></a>一些参考</h2><p>这里有一些讲非旋转$Treap$的博客：</p>\n<p><a href=\"https://blog.sengxian.com/algorithms/treap\" target=\"_blank\" rel=\"noopener\">Sengxian’s Blog</a></p>\n<p><a href=\"https://blog.xehoth.cc/NoneRotatingTreap/\" target=\"_blank\" rel=\"noopener\">xehoth’s Blog</a></p>\n<p><a href=\"http://memphis.is-programmer.com/posts/46317.html\" target=\"_blank\" rel=\"noopener\">Memphis’s Blog</a></p>"},{"title":"高斯消元法学习笔记","urlname":"Gaussian-Elimination-notes","date":"2018-06-23T12:43:54.000Z","visible":null,"_content":"\n\n高斯消元法是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个行梯阵式。\n\n<!-- more -->\n\n## 怎么消？\n\n### 一个小小的例子\n\n回想一下你的小学生活吧。\n\n老师给了你一个方程组。\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n\t2x+3y = 7 \\\\\\\\\n\t4x-5y = 3 \n\\end{array}\n\\right.  \n$$\n\n聪慧如你当然能一眼看出来这个东西的答案是：$x = 2,y = 1$，可是你是怎么看出来的呢？老师告诉过你解二元一次方程组的标准做法：加减消元法。\n\n具体来说，就是用1式乘以某比例之后去减二式，把方程组变成如下的样子：\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n2x+3y = 7 \\\\\\\\\n0x-11y = -11  \n\\end{array}\n\\right.  \n$$\n\n然后再把y带回1式就可以得到x：\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n2x+0y = 4 \\\\\\\\\n0x-11y = -11  \n\\end{array}\n\\right.  \n$$\n\n从而你知道，$x = 2,y = 1$。\n\n恭喜你，你已经完成了高斯消元。\n\n### 再看上面的例子\n\n如果我们把上面方程组的系数抽出来变成一个行列式，就会如下所示:\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 3  \\\\\\\\\n    5 & -4 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    7  \\\\\\\\\n    3 \n\\end{array}\\right| \n\\end{array}\n$$ \n\n那么我们消元的过程就会如下所示：\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 3  \\\\\\\\\n    0 & -11 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    7  \\\\\\\\\n    -11\n\\end{array}\\right| \n\\end{array}\n$$ \n\n然后是\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 0  \\\\\\\\\n    0 & -11 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    4  \\\\\\\\\n    -11\n\\end{array}\\right| \n\\end{array}\n$$ \n\n注意到，最后我们达成了一个目标：**使整个行列式只有对角线上的部分不为0，其他部分均为0**。这个条件的达成，让我们可以方便的计算出来这个方程组的解。\n\n这也是我们在接下来设计的算法中需要达到的。\n\n## 高斯-约旦消元法\n\n运用上面提到的思想去解多元一次方程组的算法，叫做高斯-约旦消元法（Gauss-Jordan Elimination）。\n\n它有着以下的优点：\n\n+ 方便理解\n+ 不用回代\n+ 精度较高\n\n它有着以下的缺点：\n\n+ 运行较慢\n\n### 实现\n\n简单来说，它的运行过程是这个样子的：**每次对于第$i$行，让第$i$列除了第$i$行之外均成为$0$，且不破坏前$i-1$列的该性质。**\n\n具体来说，**每次在处理第$i$行时，将第$i$行整行，乘以恰当比例后与除了第$i$行之外的共$n-1$行相减，使得除了第$i$行之外的$n-1$行的第$i$列均为$0$。**\n（如果你对于第i行第i列的数万一是0的情况感到困惑，请你先往下看，并假设这个位置上永远不会是0）\n\n正确性的说明：\n\n我们需要证明的，就是我们在循环中处理完第$i$行时，不会破坏前$i-1$行的该性质。注意到我们前$i-1$次操作已经使得第$i$行以后的前$i-1$列均成为了$0$，即为如下所示：(将要处理第4行)\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    a & 0 & 0 & 3 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & b & 0 & 5 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & c & 3 & 2 & 3 & 2 & 3\\\\\\\\\n\t0 & 0 & 0 & d & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 7 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 5 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 3 & 2 & 3 & 2 & 3\\\\\\\\\n\t0 & 0 & 0 & 8 & 2 & 3 & 2 & 3\\\\\\\\      \n\\end{array}\\right|\n\\end{array}\n$$ \n\n这个时候我们拿第i行无论如何与其他n-1行相减，都不会使前i-1列的数发生任何改变。这是因为第i行的前i-1列都是0。\n\n### 微小的优化\n\n这个算法主要有两个微小的优化：一个是精度上的优化，一个是时间上的优化。\n\n#### 精度优化\n\n注意到我们在处理第i行的时候，在第i+1 \\rightarrow n行之间的这些行与第i行完全是可以互换的。而这个时候我们用第i行与其他行相减的时候，我们为了能获得更优秀的精度，往往会选择**在第i行到第n行中，第i列的数的绝对值最大的那一行，与第i行交换**，然后再进行后面的操作。\n\n#### 时间优化\n\n\n### 无解的判定\n\n## 代码","source":"_posts/高斯消元法学习笔记.md","raw":"---\ntitle: 高斯消元法学习笔记\nurlname: Gaussian-Elimination-notes\ndate: 2018-06-23 20:43:54\ntags:\n- 数学\n- 学习笔记\ncategories: OI\nvisible:\n---\n\n\n高斯消元法是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个行梯阵式。\n\n<!-- more -->\n\n## 怎么消？\n\n### 一个小小的例子\n\n回想一下你的小学生活吧。\n\n老师给了你一个方程组。\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n\t2x+3y = 7 \\\\\\\\\n\t4x-5y = 3 \n\\end{array}\n\\right.  \n$$\n\n聪慧如你当然能一眼看出来这个东西的答案是：$x = 2,y = 1$，可是你是怎么看出来的呢？老师告诉过你解二元一次方程组的标准做法：加减消元法。\n\n具体来说，就是用1式乘以某比例之后去减二式，把方程组变成如下的样子：\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n2x+3y = 7 \\\\\\\\\n0x-11y = -11  \n\\end{array}\n\\right.  \n$$\n\n然后再把y带回1式就可以得到x：\n\n$$\n\\left\\\\{  \n\\begin{array}{rc}\n2x+0y = 4 \\\\\\\\\n0x-11y = -11  \n\\end{array}\n\\right.  \n$$\n\n从而你知道，$x = 2,y = 1$。\n\n恭喜你，你已经完成了高斯消元。\n\n### 再看上面的例子\n\n如果我们把上面方程组的系数抽出来变成一个行列式，就会如下所示:\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 3  \\\\\\\\\n    5 & -4 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    7  \\\\\\\\\n    3 \n\\end{array}\\right| \n\\end{array}\n$$ \n\n那么我们消元的过程就会如下所示：\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 3  \\\\\\\\\n    0 & -11 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    7  \\\\\\\\\n    -11\n\\end{array}\\right| \n\\end{array}\n$$ \n\n然后是\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    2 & 0  \\\\\\\\\n    0 & -11 \n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}   \n    4  \\\\\\\\\n    -11\n\\end{array}\\right| \n\\end{array}\n$$ \n\n注意到，最后我们达成了一个目标：**使整个行列式只有对角线上的部分不为0，其他部分均为0**。这个条件的达成，让我们可以方便的计算出来这个方程组的解。\n\n这也是我们在接下来设计的算法中需要达到的。\n\n## 高斯-约旦消元法\n\n运用上面提到的思想去解多元一次方程组的算法，叫做高斯-约旦消元法（Gauss-Jordan Elimination）。\n\n它有着以下的优点：\n\n+ 方便理解\n+ 不用回代\n+ 精度较高\n\n它有着以下的缺点：\n\n+ 运行较慢\n\n### 实现\n\n简单来说，它的运行过程是这个样子的：**每次对于第$i$行，让第$i$列除了第$i$行之外均成为$0$，且不破坏前$i-1$列的该性质。**\n\n具体来说，**每次在处理第$i$行时，将第$i$行整行，乘以恰当比例后与除了第$i$行之外的共$n-1$行相减，使得除了第$i$行之外的$n-1$行的第$i$列均为$0$。**\n（如果你对于第i行第i列的数万一是0的情况感到困惑，请你先往下看，并假设这个位置上永远不会是0）\n\n正确性的说明：\n\n我们需要证明的，就是我们在循环中处理完第$i$行时，不会破坏前$i-1$行的该性质。注意到我们前$i-1$次操作已经使得第$i$行以后的前$i-1$列均成为了$0$，即为如下所示：(将要处理第4行)\n\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}   \n    a & 0 & 0 & 3 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & b & 0 & 5 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & c & 3 & 2 & 3 & 2 & 3\\\\\\\\\n\t0 & 0 & 0 & d & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 7 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 5 & 2 & 3 & 2 & 3\\\\\\\\\n    0 & 0 & 0 & 3 & 2 & 3 & 2 & 3\\\\\\\\\n\t0 & 0 & 0 & 8 & 2 & 3 & 2 & 3\\\\\\\\      \n\\end{array}\\right|\n\\end{array}\n$$ \n\n这个时候我们拿第i行无论如何与其他n-1行相减，都不会使前i-1列的数发生任何改变。这是因为第i行的前i-1列都是0。\n\n### 微小的优化\n\n这个算法主要有两个微小的优化：一个是精度上的优化，一个是时间上的优化。\n\n#### 精度优化\n\n注意到我们在处理第i行的时候，在第i+1 \\rightarrow n行之间的这些行与第i行完全是可以互换的。而这个时候我们用第i行与其他行相减的时候，我们为了能获得更优秀的精度，往往会选择**在第i行到第n行中，第i列的数的绝对值最大的那一行，与第i行交换**，然后再进行后面的操作。\n\n#### 时间优化\n\n\n### 无解的判定\n\n## 代码","slug":"高斯消元法学习笔记","published":1,"updated":"2018-06-24T11:56:19.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjissu3nf0077bljr31dztfyz","content":"<p>高斯消元法是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个行梯阵式。</p>\n<a id=\"more\"></a>\n<h2 id=\"怎么消？\"><a href=\"#怎么消？\" class=\"headerlink\" title=\"怎么消？\"></a>怎么消？</h2><h3 id=\"一个小小的例子\"><a href=\"#一个小小的例子\" class=\"headerlink\" title=\"一个小小的例子\"></a>一个小小的例子</h3><p>回想一下你的小学生活吧。</p>\n<p>老师给了你一个方程组。</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>    2x+3y = 7 \\\\<br>    4x-5y = 3<br>\\end{array}<br>\\right.<br>$$</p>\n<p>聪慧如你当然能一眼看出来这个东西的答案是：$x = 2,y = 1$，可是你是怎么看出来的呢？老师告诉过你解二元一次方程组的标准做法：加减消元法。</p>\n<p>具体来说，就是用1式乘以某比例之后去减二式，把方程组变成如下的样子：</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>2x+3y = 7 \\\\<br>0x-11y = -11<br>\\end{array}<br>\\right.<br>$$</p>\n<p>然后再把y带回1式就可以得到x：</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>2x+0y = 4 \\\\<br>0x-11y = -11<br>\\end{array}<br>\\right.<br>$$</p>\n<p>从而你知道，$x = 2,y = 1$。</p>\n<p>恭喜你，你已经完成了高斯消元。</p>\n<h3 id=\"再看上面的例子\"><a href=\"#再看上面的例子\" class=\"headerlink\" title=\"再看上面的例子\"></a>再看上面的例子</h3><p>如果我们把上面方程组的系数抽出来变成一个行列式，就会如下所示:<br>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 3  \\\\<br>    5 &amp; -4<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    7  \\\\<br>    3<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>那么我们消元的过程就会如下所示：</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 3  \\\\<br>    0 &amp; -11<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    7  \\\\<br>    -11<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>然后是</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 0  \\\\<br>    0 &amp; -11<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    4  \\\\<br>    -11<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>注意到，最后我们达成了一个目标：<strong>使整个行列式只有对角线上的部分不为0，其他部分均为0</strong>。这个条件的达成，让我们可以方便的计算出来这个方程组的解。</p>\n<p>这也是我们在接下来设计的算法中需要达到的。</p>\n<h2 id=\"高斯-约旦消元法\"><a href=\"#高斯-约旦消元法\" class=\"headerlink\" title=\"高斯-约旦消元法\"></a>高斯-约旦消元法</h2><p>运用上面提到的思想去解多元一次方程组的算法，叫做高斯-约旦消元法（Gauss-Jordan Elimination）。</p>\n<p>它有着以下的优点：</p>\n<ul>\n<li>方便理解</li>\n<li>不用回代</li>\n<li>精度较高</li>\n</ul>\n<p>它有着以下的缺点：</p>\n<ul>\n<li>运行较慢</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>简单来说，它的运行过程是这个样子的：<strong>每次对于第$i$行，让第$i$列除了第$i$行之外均成为$0$，且不破坏前$i-1$列的该性质。</strong></p>\n<p>具体来说，<strong>每次在处理第$i$行时，将第$i$行整行，乘以恰当比例后与除了第$i$行之外的共$n-1$行相减，使得除了第$i$行之外的$n-1$行的第$i$列均为$0$。</strong><br>（如果你对于第i行第i列的数万一是0的情况感到困惑，请你先往下看，并假设这个位置上永远不会是0）</p>\n<p>正确性的说明：</p>\n<p>我们需要证明的，就是我们在循环中处理完第$i$行时，不会破坏前$i-1$行的该性质。注意到我们前$i-1$次操作已经使得第$i$行以后的前$i-1$列均成为了$0$，即为如下所示：(将要处理第4行)</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    a &amp; 0 &amp; 0 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; b &amp; 0 &amp; 5 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; c &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; d &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 7 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 5 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 8 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>这个时候我们拿第i行无论如何与其他n-1行相减，都不会使前i-1列的数发生任何改变。这是因为第i行的前i-1列都是0。</p>\n<h3 id=\"微小的优化\"><a href=\"#微小的优化\" class=\"headerlink\" title=\"微小的优化\"></a>微小的优化</h3><p>这个算法主要有两个微小的优化：一个是精度上的优化，一个是时间上的优化。</p>\n<h4 id=\"精度优化\"><a href=\"#精度优化\" class=\"headerlink\" title=\"精度优化\"></a>精度优化</h4><p>注意到我们在处理第i行的时候，在第i+1 \\rightarrow n行之间的这些行与第i行完全是可以互换的。而这个时候我们用第i行与其他行相减的时候，我们为了能获得更优秀的精度，往往会选择<strong>在第i行到第n行中，第i列的数的绝对值最大的那一行，与第i行交换</strong>，然后再进行后面的操作。</p>\n<h4 id=\"时间优化\"><a href=\"#时间优化\" class=\"headerlink\" title=\"时间优化\"></a>时间优化</h4><h3 id=\"无解的判定\"><a href=\"#无解的判定\" class=\"headerlink\" title=\"无解的判定\"></a>无解的判定</h3><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2>","site":{"data":{}},"excerpt":"<p>高斯消元法是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个行梯阵式。</p>","more":"<h2 id=\"怎么消？\"><a href=\"#怎么消？\" class=\"headerlink\" title=\"怎么消？\"></a>怎么消？</h2><h3 id=\"一个小小的例子\"><a href=\"#一个小小的例子\" class=\"headerlink\" title=\"一个小小的例子\"></a>一个小小的例子</h3><p>回想一下你的小学生活吧。</p>\n<p>老师给了你一个方程组。</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>    2x+3y = 7 \\\\<br>    4x-5y = 3<br>\\end{array}<br>\\right.<br>$$</p>\n<p>聪慧如你当然能一眼看出来这个东西的答案是：$x = 2,y = 1$，可是你是怎么看出来的呢？老师告诉过你解二元一次方程组的标准做法：加减消元法。</p>\n<p>具体来说，就是用1式乘以某比例之后去减二式，把方程组变成如下的样子：</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>2x+3y = 7 \\\\<br>0x-11y = -11<br>\\end{array}<br>\\right.<br>$$</p>\n<p>然后再把y带回1式就可以得到x：</p>\n<p>$$<br>\\left\\{<br>\\begin{array}{rc}<br>2x+0y = 4 \\\\<br>0x-11y = -11<br>\\end{array}<br>\\right.<br>$$</p>\n<p>从而你知道，$x = 2,y = 1$。</p>\n<p>恭喜你，你已经完成了高斯消元。</p>\n<h3 id=\"再看上面的例子\"><a href=\"#再看上面的例子\" class=\"headerlink\" title=\"再看上面的例子\"></a>再看上面的例子</h3><p>如果我们把上面方程组的系数抽出来变成一个行列式，就会如下所示:<br>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 3  \\\\<br>    5 &amp; -4<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    7  \\\\<br>    3<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>那么我们消元的过程就会如下所示：</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 3  \\\\<br>    0 &amp; -11<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    7  \\\\<br>    -11<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>然后是</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    2 &amp; 0  \\\\<br>    0 &amp; -11<br>\\end{array}\\right|<br>\\quad<br>\\left|\\begin{array}{cccc}<br>    4  \\\\<br>    -11<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>注意到，最后我们达成了一个目标：<strong>使整个行列式只有对角线上的部分不为0，其他部分均为0</strong>。这个条件的达成，让我们可以方便的计算出来这个方程组的解。</p>\n<p>这也是我们在接下来设计的算法中需要达到的。</p>\n<h2 id=\"高斯-约旦消元法\"><a href=\"#高斯-约旦消元法\" class=\"headerlink\" title=\"高斯-约旦消元法\"></a>高斯-约旦消元法</h2><p>运用上面提到的思想去解多元一次方程组的算法，叫做高斯-约旦消元法（Gauss-Jordan Elimination）。</p>\n<p>它有着以下的优点：</p>\n<ul>\n<li>方便理解</li>\n<li>不用回代</li>\n<li>精度较高</li>\n</ul>\n<p>它有着以下的缺点：</p>\n<ul>\n<li>运行较慢</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>简单来说，它的运行过程是这个样子的：<strong>每次对于第$i$行，让第$i$列除了第$i$行之外均成为$0$，且不破坏前$i-1$列的该性质。</strong></p>\n<p>具体来说，<strong>每次在处理第$i$行时，将第$i$行整行，乘以恰当比例后与除了第$i$行之外的共$n-1$行相减，使得除了第$i$行之外的$n-1$行的第$i$列均为$0$。</strong><br>（如果你对于第i行第i列的数万一是0的情况感到困惑，请你先往下看，并假设这个位置上永远不会是0）</p>\n<p>正确性的说明：</p>\n<p>我们需要证明的，就是我们在循环中处理完第$i$行时，不会破坏前$i-1$行的该性质。注意到我们前$i-1$次操作已经使得第$i$行以后的前$i-1$列均成为了$0$，即为如下所示：(将要处理第4行)</p>\n<p>$$<br>\\begin{array}{}<br>\\left|\\begin{array}{cccc}<br>    a &amp; 0 &amp; 0 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; b &amp; 0 &amp; 5 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; c &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; d &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 7 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 5 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 3 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>    0 &amp; 0 &amp; 0 &amp; 8 &amp; 2 &amp; 3 &amp; 2 &amp; 3\\\\<br>\\end{array}\\right|<br>\\end{array}<br>$$ </p>\n<p>这个时候我们拿第i行无论如何与其他n-1行相减，都不会使前i-1列的数发生任何改变。这是因为第i行的前i-1列都是0。</p>\n<h3 id=\"微小的优化\"><a href=\"#微小的优化\" class=\"headerlink\" title=\"微小的优化\"></a>微小的优化</h3><p>这个算法主要有两个微小的优化：一个是精度上的优化，一个是时间上的优化。</p>\n<h4 id=\"精度优化\"><a href=\"#精度优化\" class=\"headerlink\" title=\"精度优化\"></a>精度优化</h4><p>注意到我们在处理第i行的时候，在第i+1 \\rightarrow n行之间的这些行与第i行完全是可以互换的。而这个时候我们用第i行与其他行相减的时候，我们为了能获得更优秀的精度，往往会选择<strong>在第i行到第n行中，第i列的数的绝对值最大的那一行，与第i行交换</strong>，然后再进行后面的操作。</p>\n<h4 id=\"时间优化\"><a href=\"#时间优化\" class=\"headerlink\" title=\"时间优化\"></a>时间优化</h4><h3 id=\"无解的判定\"><a href=\"#无解的判定\" class=\"headerlink\" title=\"无解的判定\"></a>无解的判定</h3><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2>"}],"PostAsset":[{"_id":"source/_posts/2018-AprWeek3-4/title.jpg","slug":"title.jpg","post":"cjissu3fb0007bljrmd9uw6b7","modified":0,"renderable":0},{"_id":"source/_posts/2018-FebWeek4/title.jpg","slug":"title.jpg","post":"cjissu3fx000hbljr9en9ihw1","modified":0,"renderable":0},{"_id":"source/_posts/2018-AprWeek1/title.jpg","slug":"title.jpg","post":"cjissu3em0002bljrv0ylek3s","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/booklet.jpg","slug":"booklet.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/2018-JanWeek2/title.png","slug":"title.png","post":"cjissu3g1000jbljrj7107zst","modified":0,"renderable":0},{"_id":"source/_posts/2018-MarWeek1/title_1024px.jpg","slug":"title_1024px.jpg","post":"cjissu3gr000pbljrpsju4ca8","modified":0,"renderable":0},{"_id":"source/_posts/2018-MarWeek3/title.jpg","slug":"title.jpg","post":"cjissu3gz000tbljr1m3zd4td","modified":0,"renderable":0},{"_id":"source/_posts/“长大”/time.jpg","slug":"time.jpg","post":"cjissu3i4001tbljrga27c1sy","modified":0,"renderable":0},{"_id":"source/_posts/「CQOI2014」排序机械臂-Splay/explanation.png","slug":"explanation.png","post":"cjissu3ia0024bljrd71nqh4d","modified":0,"renderable":0},{"_id":"source/_posts/2018-AprWeek2/title.jpg","slug":"title.jpg","post":"cjissu3et0004bljrzvy2l2jm","modified":0,"renderable":0},{"_id":"source/_posts/2018-AprWeek5/title.png","slug":"title.png","post":"cjissu3ff0009bljrk7ffur97","modified":0,"renderable":0},{"_id":"source/_posts/2018-FebWeek1/title.jpg","slug":"title.jpg","post":"cjissu3fi000bbljreegj9ch9","modified":0,"renderable":0},{"_id":"source/_posts/2018-FebWeek2/title.png","slug":"title.png","post":"cjissu3fp000dbljr8a0a6g8h","modified":0,"renderable":0},{"_id":"source/_posts/2018-FebWeek3/title.jpg","slug":"title.jpg","post":"cjissu3fs000ebljro8332wjr","modified":0,"renderable":0},{"_id":"source/_posts/2018-JanWeek3/title.jpg","slug":"title.jpg","post":"cjissu3g4000lbljr8a086iyp","modified":0,"renderable":0},{"_id":"source/_posts/2018-JanWeek4/title.jpg","slug":"title.jpg","post":"cjissu3gd000nbljrao2th7wk","modified":0,"renderable":0},{"_id":"source/_posts/2018-MarWeek2/title.jpg","slug":"title.jpg","post":"cjissu3gw000rbljrj9wlr587","modified":0,"renderable":0},{"_id":"source/_posts/2018-Marweek4/title.jpg","slug":"title.jpg","post":"cjissu3h5000vbljr3bmqg07s","modified":0,"renderable":0},{"_id":"source/_posts/2018-MayWeek1/title.jpg","slug":"title.jpg","post":"cjissu3h9000xbljr74t9zysk","modified":0,"renderable":0},{"_id":"source/_posts/2018-MayWeek2/title.jpg","slug":"title.jpg","post":"cjissu3hb000zbljr1cxdhxdl","modified":0,"renderable":0},{"_id":"source/_posts/2018-MayWeek3/title.jpg","slug":"title.jpg","post":"cjissu3hc0011bljrc2qwlqpw","modified":0,"renderable":0},{"_id":"source/_posts/2018-MayWeek4-5/title.jpg","slug":"title.jpg","post":"cjissu3he0013bljrbuds2s4r","modified":0,"renderable":0},{"_id":"source/_posts/「Luogu1043」数字游戏-dp/description.png","slug":"description.png","post":"cjissu3ix002vbljrbhruzuvs","modified":0,"renderable":0},{"_id":"source/_posts/「梦想」/2333.jpg","slug":"2333.jpg","post":"cjissu3mj0060bljr8d002swd","modified":0,"renderable":0},{"_id":"source/_posts/「红楼一梦」/lindaiyu.jpg","slug":"lindaiyu.jpg","post":"cjissu3mo0067bljrcuz30fgn","modified":0,"renderable":0},{"_id":"source/_posts/2018-MarWeek1/title.jpg","slug":"title.jpg","post":"cjissu3gr000pbljrpsju4ca8","modified":0,"renderable":0},{"_id":"source/_posts/2018年六月·上/title1.jpg","slug":"title1.jpg","post":"cjissu3hi0017bljrg4d3h9rz","modified":0,"renderable":0},{"_id":"source/_posts/2018年六月·上/title2.jpg","slug":"title2.jpg","post":"cjissu3hi0017bljrg4d3h9rz","modified":0,"renderable":0},{"_id":"source/_posts/Splay学习笔记/splay_cqq.pdf","slug":"splay_cqq.pdf","post":"cjissu3hx001jbljriy2ai74z","modified":0,"renderable":0},{"_id":"source/_posts/Splay学习笔记/splay_tarjan.pdf","slug":"splay_tarjan.pdf","post":"cjissu3hx001jbljriy2ai74z","modified":0,"renderable":0},{"_id":"source/_posts/Treap学习笔记/lower_upper.gif","slug":"lower_upper.gif","post":"cjissu3i0001nbljr0oyrrtlw","modified":0,"renderable":0},{"_id":"source/_posts/Treap学习笔记/rotate.gif","slug":"rotate.gif","post":"cjissu3i0001nbljr0oyrrtlw","modified":0,"renderable":0},{"_id":"source/_posts/BJOI2018游记/1.jpg","slug":"1.jpg","post":"cjissu3hp001bbljrjac1f20m","modified":0,"renderable":0},{"_id":"source/_posts/BJOI2018游记/3.jpg","slug":"3.jpg","post":"cjissu3hp001bbljrjac1f20m","modified":0,"renderable":0},{"_id":"source/_posts/BJOI2018游记/4.jpg","slug":"4.jpg","post":"cjissu3hp001bbljrjac1f20m","modified":0,"renderable":0},{"_id":"source/_posts/可持久化线段树学习笔记/segtree.png","slug":"segtree.png","post":"cjissu3mr006cbljrxxlhlgo8","modified":0,"renderable":0},{"_id":"source/_posts/可持久化线段树学习笔记/segtree1.png","slug":"segtree1.png","post":"cjissu3mr006cbljrxxlhlgo8","modified":0,"renderable":0},{"_id":"source/_posts/可持久化线段树学习笔记/segtree2.png","slug":"segtree2.png","post":"cjissu3mr006cbljrxxlhlgo8","modified":0,"renderable":0},{"_id":"source/_posts/冬令营旅游记/1.jpg","slug":"1.jpg","post":"cjissu3mq006abljrpumvkeod","modified":0,"renderable":0},{"_id":"source/_posts/冬令营旅游记/2.jpg","slug":"2.jpg","post":"cjissu3mq006abljrpumvkeod","modified":0,"renderable":0},{"_id":"source/_posts/冬令营旅游记/3.jpg","slug":"3.jpg","post":"cjissu3mq006abljrpumvkeod","modified":0,"renderable":0},{"_id":"source/_posts/冬令营旅游记/4.jpg","slug":"4.jpg","post":"cjissu3mq006abljrpumvkeod","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/airplane.jpg","slug":"airplane.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/cannon.jpg","slug":"cannon.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/classroom.jpg","slug":"classroom.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/clock.jpg","slug":"clock.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/final.jpg","slug":"final.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/gate.jpg","slug":"gate.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/lake.jpg","slug":"lake.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/play_basketball.jpg","slug":"play_basketball.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/playground.jpg","slug":"playground.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/rank.jpg","slug":"rank.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/screen.jpg","slug":"screen.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0},{"_id":"source/_posts/衡水中学游记/tank.jpg","slug":"tank.jpg","post":"cjissu3n3006xbljrwdqoonoo","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjissu3ff0009bljrk7ffur97","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3fv000fbljrljc093gm"},{"post_id":"cjissu3em0002bljrv0ylek3s","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3fz000ibljroo9d5c2x"},{"post_id":"cjissu3fi000bbljreegj9ch9","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3g3000kbljrjb077jpy"},{"post_id":"cjissu3fp000dbljr8a0a6g8h","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3g6000mbljrqy1ivr0c"},{"post_id":"cjissu3et0004bljrzvy2l2jm","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3gf000obljrup8mduz2"},{"post_id":"cjissu3fs000ebljro8332wjr","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3gt000qbljrjzydwuac"},{"post_id":"cjissu3fx000hbljr9en9ihw1","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3gy000sbljrntpzaz8n"},{"post_id":"cjissu3fb0007bljrmd9uw6b7","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3h1000ubljr5m3trxl3"},{"post_id":"cjissu3g1000jbljrj7107zst","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3h8000wbljrzpqkqqz4"},{"post_id":"cjissu3g4000lbljr8a086iyp","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3ha000ybljr48h9qfmp"},{"post_id":"cjissu3gd000nbljrao2th7wk","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hc0010bljr8wp24vk4"},{"post_id":"cjissu3gr000pbljrpsju4ca8","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hd0012bljrfgqyw26s"},{"post_id":"cjissu3gw000rbljrj9wlr587","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hf0014bljr63qi3foa"},{"post_id":"cjissu3gz000tbljr1m3zd4td","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hh0016bljrgyaoz2aq"},{"post_id":"cjissu3h5000vbljr3bmqg07s","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hk0018bljresszptxw"},{"post_id":"cjissu3h9000xbljr74t9zysk","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hp001abljrez4xztp8"},{"post_id":"cjissu3hb000zbljr1cxdhxdl","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hq001cbljrc53kbkml"},{"post_id":"cjissu3hc0011bljrc2qwlqpw","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3ht001gbljr11vbh5ct"},{"post_id":"cjissu3he0013bljrbuds2s4r","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hw001ibljr74eqfzq3"},{"post_id":"cjissu3hg0015bljryvrlq1ws","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3hz001mbljr03megfgk"},{"post_id":"cjissu3hi0017bljrg4d3h9rz","category_id":"cjissu3f20005bljruhvf5jts","_id":"cjissu3i1001obljrr7444ha1"},{"post_id":"cjissu3ht001hbljrz7uroccc","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3i3001rbljriht9beyw"},{"post_id":"cjissu3hn0019bljrglcbvb25","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3i5001ubljrfb3w0507"},{"post_id":"cjissu3hx001jbljriy2ai74z","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3i7001wbljr6aujr2h3"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3i80020bljrire2rsmw"},{"post_id":"cjissu3hp001bbljrjac1f20m","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ia0022bljrusuysy6y"},{"post_id":"cjissu3hs001fbljrpi0ar20g","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ic0025bljrgtacoxnn"},{"post_id":"cjissu3i6001vbljrsa3i7yqk","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3id0028bljrdqnmmhza"},{"post_id":"cjissu3i7001zbljr67jfyb1y","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ig002cbljryncnv6ib"},{"post_id":"cjissu3i90021bljrv3yuqq9u","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ij002fbljroy0up8uu"},{"post_id":"cjissu3i4001tbljrga27c1sy","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3im002jbljrpk1k4dub"},{"post_id":"cjissu3ia0024bljrd71nqh4d","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ip002mbljrjguxmp1a"},{"post_id":"cjissu3ic0027bljrrs1jbjar","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ir002obljrz7mtcueg"},{"post_id":"cjissu3ie002abljrfiipcorj","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3iv002rbljrsf0qhwxm"},{"post_id":"cjissu3ih002ebljrp96agzak","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ix002tbljr42h5kiwc"},{"post_id":"cjissu3il002hbljrn2fwn8nx","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3iz002wbljr9ukbeqop"},{"post_id":"cjissu3io002lbljr1aa4m6gl","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3j2002ybljrwsx1el44"},{"post_id":"cjissu3ip002nbljrvs2lwhkm","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3j50031bljrbgacv8cj"},{"post_id":"cjissu3is002qbljrfjdtneni","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ja0034bljrespvl8lu"},{"post_id":"cjissu3ix002vbljrbhruzuvs","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3je0038bljrpbhk35t6"},{"post_id":"cjissu3j40030bljrrwu4as6j","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jg003bbljrboo4gcps"},{"post_id":"cjissu3j80033bljro9qe6bw9","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ji003fbljr25sgddv4"},{"post_id":"cjissu3jc0037bljrf3j6iknd","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jk003hbljr2d2yzyj0"},{"post_id":"cjissu3jf003abljrq69r7hja","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jm003jbljrpenq8w1t"},{"post_id":"cjissu3jh003dbljrkgcqpuo7","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jp003nbljrqgcdx0ft"},{"post_id":"cjissu3jj003gbljrkz0mm4f7","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jr003qbljrs52szhf2"},{"post_id":"cjissu3jl003ibljrs7oxti4l","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ju003ubljrw52lzvzw"},{"post_id":"cjissu3jn003lbljr1d4w6vqc","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jw003xbljr8li1uroq"},{"post_id":"cjissu3jp003obljrm837jh8w","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jx0040bljrx8r61c95"},{"post_id":"cjissu3jt003sbljrr350wazw","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3jy0042bljrjpaiy23u"},{"post_id":"cjissu3jv003vbljrnuk6yd82","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3k00045bljrto8rhnpu"},{"post_id":"cjissu3jw003zbljr0wy82koz","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3k20047bljrzt9qh6qg"},{"post_id":"cjissu3jz0044bljrg8vs03ho","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3kb004cbljr2prjivqo"},{"post_id":"cjissu3k00046bljr0gwtfq9k","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3kf004gbljrbb9c55ih"},{"post_id":"cjissu3k20049bljroj5wxwle","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ki004jbljr70eum695"},{"post_id":"cjissu3k5004bbljrcxjmfy23","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3kl004nbljry2z0a878"},{"post_id":"cjissu3kc004fbljrm8z8orav","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ko004qbljrzx9yfsnk"},{"post_id":"cjissu3kh004ibljrmum4rael","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3kr004sbljr24y8ve0d"},{"post_id":"cjissu3kj004mbljrximb5fi7","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3kw004wbljrqidwe77i"},{"post_id":"cjissu3km004pbljrg1nfg0wf","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3l0004zbljr2rleoume"},{"post_id":"cjissu3kp004rbljr5wu2r2d2","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3l20053bljrnswq57zb"},{"post_id":"cjissu3ks004vbljrnp6zkadm","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3l40055bljrpg3u8cvi"},{"post_id":"cjissu3kz004ybljr8t3guaec","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3lw0059bljrxgxilzjq"},{"post_id":"cjissu3l10052bljr1fdtzfcu","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3lz005cbljrq5wrtrkx"},{"post_id":"cjissu3l30054bljr5pbtphfj","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3m5005gbljrpj1y72y7"},{"post_id":"cjissu3l50058bljrqofzyfln","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3m7005jbljrdsmohlrl"},{"post_id":"cjissu3lx005bbljrjczups0b","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mb005nbljra20awsco"},{"post_id":"cjissu3m3005fbljrsje9qoo2","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mc005qbljrqcelo3e6"},{"post_id":"cjissu3m9005mbljrsbe83c5v","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mg005vbljrw5sumu0z"},{"post_id":"cjissu3mb005pbljr1p4hclox","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mi005ybljrtavkyn0e"},{"post_id":"cjissu3md005tbljrg2hgzfux","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mk0061bljr5vmopina"},{"post_id":"cjissu3mf005ubljrjfz8av6i","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mn0065bljrpo9ftsb5"},{"post_id":"cjissu3mi005xbljrjcs0hav9","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3mp0068bljr6ilugev5"},{"post_id":"cjissu3mj0060bljr8d002swd","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3mr006bbljrgykf0tbk"},{"post_id":"cjissu3ml0064bljrjebgntz4","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ms006dbljrpatkek8t"},{"post_id":"cjissu3mo0067bljrcuz30fgn","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3mu006gbljr795pqlh9"},{"post_id":"cjissu3mq006abljrpumvkeod","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mv006ibljrv7h1bqoc"},{"post_id":"cjissu3mr006cbljrxxlhlgo8","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3mx006lbljr2gkerm8d"},{"post_id":"cjissu3mt006fbljrstxwbr7e","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3mz006pbljrc5j6jj1c"},{"post_id":"cjissu3my006obljrx8gq43ef","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3n4006ybljr4sfaiqqm"},{"post_id":"cjissu3n0006sbljruwennz65","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3n90070bljryu1j3riz"},{"post_id":"cjissu3mu006hbljrl6o8m74n","category_id":"cjissu3mx006nbljr46kphta8","_id":"cjissu3nb0072bljr7ytaktle"},{"post_id":"cjissu3n1006ubljrp4jed8qz","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3ne0075bljrh64boip2"},{"post_id":"cjissu3n3006xbljrwdqoonoo","category_id":"cjissu3i7001ybljryvvbnzrg","_id":"cjissu3nh0078bljrbrmwres3"},{"post_id":"cjissu3n5006zbljruvt8grt5","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3nj007bbljrtlrvo7hw"},{"post_id":"cjissu3n90071bljrh1oreyn6","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3nj007dbljr1exuc9ic"},{"post_id":"cjissu3nc0074bljr7h6pglfq","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3nj007gbljr4r5qfyxz"},{"post_id":"cjissu3nf0077bljr31dztfyz","category_id":"cjissu3hr001dbljr7l25slds","_id":"cjissu3nj007ibljrm7u131mb"}],"PostTag":[{"post_id":"cjissu3hn0019bljrglcbvb25","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3ic0026bljrwzukstv1"},{"post_id":"cjissu3hn0019bljrglcbvb25","tag_id":"cjissu3hy001lbljrx6o4ep3f","_id":"cjissu3ie0029bljr75mf5k6h"},{"post_id":"cjissu3hn0019bljrglcbvb25","tag_id":"cjissu3i4001sbljrwb3b7fz2","_id":"cjissu3ig002dbljrb8lvy0mq"},{"post_id":"cjissu3hn0019bljrglcbvb25","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3il002gbljrfqtdmf7h"},{"post_id":"cjissu3hp001bbljrjac1f20m","tag_id":"cjissu3ia0023bljrxbkp8bcx","_id":"cjissu3in002kbljrnoq4je9q"},{"post_id":"cjissu3hs001fbljrpi0ar20g","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3j70032bljrgnrrg8sc"},{"post_id":"cjissu3hs001fbljrpi0ar20g","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3jc0035bljrpuot9tn4"},{"post_id":"cjissu3hs001fbljrpi0ar20g","tag_id":"cjissu3is002pbljrmqr9q82d","_id":"cjissu3je0039bljrd4zathrc"},{"post_id":"cjissu3hs001fbljrpi0ar20g","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3jg003cbljrswqvcp5k"},{"post_id":"cjissu3hx001jbljriy2ai74z","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3jo003mbljryy2h7xj4"},{"post_id":"cjissu3hx001jbljriy2ai74z","tag_id":"cjissu3j3002zbljr3ynvycju","_id":"cjissu3jr003pbljrmqffsmdo"},{"post_id":"cjissu3hx001jbljriy2ai74z","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3ju003tbljry2geurzt"},{"post_id":"cjissu3hx001jbljriy2ai74z","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3jw003wbljrodxl389l"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3k4004abljr5n40zxxh"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3kb004dbljrsujcut7n"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","tag_id":"cjissu3jw003ybljrn4rwqaew","_id":"cjissu3kg004hbljr9m3s6nsi"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3kj004kbljrhji32swb"},{"post_id":"cjissu3i0001nbljr0oyrrtlw","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3kl004obljrd7yu3yp8"},{"post_id":"cjissu3i6001vbljrsa3i7yqk","tag_id":"cjissu3k20048bljri4qc32jz","_id":"cjissu3ks004ubljr2bu4kem5"},{"post_id":"cjissu3i6001vbljrsa3i7yqk","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3kz004xbljrqdx0sove"},{"post_id":"cjissu3i6001vbljrsa3i7yqk","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3l00051bljr2ldb04mf"},{"post_id":"cjissu3l10052bljr1fdtzfcu","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3l50057bljrny114x3t"},{"post_id":"cjissu3l10052bljr1fdtzfcu","tag_id":"cjissu3jw003ybljrn4rwqaew","_id":"cjissu3lx005abljrxf0ovw3w"},{"post_id":"cjissu3l10052bljr1fdtzfcu","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3m0005ebljrzsg6eb9m"},{"post_id":"cjissu3l10052bljr1fdtzfcu","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3m6005hbljr14y9veuz"},{"post_id":"cjissu3i7001zbljr67jfyb1y","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3m9005lbljr1om1s1ap"},{"post_id":"cjissu3i7001zbljr67jfyb1y","tag_id":"cjissu3l00050bljr69gtu32j","_id":"cjissu3mb005obljrxx51zm4f"},{"post_id":"cjissu3i7001zbljr67jfyb1y","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3md005sbljrfrvdops5"},{"post_id":"cjissu3i90021bljrv3yuqq9u","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3mj005zbljrnk89qsbk"},{"post_id":"cjissu3i90021bljrv3yuqq9u","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3mk0062bljrvah4vg4j"},{"post_id":"cjissu3i90021bljrv3yuqq9u","tag_id":"cjissu3md005rbljry2snkgfi","_id":"cjissu3mn0066bljrqwu4k75f"},{"post_id":"cjissu3ia0024bljrd71nqh4d","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3mx006mbljru3co59o0"},{"post_id":"cjissu3ia0024bljrd71nqh4d","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3mz006qbljrsb48ffpw"},{"post_id":"cjissu3ia0024bljrd71nqh4d","tag_id":"cjissu3j3002zbljr3ynvycju","_id":"cjissu3n1006tbljrjb3tiffk"},{"post_id":"cjissu3ia0024bljrd71nqh4d","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3n2006vbljrzbl70r1w"},{"post_id":"cjissu3n90071bljrh1oreyn6","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3nf0076bljrvnvpgr3f"},{"post_id":"cjissu3nc0074bljr7h6pglfq","tag_id":"cjissu3jw003ybljrn4rwqaew","_id":"cjissu3ni007abljrtwzw606r"},{"post_id":"cjissu3nc0074bljr7h6pglfq","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3nj007cbljr8g5pq5ts"},{"post_id":"cjissu3nc0074bljr7h6pglfq","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3nj007fbljr5fhgskri"},{"post_id":"cjissu3nc0074bljr7h6pglfq","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3nj007hbljrkcyhp607"},{"post_id":"cjissu3ic0027bljrrs1jbjar","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3nk007kbljrhl6de75a"},{"post_id":"cjissu3ic0027bljrrs1jbjar","tag_id":"cjissu3mz006rbljr8nmnihqt","_id":"cjissu3nk007lbljr0w265up7"},{"post_id":"cjissu3ic0027bljrrs1jbjar","tag_id":"cjissu3n3006wbljr7bts502o","_id":"cjissu3nk007nbljrelugbgu7"},{"post_id":"cjissu3ic0027bljrrs1jbjar","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3nm007obljrh7t8ld78"},{"post_id":"cjissu3ie002abljrfiipcorj","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3nn007qbljrviyww960"},{"post_id":"cjissu3ie002abljrfiipcorj","tag_id":"cjissu3nj007ebljrks6pz41k","_id":"cjissu3no007rbljr4cmt12ld"},{"post_id":"cjissu3ie002abljrfiipcorj","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3no007sbljrp2tuq9mv"},{"post_id":"cjissu3ih002ebljrp96agzak","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3np007vbljr5uaxpevr"},{"post_id":"cjissu3ih002ebljrp96agzak","tag_id":"cjissu3nm007pbljrek204vi4","_id":"cjissu3np007wbljrrw238lpb"},{"post_id":"cjissu3ih002ebljrp96agzak","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3np007ybljr4fo0c6lz"},{"post_id":"cjissu3il002hbljrn2fwn8nx","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3nr0081bljrnmhxl09k"},{"post_id":"cjissu3il002hbljrn2fwn8nx","tag_id":"cjissu3np007xbljr29tq4cfz","_id":"cjissu3nr0082bljr1oevreue"},{"post_id":"cjissu3il002hbljrn2fwn8nx","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3nr0084bljrltwi4ltq"},{"post_id":"cjissu3io002lbljr1aa4m6gl","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ns0088bljr37fp399c"},{"post_id":"cjissu3io002lbljr1aa4m6gl","tag_id":"cjissu3nr0083bljr20rofbbr","_id":"cjissu3ns0089bljrfip1f65m"},{"post_id":"cjissu3io002lbljr1aa4m6gl","tag_id":"cjissu3nr0085bljrsyv1yl5h","_id":"cjissu3nt008bbljrmqzmekgx"},{"post_id":"cjissu3io002lbljr1aa4m6gl","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3nt008cbljrm17ir1v0"},{"post_id":"cjissu3ip002nbljrvs2lwhkm","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3nu008gbljrxe7p7dez"},{"post_id":"cjissu3ip002nbljrvs2lwhkm","tag_id":"cjissu3ns008abljr423g5y0l","_id":"cjissu3nu008hbljrgorp2eqy"},{"post_id":"cjissu3ip002nbljrvs2lwhkm","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3nu008jbljrmq80q4nb"},{"post_id":"cjissu3ip002nbljrvs2lwhkm","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3nu008kbljr3no2yyqk"},{"post_id":"cjissu3is002qbljrfjdtneni","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3nx008obljra2butbvc"},{"post_id":"cjissu3is002qbljrfjdtneni","tag_id":"cjissu3nu008ibljr0hj3jd6l","_id":"cjissu3nx008pbljro33secdq"},{"post_id":"cjissu3is002qbljrfjdtneni","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3ny008rbljr13oerffz"},{"post_id":"cjissu3is002qbljrfjdtneni","tag_id":"cjissu3np007xbljr29tq4cfz","_id":"cjissu3ny008sbljr9jwagw9c"},{"post_id":"cjissu3ix002vbljrbhruzuvs","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3nz008ubljrzkcpdo5a"},{"post_id":"cjissu3ix002vbljrbhruzuvs","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3o0008vbljrbrsdmj39"},{"post_id":"cjissu3j40030bljrrwu4as6j","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3o50090bljrnq04v5rp"},{"post_id":"cjissu3j40030bljrrwu4as6j","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3o50091bljr2606ah78"},{"post_id":"cjissu3j40030bljrrwu4as6j","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3o60093bljrmc2hh7cs"},{"post_id":"cjissu3j40030bljrrwu4as6j","tag_id":"cjissu3o2008ybljri941r3hz","_id":"cjissu3o60094bljr7fza8lts"},{"post_id":"cjissu3j80033bljro9qe6bw9","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3o90097bljrasvs70j1"},{"post_id":"cjissu3j80033bljro9qe6bw9","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3o90098bljri69hzdie"},{"post_id":"cjissu3j80033bljro9qe6bw9","tag_id":"cjissu3o60095bljrceqg3j2x","_id":"cjissu3o9009abljr10vmh27h"},{"post_id":"cjissu3jc0037bljrf3j6iknd","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ob009dbljr1dml33xd"},{"post_id":"cjissu3jc0037bljrf3j6iknd","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3ob009ebljrxwc7a2o0"},{"post_id":"cjissu3jc0037bljrf3j6iknd","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3oc009gbljr09sq5cyf"},{"post_id":"cjissu3jc0037bljrf3j6iknd","tag_id":"cjissu3j3002zbljr3ynvycju","_id":"cjissu3od009hbljrt8pdqnqz"},{"post_id":"cjissu3jf003abljrq69r7hja","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3of009kbljrpuu7xgl1"},{"post_id":"cjissu3jf003abljrq69r7hja","tag_id":"cjissu3jw003ybljrn4rwqaew","_id":"cjissu3of009lbljrqu1t7fxi"},{"post_id":"cjissu3jf003abljrq69r7hja","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3of009nbljrqpqd5gyx"},{"post_id":"cjissu3jf003abljrq69r7hja","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3og009obljr4p9iktbb"},{"post_id":"cjissu3jh003dbljrkgcqpuo7","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3oh009qbljr3d2rlzsp"},{"post_id":"cjissu3jh003dbljrkgcqpuo7","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3oh009rbljrw4ygi0nd"},{"post_id":"cjissu3jh003dbljrkgcqpuo7","tag_id":"cjissu3jc0036bljrrbhu1imh","_id":"cjissu3oh009tbljrpys383r6"},{"post_id":"cjissu3jj003gbljrkz0mm4f7","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ok009wbljr7y1z1lo4"},{"post_id":"cjissu3jj003gbljrkz0mm4f7","tag_id":"cjissu3oh009sbljrmm5h7nb4","_id":"cjissu3ok009xbljrcxkornul"},{"post_id":"cjissu3jj003gbljrkz0mm4f7","tag_id":"cjissu3oi009ubljr3angs79z","_id":"cjissu3om009zbljr8zqdrvc5"},{"post_id":"cjissu3jl003ibljrs7oxti4l","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3oq00a1bljrxw2otxia"},{"post_id":"cjissu3jl003ibljrs7oxti4l","tag_id":"cjissu3md005rbljry2snkgfi","_id":"cjissu3oq00a2bljr24zzoao9"},{"post_id":"cjissu3jl003ibljrs7oxti4l","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3or00a4bljrst1b21ko"},{"post_id":"cjissu3jn003lbljr1d4w6vqc","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3or00a6bljrfpfs0qrn"},{"post_id":"cjissu3jn003lbljr1d4w6vqc","tag_id":"cjissu3hy001lbljrx6o4ep3f","_id":"cjissu3or00a7bljrgh695c8h"},{"post_id":"cjissu3jn003lbljr1d4w6vqc","tag_id":"cjissu3oq00a3bljrm93rqgvs","_id":"cjissu3os00a9bljrmld1vbhu"},{"post_id":"cjissu3jp003obljrm837jh8w","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ot00acbljr4ai9roz7"},{"post_id":"cjissu3jp003obljrm837jh8w","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3ot00adbljr6oxt8cyz"},{"post_id":"cjissu3jp003obljrm837jh8w","tag_id":"cjissu3ns008abljr423g5y0l","_id":"cjissu3ot00afbljr8k4iidi9"},{"post_id":"cjissu3jp003obljrm837jh8w","tag_id":"cjissu3os00aabljrj2kqsxxm","_id":"cjissu3ot00agbljrcxld1d9f"},{"post_id":"cjissu3jt003sbljrr350wazw","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ov00ajbljrnqg64507"},{"post_id":"cjissu3jt003sbljrr350wazw","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3ov00akbljrsp9hymlt"},{"post_id":"cjissu3jt003sbljrr350wazw","tag_id":"cjissu3ot00aebljrp7deaxzp","_id":"cjissu3ov00ambljr86kv5ous"},{"post_id":"cjissu3jt003sbljrr350wazw","tag_id":"cjissu3o2008ybljri941r3hz","_id":"cjissu3ov00anbljr15gs26yy"},{"post_id":"cjissu3jv003vbljrnuk6yd82","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3oy00arbljr3ak9u5lw"},{"post_id":"cjissu3jv003vbljrnuk6yd82","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3oy00asbljrdi6ln66i"},{"post_id":"cjissu3jv003vbljrnuk6yd82","tag_id":"cjissu3ov00albljrg2gguu8o","_id":"cjissu3oz00aubljrsf5ws789"},{"post_id":"cjissu3jv003vbljrnuk6yd82","tag_id":"cjissu3o2008ybljri941r3hz","_id":"cjissu3oz00avbljrsnoxnzg2"},{"post_id":"cjissu3jv003vbljrnuk6yd82","tag_id":"cjissu3mz006rbljr8nmnihqt","_id":"cjissu3oz00axbljrohi5krov"},{"post_id":"cjissu3jw003zbljr0wy82koz","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3oz00aybljr09yrgzig"},{"post_id":"cjissu3jw003zbljr0wy82koz","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3p400b0bljrsdau11xs"},{"post_id":"cjissu3jw003zbljr0wy82koz","tag_id":"cjissu3oy00atbljrav7eczas","_id":"cjissu3p400b1bljr88ol6aic"},{"post_id":"cjissu3jz0044bljrg8vs03ho","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3p600b4bljrs147v1u9"},{"post_id":"cjissu3jz0044bljrg8vs03ho","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3p600b5bljrzp6wkc0y"},{"post_id":"cjissu3jz0044bljrg8vs03ho","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3p700b7bljrdbjr7dvm"},{"post_id":"cjissu3k00046bljr0gwtfq9k","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3p800babljrhwocgk0z"},{"post_id":"cjissu3k00046bljr0gwtfq9k","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3p800bbbljrosp219zc"},{"post_id":"cjissu3k00046bljr0gwtfq9k","tag_id":"cjissu3ns008abljr423g5y0l","_id":"cjissu3p800bdbljr3b9fd3si"},{"post_id":"cjissu3k00046bljr0gwtfq9k","tag_id":"cjissu3os00aabljrj2kqsxxm","_id":"cjissu3p800bebljr9hkhggnl"},{"post_id":"cjissu3k20049bljroj5wxwle","tag_id":"cjissu3p700b9bljrvy3c1qi3","_id":"cjissu3p900bhbljrg4pqmygx"},{"post_id":"cjissu3k20049bljroj5wxwle","tag_id":"cjissu3p800bcbljrfzyv9oon","_id":"cjissu3pa00bibljr3ouu3xp7"},{"post_id":"cjissu3k20049bljroj5wxwle","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pa00bkbljrqs7xomoh"},{"post_id":"cjissu3k5004bbljrcxjmfy23","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pb00bmbljr7jmtqpp9"},{"post_id":"cjissu3k5004bbljrcxjmfy23","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3pb00bnbljrnqzenib7"},{"post_id":"cjissu3k5004bbljrcxjmfy23","tag_id":"cjissu3md005rbljry2snkgfi","_id":"cjissu3pb00bpbljr1ws6k1dv"},{"post_id":"cjissu3kc004fbljrm8z8orav","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pd00bsbljr7soulyrf"},{"post_id":"cjissu3kc004fbljrm8z8orav","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3pd00btbljrpi2o1z09"},{"post_id":"cjissu3kc004fbljrm8z8orav","tag_id":"cjissu3ot00aebljrp7deaxzp","_id":"cjissu3pe00bvbljrd4pxtysk"},{"post_id":"cjissu3kc004fbljrm8z8orav","tag_id":"cjissu3o2008ybljri941r3hz","_id":"cjissu3pe00bwbljrue24mr9r"},{"post_id":"cjissu3kh004ibljrmum4rael","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pg00c0bljrsdzjyxwg"},{"post_id":"cjissu3kh004ibljrmum4rael","tag_id":"cjissu3nm007pbljrek204vi4","_id":"cjissu3pg00c1bljrsbfvnul6"},{"post_id":"cjissu3kh004ibljrmum4rael","tag_id":"cjissu3pe00bxbljrby1z8xu9","_id":"cjissu3pg00c3bljr4yy3jcr9"},{"post_id":"cjissu3kh004ibljrmum4rael","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3pg00c4bljrlx9nn045"},{"post_id":"cjissu3kj004mbljrximb5fi7","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pm00c7bljrhekvm9vm"},{"post_id":"cjissu3kj004mbljrximb5fi7","tag_id":"cjissu3mz006rbljr8nmnihqt","_id":"cjissu3pm00c8bljrup6ffuih"},{"post_id":"cjissu3kj004mbljrximb5fi7","tag_id":"cjissu3k20048bljri4qc32jz","_id":"cjissu3pn00cabljrqus4k9zp"},{"post_id":"cjissu3kj004mbljrximb5fi7","tag_id":"cjissu3nr0083bljr20rofbbr","_id":"cjissu3pn00cbbljrlxizsm20"},{"post_id":"cjissu3km004pbljrg1nfg0wf","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3po00cdbljru6hmkzu1"},{"post_id":"cjissu3km004pbljrg1nfg0wf","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3po00cebljrfzuqbsai"},{"post_id":"cjissu3km004pbljrg1nfg0wf","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3pp00cgbljrztbs9onx"},{"post_id":"cjissu3km004pbljrg1nfg0wf","tag_id":"cjissu3pe00bxbljrby1z8xu9","_id":"cjissu3pp00chbljr633sx4kf"},{"post_id":"cjissu3kp004rbljr5wu2r2d2","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pq00cjbljrea4h3kwe"},{"post_id":"cjissu3kp004rbljr5wu2r2d2","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3pq00ckbljr8541kwax"},{"post_id":"cjissu3kp004rbljr5wu2r2d2","tag_id":"cjissu3o2008ybljri941r3hz","_id":"cjissu3pq00cmbljr68k4tqvg"},{"post_id":"cjissu3kp004rbljr5wu2r2d2","tag_id":"cjissu3ot00aebljrp7deaxzp","_id":"cjissu3pq00cnbljrt0ymypa4"},{"post_id":"cjissu3ks004vbljrnp6zkadm","tag_id":"cjissu3hy001lbljrx6o4ep3f","_id":"cjissu3pr00cpbljrpahrq0u8"},{"post_id":"cjissu3ks004vbljrnp6zkadm","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pr00cqbljr78aapno7"},{"post_id":"cjissu3ks004vbljrnp6zkadm","tag_id":"cjissu3pp00cibljrlu46z6g4","_id":"cjissu3ps00csbljr1y1d376f"},{"post_id":"cjissu3kz004ybljr8t3guaec","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3ps00ctbljrlf8771il"},{"post_id":"cjissu3kz004ybljr8t3guaec","tag_id":"cjissu3pq00clbljr9z7o5j62","_id":"cjissu3ps00cvbljrljan50br"},{"post_id":"cjissu3l30054bljr5pbtphfj","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pt00cwbljrfe22jbfj"},{"post_id":"cjissu3l30054bljr5pbtphfj","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3pt00cybljraqwula3v"},{"post_id":"cjissu3l30054bljr5pbtphfj","tag_id":"cjissu3np007xbljr29tq4cfz","_id":"cjissu3pt00czbljra7eh6qpy"},{"post_id":"cjissu3l50058bljrqofzyfln","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pv00d1bljrurarigki"},{"post_id":"cjissu3l50058bljrqofzyfln","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3pv00d2bljr8oxmqql5"},{"post_id":"cjissu3l50058bljrqofzyfln","tag_id":"cjissu3ps00cubljrr8jr8pve","_id":"cjissu3px00d4bljr8wzwpi8a"},{"post_id":"cjissu3l50058bljrqofzyfln","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3px00d5bljrfx42bd7h"},{"post_id":"cjissu3lx005bbljrjczups0b","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3pz00d7bljr6labcffg"},{"post_id":"cjissu3lx005bbljrjczups0b","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3pz00d8bljr80uxg2d9"},{"post_id":"cjissu3lx005bbljrjczups0b","tag_id":"cjissu3oy00atbljrav7eczas","_id":"cjissu3q000dabljrhhqbalhc"},{"post_id":"cjissu3lx005bbljrjczups0b","tag_id":"cjissu3is002pbljrmqr9q82d","_id":"cjissu3q000dbbljrrchfjtlh"},{"post_id":"cjissu3m3005fbljrsje9qoo2","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3q200ddbljrqy69z0ab"},{"post_id":"cjissu3m3005fbljrsje9qoo2","tag_id":"cjissu3ot00aebljrp7deaxzp","_id":"cjissu3q200debljrjh5p12j4"},{"post_id":"cjissu3m3005fbljrsje9qoo2","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3q200dgbljrnwoqtnse"},{"post_id":"cjissu3m6005ibljrybzceqjf","tag_id":"cjissu3nj007ebljrks6pz41k","_id":"cjissu3q300dhbljrbp4xozkq"},{"post_id":"cjissu3m6005ibljrybzceqjf","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3q500djbljryavalm9e"},{"post_id":"cjissu3m6005ibljrybzceqjf","tag_id":"cjissu3nk007jbljr5ku987vt","_id":"cjissu3q500dkbljr41g0nrzy"},{"post_id":"cjissu3m9005mbljrsbe83c5v","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3q700dmbljrijua36hd"},{"post_id":"cjissu3m9005mbljrsbe83c5v","tag_id":"cjissu3im002ibljr7g3bbbtw","_id":"cjissu3q700dnbljr8usy1u9k"},{"post_id":"cjissu3m9005mbljrsbe83c5v","tag_id":"cjissu3md005rbljry2snkgfi","_id":"cjissu3q800dpbljrywudyqg9"},{"post_id":"cjissu3m9005mbljrsbe83c5v","tag_id":"cjissu3q200dfbljrnmirdv2n","_id":"cjissu3q800dqbljr48u1bn8t"},{"post_id":"cjissu3mb005pbljr1p4hclox","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3q900dsbljrwr7zw1u4"},{"post_id":"cjissu3mb005pbljr1p4hclox","tag_id":"cjissu3q300dibljruvawb0za","_id":"cjissu3qa00dtbljrnklec8ui"},{"post_id":"cjissu3mb005pbljr1p4hclox","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3qa00dubljrgd2cao1l"},{"post_id":"cjissu3md005tbljrg2hgzfux","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3qc00dwbljrzp8uzyfh"},{"post_id":"cjissu3md005tbljrg2hgzfux","tag_id":"cjissu3p700b9bljrvy3c1qi3","_id":"cjissu3qc00dxbljrbtxyppbw"},{"post_id":"cjissu3mf005ubljrjfz8av6i","tag_id":"cjissu3q700dobljri5wb5wsl","_id":"cjissu3qd00dzbljrq2f6yw9g"},{"post_id":"cjissu3mf005ubljrjfz8av6i","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3qe00e0bljryasxp5gt"},{"post_id":"cjissu3mi005xbljrjcs0hav9","tag_id":"cjissu3q800drbljrwib0uo3m","_id":"cjissu3qf00e2bljrf2qplcwg"},{"post_id":"cjissu3mi005xbljrjcs0hav9","tag_id":"cjissu3qa00dvbljrf34zfgux","_id":"cjissu3qf00e3bljre8lqlnhj"},{"post_id":"cjissu3ml0064bljrjebgntz4","tag_id":"cjissu3kj004lbljr3i2lp6b9","_id":"cjissu3qg00e5bljrms1kcccv"},{"post_id":"cjissu3ml0064bljrjebgntz4","tag_id":"cjissu3l00050bljr69gtu32j","_id":"cjissu3qg00e6bljrklupajtk"},{"post_id":"cjissu3ml0064bljrjebgntz4","tag_id":"cjissu3p800bcbljrfzyv9oon","_id":"cjissu3qh00e8bljr3uw1ufzb"},{"post_id":"cjissu3ml0064bljrjebgntz4","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3qh00e9bljr84r94k5q"},{"post_id":"cjissu3mq006abljrpumvkeod","tag_id":"cjissu3qe00e1bljrux44k9xj","_id":"cjissu3qi00ebbljraqo3cnkf"},{"post_id":"cjissu3mr006cbljrxxlhlgo8","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3qi00ecbljr92ac81xs"},{"post_id":"cjissu3mr006cbljrxxlhlgo8","tag_id":"cjissu3mz006rbljr8nmnihqt","_id":"cjissu3qi00eebljr38elve30"},{"post_id":"cjissu3mr006cbljrxxlhlgo8","tag_id":"cjissu3ov00albljrg2gguu8o","_id":"cjissu3qj00efbljrrla33289"},{"post_id":"cjissu3mr006cbljrxxlhlgo8","tag_id":"cjissu3ji003ebljr1eactahg","_id":"cjissu3qm00ehbljrz4ptvdrt"},{"post_id":"cjissu3my006obljrx8gq43ef","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3qm00eibljry02r0rms"},{"post_id":"cjissu3my006obljrx8gq43ef","tag_id":"cjissu3q700dobljri5wb5wsl","_id":"cjissu3qn00ekbljryqj8ishq"},{"post_id":"cjissu3my006obljrx8gq43ef","tag_id":"cjissu3nt008ebljrua3bwddi","_id":"cjissu3qn00elbljrcka6xxvw"},{"post_id":"cjissu3n1006ubljrp4jed8qz","tag_id":"cjissu3p700b9bljrvy3c1qi3","_id":"cjissu3qn00enbljrhik75x5l"},{"post_id":"cjissu3n1006ubljrp4jed8qz","tag_id":"cjissu3hr001ebljrs1ity088","_id":"cjissu3qo00eobljrdobqvgpu"},{"post_id":"cjissu3n1006ubljrp4jed8qz","tag_id":"cjissu3i7001xbljr0zei67lm","_id":"cjissu3qo00eqbljrcqw10g14"},{"post_id":"cjissu3n5006zbljruvt8grt5","tag_id":"cjissu3qm00ejbljrwxjt2pte","_id":"cjissu3qo00erbljravme8zup"},{"post_id":"cjissu3nf0077bljr31dztfyz","tag_id":"cjissu3oh009sbljrmm5h7nb4","_id":"cjissu3qp00esbljr4o50avm7"},{"post_id":"cjissu3nf0077bljr31dztfyz","tag_id":"cjissu3qo00epbljrnr6as4fy","_id":"cjissu3qp00etbljri2lksen2"}],"Tag":[{"name":"笔记","_id":"cjissu3hr001ebljrs1ity088"},{"name":"字符串","_id":"cjissu3hy001lbljrx6o4ep3f"},{"name":"AC自动机","_id":"cjissu3i4001sbljrwb3b7fz2"},{"name":"模板","_id":"cjissu3i7001xbljr0zei67lm"},{"name":"省选","_id":"cjissu3ia0023bljrxbkp8bcx"},{"name":"图论","_id":"cjissu3im002ibljr7g3bbbtw"},{"name":"Dinic","_id":"cjissu3is002pbljrmqr9q82d"},{"name":"Splay","_id":"cjissu3j3002zbljr3ynvycju"},{"name":"平衡树","_id":"cjissu3jc0036bljrrbhu1imh"},{"name":"数据结构","_id":"cjissu3ji003ebljr1eactahg"},{"name":"Treap","_id":"cjissu3jw003ybljrn4rwqaew"},{"name":"最近公共祖先","_id":"cjissu3k20048bljri4qc32jz"},{"name":"题解","_id":"cjissu3kj004lbljr3i2lp6b9"},{"name":"CDQ分治","_id":"cjissu3l00050bljr69gtu32j"},{"name":"费用流","_id":"cjissu3md005rbljry2snkgfi"},{"name":"可持久化线段树","_id":"cjissu3mz006rbljr8nmnihqt"},{"name":"差分","_id":"cjissu3n3006wbljr7bts502o"},{"name":"数位dp","_id":"cjissu3nj007ebljrks6pz41k"},{"name":"动态规划","_id":"cjissu3nk007jbljr5ku987vt"},{"name":"单调队列","_id":"cjissu3nm007pbljrek204vi4"},{"name":"树形dp","_id":"cjissu3np007xbljr29tq4cfz"},{"name":"启发式合并","_id":"cjissu3nr0083bljr20rofbbr"},{"name":"set","_id":"cjissu3nr0085bljrsyv1yl5h"},{"name":"动态树","_id":"cjissu3ns008abljr423g5y0l"},{"name":"树形结构","_id":"cjissu3nt008ebljrua3bwddi"},{"name":"0/1分数规划","_id":"cjissu3nu008ibljr0hj3jd6l"},{"name":"线段树","_id":"cjissu3o2008ybljri941r3hz"},{"name":"并查集","_id":"cjissu3o60095bljrceqg3j2x"},{"name":"数学","_id":"cjissu3oh009sbljrmm5h7nb4"},{"name":"最大公约数","_id":"cjissu3oi009ubljr3angs79z"},{"name":"KMP","_id":"cjissu3oq00a3bljrm93rqgvs"},{"name":"Link Cut Tree(LCT)","_id":"cjissu3os00aabljrj2kqsxxm"},{"name":"树链剖分","_id":"cjissu3ot00aebljrp7deaxzp"},{"name":"主席树","_id":"cjissu3ov00albljrg2gguu8o"},{"name":"二分图匹配","_id":"cjissu3oy00atbljrav7eczas"},{"name":"莫队","_id":"cjissu3p700b9bljrvy3c1qi3"},{"name":"树状数组","_id":"cjissu3p800bcbljrfzyv9oon"},{"name":"树的直径","_id":"cjissu3pe00bxbljrby1z8xu9"},{"name":"后缀数组","_id":"cjissu3pp00cibljrlu46z6g4"},{"name":"分块","_id":"cjissu3pq00clbljr9z7o5j62"},{"name":"强连通分量","_id":"cjissu3ps00cubljrr8jr8pve"},{"name":"网络流","_id":"cjissu3q200dfbljrnmirdv2n"},{"name":"整体二分","_id":"cjissu3q300dibljruvawb0za"},{"name":"点分治","_id":"cjissu3q700dobljri5wb5wsl"},{"name":"摘录","_id":"cjissu3q800drbljrwib0uo3m"},{"name":"作文","_id":"cjissu3qa00dvbljrf34zfgux"},{"name":"冬令营","_id":"cjissu3qe00e1bljrux44k9xj"},{"name":"歌曲","_id":"cjissu3qm00ejbljrwxjt2pte"},{"name":"学习笔记","_id":"cjissu3qo00epbljrnr6as4fy"}]}}