[{"content":"哈哈。\n 匆匆过了二十多年，我自然也是常常哭，常常笑，别人的啼笑也看过无数回了。\n可是我生平不怕看见泪，自己的热泪也好，别人的呜咽也好；对于几种笑我却会惊心动魄，吓得连呼吸都不敢出声，这些怪异的笑声，有时还是我亲口发出的。\n当一位极亲密的朋友忽然说出一句冷酷无情冰一般的冷话来，而且他自己还不知道他说得会使人心寒，这时候，我们只能哈哈哈莫名其妙地笑了。因为若使不笑，叫我们怎么样好呢？我们这个强笑或者是出于看到他真正的性格（他这句冷语所显露的）和我们先前所认为的他的性格的矛盾，或者我们要勉强这么一笑来表示我们是不会给他的话所震动，我们自己另有一个超乎一切的生活，他的话不能损坏我们于毫发的，或者\u0026hellip;\u0026hellip;。但是那时节我们只觉得不好不这么大笑一声，所以才笑，实在也没有闲暇去仔细分析自己了。\n当我们心里有说不出的苦痛缠着，正要向人细诉，那时我们平时尊敬的人却用个极无聊的理由（甚至于最卑鄙的）来解释我们这穿过心灵的悲哀。看到这深深一层的隔膜，我们除开无聊赖的破涕为笑，还有什么别的办法吗？\n有时候我们倒霉起来，整天从早到晚做的事没有一件不是失败的。到晚上疲累非常，懊恼万分，悔也不是，哭也不是，也只好咽下眼泪，空心地笑着。我们一生忙碌，把不可再得的光阴消磨在马蹄铁轮，以及无谓敷衍之间，整天打算，可是自己不晓得为甚这么费心机，为了要活着用尽苦心来延长这寿命，却又不觉得或者到底有何好处，自己并没有享受生活过，总之黑漆一团活着。夜阑人静，回头一想，哪能够不吃吃地笑，笑时感到无限的生的悲哀。\n就说我们淡于生死了，对于现世界的厌烦同人事的憎恶还会像毒蛇般蜿蜒走到面前，缠着身上。我们真可说倦于一切，可惜我们也没有爱恋上死神，觉得也不值得花那么大劲去求死，在此不生不死心境里，只见伤感重重来袭，偶然挣些力气，来叹几口气，叹完气也免不了失笑，那笑是多么酸苦的。这几种笑声发自我们的口里，自己听到，心中生个不可言喻的恐怖，或者又引起另一个鬼似的狞笑。若使是由他人口里传出，只要我们探讨出他们的源泉，我们也会惺惺惜猩猩而心酸，同时害怕地全身打战。\n此外失望人的傻笑，下头人挨了骂对于主子的陪笑，趾高气扬的热官对于贫贱故交的冷笑，老处女在她们结婚席上所呈的干笑，生离永别时节的苦笑——这些笑全是“自然”跟我们为难，把我们弄得没有办法，我们承认失败了的表现是我们心灵的堡垒下面刺目的降幡。\n莎士比亚的妙句“对着悲哀的微笑”（smiling at grief）说尽此中的苦况。拜伦在他的杰作Don Juan《唐璜》里有二句：\n “Of all tales \u0026lsquo;tis the saddest——and more sad. Because it makes us smile.”\n（在所有故事中它是最可悲——而且还要可悲，因为它让我们微笑。）\n 这两句是我愁闷无聊时所喜欢反复吟诵的，因为真能传出“笑”的悲剧情调。\n 虽然我现在面前有 tons of work，但我仍要在这里书写，因为我感到我不能不写。\n当你感受到你身边的那个人，那个你认为和你走的是一路的人，他其实和你在很早就已经分叉。对那些，你要说任何都会觉得“——又有什么用呢”，把到嘴边的话咽下，或许还会立下誓再也不提。\n但，偏偏你还有求于他，他却连你认为的顺手之忙都不肯给予。\n偏偏你还以为你们的交情足够让他无条件相信你，他却不肯向你移动、移动哪怕一步。\n偏偏你以为无关紧要的事情，他却珍视似瑰宝、灵魂。\n此刻，你怎能不在那巨大到充满你所有生活的迷墙前停下？\n无论你尽多少努力，无论你付出多少心意，你觉得你主观上已经不能做得更多，但是你永远无法接近他，你从他那里收获的是沉默，收获的是比沉默更无声的微笑\u0026hellip;这是一个看不到底的洞口，他给你的无力感、不安全感，而你偏偏也不能轻易离开他\u0026hellip;\n你说你以为\u0026hellip;但他摧毁了所有“你以为”，以无可辩驳的，以无可反抗的方式。你想，即使他直接把我推下洞口呢\u0026hellip;告诉我这一切啊，我不想猜，我也没有猜的能力\u0026hellip;我怎么还敢相信心中对于你的任何印象呢？我认识你吗？\n你看着那个你身边的人，你那么熟悉他，你日日和他相处，但此刻你突然觉得他那么陌生，你心中对他所有的预设都悄然崩塌。\n你认识他吗？你觉得你一定认识。你认识他吗？你又觉得不。你看着他，真实在你面前的他，但你只能看到他的皮囊，那个你可能熟悉到每一寸的皮囊。他所有皮囊以下的东西，所有那些你真正“认识”他的东西，似乎都重新隐藏到了厚厚的迷雾下，离你那么遥远，是那么的虚幻，不可触摸。可那是你曾经用几年时间才慢慢擦掉（——至少你这么以为）的啊。\n每每在这种时刻，一些人和人的关系更能让你不禁生出感慨与赞叹。亲情、爱情，他们之所以被称为崇高，就是人无条件地相信另一个人。父母可以为儿女牺牲自己，爱人会为彼此燃烧自我，这不需要什么理由，唯一的理由就是他们本身。\n当然，他们的轰然崩塌，也更加“壮观”啊。\n今天的我或许懂了当时的你，在这里说声对不起。\n你或许马上就能看到，或许永远都看不到吧。\n “温馨提示：过量饮酒 有害健康”\n ","description":"","id":3,"section":"posts","tags":["随笔"],"title":"「随笔」五月二十五日","uri":"https://blog.chenqiqian.com/posts/essay-20210525/"},{"content":"二〇二一年五月十四日，星期五，天阴。\n今天（事实上是昨天）换了一个微信签名：\n 「淒然似秋 煖然似春」\n 这句话语出《庄子 大宗师》，前后文摘录如下：\n 古之真人，不知说生，不知恶死。其出不欣，其入不距。翛然而往，翛然而来，而已矣。不忘其所始，不求其所终。受而喜之，忘而复之。是之谓不以心捐道，不以人助天，是之谓真人。若然者，其心志，其容寂，其颡鼽。凄然似秋，煖然似春，喜怒通四时，与物有宜而莫知其极。\n 我曾经想做一个喜怒不形于色的人，但做不成。如果你善于观察，并且有兴趣观察我的表情，你其实完全能够洞察我的情思。\n然而，这是我的情感的本真呈现吗？还是扭曲的呢？大概停下追问之后所剩下的，就是所谓的“本真”了吧。\n所以吧，不管是喜怒，还是爱恨，就应该像四季。四季就是这个样子，古往今来都是。\n","description":"","id":4,"section":"posts","tags":["随笔"],"title":"「随笔」五月十四日","uri":"https://blog.chenqiqian.com/posts/essay-20210514/"},{"content":"二〇二一年五月六日，星期四，上周一的课，沙尘暴。\n出分流结果之后，真的不知道该摆出什么样的表情。\n一方面，这是很大的事情，之后三年的学习生活皆系于此；另一方面，这似乎也是很小的事情，甚至连名单我都看 不到。\n一方面，这是与我切身相关的事情，身边的那些熟悉或不熟悉的人来了又走；另一方面，这似乎也是与我毫不相关的事情，我完全可以不管不问，似乎真的什么都没有发生。\n一方面，我应该表现出淡然，因为要走的人和要来的人都是他们自己的选择、自己的命运，并且早有预兆；另一方面，我却实实在在感受到内心的强烈波动。\n我不能遏住我的内心强迫它停下，于是我只能问我自己，我到底是什么情绪？我问我自己，我到底是为什么会这样？\n我嫉妒他们吗？我后悔自己的选择吗？我惋惜这些“朋友”的离去吗？我悲哀身边日益膨胀的男女比例吗？\n似乎都是，似乎也都不是。\n总有一些情绪藏在理智的背后，它不会承认自己的存在，却又顽强地显示着自己的存在。\n是什么呢？为什么呢？\n没有人知道，那个在黄色的天空下骑车穿行于高大杨树间，那个心中空空荡荡双脚却不能停下片刻的人，为什么眼里会含着泪水。\n","description":"","id":5,"section":"posts","tags":["随笔"],"title":"「随笔」五月六日","uri":"https://blog.chenqiqian.com/posts/essay-20210506/"},{"content":"想来想去，我的高考都不是一次成功的经历，但好在它没有太大地影响我的前路。\n如果只能说一个点，我记得出数学考场不久，我就知道我错了一道选择外加全部最后三道大题的最后一问，大概十五分。出考点时，我遇到了某位同学，我就对他说我数学考炸了。我忘记了他对我说了什么。\n只能说，高考归根到底是一个人自己的战场。走进考场，别人很难再影响到你，而面对着六套试卷、十个小时，你必须一个人走过。高考的战线很长，四天，必须调整好心态。到这份上了，无论发生什么，是作文跑题，还是解析算崩，还是完型四五个题配不平，都不能怕啊，怕也没人替你承受，你必须勇敢起来。\n考试结束了，或者哪怕只是某一分钟结束了，它就是结束了，你只能向前看，“笃前行而勿顾后”。坦然接受，不仅是对于最后的数字，更是对于过去的每一分钟。哪怕背后已经是洪水滔天，你也必须，也只能安静地搭脚底的路，为下一刻准备。\n哦对了，考前那一周多睡点觉，说不定比复习有用。\n祝你们，高考快乐。\n","description":"","id":6,"section":"posts","tags":["随笔","高考"],"title":"高考回忆","uri":"https://blog.chenqiqian.com/posts/write-for-gaokao/"},{"content":"The Story of Stones.\n左边那块叫天河石，右边那块叫紫水晶。\n它们的样子实在太普通了，形状不奇特，材质不透亮，也没有诱人的光彩，在石堆中丝毫不引人注目。它们的价格都不到一顿午饭，有太多比它们珍贵的石头了。\n但是，没有两块石头是完全一样的，即使他们看着那么相似，况且更多情况下它们看起来都那么不同。每一块石头，都内蕴着四十六亿年的过往。\n因此，它们珍贵吗？它们再普通不过。它们普通吗？它们都独一无二。\n有那么多形形色色的石头摆在这里，唯独它们在这里相遇、并列了，这有原因吗？或许可以找出一百个原因，它们的绝对、相对位置如何如何，它们的形状、光泽如何如何，它们的纹理、杂质如何，等等、等等。\n是，但也不是；因为我挑的时候，只是左边一块，右边一块。\n然而，它们的确被挑出来了，这是无可辩驳的事实。它们的生活从此完全改变了。它们从高原下到平原，从展示柜到书架。\n然而，现在它们的确相遇了，它们的确并列了，这是无可辩驳的事实。但是，它们对于彼此的特殊有什么理由吗？没有，如果每个人都不同，这些不同并没有什么不同。它们对于彼此一定是最适合的吗？不是，因为我只看了摆在最上面的几个。\n它们的确被挑进购物袋中，它们的确相遇在展示柜案头，它们的确并列在书桌架上，这是无可辩驳的事实。有的时候，必须停止（至少是暂时地）那些问句：“为什么？”，因为这无可辩驳，它就是这个样子。\n所以呢？我问我的内心。\n我不知道。\n接受1，并试图去享受2吧。\nP.S. 迷惑发言：\n “存在先于本质。”\n\u0026ldquo;Existence precedes essence.\u0026rdquo;\n  这只代表接受过去的世界，并不代表接受这个过去的世界于未来中仍存续。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 与世界中的不幸抗争，大概也是一种享受。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":7,"section":"posts","tags":["随笔"],"title":"石头记","uri":"https://blog.chenqiqian.com/posts/stones/"},{"content":"作为一位曾经的 OIer （请允许我这么自称），与心中的贵系情结和解并非易事。\n虽然我现在看着像个精北，但其实从高一第一次接触信息学竞赛开始（或者更早），清华、计算机就成为我高中最重要的那张答题卡中唯一的选项。\n清华大学计算机科学与技术系，或称贵系，在那时的我看来，就是全中国工科的皇冠，是清华大学科研与教学实力最雄厚、建系历史最悠久、院系文化最丰富、学生生源水平最高的院系之一。它是清华大学响当当的招牌。贵系出现在信息学竞赛的舞台中央和各个角落，是高水平的代名词。贵系，贵系，你自己知不知道你多么能成为一个孩子的最强烈的希冀呢。\n而软件学院，那是什么？我对它几乎一无所知。\n来清华之后，虽然代管在软院，但我上的几乎全是贵系的课，wyp 老师的程设，myc 老师的离散一，邓老师的 dsa ，yhl 的老师的 oop ，甚至还去旁听 zxp 老师的离散二（离散二是我唯一本院老师的课程）；即使今天已经确定留在软院，也想在大二大三蹭 or 上许多贵系的专业课。\n要夸贵系的话，即使现在我也能一口气写出好几个 800 字；而对软院，仍然很难下笔。\n诚恳地说，我信息学竞赛学的不好。我没有进入省队，也因为各种原因没有参加过 WC ，APIO，CTSC 中的任何一项，OIerDB 上有且只有两条关于我的记录。\n我现在还能清晰的感知到 OI 带给我的那种自卑。在教室里和考场上，我几乎永远是会的东西最少的，我几乎永远是认识的人最少的，我几乎永远是对题目反应最慢的。第二年，我自认为已经准备不错，但在 NOIP 考场上用不到五行代码写没了 60 分。第二年，我也明知道几乎什么都不会，在广州 THUWC 的考场上几乎爆零。第二年，我也明知道自己没有什么希望，却在 BJOI 上差点翻盘进队。第二年，我自以为有点希望，在省选后的 THUSC 因为年龄和分数而只拿到一张毫无用处的三等奖。卑微、卑微到泥土里，一度只想着逃离，却不得不强迫自己面对，这就是我对于 OI 的印象。\n自始至终，我感觉自己都没有融入 OIer 这个圈子。我似乎一直是个旁观者，在各种颁奖仪式上旁观，在微信/QQ群里旁观，甚至在等待出分时旁观台上的人打游戏\u0026hellip;可能是因为我实力不够，可能也只是我来晚了吧。\n高二下学期期中，我回归课内。我用硬纸板做了个小签，在上面用最普通的黑色圆珠笔描出来几个粗笔画的字符：THU CS 2020，把它贴在书桌我眼前的书架上。虽然两年 OI 并没有让我拿到清华的入场券，但课内的学习让我满心以为我的梦想就要实现。我成绩很好。我甚至考出了我从来没敢想过的年级第一。两次。1\n在疫情给我的家庭、生活、学习带来的各种巨变下，这强烈的愿望把我反噬了。虽然你可能认为这只是借口，虽然我也是这么认为。\n或许是个意外，或许并不意外，我高考考出了我整个高三以来的最差成绩。虽然我还是高出分数线 9 分，虽然我还满心以为我可以实现我写在小纸板上的 \u0026ldquo;THU CS\u0026rdquo; 梦。2我没有任何犹豫的来到艺博，填了计算机类。3我隐隐感觉我分数不够，会被代管到软院，但我选择逃避了这个想法\u0026hellip;\n9 月 1 日，我记得我在回家的地铁上查到了代管结果，软件学院。4和同学交流之后，我才发现我离代管到计算机系只差 1 分。\n这简直是对我的一场嘲弄。\n说起来，数字能代表很多，但它能代表的也太少。刚开学，茶园二招面试的表格上只让填写了两个数：NOIP 分数和高考排名。这恰巧是我最“不好看”的两个数字。看到这两个数字，怎么能让人知道背后三年时光中的“故事”呢……\n在我高中几乎从未设想过的软件学院，我的大一上学期开始了。我以为凭借着 OI 的基础，加上暑假现在看起来微不足道的预习，在计算机类成为“卷王”去贵系十分容易，但我错了。我高估了我的能力。\n我在上学期选了 13 门课， 31 个学分，包括巨硬的写沟，包括巨硬的英语，包括巨硬的微积分 W 。我在上半学期一周的课时有足足 42 个，还没有算上你清引以为傲的“集体活动”。我还面临着感情的矛盾，我还面临着身体的压力。当然，这是我自己的选择，我没有办法去抱怨。\n我学不会微积分（或者是我学不会微积分 W ，也许这有区别，也许这没有区别， 我这辈子大约的确不会知道了）。我用其他科目去逃避微积分。并不意外地， 5 个学分的微积分，我拿了 C+ ，2.6。有难过，有失望，当我氪金查分后却又一次发现自己即将与“梦想”分道扬镳。但这毕竟是我自己的选择，我无法去抱怨。\n当一个人所坚信的事物在他面前崩塌，他要么一样崩溃，要么换一个信仰，为自己辩护。我发现我其实只是个“叛逆”的人。或许是因为我骨子里仍然很骄傲，仍然坚信自己与众不同，仍然坚信自己就应该是 stand out 的那些人中的一个。我试图叛逆人的“本性”，试图叛逆周围的大多数，而也“叛逆”曾做过的选择。所以上个学期，大概是为了逃避现实，给自己的现状辩护，我“叛逆”了我自己，你可以看到我很“真诚地”说我更喜欢文科，你可以看到我屡屡“真诚地”表现出精北。5\n而面对身边的人离去或离开，我试图在哲学中寻觅答案，虽然我后来发现哲学完全不是所谓的导师。从离散数学衍生了解到的维特根斯坦哲学，课上学到的解构一切理性的《科学革命的结构》，给我所谓“理性”世界观的消逝以极大的推力。除了闭环的逻辑6，我开始质疑一切的“合理性”与“价值”7，从自己的生命到世界中的一切，也真正质疑人和人的共识是否可能发生。理性之间由不矛盾但又相互矛盾的前提挖下了不可跨越的鸿沟，总有一些不可“反驳”的事物：正是“你说的对，但对我没有意义”。\n或多或少的，我陷入了虚无主义。（请宽恕我在这里滥用并不规范的学术名词）如\n果一个人认为生命没有任何价值，他一定可以放下生命附属的所有的一切。\n所以虽然我后来发现，我的成绩加上 OI 经历其实大概足够分流去贵系，但我并没有改变留下的选择。我大概与我自己达成了和解（换个说法，也是某个我“自杀”了）：生命的结果没有意义，它的所有意义都在于它发展的过程。既然世界在我面前这样打开，无论我是靠近了它，还是推走了它，你都决不能说我做错了什么，决不能说我做的毫无意义（虽然你当然可以这么说）。\n面对心中的无意义，唯一特殊的存在是“我”。8最近的学期，我试图去感受真实的我：我试图去不断获得获得全新的人生体验，我试图去“顺其自然”。似乎只有在这些时刻，我才会惊讶地发现我的存在。而软院似乎是能够让我开心，能够给我提供这样体验的地方，让我体会到“我之为我”的地方吧，因此我选择打开这扇门。\n说点题外话。庄子说：“终身役役9而不见其成功，苶然10疲役而不知其所归，可不哀邪！人谓之不死，奚益！其形化11，其心与之然，可不谓大哀乎？人之生也，固若是芒12乎？其我独芒，而人亦有不芒者乎？”这半年深刻体会到，人和人的悲欢不能相通，而每个人都处在他自己孤独的大寂寞中，几乎没有人能够和他共同体会。或许我们会急着把这寂寞抛却出去，试图找到另一个人来理解自己，帮助自己排解这忧愁，但毕竟知心者难求，许多事情终究还是得一个人走过。归根到底，当我们仔细地检视内心，一定会发现那些难以消解的，孤独的寂寞和迷茫的虚无。\n顺带提醒一下那些可能半年一年没有见到我的同学：我已经远非那个高中的我了。\n有人说过：“我们登上并非我们所选择的舞台，演出并非我们所选择的剧本”。也有人说过，我们是被“无端地抛掷到这个世界上”的。对于某些事情，在某些时候，我总想要去找到一些原因，获得一些“解释”，总想要去厘清一切。\n但即使面对同样的事情，顺其自然与怠惰无为，发挥能动性和刻意强求，客观条件缺失和主体能力不足，这之间的界限仍总是模糊不清。我想要做某事，我没有做成某事。这是什么原因？这是能说清楚的吗？\n人们总说做事要尽力，要无愧于心，要“尽吾志也”，还要有“坚忍不拔之志”，然而到底哪里是边界？我们过去曾经试过，我们会发现这像是海绵挤水，只要使更大的劲，总是能挤出水，甚至挤出更多的水，那这样的边界到底在哪里？当我们深叩自己的内心，这种不满足只能给我们痛苦，这好吗？\n因此，当我选择将以上评判的指针向一侧拨动，你可以说我在软弱地逃避，你也可以说我躺平胸无大志，我愿意接受任何评价（“你说的对，但对我没有意义”）。但没有人知道我经历了什么，无论别人如何试图去“全面”评价我，如何试图去“全面”理解我，都只是对我做了维数或高或低投影后的观察，而永远不可能完整的体验我。\n既然世界如此呈现给我，既然我的选择如此做出，它们在生发出的一瞬间也就成为了我的一部分，它对我就已经充满了意义，无论在现实上或在精神上它会给我带来什么结果。\n所以说回分流，比起所谓名号、成绩、课程、发展，我或许还找到了另一些、或许对我有价值的东西。既然那些都是“懂的都懂，不好明讲”，而这些又是因超出 800 字限额而无法言说的，那我也只能：\n “但我坦然，但我欣然；我将大笑，我将歌唱。”\n 以上是在这个分叉口即将踏上无法回头的道路的人，对于自己过去几年的清算吧。它或许对于读者没有任何意义，且引发不起任何共鸣，且可能看起来矫揉造作，且都是些已经说了好多遍的无聊死了的故事，但对于我来说，又何必需要读者怎么想呢。\n 我把心剖开了给你看，很疼的\u0026hellip;但你也不用回应我或给我安慰，我只求你的理解，理解我为何会如此之疼，为何明知如此之疼也一定要剖开它。\n P.S. 我很喜欢这篇文章（Web Archive） ，我虽然没有他那样厉害，但我和他所面对的那些命运大概是类似的\u0026hellip; 还有这一篇（Web Archive）。\n 或许有读者不知道这里提到的“年级第一”代表着什么\u0026hellip;反正就是看起来“很厉害”吧。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 毕竟，每次见到招生老师，也只会又确认一次，计算机类的录取分数线比对外公开的分数线高五分左右。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 甚至连北大博雅酒店招生点都没去，现在想想真是对不起北大热情的招生同学和老师orz\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 上一次这样的体验还是在新奥购物中心，收到高中分班的短信\u0026hellip;回想起来真是五味杂陈。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 关于引号：何谓真诚呢？如果周围的人都热爱文科，如果周围的人都是精北，那仍然作为一个 loser 的我，是不是就成了工业党 + 你清紫卫兵了呢hhh\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 又何尝不是游戏呢。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 当你发现你本有的信仰和思想是那样千疮百孔，而他又给你提供了一个看似完美无缺的圆，你又哪里还敢于“确”信什么呢\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 或许这是主观唯心主义。的确是，但主观唯心没有错，它只是一个没有什么“意义”的闭环。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 忙碌。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 因病而疲困之状。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 老。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 迷茫，糊涂。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":8,"section":"posts","tags":["随笔"],"title":"写在分流之前","uri":"https://blog.chenqiqian.com/posts/write-before-rearrange/"},{"content":"《离散数学2》图论学习笔记——树部分。\nhttps://www.zybuluo.com/chenqiqian/note/1788174\n由于 Hugo 的 markdown 引擎 goldmark 对于 latex 的支持简直是 ***，本文暂时在上界面发布。\n以下定义和概念都是对于无向图而言。 + （森）林：不含任何回路的图 $G(V,E)$。 + 树：联通，但不含任何回路的图 $G (V,E)$ 。  注意：有向图的“连通”一般指“弱联通”，即刨除方向后的联通；有向图强联通的概念不在这里介绍。 + 树枝：树的边。 + 树叶：树中度数 1 的节点。 + 分支节点（内节点）：树中度数大于 1 的节点。 ### 树的其他等价定义 以下六个对树的定义等价。 1. （G 联通，且无回路）  6-1: 若不联通，加入存在一条边后必然没有回路。 2. G 的任意两个顶点之间存在唯一路径  1-2: 若有两条路径，异或则可得到一条回路。 3. G 中无回路，且 $m = n-1$  2-3: 若存在回路，则必然能找到不唯一路径；归纳法，利用点边和连通性证明 $m = n-1$ 。 4. G 是联通的，且 $m = n-1$  3-4: 若不连通，不可能有 $n-1$ 这么多条边。 5. G 是联通的，且 G 中任意边都是桥  4-5: 证明若只有 $n-2$ 边，不可能联通。 6. G 中无回路，且加入任意一条边能在图中得到唯一一条含新边的回路  5-6: 无回路显然，故利用 (1) 其是树；利用 (2) 中，树有唯一路径得到唯一回路（这个证明不好） ### 支撑树 + 支撑树：图 $G(V,E)$ 支撑子图 $T$ （即图 $T$ 边的端点集合之并为 $V$），且 $T$ 为树。 + 树边：$G$ 的在 $T$ 中的边。 + 余树：$G-T$，即图刨除任意支撑树的边。 + 余树边（树的弦）：$G$ 在余树中的边。 性质：支撑树与余树一一对应。（用在后面支撑树生成，只要枚举出余树也就枚举出了支撑树）。 ## 基本关联矩阵与支撑树计数  以下关联矩阵、基本关联矩阵都是对有向图而言。对于无向图，一般可以给每条边指定一个方向，大部分方法可以套用。   【其实支撑树计数问题应该是基于无向图的，使用指定边的方向转化为有向图求解。这和课本的逻辑有微小的差距。】 ### 关联矩阵 每一列代表一条边，如果边从 $v_i$ 指向 $v_j$ ，那么该列第 $i$ 行填 $1$ ，第 $j$ 行填 $-1$ ，其余均为 $0$ 。 $n \\times m$ 矩阵。 用 $B$ 来代表关联矩阵。 关联矩阵是一种表示边点关系的方式。边和点可以构成“回路”，树恰好不要“回路”，那么运用一点微小的线性代数知识，我们可以获得如下的结论，从而帮助我们以数学视角探究一些图的性质，并计算支撑树数目。 #### 性质1：关联矩阵与回路 关联矩阵的 $k$ 列线性相关 $\\Leftrightarrow$ 对应的 $k$ 条边中存在回路。  证明：这几乎是显然的，将回路对应的边调整好方向（也就是把列乘上 $1$ 或者 $-1$），从而可以顺序连接；把这些列相加可以得到 $0$ 列。 #### 性质2：关联矩阵的秩 关联矩阵的秩的图论意义是什么？根据上面的性质，上面最多能从图中挑出多少边，使它们的导出子图上没有回路。 对于有向【联通！】图的关联矩阵 $B$ ： 1. $\\text{rank}(B) 证明：线性代数来说，可以把所有行（$n$ 行加到一起，每个位置都是 $0$（每列只有一个 $1$ 和一个 $-1$），因此线性相关）。 2. $\\text{rank}(B) = n-1$ 。这是说，一个图一定存在 $n-1$ 条边，他们的导出子图没有回路。根据上面的等价定义，这也就是说，（联通图的）支撑树一定存在。  证明：从线性代数视角，考虑若干行（注意，是行！）的线性组合。如果他们的和是 $0$，且存在一个系数非 $0$ ，那么根据连通性，所有行对应的系数都是一样的（因为每列只有一个 $1$ 和一个 $-1$，这两行的系数必然相同，又因为联通，可以走到所有的 $n$ 行）。所以所有行的系数都非 $0$ ，也就不存在 $n-1$ 行的线性组合是 $0$ 。  重要的结论：关联矩阵的任意 $n-1$ 行，他们都不线性相关。这保证了下面基本关联矩阵相关性结论的正确性。 ### 基本关联矩阵 在关联矩阵 $B$ 中划掉第 $i$ 行（$1 \\leq i \\leq n$ ，$i$ 是任选的），得到基本关联矩阵 $B_i$ 。 注意，基本关联矩阵和关联矩阵含有相同量的信息，根据基本关联矩阵我们可以推出关联矩阵。这一点可以和 $\\text{rank}(B) = n-1$ 共同理解。 理解基本关联矩阵，核心的问题是：**为什么要删掉 $1$ 行呢？** 这就需要进入数学的视角来考察“树”。 因为在数学上，图“有无回路”的特征（也就是树的特征）用的是关联矩阵的线性相关性来刻画，而这一线性相关性可以用行列式来在**数值**上刻画，而行列式只能运用于方阵。 因此我们想要判断 $n-1$ 条边是否构成树（也就是判断关联矩阵中对应 $n-1$ 列是否线性相关），为了使用行列式来刻画这 $n-1$ 列的线性相关性，我们只需要 $n-1$ 行，因此是需要删除一行的。如果行列式不是 $0$ ，那么这就是一棵树；若行列式为 $0$ ，则不是。 然而，我们可以敏感的发觉“删除一行”的操作可能会出现问题。删除掉一行之后，**这 $n-1$ 列的线性相关性是否还能保持** ？答案是确定的，详细证明如下。  证明：   1. 有一个方向是显然的：从线性代数视角来看，如果原来的 $n-1$ 列线性相关，那么删掉一行（也就是减少一个维度）之后这 $n-1$ 列仍然线性相关；  2. 另一个方向略显困难：如果原来关联矩阵的 $n-1$ 列线性无关，那么删掉一行之后，在基本关联矩阵中这 $n-1$ 列仍然线性无关吗？如果删掉某行后不是线性无关，那么存在这些列的线性组合使得到的列中该行位置的元素不是 $0$，该行之外位置的元素全都是 $0$ 。那么关联矩阵的这 $n-1$ 列的线性组合后的元素和不为 $0$ ；这与关联矩阵中每一列所有元素和都是 $0$ 矛盾。 在用行列式刻画基本关联矩阵中取出来 $n-1$ 列的线性相关性的时候，我们注意到一个很好的性质：这样的行列式只会是 $\\pm1$ 或 $0$ 。直观理解的话，因为矩阵很稀疏且只有 $\\pm 1$ 的非 $0$ 元，所以代数余子式展开的时候不会很大。详细证明如下。  证明：使用数学归纳法，对阶数进行归纳。（略，待补） 这一结论（线性无关是 $\\pm 1$ ，相关是 $0$ ）在下文计数时提供了很大的便利（平方后算术加和即可得到非零的“个数”）。 ### 支撑树计数 有一个近乎显然的做法：我们**枚举**基本关联矩阵抽出任意 $n-1$ 列构成的子阵（它是方的），如果它的行列式不是 $0$（那么就是 $1$ 或者 $-1$ ，它的平方一定是 $1$ ），那么代表这 $n-1$ 列对应的 $n-1$ 条边可以构成一棵支撑树。  证明：行列式不是 $0$ $\\Rightarrow$ $n-1$ 列线性无关 $\\Rightarrow$ 边导出的图没有回路 $\\Rightarrow$ 是一棵树 那么我们把所有的对应的行列式的平方求和即可得到某图中支撑树的数目。 接下来所有的事情都是为了加速（至少在形式上“加速”）这一过程。 #### 比内-柯西（Binet-Cauchy）定理 首先做一些纯粹数学上的准备。 对于 $ A = (a _ {ij})_ {m \\times n}, B = (b _ {ij}) _ {n \\times m} (m \\leq n) $ ， 我们有 $\\det(AB) = \\sum\\limits _ {S}\\det(A _ {S}B_S)$ ，其中 $S \\subseteq \\{1,2,\\cdots, n\\}, |S| = m$ ；  关于记号的说明：$A_S$ 表示从 $A$ 中挑选 $S$ 集合下标的 $m$ 【列】构成的 $m \\times m$ 方阵；$B_S$ 同理表示从 $B$ 中挑选同样 $S$ 集合下标的 $m$ 【行】构成的 $m \\times m$ 的方阵。  证明：（略，不打算补） #### 利用基本关联矩阵：无限制支撑树计数 利用上面的定理，我们可以巧妙的加速以上运算（或者至少让看起来的形式简洁一点）。 我们令 $B_i$ 为点 $v_i$ 对应（把 $v_i$ 对应的行删掉）的基本关联矩阵。则： $$ \\det(B_i{B_i}^T) = \\sum\\limits_S \\det({B_i} _ S {{B_i} _ S}^T) = \\sum\\limits_ {S} \\det({B_i} _ S)^2 $$ 注意到，这个式子可以和上文的“显然的做法”对应： $\\sum\\limits _ {S}$ 对应中的“枚举 $n-1$ 列”，${B_i} _ S$ 对应挑出来的 $n-1$ 列构成的方阵。 于是：$\\det(B_i {B_i}^T)$ 即为图的支撑树个数。 ### 带限制条件的支撑树计数 有的时候，我们会对支撑树做出一些限制，而为了计算符合条件的支撑树个数，我们需要对上面的方法进行一些微小的特异化。 #### 包含或不含特定边的支撑树计数 不含 $e$ 的支撑树：删去边 $e$ 之后，按照新图构造关联矩阵与基本关联矩阵（其实就是从原来的矩阵里面删掉一列）进行计算。 包含 $e$ 的支撑树： 1. 把 $e$ 两边的点缩成一个点，再进行计算 2. 所有支撑树 - 不含 $e$ 的支撑树 = 含 $e$ 的支撑树 #### 以特定节点为根的支撑树计数 再次申明，这一概念只适用于有向图。 严格来说，“对于一棵树，其以 $v_i$ 为根” 当且仅当 “这棵树中， $v_i$ 的负度为 $0$，剩余所有节点的负度均为 $1$ ”。 以直观的视角来看，“对于一棵树，其以 $v_i$ 为根” 当且仅当 “对于一棵树，将 $v_i$ 放在最上面，按照“重力”下垂，所有的边都由上指向下”。【“重力下垂”是个很强的条件，仅仅拥有“从上向下”的边并不能保证得到的是树，只能保证得到的是有向无环图】 我们需要想办法排除掉所有不符合根条件的支撑树。也就是对关联矩阵进行修改（具体来说，就是把所有 $1$ 置为 $0$ ），使得所有不满足根条件的支撑树所对应的 $n-1$ 阶子式的行列式变为 $0$ ；满足条件的仍是它本身。  后者我们通过可以**给有根树的点和边重新编号**，使 $v_1$ 为根，使所有的边 $e_j = (v_i,v_j)(j = 2,3,\\cdots,n)$ 都有 $i  边和点的重新编号，体现在矩阵/行列式的数学视角里面是什么呢？对边的重新编号是列交换，对点的重新编号是行交换。   以上三个操作都不改变行列式的值，  前者不太好说【书上直接“显然”了】：对于一棵支撑树，如果其不以 $v_r$ 为根，那么必然存在节点 $ v_j$ , $v_j \\neq v_r$ 的负度为 $0$ （利用 $ \\sum \\limits _ {i}{{d^-}(v_i)} = m = n-1 $），即 $v_j$ 对应的行全为 $0$ （因为正度的 $1$ 全被删掉了），有全 $0$ 行的矩阵的行列式必然为 $0$。【其实这也有点图论视角。】  从图论的视角来看这个问题更加明显一点。去除所有 $1$ 后，（基本）关联矩阵本质上只表示负度，也就是某行的 $-1$ 的个数表示该行对应的点的负度度数，每列有且仅有一个 $-1$ 。而根据有根树的定义，对于一棵树，其以 $v_i$ 为根 当且仅当 $v_i$ 的负度为 $0$ 且剩余所有节点的负度均为 $1$ 。那么转化成数学表示的话，后一个条件就是 $n-1$ 阶方阵每一行、每一列有且仅有一个 $-1$ 。我们知道，这是一个置换矩阵，行列式是 $\\pm 1$ 。这样想可以使两方面的推导都更加自然。 所以结论： 且令 $\\vec{B_i}$ 表示将 $v_i$ 对应的基本关联矩阵中所有的 $1$ 置成 $0$ 之后的矩阵，那么以 $v_i$ 为根的数的个数就等于 $\\det(\\vec{B_i}{B_i}^T)$ 。 至于为什么不采用 $\\det(\\vec{B_i}\\vec{B_i}^T)$ 作为表达式？ 因为上文关于 $\\vec{B_i}$ 中 $n-1$ 阶子阵行列式变化视角和图论视角下的讨论，都是基于**挑出来的列对应的边能构成一棵树**的前提下进行的。而如果缺乏这个前提，上文的讨论是不能成立的。本质上来说，就是 “$v_i$ 的负度为 $0$ 且除了 $v_i$ 的点负度均为 $1$ ”的条件（删去 $v_i$ 行，再挑出来满足这样条件的边对应的的 $n-1$ 阶子阵的行列式不是 $0$ 哦！）并不能确保这些边的导出子图为一棵树。容易想到的反例就是一棵有根树 + 一堆环。 --- 以上两种形式的约束可以组合。值得提到的是，包含某条边的特定节点的支撑树计数，有一种较为简单的办法：把该边指向的节点的其余所有入度都删掉。 ### 矩阵树（Matrix Tree）定理 一种较为简便求解支撑树计数问题的方法。 对于**无向图** $G(V,E)$ ，定义拉普拉斯矩阵 $L _ {n \\times n}$： $$ L _ {ij} = \\left \\{ \\begin{aligned}-m _ {ij}\u0026,i \\neq j \\\\ \\text{deg}(v_i)\u0026,i = j\\end{aligned}\\right. $$ 其中 $m _ {ij}$ 表示 $v_i$ 与 $v_j$ 之间的边数。 则该无向图 $G$ 的支撑树个数则为 $t(G) = \\det(L_i)$ ，$L_i$ 为去掉第 $i$ 行和第 $i$ 列后得到的矩阵，$i = 1, 2, \\cdots, n$。 或者，用特征值表示：找出 $L$ 的 $n-1$ 个非 $0$ 特征值 $ \\lambda _ 1 , \\cdots, \\lambda _ {n-1} $， 那么 $t(G) = \\frac{1}{n} \\prod\\limits _ {1 \\leq i \\leq n-1} \\lambda_i$ 这一定理的本质是找到了一个对于关联矩阵与其转置乘积结果的简洁表达，因此在 $m$ 较大时能节省出很多的时间。具体证明如下：  引理1: $BB^T = L$   证明： $(BB^T) _ {ij} = \\sum \\limits _ {e_k \\in E} B _ {ik} {B^T} _ {kj} = \\sum\\limits _ {e_k \\in E} B _ {ik}B _ {jk}$ 。   1. 当 $i=j$ 时，显然只有 $e_k$ 邻接与 $i$ 的时候， $B _ {ik} = \\pm1$ ，其余时候均为 0 ；故求和即为与 $i$ 邻接的边的个数，即 $deg(v_i)$ 。  2. 当 $i \\neq j$ 时，$B _ {ik} \\neq 0$ 且 $B _ {jk} \\neq 0$ 当且仅当 $e_k$ 连接 $v_i$ 与 $v_j$ ；而 $B _ {ik}$ 与 $B _ {jk}$ 显然一者为 $1$ ，一者为 $-1$，故乘积为 $-1$ ，求和后即为 $-m _ {ij}$ 。   引理2：$B_i{B_i}^T = L_i$   证明：这几乎是显然的。 关于有根树的矩阵树定理，在这里不加证明的展示以下结论：  对于有向图 $G(V,E)$ ，定义出度拉普拉斯矩阵 $L^\\text{out}$ ：（$n \\times n$）   $$  {L^\\text{out}} _ {ij} =  \\left\\{\\begin{aligned}-m _ {ij}\u0026,i \\neq j \\\\ \\text{deg}^{\\text{out}}(v_i)\u0026,i = j\\end{aligned}\\right.  $$   其中 $m _ {ij}$ 为从 $v_i$ 指向 $v_j$ 的有向边条数。   同理可以定义入度拉普拉斯矩阵 $L^{\\text{in}}$ 。   定义 ${L^{\\text{out}}} _ i$ 为 $L^\\text{out}$ 去掉 第 $i$ 行和第 $i$ 列得到的矩阵；那么以 $v_r$ 为根节点的有根树个数即为 $t^{root}(G,r) = \\det({L^{out}} _ r)$ 。   同理可以定义 ${L^{\\text{in}}} _ i$ ，则以 $v_r$ 为叶节点的有根树数目即为 $t^\\text{leaf}(G,r) = \\det({L^{\\text{in}}} _ r)$。 ## 回路矩阵、割集矩阵与支撑树生成 回路矩阵、割集矩阵都可以通过某种方式与支撑树形成一一对应，从而我们可以通过枚举回路和割集来确定所有的支撑树。 ### 定义与概念 ## 参考 1. 戴一奇等：《图论与代数结构》，清华大学出版社。 2. https://oi-wiki.org/graph/matrix-tree/ 3. https://zhuanlan.zhihu.com/p/108209378 -- ","description":"","id":9,"section":"posts","tags":["图论","树"],"title":"图论学习笔记2——树","uri":"https://blog.chenqiqian.com/posts/notes-graph-2/"},{"content":"本文为信息科学技术概论课程论文，写于2020年12月7日。\n摘要 本文主要探究一门新兴交叉学科——计算社会科学(Computational Social Science)的伦理问题。本文从计算社会科学的历史和发展趋势中提出对其学科伦理问题探究的紧迫性与必要性；随后以具有争议性的学科研究实例引入，综合计算社会科学在“数据”方面的本质特性，提出其学科研究范式，以及由此决定的学科伦理问题框架。随后，本文考察了当前学界对于计算社会科学研究中伦理原则的意见。最后，综合以上研究和探讨，针对伦理问题，本文从不同方面提出了一些促进计算社会科学克服伦理问题发展的具体措施。\n关键词：计算社会科学；伦理学；大数据；社交媒体\nAbstract This article mainly explores the ethical issues of a new interdisciplinary\u0026ndash;Computational Social Science. This article proposes the urgency and necessity of exploring the ethical issues of its subject from the history and development trend of computational social science; then it introduces controversial subject research examples, integrating the essential characteristics of computational social science in \u0026ldquo;data\u0026rdquo;, to purpose subject\u0026rsquo;s research paradigm and the framework of subject ethics issues determined thereby. Subsequently, this article examines the current academic communities' opinions on ethical principles. Finally, based on the above research and discussion, this article proposes some specific measures to promote the development of computational social science，overcoming ethical problems from different aspects.\nKeywords: Computer Social Science; ethics; Big Data; social media\n计算社会科学(Computational Social Science, CSS)是一门新兴的交叉学科。目前学界认为，计算社会科学可以看作计算科学作为一种通用方法向社会科学的传导，其核心问题是如何使用计算方法对人类产生的数据信息进行分析，进而解释和预测人类社会问题的过程与结果。1\n近些年，计算社会科学在信息时代的春风中，得到了迅速的发展。在谷歌图书关键词排序中，“计算社会科学”（英文）在英文图书中的出现频率在2010年之后呈现指数型增长（见图1）2；而在中国知网上，所有计算社会科学相关的中文期刊论文中，近1/3都发表在近两年间。\n图 1 Google Books Ngram Viewer 中“计算社会科学”条目的出现趋势2\n然而，计算社会科学的快速发展也使许多其学科内部的矛盾凸显，其中最核心的就是研究中的伦理问题。计算社会科学在社会中遭受了广泛的质疑。各购物平台利用大数据分析用户，从而进行“大数据杀熟”3；“魏则西事件”中，百度作为掌握用户大量搜索数据的公司，利用这些数据进行“莆田系医院”广告的精准推送。\n正如上文提出和下文要讨论的那样，计算社会科学的学科本质属性，再加上计算社会科学的飞速发展，使许多伦理方面的讨论出现。而在不少学者对于计算社会科学的研究中，对于伦理问题的探讨却不够充分，甚至根本没有注意到在它们的存在。45这驱使我们探究计算社会科学中伦理的边界。\n1 研究背景简介 从塔斯基吉梅毒实验开始，经过近几十年的发展，科学研究的基本伦理原则先后在《贝尔蒙报告》、《门罗报告》、《美国联邦受试者保护通则》中得到充分展示，有研究者概括出四条基本原则：尊重原则、有利化原则、公正原则、对法律和公共利益的尊重原则。6\n无论在计算机科学中还是在社会科学中，关于伦理的讨论并非刚刚出现，但两者的伦理观有一定的区别。计算机科学由于其理论性较强，对于伦理问题的考虑较为少见。社会科学则因其与人类相关的实践性成分更多，对伦理问题的考虑一般更加充分；许多研究都需要经过专门的“伦理委员会”的讨论。\n作为计算机科学和社会科学的交叉学科，计算社会科学兼具理论性和实践性两种特性，十分可能对现实世界中的人造成影响，因此伦理是必须要考虑的问题。然而，两种学科伦理观的碰撞导致学术群体对于某些伦理问题的看法存在较大的争议。对由计算机科学转入计算社会科学的学者，其由实验可行性的思考转入对可能施加于数百万人的实验的过程会更加直接；而不像使用数据方法的传统社会科学家那样，在实验之前对伦理问题作出周密论证。7\n2 计算社会科学焦点研究实例 为了研究计算社会科学的伦理问题，本节将从一个曾引起了很大争议的研究实例谈起。\n2012年，脸谱网(facebook.com)利用其社交平台进行了一项社会心理学研究，并在2014年将其成果发表。在一周的时间中，平台在没有取得用户”同意”的情况下，使用算法操纵了689,003名用户的时间线，筛选了情感因素，使一部分人暴露在更多的正面情绪内容下，另一部分暴露在更多的负面情绪内容下。通过分析用户在一周中发表内容的情绪关键词使用情况，平台得出一个社会心理学的结论：人即使是在没有意识到的情况下暴露在某种情绪的环境中，也会给人的情绪带来相同方向的影响。8\n这个实验在网络上引起了广泛的争论。《纽约时报》、《卫报》、《福布斯》等报纸和杂志都发表了文章来评论该次事件。脸谱网官方说明，由于用户均在注册时同意了“隐私条款”，其中允许脸谱网利用用户的数据进行“研究(research)”。但有网络评论认为，脸谱网的行为虽然不违法，但对于用户进行心理实验“超越了伦理问题的红线(cross the line)”，因为其没有获得用户的“知情同意”（informed consent）。9\n通过上面的例子，也通过某些学者的研究，我们发现不同的研究者之间、研究者与公众之间，对于计算社会科学的研究的伦理红线都有较为不同的认识。因此，厘清计算社会科学中的伦理原则和伦理边界就显得至关重要。\n3 计算社会科学范式：构建独特伦理框架 无论是相比于计算机相关学科还是社会科学相关学科，计算社会科学都可以算是一门“全新”的学科。直至2009年，15位科学家共同在《科学》期刊上发文，才标志着当前计算社会科学的学科范式初步建立。10本节将对这个范式作出一些基本的阐释，并试图从此范式得出计算社会科学的一些基本伦理原则。\n正如本文在最开始，以及15位科学家所指出的：计算社会科学的目的是通过分析和研究人类产生的信息数据，对人类社会进行解释和预测。10这可以体现出计算社会科学具有的“计算”和“社会”的两面性，而这样的两面性共同构建了计算社会科学的学科范式。\n3.1 信息与互联网时代：“数据”的内在矛盾 相比机械工业时代，信息时代的一个显著特点是人们在社会生活中所产生的许多“信息”都会以“无损”的数字存储形式保留下来，成为所谓“数据”。而伴随着互联网、社交媒体用户急剧攀升，人们的互联网行为越发频繁，产生的数据也就是海量的。如此规模的数据（常被称为大数据）被认为是计算社会科学能够进行的基础和推动力。10然而，互联网的这些人类行为数据作为计算社会科学发展的元动力，其产生和存在的形式就具有许多矛盾，这些矛盾直接决定了计算社会科学的范式以及其内在的伦理问题。以下是“数据”内在矛盾的几个主要方面：\n数据所有权的矛盾。首先，互联网的数据产生于服务使用者的行为，然而却保存在服务提供平台或公司处，这模糊了这些数据的所有权。服务提供的平台或公司对于这些数据拥有多少所有权，能够在多大程度上使用和公开这些数据，这是学界和社会各界都没有达成共识的问题。11这也就是上文脸谱网的研究实例产生如此大的争议的原因。其次，互联网的出现导致“公共”和“私人”数据界限的模糊。例如，用户在微信“朋友圈”之类小规模社交圈发表的消息的隐私权和公开程度的处理也引起社会和学界争议。12而且，有学者认为公开数据和私人数据两者的区别已经消失。因为在一定程度上，虽然经过了“匿名化”，甚至加入了随机的扰动，但足够多的公开数据完全可以追溯出更加私人的数据。611其实，上文所述的数据所有权的矛盾一定程度上正是互联网中用户的隐蔽性、匿名性与社会科学研究中数据公开性之间的矛盾的体现。\n数据目的性的矛盾。其具体表现为数据生成时的少目的性与数据利用时的强目的性的矛盾。在信息时代，人们产生的信息与数据并不为某一特定的原因和过程生成，其原因可能不存在或十分驳杂。但在传统社会学研究中，数据的获取和生成带有强目的性，传统社会学对数据的研究也具有强目的性。然而，在计算社会科学的研究中，其研究主体的强目的性与研究客体的弱目的性的交错，可能导致数据的所有者因为自己的语境被过分或错误解读而感到不适。6\n数据来源的矛盾。目前计算社会科学的研究对象主要都是采用社交平台的“公开”数据，或从私人企业合作中获得的数据，但这些数据能多大程度上代表被研究者的整体是有待商榷的。对这些数据进行系统性的筛选基本上是不可能的，这是与传统社会科学有针对性的获取数据的最大的区别。网民不能代表人民，在某种数据平台上的人也不能代表所有网民，系统性的误差是很可能出现并且不被意识到的。由这样“坏数据”，我们做出的结论也就很可能会出现误差，从而导致给现实中的人类造成伤害。\n3.2 数据之上：社会性的综合 上面的讨论仅限于计算社会科学研究客体，也就是“数据”层面；如果以上面的“数据”视角考察计算社会科学科学研究的主体“人类社会”时，伦理问题就纷纷出现。\n在大数据的研究范式中，少数群体很可能被忽视。大数据研究重视理论对实践上的“准确度”，但是忽略了社会个体的差异的内在秉性。比如对随机个体的预测准确度是95%的某种算法与一个对于占90%的多数群体预测准确率100%和10%的少数群体预测正确率50%的算法，两者在总体数据层面表现出来可能几乎没有差别，但是对于少数群体来说却是巨大的偏见。13结果的歧视性可能由数据的不客观性、方法不客观带来。数据集的规模虽然可以很大，但数据集本身就是由之前人类可能存在的偏见生成，因此机器学习等训练出来的模型也就可能会带有偏见的色彩；研究者也不可能完全客观，因而设计的研究方法（比如对数据的处理方式）也就会原发性地带有歧视性。14\n计算社会科学并非单纯对社会信息的计算方法研究。计算社会科学学科范式中有鲜明的社会科学学科范式内容。13正如第二节中提到的，计算社会科学在本质上还是一门以人类为研究主体的科学（human subjects research），需要考虑到对于人们现实的生活的影响。相比于其他计算科学如人工智能围棋等，通过计算得到的模型具有可以直接施加于现实的人的能力。\n总结来说，计算社会科学是对计算科学研究范式的延伸，对传统社会学研究范式的重构，带来了全新的伦理学问题。而有学者认为，计算社会科学研究中伦理制约的根本性原因在于“计算技术“带来了对被试者不断增强的控制力，超越了道德规范和法律修订来约束的速度。15仍以脸谱网的研究为例，在该项研究中，研究者轻而易举地操纵了数百万人的生活。\n4 关于计算社会科学伦理原则 基于《贝尔蒙报告》、《门罗报告》和《通则》中指出的科学伦理原则，再综合以上对于计算社会科学学科“数据”本质矛盾的探讨，下面本文提出和讨论一些适用于计算社会科学学科的伦理原则：\n第一，保证被实验者的“自主权”。计算社会科学的实验应该更多的观察现象而非操纵行为，应该更多的是解释而非再生成信息，从而减少对被实验者的影响。由此“自主权”衍生出的“知情同意”则具有较大的争议。许多学者在进行实验的过程中并没有获得被试者的知情同意。9事实上有学者认为，在大数据语境下，因为需要征求的被试者过多，几乎不可能获得所有被实验者的知情同意。而且，知情同意可能会增加客体受到伤害的风险，并瓦解实验的科学性。11因此现在学界认为，在信息可以公开获取的情况下，无需知情同意即可进行试验。\n第二，保证被实验者的隐私权、匿名权。在公开实验结果、分享实验数据时，应该充分考虑被实验者的隐私和匿名，对敏感信息进行处理，并对数据可获取性进行一定的限制，例如仅对可验证身份的研究者开放信息的共享。\n第三，保证被实验者不受到伤害（do no harm）。值得注意的是，在计算社会科学中，不同于以往的社会科学，借助于社交媒体的广泛传播性，实验可能对被试者造成更多的困扰，比如网络暴力、社交媒体上的“社会性死亡”等等。11\n5 计算社会科学与伦理的和解 针对以上的伦理原则，本节将从不同方面提出使计算科学研究减少被伦理问题困扰，从而健康发展的具体方法：\n明确学科范式。首先，在研究者由其他领域进入计算社会科学领域时，应加强关于伦理原则的宣传和教育，促进学者团体对学科伦理原则的坚持。除此之外，应该加强对于伦理的连续而非二分性的认识。许多现代伦理问题并非一棒子打死的“行”或“不行”，而是“更为合适”与“更不合适”的区别。其次，完善数据使用与共享机制。根据伦理的非二分性以及计算社会科学的新兴性导致的不确定性，当遇到隐私隐私，研究者和审查者都不应该明确的反对或者支持，而是在平衡风险和效益下进行决策，选择合适的数据使用的限度和分享的范围。6\n对于监管者，加强对于伦理问题的监管。在计算社会科学设置专门“伦理委员会”，对所有相关的研究进行预先的伦理审查(Pre-study review)，从源头层面防止有害于伦理道德研究进入实施。\n对于研究者，有以下两个方面：\n  加强合作与交流。通过社区合作，利用社区的同行监督功能，进一步明晰计算社会科学的伦理边界，并对研究在发表前加以预先审核，防止超越伦理界限的研究出现和不良社会影响的产生。促进使不同领域的研究者充分交流，使交叉学科继续融合，继续构建计算社会科学的学科范式，推进不同伦理观念的融合。\n  强调具体问题具体分析的方法。比较有代表性的是尼森鲍姆提出的“情景完整性”（situational ethics）的伦理判断方针，强调根据三个要素判定信息是否能够流通：角色（主体、发送者、接受者）、属性（数据类型）和传输原则（数据流通限制）。在讨论某种数据传播和应用是否侵犯了隐私权时，需从这三方面进行考虑，而不是简单地认为数据应当完全共享或者共享即侵权。14计算社会科学作为新兴学科，必然要面对各种不确定性，此时其能够为计算社会科学还没有积累充分经验时提供可行的伦理分析方法。\n  6 结语 在大数据、人工智能等手段日益繁荣的当下，计算社会科学有光明的前途，可期待的研究领域十分广泛。然而正如之前提到的那样，由于拥有社会科学的背景，计算社会科学的理论研究与实践密不可分，而伦理在有关人的实践科学中地位重要。计算社会科学发展道路的曲折程度的大小，将很大程度上取决于研究者能否克服面前的伦理问题。这些伦理问题，本质上源自对社会科学范式的继承和计算学科范式决定的研究方法中对于充满矛盾的人类“数据”的广泛应用和。\n因此，通过认识人类“数据”的本质矛盾，从而处理好研究着、公众与作为研究对象的人类“数据”之间的关系，计算社会科学中的伦理问题才能得到妥善的解决的前提。由于计算社会科学的新兴性，许多伦理问题并不能预先预料到伦理在计算社会科学的发展中应该起到框架性的指导作用，而非约束性的限制作用。11\n本文从对计算社会科学本质的思考提出计算社会科学应该遵循的原则，希望能够为计算社会科学研究的框架的形成做出一些贡献。\n参考文献 后记 这门课拿了3.6，就离谱\u0026hellip;\n EDELMANN A, WOLFF T, MONTAGNE D, et al. Computational Social Science and Sociology[J]. Annual Review of Sociology, 2020, 46.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Google Inc. Google Books Ngram Viewer [Z/OL]. (2020-11-29) [2020-11-29]. http://t.cn/A6GdeqIe.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 央视网. 从“大数据杀熟”透视中国企业商业伦理的缺失[N/OL].(2018-03-29) [2020-11-29]. http://t.cn/RnE91oW.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 朱萌,龚为纲. 计算社会科学：一种新研究范式[N]. 中国社会科学报,2020-11-18(005).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 韩军徽,张钺,李正风.计算社会科学——缘起、变革与挑战[J].清华社会科学,2019,1(02):117-132. HAN J H, ZHANG Y, LI Z F. Computational Social Science: Origin, Revolution and Challenges[J]. Tsinghua Journal of Social Sciences, 2019,1(02):117-132 (in Chinese)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 萨尔加尼克 M J, 赵红梅, 赵婷 计算社会学[M]. 北京: 中信出版集团, 2019. SALGANIK M J. ZHAO H M, ZHAO T. Bit by bit: social research in the digital age[M]. Beijing: CITIC Press, 2019. (In Chinese)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n KASHMIR H. Facebook manipulated 689,003 users' emotions for science [OL]. (2014-06-28) [2020-12-02]. http://t.cn/A6GFxFBD\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Verma I M. Editorial expression of concern: Experimental evidence of massive-scale emotional contagion through social networks[J]. Proceedings of the National Academy of Sciences of the United States of America,2014,111(29).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n VINDU G. Emotions in News Feed experiment, stirring outcry [OL]. (2014-06-29) [2020-12-02]. http://t.cn/A6GF6JTF\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n LAZER D, PENTLAND A, ADAMIC L, et al. SOCIAL SCIENCE: Computational Social Science[J]. Science (American Association for the Advancement of Science), 2009, 323(5915): 721-723.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n HENNELL K, LIMMER M, PIACENTINI M. Ethical Dilemmas Using Social Media in Qualitative Social Research: A Case Study of Online Participant Observation[J]. Sociological Research Online, 2019, 25(3): 473–489.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 江旻哲.对微信朋友圈构成“公共场所”之分析[J].法制博览,2017(11):242.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n WALLACH H. Computational Social Science not equal Computer Science plus Social Data[J]. Communications of the ACM,2018,61(3):42-44.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 凌昀,李伦.计算社会科学研究：范式转换与伦理问题[J].江汉论坛,2020(09):26-31.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 王泽南. 从传统社会学到计算社会学的方法论探析[D].哈尔滨工业大学,2020. WANG Z N. Research on methodology from traditional society to computational Sociology[D]. Harbin Institute of Technology. 2020. (in Chinese)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":10,"section":"posts","tags":["计算社会科学"],"title":"计算社会科学中伦理问题探究","uri":"https://blog.chenqiqian.com/posts/ethical-issues-in-css/"},{"content":"形式与政策课程论文。\n一、 “围墙”——问题起源和研究背景 想到并决定以“围墙”为题，有许多的原因。\n最主要的是昨天（11月20日）发生的一件小事。在第一教室楼上课前，我注意到放在前台附近的“意见本”，其内容十分丰富；而第一页尤其如此：\n这页密集的信息集中在讨论非清华师生能否使用教学楼，而其中给我留下印象最深的一句是：“无关人员留念，没有围墙的大学。”但是，在我进入清华大学的这三个月以来，我还没有过与校外人员冲突的经历；而后我意识到这是因为疫情，清华大学现在仅允许很少的校外人员进入校园，所以像反映在上图中的校内外人员间的矛盾比较少见。这是不是清华大学的“围墙”变得更高，更厚了呢？\n还有一个原因。今天（11月21日），知乎热搜榜首又一次被清华大学的相关问题占据。\n具体事件的经过我并不愿意在这里描述；但我愿意描述一下我看到的人群之间的撕裂：不同院系之间、不同性别之间乃至不同思维模式之间……虽然这些和疫情没有直接关系，但在一定程度上，这不是人和人之间的“围墙”更高、更厚了吗？\n在即将过去的2020年，因为新型冠状病毒肺炎的爆发，我们目睹了各种形式的“围墙”的新出现或重新出现。我们居住的居民小区从开放式变成了半封闭式，许多出入口被“围墙”替代；清华大学紫荆公寓现在一栋楼仍仅开一个单元门，剩下的门就成了另一种形式的“围墙”；在世界范围内，约4/5的国家或地区都有对入境的限制或强制隔离政策……1\n而这些“围墙”在疫情中的再现，在后疫情的阶段，我认为可以概括为社会排外主义思潮的发展。本文将探讨疫情如何使排外主义思潮泛起，在疫情及后疫情时代排外主义思潮的本质，以及作者本人对于该时段产生的排外主义思潮的理解。\n二、 疫情与后疫情时代的“围墙”：排外主义思潮 社会思潮，一般是指在一定时期内、反映某一阶级或阶层利益和要求的、得到广泛传播并对社会生活产生某种影响的思想趋势或思想潮流。2而关于排外主义的概念，国内外学界尚无统一的界定。有学者认为，排外主义更多地体现为：因认知偏见，对本国、本民族或本地区未有的事物所产生的排斥思想或行为。3\n但作者认为，排外主义一定程度上可以具象化为“围墙”，也就是把“外面”的某些特定的人、物质和信息阻拦在某一人群、地域之外。排外主义不仅出现在国家、民族等大型群体，在小型群体中也有体现，如上文提到的清华大学校内外人员间，各院系人员间。这赋予了排外主义思潮的研究以更大的空间和意义。\n在疫情和后疫情阶段，排外主义思潮全面泛起。在中国国内，随着疫情发展情况而对武汉人、东北人、北京人的“提防”和排斥；在国际上，2020年上半年，欧美国家针对亚裔族群，尤其是针对华人族群的种族歧视和排外行为在各地接连不断地上演，国内也一度有过对留学生“建设国家你不行，千里投毒第一名”的歧视性言论。4疫情的背景下，小“围墙”围起了社区、城市和学校，大“围墙”围起了民族和国家。下图所表现的农村防疫措施，就是一道活生生的“围墙”。\n有些人根据身边的观察，表明“排外主义”相关的事件可能并没有作者描述的那么深刻。但作者必须要指出，这可能是一种观察的偏差。因为在疫情的大背景下，许多平常时的矛盾都相对被淡化、压制了。因为疫情赋予了排外以一定的正当性，排外主义思潮对社会的影响虽然在一定程度上被疫情淡化，但正如上文所言，排外主义的思潮本身却在不断的壮大。\n三、 “围墙”之高与厚——疫情与后疫情期排外主义思潮的表现 与一般时期的“排外主义”不同，疫情和后疫情时期的排外主义思潮作用在社会、经济等多个方面，表现在物质和非物质两个层次，全面性、广泛性显著。\n在经济上，排外主义表现为政府层面的贸易保护主义和民众对于外国生产商品的不信任。世界贸易组织估计，2020年全球贸易总量将会下降13%至32%，下降的部分绝大多数将是国际贸易。[^5]在社会上，排外主义表现为政府对于外人的“歧视性政策”和民众的排外情绪，如上文提到的对于外国人入境的限制措施等等。\n排外主义思潮具有物质层次上的排外。由于疫情的影响，各种人口、物流往来受到极大限制。据国际民航组织的数据，2020年1-9月全球国际航班的乘客运载距离同比下降了88.8%。5\n而且，特别值得注意的是，排外主义思潮的影响也体现在精神层面上。在互联网高度发达的当下，信息等非物质实体的交换高度发达，在疫情环境下人们需要保持社交距离的限制下仍能发挥巨大的作用。然而，疫情背景下，人们言论、思想等非物质的层面上也受到“排外主义”思潮的影响。比如在疫情中或后疫情的现在，不相信外国的消息、不相信外国人发表的言论等排外主义现象也是屡见不鲜。\n四、 “围墙”何以再现：疫情时代和后疫情时代排外主义思潮的本质 疫情与后疫情期间排外主义思潮的泛起，原因主要来自于排外主义思潮本身与疫情带来的封闭等的影响。\n排外主义本身根植于人类的本性与历史文化传统的交织。人类是社会动物，具有强烈的集群意识；因此会排斥那些与自己不同，也就是“不合群”的“外人”，这是人类排外的生物或社会学基础。其次，大多数国家都是在相对封闭的环境中发展，相对封闭的环境可能难以与其他民族和群体形成强烈的一体认同感。6\n排外主义主要来自资源的矛盾，种族的矛盾，文化的矛盾。现代中国通行的“户籍制度”，是典型的，在资源不足的情况下作出的排外主义的政策；《左传》中记载的“非我族类，其心必异”和欧洲各国的反外来难民的活动，就是种族导致的排外主义。而文化的矛盾则更加明显，如中东等国难民的生活习惯和宗教信仰使他们在欧洲遭到各国基督教徒等的反感。\n而疫情，更加突出了以上因素，使排外主义的思潮更加明显的泛起。疫情带来隔离和封闭，分离加剧了不同人群之间的误解和不信任，从而导致不同群体之间更容易产生排斥的情绪；而封闭则使排外的成本降低，即使有了强烈的排外主义思潮乃至言论，也不容易体现在实际的世界中，毕竟不能“顺着网线去打人”。\n疫情给各国带来的治理危机也间接促进了排外主义的发展。疫情给各国的治理体制和能力带来极大的挑战，给各国执政者的治理合法性带来危机。因此，面对责任难以界定或过于广泛的分布在执政者整体时，执政者会选择将危机由内部转移向外部，选择用外国来当责任的“靶子”，例如美国对我国“武汉病毒”的无端指责。除此之外，为了降低治理难度，执政者还会选择鼓动内部团结的情绪，而小范围的团结（比如一个国家内的团结）也就会带来大范围的（比如国家和外国间）的排外情绪。\n排外主义和民族主义有什么联系和区别？作者认为，两者相关，但不一致；排外主义比民族主义更加宽泛。有观点认为，右翼的排外主义与民族主义较为类似。7比如在欧洲，主张脱欧的英国独立党，和反移民、反欧盟的老牌政党法国国民阵线以及意大利“五星运动”等，都是右翼政党，具有民族主义和排外主义的双重特征。而左翼政党一般排外性较弱，因为其主要以意识形态联接，而意识形态相较种族等容易改变的多。\n五、 “围墙”之围——如何破解？ 2020年的寒冬将至，新冠肺炎仍然在世界肆虐。美国的新冠肺炎创下了近十个月以来的最猛烈记录，单日死亡人数直逼2000人。\n我国的疫情形势也不容乐观。一方面，境外输入病例有抬头之势；另一方面，本土病例也在多个边境省份散发，如内蒙古、上海等。\n后疫情时期，排外主义思潮的围墙将在一定程度上继续存在。为此，我们国家一方面提出扩大开放、多边合作的方针，希望能从政府的层面打破围墙8；但另一方面，我们国家也提出了“内循环”战略，就是应对世界大环境排外主义的思潮的大背景下可能出现的贸易保护主义，促进经济挖掘内部活力的举措。\n一方面，我们积极应对后疫情时期的排外主义思潮；另一方面，我们也要思考，这样的“围墙”到底能够在后疫情时期存在多久？疫情的影响是否比我们预想的还要深远？国际货币基金组织秘书长表示，全球经济预计2022年后才能恢复至危机前水平。9 国际民航组织预测，全球航空业到2024年才能恢复到2019年水平。10世界能源组织则预测，到2025年世界能源需求才能出现复苏。11\n而新冠肺炎给社会带来的影响，则更加持久。研究表明，新冠肺炎疫情对于我国公众造成了广泛且较为持久的心理创伤，那么大概也就可以推断出新冠肺炎疫情的封闭和隔离所带来和加深的排外主义思潮是否也会产生更加深远的影响？12会不会当我们几十年后回望，发现从今天起，排外、保守的思潮形成了短时不可逆的扩张趋势，并对人类的历史发展产生了不可逆的影响？正如1918年的西班牙大流感促进了第一次世界大战的结束，作者认为，接下来相当一段时间的历史都或多或少的会受到上文所讨论的强烈的排外主义的影响。\n六、 反思——“围墙”作为“城墙”？ 疫情当前，目睹了朝鲜的国门紧闭与美国在疫情初期门户洞开的政策以及他们所导致的不同后果13，我们不禁会质疑，排外主义真的如我们广泛认知的那样如此恶劣吗？\n作者认为，排外主义从人类的本性和自然中来，是具有一定的正当性的。其的确可以在危机中给予某个群体抵御外部风险，给予一定的帮助。\n但在后疫情阶段，当疫情对人类社会的影响慢慢远去，排外主义的思潮也应该及时退去，这应该是各国政府所努力的。只有这样，世界才能继续全球化的进程，促进科学和经济的发展，让世界人民共同得到更大的福祉。\n[^5] https://www.wto.org/english/res_e/statis_e/latest_trends_e.htm\n https://www.kayak.com/travel-restrictions\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 赵曜：《当代中国社会思潮透视》，《中国特色社会主义研究》，2002年01期，第36-41页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 史志钦：《排外主义折射欧洲人的集体焦虑》，《人民论坛》，2019年01期，第28-30页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 马正义：《新冠疫情中欧美国家的种族歧视与排外行为》，《世界民族》,2020年05期，第36-44页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n IATA: Economic reports: Air passenger monthly analysis–September-2020\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 魏娟：《浅析日本人的排外心理的原因》，《剑南文学（经典阅读）》,2013年第6期，110页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 排外是左翼思想还是右翼思想？知乎https://www.zhihu.com/question/28514513/answer/729092550\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《习近平宣布中国全面扩大开放新举措》，央视新闻，2020年11月4日。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《IMF：全球经济2022年后才能恢复至危机前水平》，新浪网，2020年11月21日。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《IATA：航空业到2024年才能恢复到2019年水平》，搜狐网，2020年7月29日。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《IEA：全球能源需求将于2025年恢复》，东方财富网，2020年10月28日。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 冯正直、柳雪荣、陈志毅：《新冠肺炎疫情期间公众心理问题特点分析》，《西南大学学报(社会科学版)》,2020年04期。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 截至11月22日，朝鲜感染数为0，美国感染数约为1245万人。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":11,"section":"posts","tags":["政治"],"title":"“围墙”再现——疫情与后疫情时期排外主义思潮分析","uri":"https://blog.chenqiqian.com/posts/the-wall/"},{"content":"读了两本历史研究类的书籍。\n最近看的三本书总结起来就是：《你说这个党 or 国，咋就完蛋了呢》\n《党员，党权与党争》 这本书其实是在找《张力与限界》的时候顺带看到的。\n论及起源，有人说国民党1924年改组之后，和共产党是“结在一根藤上的两个瓜”。两党同法苏俄的政党制度，甚至一段时间内国民党受到苏俄的帮助还更多一些。国民党改组后，到49年全国解放，国共之间宏大的历史叙事我们都很熟悉：国共合作北伐，四一二事变等等，在此不再赘述。\n然而，既然师出同门，为何国民党最终失败而共产党赢得了中国？作者在组织层面上考察了这一问题，最终指出国民党的“弱势独裁”的组织特性是失败的根源；也就是名义上是蒋介石作为党魁的独裁，但事实上由于组织上的不力而导致的派系纷争、基层缺失因素极大削弱了国民党或者说党魁对于国家的统治或指导能力，上说下不听，失败也就在所难免。\n而对于组织上的不力，作者最终还是归结到了孙中山建党（1924年改组国民党）时“拧巴”的思路：一方面走欧美影响的权力分立和制衡，另一方面同时也走苏俄的一党专政，一定程度上也可以和上面的弱势独裁相对应。\n在我看来，说到底还是国民党的思想和意识形态没有搞出名堂，尤其是清共之后对“左派”思想的彻底的（也可以说是盲目的）清算，使国民党的意识形态进一步迷失和无力，也就给不出国民党作为一个整体前进的方向（尤其是没有高远的，可以和具体的党的领导者划分开的前进方向，用最近的话说，就是没有“功成即可，不必在我”的精神\u0026hellip;），国民党也就成为一个只能试图维持统治现状的“僵尸”，成为那些现时统治者的“党”。\n摘录一段给我印象极度深刻的文段：\n 1927年3月6日晚8时 ， 国民党中央监察委员吴稚晖在上海环龙路26号与中共总书记陈独秀闲谈。 在座的还有钮永建、 杨铨、 罗亦农等人。\n吴问陈：“你定中国实行列宁式共产主义需要若干年？” “20年！”陈毫不迟疑地回答。\n吴作骇极之状。罗在一旁似怪陈过于直率。\n合座默然。\n吴即乱以闲语曰：“由此，国民党生命止（只）剩19年了。前时总理答越飞，国民党国民革命完成，应需三十年。若你们共产党急迫至此，未免取得（代）国民党的生命太快了一点，应当通盘商量才好！\u0026quot;\n这一场景对话 ， 出自吴稚晖于 “四一二\u0026quot; 政变前夕向国民党中央监察委员会提交的弹劾共产党文。当年陈独秀 “二十年\u0026quot; 之说 ，也许只是国共朋友之间私下闲聊之语 ，吴稚晖却以之为清党反共的借口，显然有借题发挥之嫌。 而陈之闲语在22年之后竟成现实，恐是当年吴稚晖和陈独秀均未曾预料到的。\n 有的时候，历史的车轮真不是我们所能预测的啊。\n也有一点个人的思考，国民党那些人难道意识不到自己意识形态的无力吗？但共产党占据了绝大多数的理论高地，国民党的意识形态其实已经被困住了。因此他们只有两个选择，要么背弃自己曾经的所谓“信仰”和一直以来的社会地位给他们的“符号”，或者守在一条看不到希望的向死之路上，继续所谓的“斗争”\u0026hellip;打破过去需要很多勇气，有时候即使有勇气似乎也不可能做到，我们或多或少都被困在过去的影子里\u0026hellip;\n《戈尔巴乔夫之谜》 在参考文献里发现的有趣书（有趣是因为在水木搜索里出来“出版者不详，出版时间不详”2333），读完觉得没白读。在阐述对这本“回忆录”的读后感之前，我感到有必要介绍它的作者：利加乔夫。\n利加乔夫，出生于1920年11月，现在仍然在世；在苏联解体前，他曾依次担任过苏共托木斯克州委第一书记，苏共中央组织部部长，苏共中央第二书记。他在1985年到1990年，是名义上的苏联第二号人物。而这本书，正是一本他苏共中央岁月的回忆录，记载了他视角下的戈尔巴乔夫的苏联经济政治改革。\n正如其书名之“谜”，全书的主旨其实就一句话：“这个戈尔巴乔夫，我看着还挺对劲的，怎么就把我的苏联搞没了呢？”而作者暗示的结论是：“我相信戈尔巴乔夫是改革的好舵手，只是被人利用最后把苏联的大船开翻的。”作者写作该书大约是在1991年，如今关于戈尔巴乔夫的许多资料，似乎也并不支持作者的结论。我无意，也无能力断定是与非。但以苏共高层的视角来审视那段动荡的岁月，确实让人新奇。\n这本书里值得反复品味的段落很多，如之前摘录的谈报刊中的历史虚无主义的文字，功力很深；作者的文笔也还不错，读起来就像一本小说。因此下文会以摘抄为主，我自己的评论实在显得逊色。\n作者刚调到中央的时候，和戈尔巴乔夫建立了很好的个人友谊，以至于“说半句话都可以明白各自的意思”。他确实真心实意地认为戈尔巴乔夫是能够领导苏共和苏联改革的人，改革在“开头是漂亮的改革”，只是“遇到了很大困难”。这种印象贯穿了全书，作者对戈尔巴乔夫的信任几乎是无限的\u0026hellip;\n在描述1987年左右开始的改革过程中，作者反复强调自己的预感：“我预见到了飘向国家的乌云”，“一场巨大的灾难正逼近国家”，“[格鲁吉亚]发生新的尖锐冲突的可能性非常大。说实话，我很不希望自己又把事情言中”。对应地，作者自己也谈到对于政治家的理解：“准确地确定主要危险，这才是真正的政治才能”，“政治家的洞察力就表现在他能事先预见到人们情绪上发生的变化，减缓或完全防止不良倾向。”\n作者很看重舆论的功效，认为被“激进派”控制的舆论在改革过程中起到了极为恶劣的影响，正如上文反复提到的极右翼报刊。作为苏共高层，作为极力反对改革激进化趋势的人，作者经常成为报刊广播等等的中心，而且往往这些舆论都是带着攻击的欲望而来，往往也是空穴来风，相信他对于舆论的失控和威力也有着更大的感受。这对于我们今天也有许多的启示。\n利加乔夫也多次提到，自己没有尽全力进行斗争：“我们的国家正在发生影响到人民命运的历史性事件。戈尔巴乔夫、叶利钦、雅科夫列夫、利加乔夫不仅仅是一个个普通人。命运的安排使过去和现在都有太多的东西受他们每个人的左右。作为苏共政治领导人之一，我遵守了相互关系的道德准则，克制住了自己，没有谈论分歧。我这样是否正确呢？不知道\u0026hellip;\u0026hellip;也许这是个错误。”他有多次没有关于改革的路线问题表达自己更为强硬的态度以及采取个人层面措施控制舆论，他认为自己是一个“正直的正直家”….\n总体来说，与上本书的国民党相比，苏共显然面临着一个好收拾多的内部局面，但是苏联仍然解体了。如果让我说，对于意识形态和舆论战场的把握仍然是最关键的部分。苏共的组织体系显然比国民党完善，如果说国民党的问题是上面说下面接受不到或不做，那么苏共的毛病就是最上层歪掉了。最上层也有如利加乔夫这样能看明白事态的人（当然，利加乔夫无条件的信任戈尔巴乔夫显然也是十分糊涂的），也许是某些苏共的政治传统遏制了他们的斗争，也许只是他们势单力薄吧。\n改革或革命是共产党永恒的话题，如何处理改革是所有有志于共产主义的人都必须要审慎思考的。过去的历史教训，从上往下的视角一定程度上也可以补充完善我们从下往上的思考吧。\n作者在书中以一个忠诚的共产党员面目呈现自己，当今的我们读起来应当甚有亲切感，很多观点的论述我们也能认同，他的言行在中国的环境中，给一个“忠臣”称号是一点都不过分的。然而，他一个人无法挽救一艘大船，虽然几个人就能让这艘船触礁。上个世纪八九十年代，我们也有类似的政治风波，幸运的是，老一辈领导人的威信和及时的政策帮助我们挺过来了，新一辈领导人也及时的接上了。\n不管如何， 最后祝这位共产主义战士健康。\n回顾历史，观察当下，揣摩未来，思考还值得持续。历史真是很有意思呀\u0026hellip;\n","description":"","id":12,"section":"posts","tags":["历史研究"],"title":"「读书笔记」历史研究两册","uri":"https://blog.chenqiqian.com/posts/reading-note-history/"},{"content":"黄道炫著：《张力与限界：中央苏区的革命1933~1934》，北京：社会科学文献出版社，2011年11月第一版，2020年7月第10次印刷。\n读书笔记 读完《张力与限界》，一个简单的问题却始终困扰着我：第五次反“围剿”开始前，中央苏区的人口到底有多少？黄道炫使用国民党当局在第五次反围剿后的人口统计数据，估测中央苏区人口约为刚过300万1 。在某些学术论文中出现的人口数字则是根据党史办的数字，为453万 23。在一些网民看来，如果中共联合起中央苏区周围的根据地，人口甚至可以到千万之数 4。\n从300万到千万，这样的差距不可谓不大。对中央苏区的历史，网民、研究者们甚至难以对近乎“完全客观”的人口数量达成共识，更不必说“税负是否难以负担”，“ 对人力资源是否竭泽而渔”，“粮食是否能负担起战争消耗”等等带有更强主观色彩的判断了。然而恰恰是这些重重迷雾中的经济、社会、政治的基本事实，决定了我们对于当时领导人的策略的评判以及我们对历史的所谓“假设”是否能行得通。\n社会包括学界在之前，对于第五次反“围剿”的研究和叙事都着重在军事斗争和王明“左”倾路线上。对这些观点的批判，正是黄道炫的这本著作的出发点；而对于“历史光晕中”的经济等条件的考察和描述，则是黄道炫这本著作的主线。在建党一百周年之际，我们也更有必要去回望党过去的历史，这本书或许可以给我们一些历史观上的启发。\n黄道炫将目光主要聚焦在第五次“围剿”与反“围剿”过程，兼论了蒋介石国民政府和中央苏区在第五次“围剿”和反“围剿”之前的背景。\n总的来说，作者想要论证的观点在他所写的这段序言中已经表达的十分清楚：\n“1927年国共分裂时，中共几乎是白手起家开始武装反抗，仅仅数年后几十万武装即矗然挺立，缔造出共产革命的传奇。不过，神话般的故事到1930年代中期暂时画下了一个逗号，再强的张力也有自己的极限，中共在多种境遇下实现的超常发展，到这时似乎终于到了该停歇一下的时候了。从历史的大势看，1934年中共遭遇的挫折，以博古等为首的中共中央固然不能辞其咎，但这些被历史推上中心舞台的年轻人，其实本身也是历史的祭品。无论和共产革命中的前任或者后人相比，他们改变了或者可以改变的东西实属有限，他们没有也不可能改变历史的航向。”5\n正如在书名和上文的序言中提到的那样，这本书的核心概念是“张力”与“限界”。“张力”和“限界”都是作者用来摹状革命的，前者指的是革命的动力与来源，使革命接近于目标；后者则指的是革命会受到客观条件的限制，直观来说就是保持完整的“橡皮筋的拉伸”会有其边界。\n具体来说，在本书的前一、二章，作者指出：中共强力的组织机构、国内地缘政治博弈、赣西农村经济落后等主客观情况给中共的农村土地革命、阶级斗争等提供了强有力的张力；而在本书的第三至六章，作者则从南京政府和中共在第五次围剿与反围剿的准备和应对等方面入手，揭示在国民党政府的统治力加强和连年不断的“围剿”、蒋介石对于“剿匪” 布置日趋重视的背景下，中央苏区在地缘、资源、经济、社会苏维埃组织及政治领导等方面的限界被逐渐暴露，并最后导致了第七章中所描述的军事失败。\n总体来看，这本书最大的特点，是利用大量来源广泛的数据和史料来佐证关于张力和限界的观点。平均下来，每页大约有四到五个参考文献脚注，来源包括中央苏区方面当时出版的《红色中华》、《斗争》等刊物和后来汇集的中央苏维埃及红军文件，还包括国民政府方面的《蒋介石日记》，《陈诚家书》，《中华民国史档案资料汇编》等等。因此，这本书的确做到了尽可能消除政治偏见地对中央苏区1933-1934年客观（经济，社会，组织）情况做了比较全面的汇总。\n尽管作者摆出了许多似乎不可辩驳的史料来佐证自己的观点，仍有许多与作者意见向左或完全相悖的人。在他之前绝大多数关于中央苏区的书籍和文章都与他的观点大相径庭，如李涛著《赤都风云：中央苏区第五次反“围剿”纪实》，如李安葆著《红军第五次反围剿史话》，乃至中共中央1945年的《关于若干历史问题的决议》，都用标题等方式显著强调“左”倾王明路线才是第五次反“围剿”失败最关键的原因；在他写作这本书之后也有不认同他的观点的学者，专门发文驳斥他的观点。6\n这种观点主要认为：“左”倾的影响更大，是路线问题导致了红军的失败。其一，这种观点认为，军事失败比黄道炫认知中的更为重要，苏区所有的经济、政治、社会的问题都是由于军事失败导致的，而军事失败正是因为错误路线所直接形成的。其二，这种观点认为，所谓的“客观条件”缺失也是由于路线问题这样领导的主观错误导致的，如频繁发动肃反运动，提拔干部时过于重视成分等就限制了农业的发展，加剧了社会的混乱。\n莫衷一是的争论，围绕着这段历史层层展开，让人眼花缭乱。有学者总结出“中共军事失误”“寡不敌众”“辩证原因”“国际政治因素”“其他因素”等五种主流关于第五次反“围剿”失败的归因。7 而在知乎等网络论坛，则有许多关于“如果红军取得了第五次反围剿胜利，不需要长征的话，红军将会如何发展?”，“如果当年第五次反围剿苏联军事顾问不是李德……？”的讨论，足见对于这段历史的讨论不仅局限在学界，更扩大到了民间，影响广大。\n然而，我并不是专业的历史研究者，对于这段历史的了解仅限于教科书上的叙事、这本书的描述和刚刚查询的一点资料。因此，我无意在此评判书中的观点和以上的观点孰对孰错，做史实上的研究。\n我想要谈的，是在阅读黄道炫的这部关于中国近现代革命史研究的著作，并且对照了许许多多驳杂的史料和研究成果后的一些感悟。我们，作为历史学的“门外汉”，在阅读和研究历史，尤其是中国近现代的历史，尤其是中国共产党和中国人民的革命历史的时候，到底应该秉持着一种怎样的态度？形象的说，我们究竟应该以什么样的心情和神色，去回身眺望共产党和共和国的红色历史？\n先从这本书讲起。不论所谓“历史的真相”是什么，我们可以断定的是：中央苏区第五次反“围剿”这段历史的性质非凡。它是中国近现代史，它是共产党的党史，甚至可以说是共和国的国史。中共的军事失败，“长征”的开始，陕北革命根据地的扩大……这几个月直接影响了之后作为历史概念的“中国”的发展进程。作为中国共产党发展中少有的挫折（甚至是建国之前最后的）环节，这段历史注定承载了非凡的意义。最后，中华苏维埃共和国，作为中共执政的第一次实践，与10多年后的中华人民共和国在宪法、政府体系等方面都具有一定的相承的关系。但其实假如我们抬起目光，其实不只是第五次反“围剿”的历史，许多红色历史其实都具有以上的特殊性。\n正因为上面提到的许多特殊性，对这段历史的研究也具有许多特殊性：拨开历史的迷雾显得格外困难。受苏俄的影响，中共一直以政治为纲，因此我们无法完全凭空断定一切史料的客观性，必须要结合时代背景，政治背景才能做出比较客观的判断，然而这些背景相对来说更不好获取。其次，受到冷战等政治局势以及文革等政治风波，各方史料有的已经不复存在，存在者的获取至今仍然存在许多困难。\n由于这种历史的特殊性，对它们的研究具有非凡的意义：对中央苏区反“围剿”这样的“红色”历史的解读直接影响着我们现实的秩序的建立。对于我们当今国家，如何评价反“围剿”，牵涉到当前政权的合法性，尤其是当今祖国统一还没有完成。对于反围剿的评价，还会牵涉到毛泽东这一关键政治人物，从而间接地影响当前政治方向的取向。从政治背景来看，主张路线问题，认为坚持执行毛泽东路线的人更左；主张客观条件，认为难以翻盘一般更右；前者更希望掌握正确的政治斗争路线，后者则更注重“柴米油盐”，一般是现实的自由派。\n在我看来，这本书更大的意义在于，就像序言中说到“更多的只想呈现一种面对历史的方式”,它给了我们对于历史研究的一个提醒：要充分意识到历史的复杂性。历史不止于传统意义上的“某人做了什么”的纪传体或编年体，历史也包括地理、经济、社会等等客观情况。面对杂多的史料，面对纷繁的立场，面对篡改的可能，我们更要意识到，历史可能不具有明显的因果关系，我们所有的推断也仅仅是推断，历史除了物质性必然，更大的部分则是巧合。因为历史具有的复杂性，历史不可能被我们完全、完美、客观地认识。但当我们给出结论的时候，还是要谨慎一些。黄道炫在书中如此说：“许多原则性的结论后面，或许都还存留着更多可能出现的丰富细节，历史的弹性常常超乎人们的想象。”\n正因为上面提到的历史的复杂特点，因此对历史的假设是毫无意义的。尤其对于近代史，对于我们身边的历史：世界的节奏越来越快，世界间的人际关系越来越复杂。因此历史一旦被假设，就成为我们的主观假想，就像某位历史学家说过：“一切历史都是思想中的历史”。在我们回望那段红色历史的时候，我们一定要意识到，完全一致的历史不可能重演，那些纷繁复杂的历史的细节并不能被忽略，而是会像一根微小但又顽强扎在历史的路径上的钉子，阻止你将历史拨开它已有的轨道。\n对历史过分的简化往往是许多“历史虚无主义”的来源。正如《戈尔巴乔夫之谜》一书中说：\n“极右报刊所描绘的不是多维的历史，不是成就与错误相互矛盾地交织在一起的历史，而只是阴暗的污点。根据那些文章判断，过去没有一点好东西，我们的父辈和祖辈在这块土地上毫无意义地受折磨，陷入苦海，时代的延续性被切断了……这种不公正的、恶意中伤的、不真实的歪曲报道惊扰和刺激了社会气氛。于是矛头开始对准了共产党、苏共，对准了党的历史(我再说一遍，这是艰难的．然而是光荣的历史)，最终指向了人民，指向人民对历史的怀念。”8\n如果我们对于中央苏区的的历史，乃至更多的红色历史也陷入这样的虚无和偏见，我们国家就会像抽去基石的纪念碑一样轰然倒塌。\n但是历史，尤其是这些与我们密切相关的近代史、革命史应该容许我们辩论。正如欧阳军喜老师在中国近现代史的第一节课提到，历史是集体记忆的建构，历史也是指明未来的步伐。我们学历史，读历史，评历史不是为了用过去来评价现在，而是为了更好地从现在走向未来。这是研究历史的宗旨。或许我们终究无法让历史完全客观，因为它必然要反映一种当前价值观的取向，但正如书中所说，我们的争辩更应该帮助我们“戮力逼近那确定客观的唯一”。\n以上就是我读完这本书的感悟。\n摘录 “政治定性的高屋建瓴后面，被断送的可能是一个个正在具体影响着社会历史的细节。历史离开了细节，总让人想到博物馆那一具具人体谷歌，的确，那是人，但那真的还是人吗？”（P2）\n“历史如世事人生，世事无尽，人力有穷。任何人都不可能事先设计好一 切，成功者的秘诀不在于全知全能，更多的还在于其发现、领悟、把握并适时创造机会的能力。” （P77）\n“值得特别指出的是，虽然当年年轻的中共领导人在艰困局面下，没有表现出驾驭危局的足够能力，导致社会政治危机丛生，但他们并没有试图掩盖问题，也一直在寻求解决的办法，正由于此，作为后人，我们还能从中共留下的文件中体会到当年危机的严重。这种负责任的坦率态度，值得后人予以尊敬。”（P328）\n“赤白对立的发生、延续并不简单是一个政策错误问题，而应有着更深刻的社会政治原因，物质资源和政治资源的纠结与选择，是中共在赤白对立问题上举棋难定的关键。还是那句话，在高歌猛进的革命大潮后面，柴米油盐总是会顽强地显示着它们的存在，革命要从理想和浪漫中向前推进，依然离不开一点一滴的改造之功。”（P351）\n“当我们一路追问，试图去点亮、碰触历史的那些暗角时，常常会不无遗憾地发现，可以照亮的部分是如此有限，而且，就在这照亮的部分中，还有着难以透析的重重光晕。”（P479）\n“革命改变着世界政治版图，改变着国家、社会、家庭、个体，革命尤其是共产革命的张力使这种改变具有为其他政治运动所远远不及的能量，这是革命受到朝圣般欢呼的根由。不过，无论是历史具体情景下的革命实践，还是整体范围内的革命运动，终究还是要受到历史和现实环境的制约。…时时提醒人们革命在令人炫目的张力后面，应有也必有自己的限界。”（P480）\n“极右报刊所描绘的不是多维的历史，不是成就与错误相互矛盾地交织在一起的历史，而只是阴暗的污点。根据那些文章判断，过去没有一点好东西，我们的父辈和祖辈在这块土地上毫无意义地受折磨，陷入苦海，时代的延续性被切断了……这种不公正的、恶意中伤的、不真实的歪曲报道惊扰和刺激了社会气氛。于是矛头开始对准了共产党、苏共，对准了党的历史(我再说一遍，这是艰难的．然而是光荣的历史)，最终指向了人民，指向人民对历史的怀念。”（摘自《戈尔巴乔夫之谜》）\n“在社会现象领域，没有哪种方法比胡乱抽出一些个别实施和玩弄实例更普遍，更站不住脚的了。挑选任何例子是毫不费劲的，但这没有任何意义，或者只有纯粹消极的意义，因为问题完全在于，每一个别情况都有其具体的历史环境。如果从事实的整体上、从他们的联系中去把握事实，那么，事实不仅是“顽强的东西”，而且是绝对确凿的证据。如果不是从整体上、不是从联系中去掌握事实，如果事实是零碎的和随意的挑出来的，那么，它们就只能是一种儿戏，甚至连儿戏也不如。”（列宁：《统计学和社会学》，《列宁全集》第28卷）\n以下均摘自：谢维，回到革命史的实践现场——读黄道炫《张力与限界：中央苏区的革命(1933-1934)》\n我认为，革命史研究者与其研究对象之间的差别不仅是所处时代不同，而且二者之间看问题的视角亦异，研究者采用的是理论视角，研究对象则为实践视角。人们经常讲不要苛求古人。如果不能完成视角转换，恐怕就难以避免苛求。\n研究者可以选择一条单一线索进行论述，即所谓’一以贯之‘；而实践却总是同时面对众多需要解决的问题。在革命中经常同时存在彼此冲突的多重实践目标。 实践中不仅多重目标难以同时达到，而且在客观条件的制约下, 实践者也会顾此失彼，根本无法找到有利无弊的选择方案。\n将意识形态与现实利益对立起来 , 把意识形态视为虚伪的或狂热的宣传说教 , 实际上也就是将 “ 言” 与“ 行” 绝对对立。 区别言与行当然有其道理，不过，从实践角度看意识形态，言与行亦可统一起来使“言”成为“行”的一部分此“以言行事”或“话语实践”。过去很长一段时期，许多人把党史上形成的讲话、文件、总结、汇报升华为放诸四海而皆准的真理；在接下来的时间中，又有许多人将它们视为迷惑对手的政治花招，或者是蒙骗民众的花言巧语。 我以为，如果从以言行事的角度理解意识形态，似可避免对政治话语实践的误解，避免意识形态的神圣化或妖魔化，并可从移情的角度理解那些政治口水及政治结论，它们都是政治实践的需要。既非“英明决策”，亦非“原罪”。\n1933 年的第四次反“围剿”在周恩来、朱德指挥下，首次在红军中运用大兵团伏击战法取得重大胜利。毛泽东曾不吝美言，赞誉其为“空前光荣伟大胜利”，到了 1940 年代中期，他却转而指责当时的中央“用的竭泽而渔的办法，在两年之内便把苏区的力量弄到枯竭的地步，迫使红军不得不退出苏区去另寻出路”。我以为，两种评价的不同用途是其出现巨大反差的重要原因——前者要鼓舞军民士气，后者要开展党内斗争。从这个角度看，当年革命实践者的言说就不仅是要传递信息，而且是要改变周围事态、改变听众，最终甚至改变自己。\n必然性侧重客观条件的决定作用，偶然性强调主观能动性，而实践者却能够戴着客观条件的镣铐跳出别出心裁的各色舞蹈。\n也许可以这样解读陈诚的话：中央苏区的革命既非必然，亦非偶然，而是客观可能性与实践者主观能动性相结合的产物。是中共的实践将潜在可能变为现实。随心所欲的主观主义者只相信偶然性，听天由命的宿命论者只相信必然性，实践论者却相信可能性。实践者不知道结果如何 , 他在“摸着石头过河” ，却不知道所摸到的“石头”是否为过河的最佳路径。然而，只要能过河就行。所以，实践者不会像经济学中的理性人那样做“投人一产出”的量化分析，其选择标准是“可以满意”或“可以接受”。尽管如此，尽管没有把握，但只要存在可能性，革命的实践者依旧会努力将之转变为现实。\n 黄道炫著：《张力与限界：中央苏区的革命1933-1934》，北京：社会科学文献出版社，2011年，250页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 人民网：《中央革命根据地简介》，2019年，http://t.cn/A6tntqnz。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 林强：《中央苏区的范围究竟有多大》，《中共党史研究》,2008年05期，第117-119页，\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 见龙在田：“如果红军取得了第五次反围剿胜利，不需要长征的话，红军将会如何发展?-知乎” https://www.zhihu.com/question/347038697/answer/1653339159 ，2021年。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 黄道炫著：《张力与限界：中央苏区的革命1933-1934》，第3页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 翟清华，郑勃：《1934年中央苏区革命的“张力”真的达到其“限界”了吗?——与黄道炫先生商榷》，《军事历史研究》,2020年第01期，第114-124页。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 臧如月：《第五次反“围剿”失败原因研究综述》，《党史文苑》，2017年02期，第73-77页.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 《戈尔巴乔夫之谜》\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":13,"section":"posts","tags":null,"title":"「读书笔记」张力与限界：中央苏区的革命","uri":"https://blog.chenqiqian.com/posts/reading-note-revolution-chinese-soviet/"},{"content":"一些简短的思考与感悟。\n2021年 3月 不被接受的爱，比恨还要让人痛苦吧。\n一旦想要对抽象的线性结构进行描述，就必须引入基底和坐标，抽象结构也就具象化为数值矩阵。\n因此我们永远无法得知那些抽象。\n或者说，当我们谈论那些抽象结构，那些抽象结构就失去存在。\n抽象结构只能存在于我们的认识之外。\n旁人的坦途/是你的迷墙/琐碎的日常/是我的奢望\n我一无所有/我只剩愁肠/痛浩浩荡荡/靠什么丈量\n你脚下泥泞/我跌跌撞撞/我们走得很慢/怕路不够长\n如果等不来/说好的褒奖/就不要给我/注定破碎的希望\n当花落下/她没有消亡/风捡起了花/吹散她的模样\n消亡的花/被风遗忘/花没有悲伤/也没有回家\n“富田事变”，“查田运动”，“肃反”，想想邓目睹过的这些，再加上后来的大跃进，文化大革命，才明白什么叫：“警惕右，防止‘左’。”\n「有敢偶语诗书者弃市，以古非今者族，吏见知不举者与同罪。所不去者，医药卜筮种树之书。若欲有学法令，以吏为师。」\n就像「人生识字糊涂始」，哲学也一样。\n能健健康康的活着真好。\n“\u0026hellip;劝说统治者消解占有欲与控制欲。”——处理人际关系何尝不是这样？但是人际关系除了占有欲与控制欲，剩下的有什么呢？\n付出？\n果然不记就会忘掉自己曾经的那些想法啊。 ——来自三月的最后一天。\n4月 感觉自己从不是一个感情特别热烈的人，凡是情感都必须委婉、都必须压抑。\n爱情不应该是目的。\n只要热烈 都好过温存\n几经冷漠 也不屑容忍\n铭心刻骨 就要一意孤行\n越是憧憬 越要风雨兼程\n要走多远 才算走进森林\n曾几何时 开始细数生辰\n誓言久藏 怎么滋生残忍\n青涩难免 要被遗憾瓜分\n清风徐来 水波不兴\n哪个剧本 没有分生\n愈想证明 就愈不肯定\n可能完美和完整 不是一回事情\n清风徐来 水波不兴\n顺流而上 海阔天空\n人面桃花 倾国倾城\n与我谈笑风生 那些可遇而不可求的事情\n“考虑到火车参考系没有理由比铁轨参考系特殊\u0026hellip;\u0026hellip;”\n——可惜人世间不是这样。\n“你越研究越发现，坏的人全世界都是，好的人反而是少数。然而，在工程师、物理学家的‘建模’之类的假设中，自然就排除了那些坏的人。”\n——WXF谈数学\n“徐葆耕，清华大学人文社会科学学院原副院长，校学术委员会委员，中文系主任。1937年生于北京，1955年入清华大学水力发电专业学习，1960年从清华水利系毕业留校任教。1981年晋升文学副教授，1990年晋升教授。1981年创作电影剧本《邻居》，1994年因西方文学课程获北京市教学优秀一等奖，次年获北京市优秀教师称号。2010年3月14日6时05分在北京协和医院逝世，享年73岁。笔名达江复、高耘。”\n“就像跳高比赛，你最后一次总是要失败的”\n“（ Riemann 和）它给了你自由，因此也就不好判断——”\n“自由即枷锁。”\n实际上对于那些我们认为是熟知的函数，例如 $e^x$ ，我们到底知道了多少呢？单调性、凸性、周期性、微分方程而已。\nGraph theory is a delightful playground for the exploration of proof techniques in discrete mathematics.\n反思：保持敬畏，自以为简单的反驳就经得起仔细的推敲吗？因此这条路是走不通的。如果要放弃那些解构，就应该放弃的彻底一点。\n“Be a Splay!!!\u0026quot;\n夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。\n长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。\n","description":"","id":14,"section":"","tags":null,"title":"札记","uri":"https://blog.chenqiqian.com/notes/"},{"content":"今天回家了，这学期算是彻底结束了。碎碎念地总结一下吧。\n这个学期在你清，似乎没有什么“上大学”显著的变化感：气候还是一样的气候，地方也熟悉过若干次，身边的人竟都变化不大。说起来，rdfz倒确实是“更像大学的高中”。\n这学期大概和清华园成了“朋友”吧。在许多地方看过清华园的日暮（忽然想起来，日出的时候大多还没起床hhh）。\n见过午，见过夜。\n除了几个教工食堂，基本打卡了校内所有的食堂/楼层，各个图书馆都走过一遍，借书过，自习过。能试的基本都试过了，说来有趣，尝试新鲜的事物甚至可以成为生活最主要的动力。\n学习上呢，不那么尽如人意。这个学期本来就选了不少课，又因为各种原因多出来好几门课，所以就\u0026hellip;\n无论如何，这学期也算是过去了。\n说说上的课吧。\n这学期，数学课是最重的。微积分w，也不过如此嘛（雾）。wxf讲的确实好，但也确实和考试相关度不那么高；期中之后靠刷高微和偷听yp的课感觉自己（基本）学明白了，但是最后考试还是没什么分（原来换头像是没什么用的）。线性代数老师讲课一板一眼，十分认真负责，而我大概总是介于学明白和没学明白的叠加态（一会特明白，一会啥都不会），好在最后考试不是很难；离散老师很好，但架不住课**，于是在期中过后就进入了上课自学的阶段（并且十分后悔，后悔没有早点这么做），然而还是在最后三天学懂的最多（捂脸），考试\u0026hellip;也就那样吧。这学期遇到数学系的老师和助教（尤其是线代~）都很不错，十分感谢有他们。\n程序设计基础的话，当小(gong)教(ju)员(ren)【只是因为今年贵类oier少才轮到我这个菜鸡qaq】确实是很有意思的体验。最开始的时候确实有一段时间会遭遇到很多奇怪的问题（或者之后阴间作业出现的时候），不过渐渐大家好像都学会了编程，也就没什么问题了。课没怎么听，认识（也许还勉强算认识罢）的同学却多了不少，也多了一两个“朋友”，算是工具人的一点回报吧。其实给别人解释问题的时候，自己也得去思考/学习很多，比如了解了一点编译/运行的深层原理。当然，我也深刻意识到自己的语言表达能力是多么的见鬼的差，下次一定改…（哦程设还写了大作业，好像没什么好说的…）\n下一个印象深刻的课大概是写沟吧。写沟选了城市的话题，算是致敬高中选的地理。课确实很有意思，写作理论学习，辩论，集体写作等等有意思的活动。老师也很好，温婉又具有力量。但写起东西来就不是那么轻松，各种地方查文献，读参考书，学习参考文献格式…这门课大概更适合被称作“学术研究入门”。尤其是长文，开题就给自己挖了一个大坑，之后填的十分痛苦…所以劝还没上这门课的同学，写沟千万不要自己为难自己…不过，上了写沟再写其他两门课的5000字论文，就感觉轻松多了（说起来我觉得其他的两篇论文都写的比写沟长文好orz）\n（以上是孩子这学期的写的2000字+的东西orz）\n到这里已经17个学分了。说点水课吧。我曾经理想着，大学的每一门课都要认真学…后来：“有这时间，做点别的课的作业吧。”点名一下“水”课：人文社会科学计算导论：老师上课吹水+下课摸鱼；党的知识概论：从“老师”到同学都明白其性质；信息科学技术概论：交三篇论文的讲座课，能指望它有什么深度；军事理论：开始还认真听，后面管的松了之后就在课上看书了。\n思修也还有点意思。全周上课，还有小组大pre和1500字期末考试，任务量算是挺大。不过也是开始认真，后面就开始划水…不过也交到了新朋友，感觉这课上的值啊（2333 形势与政策课的老师也很不错，讲的东西也很有意思，只不过这个课时间真的很少，感觉也学不到什么。大作业倒是付出了很多的气力，希望分数不要太低吧…\n体育也遇到了一个好老师，课程常规任务结束之后允许我们快乐足球，实在是一周的快乐时光…但是我体育…还是很差…呜呜呜…\n想了一圈最后想到英语课，足以说明它的地位了…又是一个熟人很多的课，读了一本很有意思的书，和很棒的队友做了一次不是粗制滥造的pre…但老师讲的课吧，老师布置的作业吧…就透露着一股你摸我也摸的气息（\n这学期还经常和某同学交流（事实上是我单向吐槽）贵系（类）的课程设置和教学思想，其实经常是我一个人言辞慷慨。放一些暴论在此供大家批判：“程序设计基础就不应该讲算法，算法应该拆出去单独成课”“离散就是一门**课，明年血书换课本吧”“离散不如让数学系的老师来讲”“信概是什么**课，凭什么还能进必修，不如换成计科基”“我觉得应该设’计算机哲学基础’这门课”…年少轻狂，如斯也（\n——————————————————\n这学期没有什么社工活动，主要是单线生活。每天宿舍-食堂-教学楼-图书馆的活动范围，然而仍然每天被ddl追着跑。想要做点学习以外的事情，学点哲学和中文，保持阅读，也都时断时续。说起来挺不甘，但可能能力所限，也就只能这样了吧。\n这学期多了不少认识的人和一些新朋友，当然也有许多人渐渐或突然的不再联系。不过这挺正常的。越来越觉得，人和人之间的陌生才是常态。一个学期，与许多人还没相识就又成为了陌生人；许多或许相识的人，慢慢也就各自离去。有的人或许在你的微信列表里，有的人甚至从头到尾都不会在，给你留下的只有一段或有或无的记忆。这和一场梦又有什么区别呢？\n因此感谢那些曾在我身边，或还在我身边的人的人。\n来你清的这几个月也在学习怎么和人打交道，包括别人，包括自己。学着“委婉语气表坚决”的修辞方法，学着如何在网络上和现实上与别人交流，学着如何去“勇敢”的表现自己，学着如何在压力面前善待自己，学着如何接受至一个充满缺陷的自己，学会在没有做好“充足准备”的情况下做许多事情…在思考如何处理自己的情感，如何和别人更好的相处。当然我很多事情做的可能都不合适，希望各位还愿意和我做朋友，或者至少愿意还“认识”我…\n当然，回顾这几个月，长进最大的当然是自行车技术，都可以骑着车打清华拳第一节了（\n虽然写了很多，难免还是很难说尽这一个学期的得失与经历。宿舍窗外梧桐树上的乌鸦在假期也会每天准时地叫起来罢。但是之后六周，我要听不到它们的声音了。\n对寒假和下个学期也有很多的期待。前几天有人问我目标和理想，我回答的是：“希望好好活着，希望能在世俗意义上成功，也希望能拥有‘人’应有的深度和情怀。”下学期大概就是这样的目标吧。\n","description":"","id":15,"section":"posts","tags":null,"title":"2020秋季学期总结","uri":"https://blog.chenqiqian.com/posts/2020-fall-semester/"},{"content":"今天是2020年12月30日。\n我在2020年的所有事情似乎都可以在今天晚上体面的结束。从明天开始算，下一个 ddl 在 4 天之后，下一场考试在 8 天之后，那都是可以“明年再说”的事情了。\n但，我的2020年，真的到这里就结束了吗？\n不，它永远不会结束。可以说，2020年对我、乃至对世界的影响还远没有到达终点，甚至刚刚展现出它的锋芒；也可以说，我与这世界今后的每一年都将是“2020年”，一样魔幻，一样疯狂。\n2020年，这座因刻满人生百态而无比高耸的石碑，在夕阳中投下许长的影。它将久久地笼罩我们，遮去残阳仅剩的那些暖意。\n凛冬将至。\n（一）  “那么人呐就都不知道，自己就不可以预料。你一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程。”\n 如今再回顾去年此时写下的新年贺词，从无边的不真实感中，我却更加真实地感受到：**世界是如此不可预料。**伊朗、叙利亚仍然很乱、澳洲和加州的山火熊熊燃烧、长江流域的洪水一波又一波、草地贪夜蛾和蝗虫在南亚和中东肆虐、美国大选从过程到结果乱象层出\u0026hellip;\u0026hellip;这些本应能够占领“头条”的“大新闻”，却都在四个字面前败下阵来：“新冠肺炎”。如果说这已经十分魔幻，那么疫情本身的进展就是魔幻的最高境界：中国最终的“八万”确诊在疫情刚开始看起来像是一个“天塌下来”的数字；而今天全球的“八千万”确诊的场面在三月的我们心中更是完全无法想象。在“后疫情时代”，从这个“百年未有的”关键时刻出发，世界会怎么样？经济停滞？饥荒？战争？世界秩序的更替？疫情给世界带来的许多影响，我们无法预见，只能见证。\n是的，不可预料，无法想象。这就是2020年教给我们的最深刻的道理。\n不记得是谁说过：“人唯一害怕的东西就是未知。”从2021年开始，整个世界中的人们，包括我和你和他，都要在或深或浅的恐惧中，一步步前行了。\n凛冬将至？不。凛冬已来。\n（二）  “那个夜晚并不比其他夜晚更冷。\n“我准备了许多柴禾，是准备给这个冬天的。我才三十岁，肯定能走过冬天。\n“从那个夜晚我懂得了隐藏温暖——在凛冽的寒风中，身体中那点温暖正一步步退守到一个隐秘的连我自己都难以找到的深远处。\n“雪越下越大。天彻底黑透了。\n“我围抱着火炉，烤热漫长一生的一个时刻。我知道这一时刻之外，我其余的岁月，我的亲人们的岁月，远在屋外的大雪中，被寒风吹彻。\n 年底这几日北京的风很猛，时时敲打窗棂，钻进衣缝。今天晚上还算安静，坐在桌前回顾整个2020，我发现世界的剧变让我们每个人都无法置身度外，更让我们思考个人作为个体与时代、国家之为整体的关系。\n我和我的2020年，到底如何呢？\n2020年，世界这艘大船在暴风雨中起起伏伏，我的人生也跟着左摇右晃。寒假回家后，再返校竟然已经是春夏之交；春季学期，包括我在内的全国几千万中小学生适应了从来没有经历过的全线上上课；高考史无前例地推迟到了7月举办，我们经历了有史以来最长的高三。健康码成为必备之物，“清华紫荆”深入到校园的每个角落；本应在入学举行的军训，推迟到了第二学期之后；“融合式”教学在全校铺开，某些同学甚至可以在宿舍上早八；现在时近岁末，因为疫情的反弹，我们竟然又被关在学校的大门内。\n2020年，现实的世界与现实的我，更加紧密的贴实到一起。“没有人是一座孤岛。”从高中走进大学是从学校到社会的“我的一小步”，意味着我将慢慢从社会的观察者变成社会的参与者。年初的“疫情”，我是这一值得写入历史教科书的历史事件的亲历者，我们或许是受到它影响最深远的一代人；5月的“后浪”之辩，正是对我们这一代青年阶级固化状况的反思；下半年的热词中，“内卷”代表了我的现在，而“打工人”仿佛就是我们这代人的将来，阶级的分化在我身边生动体现； “学堂路车神”、“清华学姐”等等光怪陆离的网络热点在我们身边爆发，我们就站在舆论的中央。许多之前看起来“遥不可及”、“与我无关”的事情，离我越来越近，在我的生活中越来越真实。\n2020年，也就是这一年，世界给每个人“毒打”，我们的成长在18岁的关键年遭遇了“加速”，这会有什么样的影响呢？这不可预料。不过，历经一年的沧桑，终于能理解一些文章、一些歌词、某一段人事；也更懂得如何分配自己的时间和精力，如何控制自己的感情\u0026hellip;\n这一年，我发现我想要“遗世独立”、“躲进小楼”已无可能。美国大选时，有一句调侃：“大洋彼岸某个国家的总统选举，竟然会影响几年后清华大学学生保研的压力。”我所处的人生阶段，我们国家所处的历史坐标已不允许自顾自怜\u0026hellip;\u0026hellip;\n这一年，我发现我已然站在中国社会意识形态拉锯的前线。走进清华，就像是走进一个中国社会的微缩交卷。繁多而真实的社会问题、分裂的社会意识形态就存在于我每一天的生活视野之中\u0026hellip;\u0026hellip;\n这一年，我发现我已然需要独自面对纷繁错乱的世事。这个冬天并不比其他的冬天更冷，但我之所以感到寒意不散，是因为那些为我御寒的人在慢慢的退场，“一野的寒风吹着我一个人”\u0026hellip;\u0026hellip;\n但正如我在某篇作文中最后写到：\n “安适的小屋外总是风雪连天，但在屋中度过一生只是不切实际的幻想。屋内只有局促的方寸，但走出去，即使路途荆棘遍道，即使我们遍体鳞伤，漫天星河已然在我们的头顶和眼前。\n 即使看过2020年，受过寒风吹彻，我仍将对自己说：“做一朵翻涌的浪花。”\n （三）  “中文男足的意义大抵如此，它教会我们失败，教会我们平庸，教会我们面对现实。但管他呢，谁说18岁的成功不是成功。既然站上过巅峰，还怕什么深渊无穷，退一寸有退一寸的欢喜。”\n 单独就我自己来说，2020年最显著的标识就是理想与现实的矛盾。\n这一年的人生，一直在与现实斗争，与理想斗争。但是有许多想留的人无论如何还是离开了，有许多想去的地方无论如何还是没有去成，有许多想做的事还是没有成为现实\u0026hellip;.虽然也有许多事情办到了，成为所谓的“人生的辉煌”，但它给我带来的代价也一直在拷问我，这样是否真的值得？我们一直在用生命的元气换来物质或精神上的财富，这是人生的应然；但我们现在一天天地用过量的元气来交换到的，到底是什么？这值得吗？\n在高三的时候，我曾经为这种矛盾而深深折磨。但现在，我学着去接受自己在某些方面的平庸，接受自己不过是一个凡人。\n退一寸，也有退一寸的欢喜。\n （四）  “要消除命运的不确定性给人生带来的迷失，就必须超越当下和自我的局限，以长远而坚毅的目光审视自己的内心和未来。”\n 在2020年，目睹了许多的失去与凋零，经历了无数的苦痛和酸楚，也就更知道自己所看重的是什么，自己所珍爱的是什么。把今年的苦难写成对来年的期许，这一年才不是白白过去。\n那么，2021年近在眼前，我要对现在的自己说些什么呢？\n新的一年，我还要继续勇敢地、骄傲地活在这人间。在困难模式全面开启的世界上，勇敢地活着本身就值得骄傲，就值得继续。不求能够获得多高的成绩，不求能够去哪或者不去哪，不求能够做出多大的成就，这些都是所谓的身外之物了。我只求能够平安、健康，我只求能在回顾每一天时，不会发出“假如”的悔声。\n新的一年，我还要继续寻找世界上属于我的独特位置。我的人生会以何种形式于世界上存在？我的人生会如何和家、国、世界相处？我的人生会如何和世界上其他人的人生产生各种各样的关系？既然不愿成为孤岛，右应该如何和其他人相处、和世界相处呢？\n新的一年，我还要继续思考人生之为人的意义。有人给我留下许多的问题。我们作为人类，是如何存在？我们如何认识世界？我们人生的意义又是什么？有些问题或许需要用一生回答，那不如就从今天开始，从2021年开始。\n新的一年，我还要继续坚定自己内心执着的信念。世界有多么不可预料，信念就应该有多坚定。\n当然，希望只是希望。我也知道，世界流转不息，花会枯萎，人会衰老，人与人总会分开。\n所以，2021年的人生仍像2020年一样，是一场对不确定性的探索。总结一下吧：多看、多想，无问。\n （五）  “一生太短，一瞬好长”\n “我和我的xx”是这两年十分流行的的题目。这篇献词是写给自己的，是想记录下来自己在2020年最真切的体会，关于这个世界，关于我自己，关于两者之间比以往都更加密切的联系，留下自己思想的一些痕迹。\n开年疫情时，觉得这一年很漫长，过不完似的；但当新的一年到来的时候，又觉得上一年新年的记忆还都在脑海，真的仿佛还是昨天。等到人生将尽时，大概也会是这样吧。\n无论如何，2021年，世界仍然会用它固有的方式运行着，就像冬天的寒冷不会怀有任何的仁慈。冰凉的冬日，作为有灵的人类，我们更应该相拥取暖。对那些给了我温暖的，无论是我认识还是我不认识的人们，说一句：前行的路上，感谢有你们。看到这篇献词的朋友或陌生人，请把它当作在新的一年里人与人之间传递的第一缕温暖，并收下我诚恳的祝福吧：\n祝你新年平安，新年快乐！\n【完】\n附：2020年新年贺词\n","description":"","id":16,"section":"posts","tags":["新年贺词"],"title":"我和我的2020——给自己的2021年新年献词","uri":"https://blog.chenqiqian.com/posts/2021/"},{"content":" 夏丏尊 叶圣陶著，北京：生活·读书·新知三联书店，2005 年 1 月。\n 在写作与沟通课上读到了《文心》中的一篇文章，给我留下了十分惊艳的印象。摘录一段如下：\n 已是榴花照眼的时节了。大气中充满着温暖，使人卸去了夹衣，只穿着单衫，四肢百骸都感到轻松舒适的快感。这一天是星期日，大文早上起来，并不见谁来找他闲谈，也没有预期的约会\u0026hellip;\u0026hellip;\n早餐过后，他预备做功课了。坐到椅子里，书桌上一本伯伯的线装书吸引住他的注意。这是唐朝司空图的《诗品》\u0026hellip;王先生对一班同学说的话：“研究文章的风格，司空图的《诗品》不妨找来一看。\u0026hellip;\u0026hellip;”\n\u0026hellip;顺次读下去，读到“自然”一品，他又仿佛颇有所悟。“俯拾即是，不取诸邻。俱道适往，着手成春。如逄花开，如瞻岁新。真与不夺，强得易贫。幽人空山，过雨采蘋。薄言情悟，悠悠天钩。”他想作诗、作文而能“俯拾即是”，不去强求，不讲做作，那就是所谓“有什么说什么”，“爱怎么说、该怎么说就怎么说”，真达到“自然”的极点了。这又与漫无节制，信笔乱挥不同。一方面“俯拾即是”，一方面却又“着手成春”，只因为工夫已经成熟，在无所容心之间，自能应节合拍的缘故。所以一篇完成，就像花一般开得异常美好，节令一般来得异常适合。花开和节令迁流看来都是自然不过的事，然而雨露的滋润，土壤的荣养，日月的推移，气候的转换，中间费却造物的几许匠心啊。这便是“真与不夺”；换句话说，必须内里充实，作起诗与文来才能“俯拾即是”，才能“着手成春”。如果内里并不充实，也想信口开河，提笔乱挥，取得“自然”的美名，结果必然不成东西，徒然使自己后悔，供人家嘲笑；这便是“强得易贫”了。\n他把这一点心得玩味了一会，眼光重又注射到书页上，对于“含蓄”一品的“不着一字，尽得风流”；“精神”一品的“明漪绝底，奇花初胎”；“疏野”一品的“倘然适意，岂必有为”；“清奇“品的“神出古异，淡不可收；如月之曙，如气之秋”；“委曲”一品的“似往已回，如幽匪藏；水理漩洑，鹏风翱翔；道不自器，与之圆方”；“形容”一品的“风云变态，花草精神；海之波澜，山之嶙峋；俱似大道，妙契同尘；离形得似，庶几斯人”：他都能深深地领会。他好似神游于文艺的展览会，那些展览品完全脱去形迹，各标精神使他不得不惊叹于文艺界的博大和繁富。\n他想起现代一班作家的作品：朱自清的称得起“缜密”，周作人的可以说“自然”，茅盾的不愧为“洗练”，鲁迅的应号作“劲健”。他又想起古昔文学家的作品：同样是词，而苏辛的与温飞卿的不同，苏辛的“豪放”，而温飞卿的“绮丽”；同样是散文，而司马迁的与陶渊明的不同，司马迁“浑雄”，而陶渊明的“冲淡”。如果把读过的一些散文、诗、词，逐一给它们比拟，这近于什么风格，那近于什么风格，倒也是有味的事情呢。但是他随即想到司空图的二十四品实在也未尝不可增多，不然，何以王先生又曾提及还有人作《续诗品》及《补诗品》呢？既可以增补，当然也不妨减少或者合并。可见二十四品并非绝对的标准，又何能据此来衡量一切的作品。况且，王先生提出的题目原是很宽广的，只说“对于文章的风格作一点研究，写一篇笔记”罢了，并不曾教大家去判别读过的文篇的风格呀。\n 忙里偷闲，花了五六天读完了这本“故事书”，它没有让我失望。\n这本书讲的是“国文”这门科目，也就是我们今天说的“语文”。\n语文该怎么学？这个问题实在太难了。从我自身的经验来看，过去十二年我所经历的语文学习和教学，始终都在回避这么一个问题：我们学的语文应该是什么？我们学语文的目的应该是什么？\n我们的语文科目，演变成了在考场上读-写二元的游戏；我们所面对的不是丰富的文字世界，而是单调的题目组合。我们的语文教学，杂乱而不成章法。可有一位语文教师能够按照教学的规划完整的完成教学？可有一位教师三年以来的讲课内容连起来能成为清晰的、立体的知识体系？可有一位语文教师能够告诉我们，语文到底是什么？这不是教师的问题，而是我们整个语文教学体系和方法论的缺憾。\n我认为，这本书中对于语文这门学科概括的凝练程度，比我们现在的“语文”教材不知道高到哪里去了。你是否有过这样的疑问：如何读书，又如何写成读书笔记？如何写作，又如何修改自己的作品？如何鉴赏，又如何琢磨最抽象的“风格”？如何朗诵，又如何调整自己的语音语调？这本书里用一个个小故事呈现了这些语文学科中的要点，称得上“提纲挈领”。将学科体系化，尤其是像“国文”这样彻头彻尾的人文学科体系化，需要极强的功底，两位大家在这里做到了。\n举一个例子吧，免得被以为是“空谈”：\n 走了几步，枚叔又说：“从前我在学校里教课，一班学生作文，不懂得印象的描写，总是”美丽呀“、”悲痛呀“、”有趣呀“、”可恨呀“，接二连三地写着。我对他们说，这些词语写上一百回也是不相干的，因为它们都是空洞的形容，对于别人没有什么感染力。必须把怎样美丽、怎样悲痛、怎样有趣，怎样可恨用真实的印象描写出来，人家才会感到美丽、悲痛、有趣和可恨。他们依了我的话，相约少用“美丽呀”\u0026hellip;\u0026hellip;这些词语，注重随时随地观察，收得真实的印象，用作描写的材料。后来他们的文字就比较可观了。“\n——十·印象\n 诸如这样的例子数不胜数，相信读到这段文字各位已经对这本书有了一个直观的印象了。\n这本书不是套了一层皮的说教，其中更有人生的意味可以琢磨。小到个人：枚叔的失业，乐华进工厂，两对小情侣的”恋爱“；大到国家：一·二八事件，抗日救亡\u0026hellip;这本书并不建构于“虚空”，而是在某一维的现实中真实存在的。在这样的时代背景下，在这样的人生命运下，用“国文”知识应该做些什么？那些各种各样的文学形式——如“戏剧”、“日记”、“现代诗”，又应该发挥什么样的作用？一定程度上来看，这不仅是语文问题，更是人生的难题。\n还有一点与本书无关的感受：作为一个理工学生，我认为我接受到的人文教育，实在太少。诚然，时代的客观条件使我们必须看重那些有利于选拔，有利于快速发展的学科；但是不是可以慢慢往回调整这种对于立竿见影的“效果”的追捧了了呢？比如对于历史，对于哲学的学习，我认为在整个教育过程中都是大大不够的，虽然确实这些东西对于“建设社会主义”可能没有直接的作用，但这些是一个人，作为之前一切社会历史关系的总和的立身之本。虽然这些人文学科也可能在选拔的压力下变成语文一样的“走过场”，但总比没有好吧\u0026hellip;\n另外的一些摘抄：\n “\u0026hellip;换一句说，高中的国文教材应该是‘历代文学作品选粹’一类的东西“\u0026hellip;“\n”国学是一个异常不妥当的名词。文字学是国学，历代各家的本体论、认识论是国学，《尚书》和《左传》是国学，诗、词、歌、赋也是国学，好比不伦不类的许多人物穿着同一的外衣，算什么意思呢？按照本质归类，成为文字学、哲学、史学、文学，岂不准确、明白？“\n”不知道对待思想、学术不能凭主观的爱憎的，最重要的在能用批判的方法，还它个本来面目。说的明白点，就是要考究出思想、学术和时代、社会的关联；他因何发生，有因何衰落。“\n“文章的组织方法\u0026hellip;就是‘回问自己’四个大字”\n 写读书笔记之前在网上一搜，这本书位列教育部编写的初中生阅读指导书目；而我在大学才读到它，实在非常惭愧。但看到高中段的开头\u0026hellip;\n哦，那没事了\u0026hellip;\n大概他们也没指望学生真的按照这个书单读吧\u0026hellip;\n","description":"","id":17,"section":"posts","tags":["文学"],"title":"「读书笔记」《文心》","uri":"https://blog.chenqiqian.com/posts/reading-note-wenxin/"},{"content":"谨以此份报告记录我第一次（稍微有一点算）正经的开发和第一次开发事故的过程和反省，留作以后（也许有的）开发生活中回看，算是开发的初心和初念吧。\n事故经过 开发目的 2020年11月1日18时43分，游导找到刚加入开发组的我，交给我一份任务：\n 打算做一个男生节小游戏，女生们每人录一段“男生节快乐”，打乱后，同学们猜一个顺序，公众号告诉他猜对了几个人， 然后首次猜对的同学获得奖励🤔\n 开发过程 当日21时33分，提交答案功能初步上线，智能返回一个数字：“答对个数”。\n当日21时58分，加入了查看本次成绩和最好成绩，按照用户id（至少是我当时认为的用户id）阻止频繁提交的功能。\n当日22时16分，加入了查看最好成绩的提交时间的功能。\n其间，还将抽签功能的代码分开到了另一个文件 drawing.py 中，把提交答案功能分开到了 check_name.py\n此时主要代码如下：\ncheck_name.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  def check_list(answer_list, user_list): # 计算匹配个数，返回 -1 代表长度不一致 match_cnt = 0 try: assert len(answer_list) == len(user_list) for i in range(len(answer_list)): if answer_list[i] == user_list[i]: match_cnt += 1 except: match_cnt = -1 return match_cnt def check_name(username, line): grade = check_list(ans, line[1:]) response = \u0026#34;\u0026#34; if grade == -1: response = \u0026#34;没有提交有效答案！\u0026#34; else: now_time = time() result = (time(), username, grade) if result_rank.__contains__(username) and now_time - last_time[username] \u0026lt; 5: response = \u0026#34;您提交的太过频繁，请稍后再试。\u0026#34; else: last_time[username] = now_time result_list.append((now_time, result)) if not result_rank.__contains__(username) or result_rank[username][2] \u0026lt; result[2]: result_rank[username] = result response = \u0026#34;提交成功！您本次的成绩是\u0026#34; + str(grade) + \u0026#34;分。\u0026#34; if result_rank.__contains__(username): response = response + \u0026#34;您目前的最好成绩是\u0026#34; + \\ str(result_rank[username][2]) + \u0026#34;分，\u0026#34; response = response + \u0026#34;提交于\u0026#34; + \\ get_usual_time(result_rank[username][0]) + \u0026#34;。\u0026#34; else: response = response + \u0026#34;您目前还没有有效成绩。\u0026#34; return response   rylzb.py\n1 2 3 4 5 6 7 8 9  if msgType == \u0026#39;text\u0026#39;: msgText = xml.find(\u0026#39;Content\u0026#39;).text line = msgText.split() if line[0] == \u0026#39;抽签\u0026#39;: # 抽签功能 return reply_text(toUser, fromUser, drawing(line)) elif line[0] == \u0026#39;提交答案\u0026#39;: # 提交答案功能 return reply_text(toUser, fromUser, check_name(toUser,line)) else: return reply_text(toUser, fromUser, \u0026#39;你在说什么，我听不懂。\u0026#39;)   2020年11月8日公众号方面的工作准备完毕，于是把 check_name.py 中的 answer_list 替换成女生的人名名单。\n同时增加功能：增加答案不合法类型，如果答案不仅是汉字或答案出现重复，都会返回不合法信息。\n当日20时20分，公众号发布推送，随后用户数据开始出现。\n20时27分44秒，公众号接到第一条提交答案请求。\n20时36分，通过用户反馈和后台log发现程序对于用户“最好成绩”反馈有问题，进一步发现程序对于用户id的识别有问题\n20时37分，在微信群中通知程序出现了bug。此时并未将程序下线。\n20时37-40分，对代码进行修改，将所有用户相关的内容（最好成绩，同一用户提交时间限制）注释掉，只保留了判断正确个数的功能。\n20时41分55秒左右，对原来的程序进行替换。\n20时49分左右，试图查找错误，（我认为，但事实上没有）换用 toUser 变量用作用户 id。没有起效，用户ID仍然全部相同。（因为事实上不同的是 fromUser ，而我以为我用的是 fromUser，但事实上不是）\n20时55分左右，在总共第200次提交的时候，有用户已经正确猜出了14个名字，游戏结束。游戏仅仅进行了28分钟，并且获得答案的方式是通过（部分）试验的方式。\n20时50分-21时10分左右，对于分数反馈进行模糊化处理，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  message = \u0026#34;\u0026#34; if 0 \u0026lt;= grade and grade \u0026lt;= 2 : message = \u0026#34;0~2\u0026#34; elif 2 \u0026lt; grade and grade \u0026lt;= 4: message = \u0026#34;3~4\u0026#34; elif 4 \u0026lt; grade and grade \u0026lt;= 6: message = \u0026#34;5~6\u0026#34; elif 6 \u0026lt; grade and grade \u0026lt;= 8: message = \u0026#34;7~8\u0026#34; elif 8 \u0026lt; grade and grade \u0026lt;= 10: message = \u0026#34;9~10\u0026#34; elif 10 \u0026lt; grade and grade \u0026lt;= 13: message = \u0026#34;11~13\u0026#34; else: message = \u0026#34;14\u0026#34; response = \u0026#34;提交成功！正确\u0026#34; + str(message) + \u0026#34;个。\u0026#34;   21时11分左右，对原来的程序进行替换，\n21时13分左右，发现 toUser 是用户id，对代码进行更改，增添了最佳成绩和提交间隔限制。并替换程序。\n事故原因 直接原因  错误使用了微信提供的数据 fromUser 和 toUser ，导致对用户的识别失效；从而导致不能有效阻止通过短时间试错法得到正确答案； 没有加入更严格的答案反馈系统，在一开始就不返回真正分数，只返回区间；从而导致试错成本太低。  深层原因  在写代码的时候就没有做好写很强判断的准备，导致程序有些先天不足； 对上线后的可能情况思想准备不足，在遇到大量请求的时候脑子有些不太转； 发现bug之后，没有及时撤下出错的程序，而是挂着修改，导致后面想改的时候反而有所顾忌； 测试的时候，只有我一个人测试；没有多人测试（事实上有，但我没有关注具体输出），也就没有发现userid大家都一样的问题。  经验总结  “我向来是不惮以最坏的恶意，来推测用户的，然而我还不料\u0026hellip;\u0026hellip;” 写的时候就把功能写丰富一点，它可以用不到，但不能没有； 应该测试到所有的功能，找多人，多次测试； 应该挑人少的时候上线功能； 不能指望着上线了之后再去补 bug ，务必要保证代码没错再交上去； 发现 bug，立刻下线：用户暂时用不了不要紧，用户搞出点大新闻可就麻烦了； 发现 bug 之后，要冷静一点，冷静的修改和测试； 发现 bug 之后，要积极的与用户沟通，不能自己闷改。  最后 云服务器也不便宜，在上面瞎搞的机会要好好珍惜啊。之后大概不太会有人一年出快好几百块钱送你服务器玩吧。\n每一次开发的机会都要重视啊。开发的时候，面对的不仅是自己，面对的不仅是 OJ 的 Judger，而是许许多多活生生的人，要慎重呐。\n","description":"","id":18,"section":"posts","tags":["后端"],"title":"第一次开发事故报告","uri":"https://blog.chenqiqian.com/posts/first-accident-in-development/"},{"content":"【最新更新：20210309】\n其实现在已经开学一个多月了，但其实在 THU 的生活也才刚刚开始。写些东西来记录最初的生活，还是很有必要的。\n以前也曾想写过这种长篇，但是其实坚持不下来的概率很大，因为自己也不知道到底会写多长。\n 想来也有趣，在 THU 的生活总共也就 50 个月，现在已经过去了 1/50 ；人生总共 1000 个月，现在又过去了 1/1000 。\n但是现在并没有他们即将过去的感觉。\n 写小说要先介绍时间地点人物，写记录大概也要先介绍环境。\n校园 清华很大，也很小。最北边是学生公寓。\n学生公寓 学生公寓大概分为紫荆区和南区。我们住在紫荆一号楼。\ncqq翻遍了自己的手机，发现一张宿舍外景的照片都没有拍过，虽然每天都有很长的时间在宿舍度过，但宿舍却是最不留意的地方。\n从楼号就可以看出，紫荆一号楼大概是紫荆公寓里最老资历的楼了。楼外看上去与其他的楼也没什么区别，楼内的装修处在微妙的界限上，与现在的时代藕断丝连。楼内主要住的是无系，雷系和软院的同学，旁边就是无系的新生和学长。（如果我没搞错的话..？）\n由于疫情原因，现在整栋6层快一千人的宿舍楼只开了一个门，我所在的宿舍在三层，距离楼门的距离也不算远；但问到贵系某人的宿舍就在1层靠近楼门之后\u0026hellip;综上所述，没有比较，就没有内卷。宿舍门口就是卫生间，与洗漱间隔楼梯间相望。本来觉得这并不是很好，但现在觉得其实也还可以，毕竟在宿舍的时间也没多少。\n “要像坟墓一样简洁。”\n 然而，这在宿舍并做不到。上床下桌的布置给每个人一个相对独立的空间，私密性和自由度相对来说算是很不错。\n目前的一个月，还可以保持桌面整洁到可以展开一张人民日报，然而看到学长的寝室的整洁程度，真不知道自己一年过后又会怎么样\u0026hellip;\n说到桌子，就想起来在上大学前，赶着暑假看了不少书（至少比这一个月来看），哲学、逻辑学、经济学、政治学、道德经、中医、数学\u0026hellip;\u0026hellip;在开学之前天真的以为自己能有时间看书，于是就买/带了不少书来到学校，开学第一周甚至还从图书馆里借了闲书，现在才发现根本没有这个时间23333\n于是就有了\u0026hellip;书架的进击.gif\n   0909 0919 1020           我真的是计算机类的学生的吗.jpg\n现在也发现，很多书也只值得泛读，也还有很多书值得记笔记精读。要把握好度，否则啥书都读不完了.jpeg\n说到书，就要说说你清的图书馆了。\n图书馆 忘了在哪节课上听到的故事：\n 某外国大学的代表团参观校园之后，对某世一大的陪同人员说：“你们想要管理好这所学校太简单了，只要每天按时打开图书馆的大门就可以了。”\n 确实。清华的图书馆很多，也很大。老馆、西馆、北馆构成的主馆有两个标准田径场那么大，而美术馆、金融馆、建筑馆、法律馆、文科馆等等分馆散布于学校（远离紫荆公寓区）的各个角落，各有特色。\n图书馆真香。\n          北馆 西馆 法律馆    首先是资源。曾经在高大的书架之间漫步，几乎每个书架都会有那么一两本特别引人注目的书，要么是形制夺目，要么是书名奇特。据说，清华图书馆现在有几百万纸质册书，基本所有因为课程或者其他原因需要的书都可以在图书馆书目里面找到，只是不一定还在架上。之所以上一句话说纸质藏书，是因为图书馆还有很多很多电子资源，包括各种书、教参的电子版，还有各种文献网站的知网，挺不错。\n其次是环境。你清环境本来就不错，图书馆更是“颜值担当”。北馆的下沉广场和邺架轩，西馆的爬山虎，法律馆的绿萝，绿色的活力和棕色的木桌搭配，很有意境。图书馆相比宿舍最好的，就是高层高和开放的空间；高层高营造了不压抑的氛围，开放式的空间让自己不至于学到自闭。虽然宿舍也是人人都在学习，但毕竟在不认识的人面前，那种竞争的沉重也可以放下些。\n从图书馆借了不少书，目前（10.22）还没还回去几本，有几本书大概快需要续借了，有几本书自从借回来就没怎么翻过。很惭愧，一定要保证借过的书都看过！大学如果不读书哪里还是大学生活呢\u0026hellip;\n在你清，图书馆的本质其实是大型插座充足自习室。事实上也的确是的，平均下来我一天大概也能有两三个小时在图书馆，主要就是做作业和预习吧。当然，自习也不是只能在宿舍和图书馆。\n教学楼 教学楼虽然主要用来上课，自然也是自习的好地方。\n 所谓大学者，非有大楼之谓也，有大师之谓也。\n——梅贻琦\n 梅老校长的话对，但拥有世界一流大楼也是成为世界一流大学的必要条件。\n清华的公共教学楼有六座：第一至第五教室楼，第六教学楼。现在，二教和三教正在翻新/维修，我还没有机会使用。四教都是小教室，大一的大课很少有机会用到；一教有几个200人+的教室，可以开思修等全校大课；五教几乎全是180人左右的教室，所以我的许多数学课都放在这里。而六教，既有200人左右的大教室，也有80人的中等教室，还有40人及以下的小教室，教室数量多、类型齐，所以自然就成为我最常活动的地方。线代、写沟、军理、党课，不少课都是在这里上的。\n当然，某些系的系馆和一些其他的建筑也会当做教学楼来用，比如技科楼、明理楼，因为有大教室而成为某些大课的上课地点；而古色古香的清华学堂却不知道为什么成为了我们某节晚课的地点。\n我最喜欢六教。我一年前来到清华，早已说过了。六教给人一种磅礴而精巧的感受：规模宏大，B区最高有9层，6C300的教室有250人+的规模；设计巧妙，C座不同的层高设计给了阶梯教室以更大的自由度，A区三间相邻的阶梯教室，采光却自然而充足，AB座从一层到顶的空间，有助于辨别空间方位，也能够减少层高的压抑。\n有一说一，很多学校只要有这么一栋教学楼，整个学校的教学需求基本上都可以满足了。\n但清华还有一二三四五教。\n我永远喜欢六教！（至少在三教修好之前！）\n   六教A区的仰望 六教C区的远望          你清的教学楼，装备齐全。除了基本的设施，有咖啡机，有打印机，有自动售货机，还有装满了人民日报和光明日报的架子！要说不满意的，椅子确实不太舒服，当然也可能是我的腰不太行吧。\n在教学楼上完半天的课，接下来除了去图书馆和回宿舍，一般就是去食堂吃饭了。\n食堂 说来惭愧，写下这段文字的时候，已经是第二年的三月份了。\n清华园的食堂很多，都以“园”字结尾，据称有 18 个之多，这半年多差不多吃了个遍。\n作为语言艺术家，应该表演一下“报菜名”：桃李紫荆玉树芝兰；听涛观畴清芬丁香；澜园荷园熙春园；寓园融园近春园\u0026hellip;\n眼花缭乱的名字背后，其实餐食也有着很明显的缺点：不够细腻，油盐又太过，是典型的北方餐食风格。平心而论，清华的伙食水平确实也只是一般的层次，说不上多么完美。\n不过，该有的都有：快餐，火锅，披萨，拉面，休闲餐厅，以及每个食堂都有但我却从来没有吃过的麻辣香锅。不过，在食堂就餐从来都是和同学一起吃饭才有意思的，不是吗233333\n吃完饭，总要走走，去操场总不会错的~\n体育  “体育场馆的面积，相当于7个未名湖的大小\u0026hellip;”——招生宣传视频\n 确实。“吾校庄严，四个操场\u0026hellip;”\n清华的体育设施很丰富。室内的有综合体育馆，游泳馆，体育馆，健身房，充气大棚；室外的有东西北紫四个大操场，还有若干足球，棒球 ，篮球（隔壁的同学十分羡慕），网球，橄榄球（紫操？）的场地。正在（03.09）建设中的北体育馆据称会提供冰上运动的场地，cqqqwq也十分期待呢~\n在清华，操场不只是一个运动的场所，更一定程度上是学生活动的中心。以紫操为例，除了体育活动，操场开阔的场地也给许多个人/团体活动提供了场所。晚上八九点来，你或许能见到在草皮上围坐一圈的狼人杀局，你或许能见到三三两两或走或坐的情侣，你或许也能见到坐在矮矮围墙上弹着吉他的“歌手”。当然，跑步的同学在操场上自然还是占据了多数的。\n水木清华 没怎么去过，好像是工字厅后门。\n【上次更新20210309】\n【不想更新了，大概讲讲学校环境就好了】\n","description":"","id":19,"section":"posts","tags":null,"title":"First Days in THU","uri":"https://blog.chenqiqian.com/posts/thudays/"},{"content":" 看昨天的我们走远了 在命运广场中央等待\n那模糊的肩膀 越奔跑越渺小\n曾经并肩往前的伙伴 在举杯祝福后都走散\n只是那个夜晚 我深深的都留藏在心坎\n  凌晨四点的首都国际机场，寂寥且孤单。发动机的轰鸣似乎还在身后回响，许多大小飞机在停机坪上一架架整齐的停放。\n当每个人都拿到行李，沿着笔直而漫长的步道走向停车场；当我走向垂直电梯，所有同行的同学都从视野里消失；当我坐上车的后座，努力四望却只看到钢铁和水泥闪着冰冷的光。\n我于是意识到：我的高中生活，在这里写下了最后的字符。\n八天来，我与这几位同学一起乘坐了八个小时的飞机，六个小时的高铁，跨过大半个中国，只是为了：能够再沉浸在高中的氛围中，哪怕只是再多一天。只要这些熟悉的身影还在我的身边，我的高中时光仿佛也就还在我的心里，在我的面前。\n是啊。在这些可爱的同学身边，我拥有十八年来最充实与幸福的人生。\n我不用小心地掩饰自己的脆弱和疲倦，我不用紧张地约束自己符合世俗的每条规则，我可以表露我真实的感情，我可以游离于陈规旧俗之外。我说，我默，我笑，我哭，我爱，我恨。我可以活出我的自我。\n我们谈笑，我们碰杯；我们攀登，我们漫步。我们一起看星辰与大海，我们一起唱出内心的情思；我们感受温暖的人情与爱，我们交流对世界的认识和看法。\n这是青年人的生力，这是独属于我们这些青年人的生力。\n感谢。\n而这样的日子已经结束，我们要渐行渐远了。有许多想说的话没有说，有许多想做的事没有做。而我们要渐行渐远了。\n我想留住我的高中时光和高中同学，可我们仍然将要且必然要离别。人从来都不是对离别伤悲，而是对于自己的无力而伤悲。我们将要且必然要各奔东西，踏上不同的土地，进入不同的学校，认识不同的人，进入不同的圈子。这之后，我将与多少人几年都再见不了一面？与多少人几年都再说不了一言？与多少曾经的朋友，与多少曾经并肩站立、并肩行走、并肩歌唱、并肩战斗过的人在这里分离，渐渐成为彼此的路人？我虽然想继续拥抱我的同学们，但这些又有什么能够以我的意志为转移呢？就算有，我又该怎么做呢\u0026hellip;\u0026hellip;\n遗憾。\n我能做的，大概就只有把这段时光小心翼翼地打上封条，整齐地放在记忆深处那隐秘的角落，就像之前的十五年时光一样。毕竟，回忆越是甜美便越使人伤怀了。\n车在高速路上飞快奔驰，雾蒙蒙的天际隐约已经发亮。在机场还显得充沛的精力好像一下子被抽离身体，窗外的土地和建筑在视野里渐渐模糊。\n高中真正的最后一天，结束了。\n 我只想要拉住流年\n好好地说声再见\n遗憾感谢都回不去昨天\n","description":"","id":20,"section":"posts","tags":null,"title":"「随笔」毕业游后记","uri":"https://blog.chenqiqian.com/posts/trip-graduation-short/"},{"content":"关于最大公约数的欧几里得算法及其拓展。\n前置知识 整除 定义 对于 $a,b \\in \\mathbb Z$ ，若存在 $q\\in \\mathbb Z$ 使 $a = qb$ 成立，则称 $b$ 整除 $a$ 或 $a$ 被 $b$ 整除，记作 $b\\mid a$ 。\n我们称 $b$ 是 $a$ 的因数， $a$ 是 $b$ 的倍数。\n否则，我们称 $b$ 不整除 $a$ 或 $a$ 不被 $b$ 整除，记作 $b\\nmid a$ 。\n性质  $c\\mid b,b\\mid a \\implies c \\mid a$ $x,y \\in \\mathbb Z, m|a,m|b \\implies m|(ax+by)$  带余数除法 定义 若 $a,b\\in \\mathbb Z,b\u0026gt;0$ ，则存在唯一的 $q,r\\in \\mathbb Z$ ，使\n$$\na = bq+r,0\\leq r \u0026lt; b\n$$\n这里的 $q$ 称作不完全商， $r$ 称为余数。\n取整 定义 $\\lfloor x \\rfloor$ 和 $\\lceil x \\rceil$ 分别代表向下和向上取整。\n性质  在带余除法中，$q = \\lfloor \\frac{a}{b} \\rfloor$. 若$n\\in \\mathbb Z$：$\\lfloor x + n \\rfloor = \\lfloor x \\rfloor + n$ $\\lceil x \\rceil = − \\lfloor −x \\rfloor , − \\lfloor x\\rfloor = − \\lceil −x \\rceil$ $\\lceil \\frac{n}{m} \\rceil = \\lfloor \\frac{n+m-1}{m} \\rfloor$ $round(x) = \\lfloor x+0.5\\rfloor$ $\\lfloor\\frac{\\lfloor x \\rfloor}{n}\\rfloor = \\lfloor \\frac{x}{n}\\rfloor$ $\\lfloor\\frac{n}{\\lfloor x \\rfloor}\\rfloor \\neq \\lfloor \\frac{n}{x}\\rfloor$ $\\lfloor \\sqrt{x}\\rfloor = \\lfloor \\sqrt{\\lfloor x \\rfloor} \\rfloor$ $\\lfloor \\frac{n}{ab} \\rfloor = \\lfloor \\frac{\\lfloor \\frac{n}{a} \\rfloor }{b} \\rfloor$  最大公约数$\\gcd$（greatest common divisor） 定义 最大公约数，即给定两个整数 $a,b$ ，求最大的正整数 $w$，满足 $w$ 整除 $a$ 且 $w$ 整除 $b$ ( $w|a$ 且 $w|b$ ).记作 $\\gcd(a,b) = w$ .\n定义$gcd(0,0) = 0$。\n一些性质  $gcd(a,0) = |a|$ $gcd(a,ka) = |a|,,k \\in \\mathbb Z$ $gcd(a,b) = gcd(b,a)$ $gcd(a,b) = gcd(a,-b)$ $gcd(a,gcd(b,c)) = gcd(gcd(a,b),c)$ 在 $(0,0)$ 到 $(a,b)$（ $a,b \\in \\mathbb Z$ ）的线段上，有 $gcd(a,b)+1$ 个整点（包括两端点）  求法 辗转相除法。\n其本质上是一个递归算法，通过不断递归的方式计算这两个数的最大公约数。\n过程：$gcd(a,b) = gcd(b,a \\bmod b)$\n边界：$gcd(a,0) = a$\n证明 （有限性）\n令 $k$ 表示我们计算的步骤数（从 $0$ 开始计数）。\n每一步的输入是都是前两次计算的非负余数 $r _ {k−1}$ 和 $r _ {k−2}$ 。\n因为余数肯定小于除数，所以 $r _ {k−1}$ 小于 $r _ {k−2}$ 。在第 $k$ 步中，算法计算出满足以下等式的商 $q_k$ 和余数 $r_k$ ：\n$$\nr _ {k−2} = q _ {k} \\times r _ {k−1} + r_k,; \\text{其中}0\\leq r_k\u0026lt;r _ {k-1}\n$$\n此时，$r _ {k-1}$ 和 $r_k$ 就是下一次递归的输入。\n如果把所有式子都列出来，就会是这个样子：\n$$\n\\begin{aligned}{}\na =\u0026amp; q_0 \\times b + r_0\\\nb =\u0026amp; q_1 \\times r_0 + r_1\\\nr_0 =\u0026amp; q_2 \\times r_1 + r_2\\\nr_1 =\u0026amp; q_3 \\times r_2 + r_3\\\n\u0026hellip;\\\nr _ {n-2} =\u0026amp; q_n \\times r _ {n-1} + r_n\\\n\\end{aligned}\n$$\n这里的 $a,b$ 的大小在第一次除法的时候就会调节，所以不必关心，不妨设 $a\u0026gt;b$ 。\n注意到 $a \u0026gt; b \u0026gt; r_1 \u0026gt; r_2 \u0026gt; r_3 \u0026gt; r_4\u0026hellip; \u0026gt; r_n \u0026gt;=0$ ，所以一定能在 $n$ 次递归过后使得递归到边界情形，即 $r_n = 0$ 。\n此时 $r _ {n-1}$ 就是我们求得的 $\\gcd(a,b)$ 。\n（正确性）\n设 $\\gcd(a,b) = g$ ，我们需要证明 $r _ {n-1} = g$ 。\n第一步：\n因为 $r_n = 0$ ，又 $r _ {n-2} = q_n \\times r _ {n-1} + r_n$ ，所以 $r _ {n-2}$ 是 $r _ {n-1}$ 的整数倍。 $r _ {n-3}$ 由整数倍的 $r _ {n-2}$ 和一个 $r _ {n-1}$ 构成，所以 $r _ {n-3}$ 是 $r _ {n-1}$ 的整数倍。同理可得 $a,b$ 都是 $r _ {n-1}$ 的整数倍。\n所以 $r _ {n-1}$ 就是 $a,b$ 的公因数，又 $g$ 是 $a,b$ 的最大公因数，所以 $g \\geq r _ {n-1}$ 。\n第二步：\n因为 $g = gcd(a,b)$ ，令 $a = mg,b = ng$ ，其中 $n,m$ 均为自然数。\n因为 $a = q_0 \\times b + r_0$ ，所以 $r_0 = (m - q_0 \\times n)g$ ，即 $g$ 也为 $r_0$ 的因数。同理下去就可以得到 $g$ 整除 $r_0,r_1,r_2,\u0026hellip;,r _ {n-1}$ 。所以 $g \\leq r _ {n-1}$ 。\n综上可得： $g = r _ {n-1}$ 。\n所以，辗转相除法的正确性可以如上证明。\n实现 直接按照思路实现即可：\n1 2 3 4  template\u0026lt;typename T\u0026gt; T gcd(T a,T b){ return b==0?a:gcd(b,a%b); }   时间复杂度 $O(\\log n)$ ，证明参见 Lamé定理 。\n扩展欧几里得算法（exgcd） 定义 扩展欧几里得算法，即给定两个正整数 $a,b$ ，我们可以在运用欧几里得算法求出 $gcd(a,b)$ 的同时，我们也可以求出 $ax+by = gcd(a,b)$ 的一组整数解 $x_0,y_0$ 。\n其方程所有解为：\n$$\n\\left{\n\\begin{aligned}{}\nx = x_0+\\frac{b}{gcd(a,b)}\\\ny = y_0-\\frac{a}{gcd(a,b)}\n\\end{aligned}\n\\right.\n$$\n一个结论： $ax+by$ 的最小正值 $ax_0+by_0 = gcd(a,b)$\n求法\u0026amp;证明 现在我们要求 $ax+by = gcd(a,b)$ 的一组整数解。\n考虑到欧几里得算法的公式 $gcd(a,b) = gcd(b,a \\bmod b)$\n若有一组 $x',y'$ 使得 $bx'+ (a \\bmod b) y' = gcd(b,a \\bmod b)$\n这个时候我们注意到可以令 $ax+by = bx'+ (a \\bmod b) y'$ .\n因为 $a \\bmod b = a-\\lfloor\\frac{a}{b}\\rfloor b$ ，所以上式可以化为 $ax+by = bx'+(a-\\lfloor\\frac{a}{b}\\rfloor b)y'$ .\n这个时候我们已经知道 $x',y',a,b$ ，未知数有 $x,y$ 。所以这个方程事实上是要么无解要么无数个解。而我们这里只需要一个特解，所以我们把上式整理成为关于 $a,b$ 的恒成立式子，就可以通过 $x',y'$ 解出 $x,y$ 。整理得\n$$\na(x)+b(y) = a(y') + b(x'-\\lfloor\\frac{a}{b}\\rfloor y')\n$$\n可以得到一组特解：$x = y',y = x'-\\lfloor\\frac{a}{b}\\rfloor y'$。所以我们就可以递归求解。\n精简版过程：\n令 $\\text{exgcd}(a,b)$ 为 $ax+by = gcd(a,b)$ 的解 $(x,y)$ 。\n对于 $\\text{exgcd}(a,b)$ ，递归求得 $exgcd(b,a \\bmod b)$ 的解 $(x',y')$ 。\n则 $exgcd(a,b) = (y', x'-\\lfloor\\frac{a}{b}\\rfloor y')$ 。\n边界情况为 $b = 0$ 时，此时方程即为 $ax + 0y = a$ ，返回 $(1,0)$ 即可。\n代码 1 2 3 4 5 6 7  template\u0026lt;typename T\u0026gt; T exgcd(T a,T b,T \u0026amp;x,T \u0026amp;y){ if (!b){x=1,y=0;return a;} T d = exgcd(b,a%b,y,x); y-=(a/b)*x; return d; }   应用   $ax+by=c$ 不定方程\n可以证明，仅当 $gcd(a,b)|c$ 时，该方程有整数解。\n先用扩展欧几里得算法求出 $ax+by = gcd(a,b)$ 的一组整数解，然后将得到的解均乘上 $\\frac{c}{gcd(a,b)}$ 即可。\n  $ax \\equiv c \\pmod b$ 一次同余方程\n转化为 $ax + by = c$ 的一个问题，可以得出有解条件当且仅当 $gcd(a,b)|c$ 。运用上面的方法求解即可。\n  乘法逆元，将 $ax \\equiv 1 \\pmod p$ 转化成 $ax + py = 1$ 解不定方程即可。\n  类欧几里得算法 一种用于求解形似\n$$\n\\sum _ {i = 0}^n{\\lfloor\\frac{ai+b}{c}\\rfloor}\n$$\n的问题的算法。\n过程 首先对 $a,b$ 关于 $c$ 取模，使得 $a,b\u0026lt;c$ 。\n令 $m = \\lfloor\\frac{an+b}{c}\\rfloor$ 。\n此时有：\n$$\n\\sum _ {i = 0}^n{\\lfloor\\frac{ai+b}{c}\\rfloor} \\\n= \\sum _ {j = 0}^{m-1}\\sum _ {i = 0}^n[j \u0026lt; \\lfloor\\frac{ai+b}{c}\\rfloor]\\\n= \\sum _ {j = 0}^{m-1}\\sum _ {i = 0}^n[i \u0026gt; \\lfloor\\frac{cj+c-b-1}{a}\\rfloor]\\\n= \\sum _ {j = 0}^{m-1}n - \\lfloor\\frac{cj+c-b-1}{a}\\rfloor\\\n= nm - \\sum _ {j = 0}^{m-1}\\lfloor\\frac{cj+c-b-1}{a}\\rfloor\n$$\n注意到这个时候 $a,b$ 都是对 $c$ 取模的，所以这个东西很像欧几里得算法，时间复杂度大约也是 $O(\\log n)$ .\n扩展 $$\n\\sum _ {i = 0}^n{{\\lfloor\\frac{ai+b}{c}\\rfloor}^2}\\\n\\sum _ {i = 0}^n{i{\\lfloor\\frac{ai+b}{c}\\rfloor}}\n$$\n","description":"","id":21,"section":"posts","tags":["数学","欧几里得算法","模板","笔记"],"title":"欧几里得算法学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-gcd/"},{"content":"关于基础的多项式概念及计算。\n多项式（概念） 定义 一个以 $x$ 为变量的多项式是一个定义在代数域 $F$ 上的 $A(x)$ ，其可以表示为：\n$$\nA(x) = \\sum _ {j=0}^{n-1} a_jx^j\n$$\n表示 系数表示法 在多项式 $A(x)$ 中，我们称 $\\overrightarrow{a} = (a_0,a_1,a_2,\u0026hellip;,a _ {n-1})$ 为多项式 $A(x)$ 的系数向量。其即为多项式的系数表达。\n点值表示法 我们把互不相同的 $x_0,x_1,\u0026hellip;,x _ {n-1}$ 作为 $x$ 代入多项式，得到 $y_j = A(x_j)$ ，此时我们称 ${(x_0,y_0),(x_1,y_1),\u0026hellip;,(x _ {n-1},y _ {n-1})}$ 为多项式 $A(x)$ 的点值表达。其中所有的 $x_j$ 都互不相同。\n唯一性 对于 $n$ 个点值对组成的集合 ${(x_0,y_0),(x_1,y_1),\u0026hellip;,(x _ {n-1},y _ {n-1})}$ ，可以确定唯一的系数表示法 $\\overrightarrow{a}$ 。这个过程又被称为插值。\n详见：拉格朗日插值法。\n运算 系数表示下 两个多项式 $A(x)$ 和 $B(x)$， $A$ 和 $B$ 的系数表示分别为：\n$$\nA(x) = \\sum _ {j=0}^{n-1} a_jx^j,\\quad\nB(x) = \\sum _ {j=0}^{n-1} b_jx^j\n$$\n加法 若 $C(x) = A(x) + B(x)$ ，那么 $C(x)$ 的系数表示就可以写作：\n$$C(x) = \\sum _ {j=0}^{n-1} (a_j+b_j) x^j$$\n乘法 若 $C(x) = A(x)B(x)$ ，那么 $C(x)$ 的系数表示就可以写作：\n$$C(x) = \\sum _ {j = 0}^{2n-2}c_j x^j$$\n其中：\n$$c_j = \\sum _ {k = 0}^{j} a_k b _ {j-k}$$\n点值表示下 设 $A$ 的点值表达为 ${(x_0,y_0),(x_1,y_1),\u0026hellip;,(x _ {n-1},y _ {n-1})}$ ， $B$ 的点值表达为 ${(x_0,y_0‘),(x_1,y_1’),\u0026hellip;,(x _ {n-1},y _ {n-1}‘)}$ 。\n加法 若 $C(x) = A(x) + B(x)$ ,那么 $C(x)$ 的点值的表达就可以写作：\n$${(x_0,y_0+y_0'),(x_1,y_1+y_1'),\u0026hellip;,(x _ {n-1},y _ {n-1}+y _ {n-1}')}$$\n乘法 这里因为最后乘得的是一个次数界为 $2n$ 的多项式，这里 $A$ 和 $B$ 的点值就都得有 $2n$ 对。\n若 $C(x) = A(x)B(x)$ ，那么 $C(x)$ 的点值的表达就可以写作：\n$${(x_0,y_0y_0'),(x_1,y_1y_1'),\u0026hellip;,(x _ {2n-1},y _ {2n-1}y _ {2n-1}')}$$\n可以发现，点值表示在多项式的运算方面明显具有速度上的优势。\n多项式乘法（快速傅立叶变换） 定义 快速傅里叶变换（Fast Fourier Transform, FFT）是一种可在 $O(n \\log n)$时间内完成的离散傅里叶变换（Discrete Fourier Transform, DFT）算法，在 OI 中的主要应用之一是加速多项式乘法的计算。\n离散傅立叶变换，在这里即指将一个多项式的系数表示法转化为点值表示法的过程。\n前置知识：  复数  过程 首先将多项式的次数界补足成为 $2^n$ ，以方便后续的策略。\n下文提到的点值向量默认为在单位根的 $0$ 到 $n-1$ 次幂处取得。\n下文所有的数均默认在复数域中讨论，包括系数、多项式的值。\n深刻建议读者拿笔和纸把这一部分自己手算进行验证。\nDFT 设多项式 $A(x)$ 系数表达为：\n$$\nA(x) = \\sum _ {j = 0}^{n-1} a_jx^j\n$$\n将 $n$ 次单位根的 $0$ 到 $n - 1$ 次幂，即 $\\omega _n^0,\\omega _n^1,\u0026hellip;\\omega _n^{n-1}$ ，带入多项式的系数表示，所得点值向量 $(y_0,y_1,\u0026hellip;,y _ {n-1})$ 称为其系数向量 $(a_0,a_1,\u0026hellip;,a _ {n-1})$ 的离散傅里叶变换。\n按照朴素算法求得 DFT ，则时间复杂度为 $O(n^2)$ 。\n改进：FFT 由于我们要对问题进行分治处理，所以我们想办法减小这个问题的规模。\n我们根据次数奇偶对 $A(x)$ 的所有项进行分类。即：\n$$\nA(x) = (a_0 + a_2x^2 + \u0026hellip; + a _ {n-2}x^{n-2}) + (a_1x + a_3x^3 + \u0026hellip; + a _ {n-1}x^{n-1})\n$$\n注意到我们如果令：\n$$\nA_0(x) = (a_0 + a_2x + \u0026hellip; + a _ {n-2}x^{\\frac{n}{2}-1})\\\nA_1(x) = (a_1 + a_3x + \u0026hellip; + a _ {n-1}x^{\\frac{n}{2}-1})\n$$\n那么：\n$$\nA(x) = A_0(x^2) + xA_1(x^2)\n$$\n注意到 $A_0$ 和 $A_1$ 都是 $A$ 的子问题，我们试图减小数据范围的同时快速的通过 $A_0$ 和 $A_1$ 得到 $A$ 。\n若 $k\u0026lt;\\frac{n}{2}$ （上半圈），将 $\\omega _ {n}^{k}$ 代入上式得：\n$$\n\\begin{aligned}{}\nA(\\omega _ {n}^{k}) = \u0026amp; A_0(\\omega _ {n}^{2k})+\\omega _ {n}^{k}A_1(\\omega _ {n}^{2k})\\\n= \u0026amp; A_0(\\omega _ {\\frac{n}{2}}^{k})+\\omega _ {n}^{k}A_1(\\omega _ {\\frac{n}{2}}^{k})\n\\end{aligned}\n$$\n同理可得（下半圈的）：\n$$\nA(\\omega _ {n}^{k+\\frac{n}{2}}) = A_0(\\omega _ {\\frac{n}{2}}^{k})-\\omega _ {n}^{k}A_1(\\omega _ {\\frac{n}{2}}^{k})\n$$\n所以我们注意到我们只需要知道 $A_0(x)$ 和 $A_1(x)$ 在 $\\omega _ {\\frac{n}{2}}^{0},\\omega _ {\\frac{n}{2}}^{1},\u0026hellip;,\\omega _ {\\frac{n}{2}}^{\\frac{n}{2}-1}$ ，的值，然后就可以 $O(n)$ 的求得 $A(x)$ 在 $\\omega _ {n}^{0},\\omega _ {n}^{1},\u0026hellip;,\\omega _ {n}^{n-1}$ 的值，也就用 FFT 完成了我们的 DFT 过程。\n求 $A_0(x)$ 和 $A_1(x)$ 的过程完全是一个设定好系数向量 $(a_0,a_2,\u0026hellip;,a _ {n-2})$ 或者 $(a_1,a_3,\u0026hellip;,a _ {n-1})$ 就可以直接递归的一个子问题，而且每次递归过程所花的时间就是只与当前数据范围有关的 $O(n)$ 。\n总时间复杂度是 $O(n \\log n)$ 。\nIDFT 将多项式在$n$ 次单位根的 $0$ 到 $n - 1$ 次幂，即$\\omega _n^0,\\omega _n^1,\u0026hellip;\\omega _n^{n-1} $处点值向量$(y_0,y_1,\u0026hellip;,y _ {n-1})$通过插值等办法转换为唯一的多项式系数向量$(a_0,a_1,\u0026hellip;,a _ {n-1})$的过程称为离散傅里叶逆变换（IDFT）。\n如果运用拉格朗日插值去直接求得的话，时间复杂度是$O(n^2)$。\n改进：FFT 我们通过一系列的推导后会发现仍然可以使用上面已经定义好的使用 FFT 优化的 DFT 来完成这里的 IDFT 。\n因为 DFT 求的是从系数到点值，所以我们需要假装这里有一个多项式 $B(x)$ ，然后把它转化成点值，寻找其与原来多项式的系数的关系。\n令\n$$\nB(x) = \\sum _ {j = 0}^{n-1} y_jx^j\n$$\n令其经过一次离散傅立叶变换之后得到在单位根的 $0$ 到 $n-1$ 次幂的共轭复数，即 $B(x)$ 在 $w_n^{0},w_n^{-1},\u0026hellip;,w_n^{-(n-1)}$ 处的点值向量为 $(c_0,c_1,\u0026hellip;,c _ {n-1})$ ，其中：\n$$\nc_k = \\sum _ {i=0}^{n-1} y_i (\\omega_n^{-k})^i\n$$\n由于\n$$\ny_i = \\sum _ {j = 0}^{n-1} a_j(\\omega_n^i)^j\n= \\sum _ {j = 0}^{n-1} a_j(\\omega_n^j)^i\\\n$$\n代入之后得：\n$$\nc_k = \\sum _ {i=0}^{n-1} (\\sum _ {j=0}^{n-1} a_j(\\omega_n^j)^i) (\\omega_n^{-k})^i\\\n= \\sum _ {j=0}^{n-1} a_j(\\sum _ {i=0}^{n-1} (\\omega_n^{j-k})^i) \\\n$$\n令\n$$\nS(x) = \\sum _ {i=0}^{n-1}x^i\n$$\n则有如下结论（可以通过复数单位根的性质自行证明）:\n$$\nS(\\omega_n^k)=\n\\begin{cases}\n0,\u0026amp; k\\neq 0\\\nn,\u0026amp; k=0\n\\end{cases}\n$$\n则在上上上式可以写作：\n$$\nc_k = \\sum _ {j=0}^{n-1} a_jS(\\omega_n^{j-k}) \\\n$$\n当$j = k$时，$S(\\omega_n^{j-k})$为$n$，否则该项为$0$。\n所以可以得到结果：\n$$\nc_k = na_k\n$$\n所以简略总结一下$IDFT$：\n设多项式\n$$\nA(x) = \\sum _ {j = 0}^{n-1} a_jx^j\n$$\n经过一次离散傅立叶变换之后在 $n$ 次单位根的 $0$ 到 $n - 1$ 次幂，即 $\\omega _n^0,\\omega _n^1,\u0026hellip;\\omega _n^{n-1}$ 处的点值向量为 $(y_0,y_1,\u0026hellip;,y _ {n-1})$ 。\n则如果将 $(y_0,y_1,\u0026hellip;,y _ {n-1})$ 当作系数再一次进行离散傅立叶变换，其在 $n$ 次单位根的 $0$ 到 $n - 1$ 次幂的共轭复数，即 $\\omega _n^0,\\omega _n^{-1},\u0026hellip;\\omega _n^{-(n-1)}$ 处的点值向量为 $(c_0,c_1,\u0026hellip;,c _ {n-1})$ 。\n那么这个时候， $a_k = \\frac{c_k}{n}$ 。\n一种高效的迭代实现 以上的$FFT$的过程是递归的，所以效率不高。\n而我们通过对递归计算顺序的归纳之后，可以发现如下规律：\n最下层从左到右的数及其二进制表示为：$0(000),4(100),2(010),6(110),1(001),5(101),3(011),7(111)$\n可以发现，每个位置上的计算顺序恰好是原来数字的二进制反转。而对于这 $n$ 个数的二进制数反转可以通过如下算法在 $O(n)$ 的时间完成。\n利用一个类似 dp 的思想，用 $rev[i]$ 代表对 $i$ 进行二进制翻转之后的结果，那么这个时候我们有如下的结论：\n1  rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i\u0026amp;1) \u0026lt;\u0026lt; (len-1));   参考：FFT中的二进制翻转问题 | GGN_2015的博客\n\n所以我们可以按照这个树的顺序，从下到上，从左到右，依次计算对应的 DFT 点值。然后用$O(len)$ 的时间合并。\n注意到这个递归树一共有 $\\log n$ 层，每层的长度都是 $n$ ，所以时间复杂度仍然是 $O(n\\log n)$ 。\n具体来说，大概就是：\n开始的时候，数组里每个位置放的都是这个位置的点值，因为在 $n = 1$ 并没有变量 $x$ 。\n这个时候再进行向上的合并。处理到从下往上数的第 $i(i\\in[0,log_2 n])$ 层，那么这个时候我们需要处理的点值个数就是 $2^{i}$ 个。\n如果把当前正在处理的是 $A(\\omega_n^k)$ 。在处理之前，我们假设在这 $2^{i}$ 的区间的左边 $2^{i-1}$ 个元素依次放置的是 $A_0(\\omega _ {\\frac{n}{2}}^{k})$ ，右侧依次放置的是 $A_1(\\omega _ {\\frac{n}{2}}^{k})$ 。处理之后，我们希望在这 $2^i$ 个位置依次放置的是 $A(\\omega_n^k)$ ，来使我们上面的处理之前的假设成立。\n我们运用上面推导出的公式：\n$$\n\\begin{aligned}{}\nA(\\omega _ {n}^{k}) = \u0026amp; A_0(\\omega _ {\\frac{n}{2}}^{k})+\\omega _ {n}^{k}A_1(\\omega _ {\\frac{n}{2}}^{k})\\\nA(\\omega _ {n}^{k+\\frac{n}{2}}) =\u0026amp; A_0(\\omega _ {\\frac{n}{2}}^{k})-\\omega _ {n}^{k}A_1(\\omega _ {\\frac{n}{2}}^{k})\n\\end{aligned}\n$$\n这个时候 $A_0(\\omega _ {\\frac{n}{2}}^{k})$ 就在当前区间左半边的第 $k$ 个位置上，而 $A_1(\\omega _ {\\frac{n}{2}}^{k})$ 就在区间右半边的第 $k$ 个位置上。\n事实上可以发现 $A_0(\\omega _ {\\frac{n}{2}}^{k})$ 在数组中的位置就是 $A(\\omega _ {n}^{k})$ 在数组中的位置，而 $A_1(\\omega _ {\\frac{n}{2}}^{k})$ 在数组中的位置就是 $A(\\omega _ {n}^{k+\\frac{n}{2}})$ 在数组中的位置。\n所以对于这 $n$ 个点值，它们构成 $\\frac{n}{2}$ 对，互不干扰，我们只需要把这两个位置上的值取出来，经过运算之后再放回去，就可以完成这对位置上点值的合并计算。\n这个过程的形象图解：\n这里的 $y_k^{[0]}$ 就是我们的 $A_0(\\omega _ {\\frac{n}{2}}^k)$ ，$y_k^{[1]}$ 就是我们的 $A_1(\\omega _ {\\frac{n}{2}}^k)$ ， $y_k$ 就是我们的 $A(\\omega_n^k)$ 。\n这种接受两个递归得到的 $A_0$ 和 $A_1$ 值，交叉计算得到 $A$ 的值的操作被称为蝴蝶操作。\n简略概括：\n通过在递归树上从下到上，从左到右的顺序依次递推，每次得到一对更高层的点值，最后递推得到最终要求的 $n$ 个点值。\n代码 这里给出一个快速傅立叶变换模版题的C++代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef complex\u0026lt;double\u0026gt; complex_t; const int MAXN = 2610000; namespace FFT{ const double PI = acos(-1.0); // op == 1 -\u0026gt; DFT, op == -1 -\u0026gt; IDFT void fft(complex_t *P,int n,int op){ // P 传入 n 个系数（复数），op 标记操作  static int r[MAXN];//r[i] 存储 i 反转二进制后得到的数  int len = log2(n);//计算二进制位长度（001 -\u0026gt; len = 3）  for(int i = 0;i \u0026lt; n;i++) r[i] = (r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i\u0026amp;1) \u0026lt;\u0026lt; (len-1)); //递推计算 r[i]  for(int i = 0;i \u0026lt; n;i++)// 交换得到最底层序列  if(i \u0026lt; r[i]) swap(P[i],P[r[i]]); for(int i = 1;i\u0026lt;n;i\u0026lt;\u0026lt;=1){// 计算所有长度为(i\u0026lt;\u0026lt;1)的序列的DFT值  complex_t x(cos(PI/i),op*sin(PI/i));// 该长度下的单位根  for(int j = 0;j\u0026lt;n;j+=(i\u0026lt;\u0026lt;1)){ // 某一个长度为(i\u0026lt;\u0026lt;1)的序列  complex_t y(1,0); // \\omega _ {n}^{0}  for(int k = 0;k\u0026lt;i;k++,y*=x){ // 计算A(\\omgea _ {n}^{k})和A(\\omgea _ {n}^{n/2+k})  complex_t p=P[j+k],q=y*P[j+i+k]; // p = A_0(\\omgea _ {n/2}^{k})  // q = \\omgea _ {n}^{k} * A_1(\\omgea _ {n/2}^{k})  P[j+k] = p+q,P[i+j+k]=p-q; //A(\\omgea _ {n}^{k}) = p+q, A(\\omgea _ {n}^{n/2+k}) = p-q  } } } } } int n,m; complex_t a[MAXN],b[MAXN]; int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); int t; for(int i = 0;i\u0026lt;=n;i++){scanf(\u0026#34;%d\u0026#34;,\u0026amp;t);a[i] = t;} for(int i = 0;i\u0026lt;=m;i++){scanf(\u0026#34;%d\u0026#34;,\u0026amp;t);b[i] = t;} for(m+=n,n=1;n\u0026lt;=m;n\u0026lt;\u0026lt;=1); FFT::fft(a,n,1),FFT::fft(b,n,1);// 对两个多项式进行DFT  for(int i = 0;i\u0026lt;=n;i++) a[i] *= b[i];//点值乘法计算  FFT::fft(a,n,-1); // 对点值进行IDFT  for(int i = 0;i\u0026lt;=m;i++) printf(\u0026#34;%d \u0026#34;,int(a[i].real()/n + 0.5)); return 0; }   快速数论变换(NTT) 跟 $FFT$ 大致（几乎完全）一样，只需要把复数单位根替换成模形如 $a \\times 2^b + 1$ 的质数 $p$，常用质数参见：Misckoo\u0026rsquo;s Blog\n。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14  void ntt(ll *P,int n,int op){ for(int i = 0;i\u0026lt;n;i++) if(i \u0026lt; r[i]) swap(P[i],P[r[i]]); for(int i = 1;i\u0026lt;n;i\u0026lt;\u0026lt;=1){ ll w = pow((op==1?G:INVG),(MOD-1)/(i\u0026lt;\u0026lt;1),MOD); for(int j = 0;j\u0026lt;n;j+=(i\u0026lt;\u0026lt;1)){ ll wn = 1; for(int k = 0;k\u0026lt;i;k++,wn=(wn*w)%MOD){ ll p = P[j+k],q = wn*(P[i+j+k])%MOD; P[j+k] = (p+q)%MOD; P[i+j+k] = ((p-q)%MOD+MOD)%MOD; } } } }   应用 优化计算卷积。\n快速计算形如 $f(i) = \\sum g(j) g(i-j)$ 之类问题。\n参考资料 FFT详解 | GGN-2015的博客 写的很适合初学者\nFFT学习笔记 | Menci\u0026rsquo;s Blog 有详尽的数学公式，但不适合初学的同学看\nMisckoo\u0026rsquo;s Blog 简练，有关于NTT和其应用的简介 质量很高\n多项式除法、取模 给出两个多项式 $A(x),B(x)$ ，次数分别为 $n,m(n \\geq m)$，求满足：\n$$\nA(x) = Q(x)B(x) + R(x)\n$$\n且 $R(x)$ 次数小于 $B(x)$ 的次数。\n原理 多项式（包括生成函数等）中的 $x$ 可以有双重含义：占位符或者一个复变量。\n这里如果当做占位符，我们可以拿 $\\frac{1}{x}$ 代替 $x$ 代入方程，就有：\n$$\nA(\\frac{1}{x}) = Q(\\frac{1}{x})B(\\frac{1}{x}) + R(\\frac{1}{x})\n$$\n同乘 $x^n$ ，得到:\n$$\nx^n A(\\frac{1}{x}) = (x^{n-m}Q(\\frac{1}{x}))(x^m B(\\frac{1}{x})) + x^{n-m+1}(x^{m-1}R(\\frac{1}{x}))\n$$\n我们设（事实上就是把系数反了过来）\n$$\nA'(x) = x^n A(\\frac{1}{x})\\\nB'(x) = x^m B(\\frac{1}{x})\\\nQ'(x) = x^{n-m} Q(\\frac{1}{x})\\\nR'(x) = x^{m-1} R(\\frac{1}{x})\n$$\n那么\n$$\nA'(x) = Q'(x)B'(x) + x^{n-m+1}R'(x)\n$$\n两侧对 $x^{n-m+1}$ 取模得到\n$$\nA'(x) \\equiv Q'(x)B'(x) \\pmod{x^{n-m+1}}\n$$\n$$\nQ'(x) \\equiv \\frac{A'(x)}{B'(x)} \\pmod{x^{n-m+1}}\n$$\n因为 $Q'(x)$ 也就是 $Q(x)$ 的次数正好是 $n-m$ ，刚好全部保留，所以这个地方求出的在模 $x^{n-m+1}$ 意义下的 $Q'(x)$ 就是真正的 $Q'(x)$ 。\n余式 $R$ 就把 $Q$ 和 $B$ 用 NTT 乘回去减掉即可\u0026hellip;\n多项式（求逆） 多项式求逆的目的是：\n给出多项式 $A(x)$ ，求多项式 $B(x)$ ，使得 $A(x) B(x) \\equiv 1 \\pmod{x^n}$ 。系数对某个数 $p$ 取模。\n原理 我们发现，如果我们令 $B'(x)$ 为 $A(x) B'(x) \\equiv 1 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}$ 的解；又有 $A(x)B(x) \\equiv 1 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}$\n两式相减得到： $A(x)(B(x)-B'(x)) \\equiv 0 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}$，我们有 $A(x) \\not\\equiv 0 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}$，所以有 $B(x) - B'(x) \\equiv 0 \\pmod{x^{\\lceil\\frac{n}{2}\\rceil}}$ 。\n这个式子非常特殊，我们可以推出以下的式子： $(B(x)-B'(x))^2 \\equiv 0 \\pmod{x^n}$ 。为什么呢？\n我们注意到， $B(x) - B'(x)$ 在后 $\\lceil\\frac{n}{2}\\rceil$ 项的值都是 $0$ ，那么平方之后想要凑出一个次数小于 $n$ 的项，则必须含有一个次数在 $\\lceil\\frac{n}{2}\\rceil$ 以下的项，显然必须是 $0$ 。\n那么我们就有 $B(x)^2 - 2 B(x)B'(x) + B'(x)^2 \\equiv 0 \\pmod{x^n}$，两边同时乘上 $A(x)$ 就有 $B(x) - 2B'(x) + A(x)B'(x)^2 \\equiv 0 \\pmod{x^n}$ ，移项之后就有最后的答案：$B(x) \\equiv 2B'(x) - A(x)B'(x)^2 \\pmod{x^n}$。\n实现  cal(A,n)  如果 $n = 1$，直接返回该数模 $p$ 意义下的逆元。 如果 $n \u0026gt; 1$，我们计算出 B'(x) = cal(A,ceil(n/2))\n根据 B(x) = B'(x) - A(x)B'(x)^2 并用 $NTT/FFT$ 优化算出 B(x)    代码 递归版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  namespace NTT{ int init(int n);// 初始化 ntt 的各种东西  void ntt(ll *P,int n,int op);// 进行 ntt 变换  // ... } namespace xxx{ ll a[MAXN],b[MAXN],A[MAXN],B[MAXN],r[MAXN]; void work(int n){ if(n == 1) b[0] = inv(a[0],MOD); else{ int s = (n+1)/2;work(s); int t = NTT::init(2*n+2); memset(A,0,sizeof(ll) * t),memcpy(A,a,sizeof(ll) * n); memset(B,0,sizeof(ll) * t),memcpy(B,b,sizeof(ll) * s); NTT::ntt(A,t,1),NTT::ntt(B,t,1); for(int i = 0;i\u0026lt;t;i++) r[i] = (2-A[i]*B[i]%MOD+MOD)*B[i] % MOD; NTT::ntt(r,t,-1); memcpy(b,r,sizeof(ll) * n); } } void getinv(ll *P,int n){ memcpy(a,P,sizeof(ll) * n); work(n); memcpy(P,b,sizeof(ll) * n); } }   ","description":"","id":22,"section":"posts","tags":["数学","多项式","模板","笔记"],"title":"简单多项式学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-poly/"},{"content":"定义一个数字串为“妙”的当且仅当：该串包含某一子序列为 $2017$ ，且不包含子序列 $2016$。\n定义一个数字串的“丑值”为：该串至少删去几个字符，可以使得剩余串变“妙”；如果删去任意多个字符，均无法使该串变“妙”，则该串的“丑值”是 $-1$。\n给定一个长度为 $n$ 的数字串 $s$ 。有 $q$ 次询问，每次询问用 $(l_i,r_i)$ 表示。对于每次询问，回答子串 $s[l_i\u0026hellip;r_i]$ 的“丑值”。\n链接 Codeforces\n题解 我们考虑只有一个询问而且子串是整个字符串的做法。\n我们令 $dp[i][p]$ (其中 $p \\in {0,1,2,3,4}$) 表示使 $p$ 最多恰好匹配到 $2017$ 的第 $p$ 个位置的最小删除代价，那么我们可以写出如下的 dp 转移方程：\n$$\ndp[0][0] = 1,dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = \\infty\\\n\\begin{aligned}\ndp[i][0] = \u0026amp;\\left{\\begin{aligned}\ndp[i-1][0] + 1\u0026amp;, s_i \\in {2}\\\ndp[i-1][0]\u0026amp;, s_i \\not\\in {2}\\\n\\end{aligned}\n\\right.\\\ndp[i][1] = \u0026amp;\\left{\\begin{aligned}\n\\min(dp[i-1][0],dp[i-1][1])\u0026amp;,s_i \\in {2}\\\ndp[i-1][1] + 1\u0026amp;,s_i \\in {0}\\\ndp[i-1][1]\u0026amp;,s_i \\not \\in {2,0}\n\\end{aligned}\\right.\\\ndp[i][2] = \u0026amp;\\left{\\begin{aligned}\n\\min(dp[i-1][1],dp[i-1][2])\u0026amp;,s_i \\in {0}\\\ndp[i-1][2] + 1\u0026amp;,s_i \\in {1}\\\ndp[i-1][2]\u0026amp;,s_i \\not \\in {0,1}\n\\end{aligned}\\right.\\\ndp[i][3] = \u0026amp;\\left{\\begin{aligned}\n\\min(dp[i-1][2],dp[i-1][3])\u0026amp;,s_i \\in {1}\\\ndp[i-1][3] + 1\u0026amp;,s_i \\in {7,6}\\\ndp[i-1][3]\u0026amp;,s_i \\not \\in {1,6,7}\n\\end{aligned}\\right.\\\ndp[i][4] = \u0026amp;\\left{\\begin{aligned}\n\\min(dp[i-1][3],dp[i-1][4])\u0026amp;,s_i \\in {7}\\\ndp[i-1][4] + 1\u0026amp;,s_i \\in {6}\\\ndp[i-1][4]\u0026amp;,s_i \\not \\in {6,7}\n\\end{aligned}\\right.\\\n\\end{aligned}\n$$\n如果我们把一般矩阵的 $(\\mathbb Z, \\cdot,+)$ 变成 $(\\mathbb Z,+,\\min)$ ，因为我们的转移只与这个位置的字符有关，那么我们可以写出状态矩阵 $M_i$ ， 使：\n$$\nM_i\\left[\\begin{matrix}\ndp[i-1][0]\\\ndp[i-1][1]\\\ndp[i-1][2]\\\ndp[i-1][3]\\\ndp[i-1][4]\\\n\\end{matrix}\\right] \\left[\\begin{matrix}\ndp[i][0]\\\ndp[i][1]\\\ndp[i][2]\\\ndp[i][3]\\\ndp[i][4]\\\n\\end{matrix}\\right]\n$$\n  $s_i = 2$ 时：\n$$\nM_i = \\left[\\begin{matrix}{}\n1 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n0 \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0\\\n\\end{matrix}\\right]\n$$\n  $s_i = 0$ 时：\n$$\nM_i = \\left[\\begin{matrix}{}\n0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 1 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 0 \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0\\\n\\end{matrix}\\right]\n$$\n  $s_i = 1$ 时\n$$\nM_i = \\left[\\begin{matrix}{}\n0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 1 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; 0 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0\\\n\\end{matrix}\\right]\n$$\n  $s_i = 7$ 时：\n$$\nM_i = \\left[\\begin{matrix}{}\n0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 1 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; 0\\\n\\end{matrix}\\right]\n$$\n  $s_i = 6$ 时\n$$\nM_i = \\left[\\begin{matrix}{}\n0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 1 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 1\\\n\\end{matrix}\\right]\n$$\n  other\n$$\nM_i = \\left[\\begin{matrix}{}\n0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0 \u0026amp; \\inf\\\n\\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; \\inf \u0026amp; 0\\\n\\end{matrix}\\right]\n$$\n  初始矩阵：\n$$\nD= \\left[\\begin{matrix}\n0\\\n\\inf\\\n\\inf\\\n\\inf\\\n\\inf\\\n\\end{matrix}\\right]\n$$\n对于询问，我们把矩阵扔到线段树上，因为有结合律（什么你问为什么？我也不知道），每次查询线段树即可，注意合并的时候要右边的矩阵在左，左边的矩阵在右做乘法。\n事实上这道题可以支持单点修改的呢（\n时间复杂度：$O(5^2 q \\log n )$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 410000,N = 5; struct Matrix{ int num[N][N]; Matrix(int op = 0){ memset(num,0x3f,sizeof(num)); if(op == 1) for(int i = 0;i\u0026lt;N;i++){ num[i][i] = 0; } } int *operator [] (int n){return num[n];} }; Matrix mul(Matrix \u0026amp;a,Matrix \u0026amp;b){ Matrix ans; for(int i = 0;i\u0026lt;N;i++){ for(int j = 0;j\u0026lt;N;j++){ for(int k = 0;k\u0026lt;N;k++){ ans[i][j] = min(ans[i][j],a[i][k] + b[k][j]); } } } return ans; } Matrix get(int x){ Matrix t(1); if(x == 2) t[0][0] = 1,t[1][0] = 0; if(x == 0) t[1][1] = 1,t[2][1] = 0; if(x == 1) t[2][2] = 1,t[3][2] = 0; if(x == 7) t[3][3] = 1,t[4][3] = 0; if(x == 6) t[4][4] = 1,t[3][3] = 1; return t; } int n,q; char s[MAXN]; namespace Seg{ Matrix sum[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void build(int nown,int l,int r,char *s){ if(l == r) sum[nown] = get(s[l] - \u0026#39;0\u0026#39;); else{ build(lson,l,mid,s),build(rson,mid+1,r,s); sum[nown] = mul(sum[rson],sum[lson]); } } Matrix query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return sum[nown]; } else{ Matrix L(1),R(1); if(ql \u0026lt;= mid) L = query(lson,l,mid,ql,qr); if(qr \u0026gt;= mid+1) R = query(rson,mid+1,r,ql,qr); return mul(R,L); } } } int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;q); scanf(\u0026#34;%s\u0026#34;,s+1); Seg::build(1,1,n,s); for(int i = 1;i\u0026lt;=q;i++){ int l,r; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;l,\u0026amp;r); Matrix ans = Seg::query(1,1,n,l,r); printf(\u0026#34;%d\\n\u0026#34;,ans[4][0] \u0026gt; (r-l+1)?-1:ans[4][0]); } return 0; }   ","description":"","id":23,"section":"posts","tags":["矩阵","线段树","动态规划"],"title":"「CF750E」New Year and Old Subsequence-矩阵+线段树+dp","uri":"https://blog.chenqiqian.com/posts/cf750e/"},{"content":"Emoji Support Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }   Rich Content Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n Math Typesetting We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)  Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\n In this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\nCode Syntax Highlighting Verify the following code blocks render as code blocks and highlight properly.\nMore about tuning syntax highlighting is the Hugo documentation.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line   *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line Makefile CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I. 1 2 3 4 5  CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I.   JSON 1 2 3  {\u0026#34;employees\u0026#34;:[ {\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;}, ]}   Markdown 1 2 3  **bold** *italics* [link](www.example.com)   JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);   CSS 1 2 3  body { background-color: red; }   Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;  int main (void) { printf (\u0026#34;Hello world!\\n\u0026#34;); }   Python 1  print \u0026#34;Hello, world!\u0026#34;   XML 1 2 3 4 5  \u0026lt;employees\u0026gt; \u0026lt;employee\u0026gt; \u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt; \u0026lt;/employee\u0026gt; \u0026lt;/employees\u0026gt;   Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;   Bash 1  echo \u0026#34;Hello World\u0026#34;   PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;  CoffeeScript 1  console.log(“Hello world!”);   C# 1 2 3 4 5 6 7 8  using System; class Program { public static void Main(string[] args) { Console.WriteLine(\u0026#34;Hello, world!\u0026#34;); } }   C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt; main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; }   SQL 1 2  SELECTcolumn_name,column_nameFROMtable_name;  Go 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) }   Ruby 1  puts \u0026#34;Hello, world!\u0026#34;   Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame import javax.swing.JLabel; //Importing class JLabel public class HelloWorld { public static void main(String[] args) { JFrame frame = new JFrame(); //Creating frame  frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame  frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame  frame.pack(); //Setting size to smallest  frame.setLocationRelativeTo(null); //Centering frame  frame.setVisible(true); //Showing frame  } }   Latex Equation 1  \\frac{d}{dx}\\left( \\int _ {0}^{x} f(u)\\,du\\right)=f(x).   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;; const ANSWER = 42; class Car extends Vehicle { constructor(speed, cost) { super(speed); var c = Symbol(\u0026#39;cost\u0026#39;); this[c] = cost; this.intro = `This is a car runs at ${speed}.`; } } for (let num of [1, 2, 3]) { console.log(num + 0b111110111); } function $initHighlight(block, flags) { try { if (block.className.search(/\\bno\\-highlight\\b/) != -1) return processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ var e4x = \u0026lt;div\u0026gt;Example \u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;; } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { // \u0026#34;0 / 2\u0026#34; should not be parsed as regexp  if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } console.log(Array.every(classes, Boolean)); } export $initHighlight;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /********************************************************* * General */ pre[class*=\u0026#34;language-\u0026#34;], code { color: #5c6e74; font-size: 13px; text-shadow: none; font-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; } pre[class*=\u0026#34;language-\u0026#34;]::selection, code::selection { text-shadow: none; background: #b3d4fc; } @media print { pre[class*=\u0026#34;language-\u0026#34;], code { text-shadow: none; } } pre[class*=\u0026#34;language-\u0026#34;] { padding: 1em; margin: .5em 0; overflow: auto; background: #f8f5ec; } :not(pre) \u0026gt; code { padding: .1em .3em; border-radius: .3em; color: #db4c69; background: #f9f2f4; }   Shortcodes Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"77a71ba3bb9ffac7\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  #### Windows section ```javascript console.log('Hello World!'); ``` ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.  #### MacOS section Hello world!  #### Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"641b45df7b75f392\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  Links and references https://blog.chenqiqian.com/posts/about-this-blog/ Click This\nChartjs Test { \u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [{ \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8] }] } } { \u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [ { \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot; }, { \u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;, \u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot; } ] } } Flowchartjs Test st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End|future:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|future st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e JS Sequence Diagram Test Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! Title: Here is a title A-\u0026gt;B: Normal line B--\u0026gt;C: Dashed line C-\u0026gt;\u0026gt;D: Open arrow D--\u0026gt;\u0026gt;A: Dashed open arrow Mermaid Test graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; sequenceDiagram participant Alice participant Bob Alice-\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! graph TD A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u0026lt;\u0026lt;service\u0026gt;\u0026gt; int id size() } stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] pie \u0026quot;Dogs\u0026quot; : 386 \u0026quot;Cats\u0026quot; : 85 \u0026quot;Rats\u0026quot; : 15 Viz Test digraph G { subgraph cluster_0 { style=filled; color=lightgrey; node [style=filled,color=white]; a0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3; label = \u0026quot;process #1\u0026quot;; } subgraph cluster_1 { node [style=filled]; b0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3; label = \u0026quot;process #2\u0026quot;; color=blue } start -\u0026gt; a0; start -\u0026gt; b0; a1 -\u0026gt; b3; b2 -\u0026gt; a3; a3 -\u0026gt; a0; a3 -\u0026gt; end; b3 -\u0026gt; end; start [shape=Mdiamond]; end [shape=Msquare]; } Wavedrom Test failed.\n{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]}, {\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;}, {}, {\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;} ] } ","description":"Hugo and Zzo Features.","id":24,"section":"posts","tags":["test"],"title":"Hugo and Zzo Features","uri":"https://blog.chenqiqian.com/posts/hugo-and-zzo-features/"},{"content":" \u0026ldquo;记录时光与梦想\u0026rdquo;\n 这个小站是我在2017年12月的时候建立的啦。那个时候我刚上高中，刚学OI没多久，看到Menci的博客，觉得很酷，于是自己也搞了一个。\n\u0008几年来，小站成为了我记录生活、学习过程，抒发情思的一个窗口，让我结识了朋友，也让我在OI中有所精进。\n几年来，小站经历了几轮重建，从 hexo 驱动变为 hugo 驱动，主题从 next 到 icarus 到现在的 zzo ，也算是小站的成长吧。\n某书中有：\n To the time to life, rather than to life in time.\n——给时光以生命，而不是给生命以时光。\n 大概就是这个小站之所以存在的目的。\n更多关于我的介绍可以去 About 里面看啦。\n  我仍然在　无人问津的阴雨霉湿之地\n和着雨音　唱着没有听众的歌曲\n人潮仍是　漫无目的地向目的地散去\n忙碌着　无为着　继续\n ","description":"记录时光与梦想","id":25,"section":"posts","tags":null,"title":"关于这个小站的介绍","uri":"https://blog.chenqiqian.com/posts/about-this-blog/"},{"content":"2019年已经过去。2020年已经到来。\n在2019年，我经历了许多。一月广州的惊鸿一瞥，四月首师附的最后一赛，五月清华园里的一缕回味，两年信息学竞赛的学习，在今年落下了帷幕。八月盛夏，紫荆公寓的七天初体验，是高二最后的终止符，也是高三启程的汽笛。九月、十月、十一月、十二月，高三生活的画卷徐徐铺开，充满字迹的五三，逐渐饱满的卷夹和每月一次的大考共同见证了这半年的辛劳与成长。这一年，许多人还在我们身边，许多人也渐渐离我们远去;这一年，也曾欢喜，也曾颓唐。站在新年的路口上回望，过去一年的回忆已然成了刻满里程的石碑，或有平稳不惊，或有起起伏伏，如今看去，其实都似闲云。回首千帆，不过是一段写满了“成长”的经历罢了。\n在2020年，我将面对更多。已然在面前的期末考试是有重大意义的节点;而一模二模高考和九月的大学生活，都是未知的旅程。成人的到来，似乎更标志着人生进入了一个崭新的阶段。从这里开始，人生的道路不再是在有限的分叉中抉择，而是在无穷无尽的可能中寻觅方向。或许路途中会有惊慌，会有迷茫;但请不要忘记你曾吟咏过的诗行:“不管风吹浪打，胜似闲庭信步”。或许路途中也会有欢喜，会有激动;但请不要忘记东坡千年回响的箴言:“只堪妆点浮生梦”。2020年大概只是一个起点，她真正的意义恐怕更在于之后的十年，是真正从“小孩”变成“成人”的十年：脱除稚气，淬炼成金。童年的时光终会离去，从现在开始拥抱那新的社会角色吧——具有完全民事行为能力的成年人。\n抬起头来，向远方看吧。大江澎湃地奔腾，伙伴们正在争流。不要停留，不要回望，驾船出发吧;在我们的前方，人生的朝霞正在天边，闪耀着夺目的光辉。\n","description":"","id":26,"section":"posts","tags":["新年贺词"],"title":"2020年新年贺词","uri":"https://blog.chenqiqian.com/posts/2020/"},{"content":"This is contact page.\n","description":"联系cqqqwq的方式。","id":27,"section":"","tags":null,"title":"Contact","uri":"https://blog.chenqiqian.com/contact/"},{"content":" 高三摸底考试的作文题目是「初心」。\n “我学 OI 的“初心”是什么呢？”初秋的傍晚，我骑着车路过清华大学的门口，这个问题突然出现在我的脑海。\n本来这里写了很多有关我的 OI 生涯的事情，几乎都要写完了。但仔细想想，过去的就过去了，这些回忆也就让它忘却吧，不要再偶尔的牵挂了一思一缕的精力。\n我想，我学 OI 的“初心”可能是：它能给我快乐。做题可以给我快乐。做题都是一种短期回报非常大的事情，而 OI 的知识点多而小的特点让学习的回报也变得十分容易获得。当你或从书上或从网上的博客上学习到一个新的知识点，马上就能把它应用到实践当中，手指的翻飞，黑色背景和白色字体的碰撞让人的心灵得以沉浸在知识的海洋中，而绿色的及时反馈，或是或非的二分回报，从错变成对的激动瞬间，这一切都给了我无比的欢愉。课堂也可以给我愉悦。和几个知心的朋友坐在一起有说有笑，课堂开放的气氛，舒适的环境，我们不像其他竞赛那样在小小的课桌前钻研知识，我们坐在电脑前，眼前心中的境界或许都能高上许多。不像其他竞赛，即使你不是最强的人，你也可以在某些技巧上比别人好，因此所有人都可以站上讲台当其他人的“老师”。我还记得站在讲台上谈笑风生的一个个瞬间，谁又能说，这不是一场成长呢。还有也许是那几个志同的朋友。也许我们现在早已分道扬镳，但两年同学 OI 的情谊，互帮互助的温暖，深夜约CF的静谧，我真的也许一生都不会忘记。或许，这就是支持我能够在这么一条狭窄的独木桥上不断前行的根本动力吧。\n当然不可否认，我学 OI 的“初心”肯定有升学的因素。毕竟 OI 作为五大竞赛之一，在升学上的用处也是非常大的。说来搞笑，初学的时候，我可能曾经还幻想过集训队之类的东西，但后来发现，不过镜花水月而已。第一年的考试或许还可以没有压力，但第二年以来的各种考试或许就会在无形之中给了我很大的压力。但其实说来也搞笑，我考的为数不多的几场试虽然都没怎么考好，但我的心态却是十分的康健。也许我就是这么一个乐天的人吧。话归正传，我也由衷的感谢 OI ，至少让我收获了一个省一，让我能够在自主招生中或有或无的占有那么一点点的优势吧。\n其实本来这篇文章是想回忆一下我的 OI 生涯，但事实上也没有什么好回忆的；除了纪念着不长不短的 OI 生涯，我可能主要还是想给“后之览者”一些教训吧。\n首先，要全身心的投入，“笃前行而勿顾后”；其次，永远不要对自己失去信心，毕竟不到最后的分数出现在大屏幕上，你永远都不会知道你的真正实力如何。\n没有什么可以再说了。\n谨以此文作为我对 OI 最后的纪念。\n","description":"","id":28,"section":"posts","tags":null,"title":"「随笔」初心","uri":"https://blog.chenqiqian.com/posts/essay-first-mind-oi/"},{"content":"GoodBye, OI.\n太长不看版  考的还不错，rk19 退役。\n 说在前面 好好的BJWC就给取消了啊。\nWeek -2 Day1 2019-04-06 第一天，又是熟悉的首师大附中。\n今天充满了锅的味道。\n首先是晚开始了半个小时emm所以本来捉鸡的三个小时时间就变成了两个半小时（虽然后来补了半个小时）\n然后 9:30 打开题\u0026hellip;怎么文件名是 0612.pdf ？？？怎么内容是山东省队集训？？？\n好吧好吧做吧做吧。\nT1 啥啊？矩阵啥玩意？我咋看不懂题？咋没有部分分啊？？？\nT2 啥啊？图和生成树的那一套理论？？？我不会啊？？？咋没有部分分啊？？？\nT3 啥啊？看起来像个类似字符串的 dp ？为什么 lzy 在我旁边写 SA ？？？有部分分？让我推推\u0026hellip;\n推啊推 T3\u0026hellip;好像可以搞出一个 dp，但是好像没法满足第一个要求啊。\n写啊写啊写，推啊推啊推\u0026hellip;一个多小时过去，大概写了个哈希+二分+二分之类的东西；大概跑过了样例\u0026hellip;然后发现是有锅的\u0026hellip;胡乱搞了个贪心上去\u0026hellip;\n看 T1 \u0026hellip;哦我终于看懂了题意\u0026hellip;诶胡乱猜结论\u0026hellip;是不是线性无关就可以少一次操作啊\u0026hellip;那么高斯消元消消消\u0026hellip;又写了个类似线性基的东西拍一拍\u0026hellip;好像精度不太容易出锅\u0026hellip;不管了不管了\u0026hellip;\n这个时候说还可以再写半个小时\u0026hellip;不写了不写了我要吃饭\u0026hellip;\n于是就交了程序去吃饭\u0026hellip;\n饭很好吃。\n饭真的很好吃。\n饭真的超级好吃。\n下午讲题\u0026hellip;\nT1 A掉了，多亏这道题没有爆 0 qaq\n好像全世界都会T2？就是个奇葩构造？好吧\u0026hellip;\nT3 的贪心果然假了，然后获得了 0 分的好成绩\u0026hellip;好歹也想到了正解的一半呢\u0026hellip;也不多给点分数\u0026hellip;\n并列排名 20-49 名 emmm很符合蒟蒻的本质了\u0026hellip;\n讲课讲的是网络流，好像不是很难，也没怎么听。\n下午骑车回家\u0026hellip;不错啊qwq\nDay2 2019-04-07 又是熟悉的首师大附中嗯。\nhyc 同学提前进入了系统被首师大的老师训斥了（并且为了给 hyc 同学下台的机会：“小黄同学在这个屋子里不是第一也是第二名”）\n今天考试 8:30 就开始了考试，题目终于是 BJOI 开头的题目了2333\nT1 啥啊？怎么有地图啊\u0026hellip;下一题\u0026hellip;\nT2 啥啊？怎么又是图和生成树的那一套理论啊？这次还要算数\u0026hellip;下一题\u0026hellip;\nT3 啥啊？怎么又是图论中存在性染色问题啊？？？不会像去年省选那样随便猜个结论就过了吧\u0026hellip;\n先看 T1 吧。我可以预处理一波\u0026hellip;然后变成一个啥问题..？每四个 B 物品必须选一个？？？咋做啊\u0026hellip;怎么就两档 subtask 啊 （40/40+60）\u0026hellip;\n不管了先写个预处理\u0026hellip;想想想写写写 2h 就这么过去了\u0026hellip;我怎么还是不会后面的操作啊\u0026hellip;其间脑补了若干个假的做法\u0026hellip;\n好吧先放着我去想想后面的题\u0026hellip;\nT2 10 分 $k = 0$ 我会233 就是求一个生成树个数嘛\u0026hellip;后面的部分分好像也不是很难\u0026hellip;\n再看看 T3\u0026hellip; 诶？好像有个什么sb性质？？只会必要性不会充分性，那肯定就是了。可以从 $O(2^{2n})$ 优化到 $O(2^n)$ \u0026hellip; 好像可以有 40 分了诶\u0026hellip;打了个大暴力和小暴力拍拍\u0026hellip;嗯过了那这个结论好像是对的\u0026hellip;\n咦？我左边的人怎么 T1 写了 500 行？？？（赛后发现此人 A 掉了此题\u0026hellip;） 咦？我右边的人怎么再看 vim 的文档？？？好吧\u0026hellip;\n诶？T3 好像不需要枚举子图\u0026hellip;就是最大权闭合子图啊\u0026hellip;啊！这个我会！看看表\u0026hellip;还有四十分钟\u0026hellip;没事没事\u0026hellip;\n开始码 dinic \u0026hellip;前几天写了网络流 24 题\u0026hellip; dinic 的板子都快能不看键盘敲出来了\u0026hellip;说到键盘\u0026hellip;我的键盘的 backspace 居然是坏的\u0026hellip;这对于一个手残选手真的是\u0026hellip;\n10 分钟多一点敲完 dinic （我用自己的笔记本可以 7 分钟左右敲完的），建图很 easy ，拍拍拍死活拍不过\u0026hellip;然后猛然发现是要最大权非空闭合子图\u0026hellip;自闭\u0026hellip;把暴力交上去了\u0026hellip;\n嗯。出分倒是没挂分\u0026hellip;\nT1 没学过 2-SAT + 没发现光路可逆\u0026hellip;没办法吧\nT2 神仙数学\u0026hellip;倒是我少看到 30 分暴力 emmm\nT3 为什么枚举必选一个点然后多跑 500 倍次数 dinic 可以过 合着 50 次 dinic 0.04s？？？ ？？？？？我都在正解门口了啊喂\u0026hellip;差点就 100 分了啊\u0026hellip;\n最后 rk30 \u0026hellip;也差不多吧\u0026hellip;\n下午杂题选讲在写周末作业，没听。\nrdfzhyc 和 真正的 hyc 切题都切的很欢乐 orz\nWeek -1 Day1 2019-04-13 大概是有史以来在省里排名最高的一次呢\u0026hellip;\n进场要求换了个键盘，感觉比以前的那个好多了\u0026hellip;\n8:30 开始考试看题。\nT1看起来就是个dp\u0026hellip;emm好像连最小部分分都不会\u0026hellip;\nT2数据范围 $10^5$ 耶！树上的题！耶！看看啊\u0026hellip;诶先写个 20 分 $O(n^2)$ 暴力吧\u0026hellip;大概 10 分钟多大概过了\u0026hellip;\n仔细研究一下\u0026hellip;统计所有路径中满这个东西好像可以点分治，回忆了一波点分治怎么写\u0026hellip;\n然后开始写点分治\u0026hellip;大概写了一个小时写到最后的两个 dfs\u0026hellip;然后发现自己的一个 dfs 假了\u0026hellip;想了想套了一个左偏树上去从下往上合并，然后于是多了一个 $\\log$ \u0026hellip;大概两个小时调过了 T2 \u0026hellip;\n然后看 T3\u0026hellip;T3 的暴力好像非常轻松\u0026hellip; 20 分的 $O(n^3)$ 暴力 5 分钟就写完了\u0026hellip;然后推了推式子发现 $O(n^2)$ 的斜率优化也非常显然\u0026hellip;\n然后忽然想起来\u0026hellip;什么？n 个东西分成 k 份？？？我会 wqs 二分！！！\n打个表发现的确有凸性\u0026hellip;然后写了个 wqs 二分 + 斜率优化\u0026hellip;20分钟就写完了\u0026hellip;对拍拍拍改改改过过过\u0026hellip;\n然后最后还剩下半个多小时\u0026hellip;写了写 T1 的暴力没写完\u0026hellip;\n中午饭还是一如既往的好吃\u0026hellip;\n下午先讲了 COCI 的题目若干，题目是相当的毒瘤呀qaq（我一直在打游戏 \u0026amp; 写数学作业\n然后 3 点多的时候出成绩了\u0026hellip;第三题因为 eps 设大了而挂了 $30$ 分\u0026hellip;\n于是就 rk6 。\n如果省选能这么高的话大概就可以翻盘了吧（\n就算进队了我也不会去 NOI 的\u0026hellip;\nWeek 0 Day1 2019-04-20 正式比赛日。\n今天起的格外的早\u0026hellip;三周没有时间补觉，感觉自己的精力快要被耗尽了\u0026hellip;\n早上八点开始考试。\nT1 看了看。很像一个 AC 自动机上胡逼 dp 。\nT2 看了看。哇。题面好长。它在讲啥呢\u0026hellip;哦好像是个数学题。\nT3 看了看。哇。题面怎么比 T2 还长啊。看着怎么这么像一个乱搞题啊\u0026hellip;仔细看看\u0026hellip;不会告辞\u0026hellip;\n回去推了推 T1 。好像有一个 $O(n^3 \\sqrt n)$ 的显然 dp \u0026hellip;emmm 取个对数就变成了几何平均值了啊。咦？几何平均值\u0026hellip;我会 0/1 分数规划\u0026hellip;脑补了一波开始写写写\u0026hellip;得有几个月没写过 AC 自动机了\u0026hellip;AC自动机错，AC自动机错完 dp 错\u0026hellip; 想+写+调了两个小时终于过了样例\u0026hellip;\n于是看 T2 。啥玩意啊\u0026hellip;只会40分\u0026hellip;写了些 150 行+终于过掉了40分的暴力分\u0026hellip;\n看了看 T3 \u0026hellip;感觉如果写 100 行也就是 10 分\u0026hellip;不写了\u0026hellip;查查 T1 \u0026amp; T2\u0026hellip;\n然后就 13 点比赛结束了\u0026hellip;\n吃饭的时候发现并不怎么好\u0026hellip;我校除了 dmy 没人会做 T2\u0026hellip; hyc 会做 T3 怒刚 4h 过掉大样例然后就没发现 T1 是一个签到题\u0026hellip; jkp 大概跟我打的分是一样多的\u0026hellip;\n吃完饭之后等到快 3 点开始讲题\u0026hellip;我获得了 105 分\u0026hellip; T1 被卡常 TLE 了 20 分\u0026hellip; T2 不知道哪里搞错了 40 -\u0026gt; 25 \u0026hellip;咋一不小心就 rk13 了呢\u0026hellip;\nhyc T3 爆到 30 了\u0026hellip; jkp 被女选手暴打了\u0026hellip;不过还在队线上\u0026hellip;\ndmy 仍然是天下第一\u0026hellip;\n明天 hyc 一定能翻盘的！\njkp 一定能苟住队线的！\n我一定能退役的！\nDay2 2019-04-21 8 点开考。\n今天出了一些小锅\u0026hellip;不过也是在八点开始了。\n开局看 T1 \u0026hellip;咦？好想是个 sb dp？？？ $O(nms) = 2 \\times 10^8$ 常数小能过吧\u0026hellip;100分有了\u0026hellip;\n看 T2 。卧槽？怎么是个物理题？看起来是个无穷等比数列求和，我会啊（\n推了推式子。写了怎么都调不过小样例\u0026hellip;咦？模数是多少？1e9+7？？？我怎么敲成了998244353\u0026hellip;然后过掉了第一个样例\u0026hellip;测第二个三块玻璃的样例又 Wa 了\u0026hellip;仔细想想觉得还要多维护两个东西才能合并\u0026hellip;于是就写了然后过掉了样例扔到一边\u0026hellip;\n写了 T1 的暴力 * 2 然后都跑的飞快（弱智 dp 还调了半个多小时\u0026hellip;）\n然后 10 点多过掉了两个题。\n然后看 T3 。T3 一看就是一个数据结构题，初步把答案确定到平衡树和线段树两个上。然后找性质。\n先转化了一下题目的条件，然后想怎么才能构造一个最优方案。然后大概有了个结论，写了一波过了样例。转化了一下发现好像可以用线段树维护，于是就开始码线段树。也不难写，一个小时左右就写完了（其间还把时间记错慌张了好一会）\u0026hellip;写完过了拍大概是 12:00 左右\u0026hellip;\n吃饭。hyc \u0026amp; jkp都AK了。大概有翻盘的希望。我好像只要不 fst 就有翻盘的希望诶。\n于是出分。开始还想在 300 分那里找到自己，发现第一屏都没有自己于是开始慌张。\n最后发现自己 T3 爆零了\u0026hellip; 200 分 rk30 左右吧\u0026hellip;\n看了看发现自己的 T3 ac \u0026amp; wa 参杂，但是捆绑测试下就爆 0 了\u0026hellip;\n然后想了半天也觉得自己没有写挂，把做法给 hyc 讲了一下\u0026hellip;然后就被 dmy 叉掉了\u0026hellip;（dmy：“这不是我想出来过的一个假结论吗”）\n于是最后大概就是 hyc 和 jkp 都进队了，然后我总评 rk19 光荣退役\u0026hellip;大概标准分上差了 15 分？\n在省选前的那个周五， jkp 曾经想给我讲题，讲的就是 T3 的减弱版本，但被我拒绝了\u0026hellip;如果听了的话，至少能会 47 分的吧\u0026hellip;那么就进队了啊\u0026hellip;但想想如果我这样的菜鸡选手都能进队，这无疑是对那些整天勤奋刷题的神仙选手最大的不公平吧。\n我就不该买那三副扑克牌QAQ\n不过木已沉舟\u0026hellip;进队了倒是麻烦许多\u0026hellip;\n就是不进队就得考期中考试啊\u0026hellip;滚去复习了\u0026hellip;\n结束语 想送给 6 个月前的自己，和所有看到这篇 blog 的人：\n 「可是留存的人总是习惯天真的为离开者感到悲悯，殊不知留存未必是正确的选择。」\n GoodBye, OI.\n","description":"","id":29,"section":"posts","tags":null,"title":"BJOI2019退役记","uri":"https://blog.chenqiqian.com/posts/trip-bjoi2019/"},{"content":"在一个 $5 \\times 5$ 的棋盘上有 $12$ 个白色的骑士和 $12$ 个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑士的走法（它可以走到和它横坐标相差为 $1$ ，纵坐标相差为 $2$ 或者横坐标相差为 $2$ ，纵坐标相差为 $1$ 的格子）移动到空位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步数完成任务。\n链接 Luogu P2324\n题解 IDA*\u0026hellip;\n其实就是\n 设置一个深度限制防止搜索过深\u0026hellip; 设置一个估价函数最优性剪枝\u0026hellip;  看起来是吧\u0026hellip;\n好像 A* 就是用估价函数 + 优先队列优化？\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 8; int n = 5; int t[N][N]; char s[N][N];int a[N][N]; int mv[8][2] = {{1,-2},{1,2},{2,1},{2,-1},{-2,1},{-2,-1},{-1,-2},{-1,2}}; void init(){ for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%s\u0026#34;,s[i]+1); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n;j++){ a[i][j] = s[i][j] == \u0026#39;*\u0026#39;? -1 : s[i][j] - \u0026#39;0\u0026#39;; } } } int maxd = 0; int dfs(int dep,int x,int y,int left,int last){ if(dep + left \u0026gt; maxd + 1) return 0; // 考虑到我们最后一次一定是直接把剩余的格子减小 2，这么说感觉题解大部分是错的  // hack数据：  /* 1 11111 01111 00*11 00001 00000 答案：0 有的题解会输出 “-1” */ if(left == 0) return 1; for(int i = 0;i \u0026lt; 8;i++)if(i != 7 - last){ int nx = x + mv[i][0],ny = y + mv[i][1]; if(nx \u0026lt; 1 || nx \u0026gt; n || ny \u0026lt; 1 || ny \u0026gt; n) continue; int newleft = left; if(a[x][y]==t[x][y]) newleft++; if(a[nx][ny]==t[nx][ny]) newleft++; if(a[x][y]==t[nx][ny]) newleft--; if(a[nx][ny]==t[x][y]) newleft--; swap(a[x][y],a[nx][ny]); if(dfs(dep+1,nx,ny,newleft,i)) return 1; swap(a[x][y],a[nx][ny]); } return 0; } void solve(){ int tx,ty,tleft = 0; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n;j++){ if(a[i][j] != t[i][j]) tleft++; if(a[i][j] == -1) tx = i,ty = j; } } for(maxd = 0;maxd \u0026lt;= 15;maxd++){ if(dfs(0,tx,ty,tleft,-1)) return (void)(printf(\u0026#34;%d\\n\u0026#34;,maxd)); } printf(\u0026#34;-1\\n\u0026#34;); } int main(){ t[1][1]=t[1][2]=t[1][3]=t[1][4]=t[1][5]=t[2][2]=1; t[2][3]=t[2][4]=t[2][5]=t[3][4]=t[3][5]=t[4][5]=1; t[2][1]=t[3][1]=t[3][2]=t[4][1]=t[4][2]=t[4][3]=0; t[4][4]=t[5][1]=t[5][2]=t[5][3]=t[5][4]=t[5][5]=0; t[3][3]=-1; int T;scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ init(),solve(); } return 0; }   ","description":"","id":30,"section":"posts","tags":["搜索"],"title":"「SCOI2005」骑士精神-搜索","uri":"https://blog.chenqiqian.com/posts/scoi2005-knight/"},{"content":"题意过长，概括如下：\n你有 $n$ 种食材，评委 $m$ 个要求，你需要加工这 $n$ 种食材，每种从\u0026quot;汉式（h）\u0026ldquo;或者\u0026quot;满式（m）\u0026ldquo;中选择一种。每个要求用两个形如 $\\text{h} x$ 或者 $\\text{m}x$ （ $x$ 为一个 $1 \\sim n$ 的正整数），意为第 $x$ 道菜需要用用\u0026quot;汉式（h）\u0026ldquo;或者\u0026quot;满式（m）\u0026ldquo;来进行加工，每个要求中的两个条件必须至少满足一个，每种食材最多只能用一种方式来加工。\n请你判断存不存在一个合法的方式。\n链接 Luogu P4171\n题解 如果我们把做满式和汉式看成一个变量的 $0/1$ 取值，我们注意到这个就是个 2-SAT 模型。\n练习模版背诵技巧（\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 11100; struct Edge{ int to,nex; }edge[MAXN*2];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]},fir[a] = ecnt++; } void clear(){ecnt = 2;memset(fir,0,sizeof(fir));} int n,m; int p(int x,int op){return x + op * n;} void add(int i,int a,int j,int b){ addedge(p(i,a^1),p(j,b)),addedge(p(j,b^1),p(i,a)); } int dfn[MAXN],low[MAXN],col[MAXN],cnum,S[MAXN]; void tarjan(int x){ dfn[x] = low[x] = ++dfn[0];S[++S[0]] = x; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dfn[v]) tarjan(v),low[x] = min(low[x],low[v]); else if(!col[v]) low[x] = min(low[x],dfn[v]); } if(low[x] == dfn[x]){ for(++cnum;S[S[0]] != x;--S[0]) col[S[S[0]]] = cnum; col[S[S[0]--]] = cnum; } } bool solve_sat(){ memset(dfn,0,sizeof(dfn)),memset(low,0,sizeof(low)); memset(S,0,sizeof(S)),memset(col,0,sizeof(col)); cnum = 0; for(int i = 1;i \u0026lt;= 2*n;i++) if(!dfn[i]) tarjan(i); for(int i = 1;i\u0026lt;=n;i++) if(col[p(i,0)] == col[p(i,1)]) return 0; return 1; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); char s1[10],s2[10];int x,y; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%s %s\u0026#34;,s1,s2); sscanf(s1+1,\u0026#34;%d\u0026#34;,\u0026amp;x),sscanf(s2+1,\u0026#34;%d\u0026#34;,\u0026amp;y); add(x,s1[0]==\u0026#39;h\u0026#39;,y,s2[0]==\u0026#39;h\u0026#39;); } } int main(){ int T;scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ clear(),init(); printf(solve_sat()?\u0026#34;GOOD\\n\u0026#34;:\u0026#34;BAD\\n\u0026#34;); } return 0; }   ","description":"","id":31,"section":"posts","tags":["图论","2-SAT"],"title":"「JSOI2010」满汉全席-2-SAT","uri":"https://blog.chenqiqian.com/posts/jsoi2010-feast/"},{"content":"若能将无向图 $G=(V, E)$ 画在平面上使得任意两条无重合顶点的边不相交，则称 $G$ 是平面图。判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图，图中存在一个包含所有顶点的环，即存在哈密顿回路。\n链接 Luogu P3209\n题解 我们把哈密顿回路拎出来，剩下的边要么在环外要么在环内，如果两条边同时在环内会导致相交（判定比较啰嗦就不说了），我们就建边约束 $x_i \\oplus x_j = 1$ 即可。\n可以用 2-SAT 模型解决该问题。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 11000; struct Edge{ int to,nex; }edge[MAXN*100];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]},fir[a] = ecnt++; } void clear(){ecnt = 2;memset(fir,0,sizeof(fir));} int n,m; int s[MAXN]; int p(int i,int op){return i + op * m;} void add_xor(int i,int j){// i xor j == 1  addedge(p(i,1),p(j,0)),addedge(p(i,0),p(j,1)); addedge(p(j,0),p(i,1)),addedge(p(j,1),p(i,0)); } int dfn[MAXN],low[MAXN],S[MAXN],col[MAXN],cnum; void tarjan(int x){ dfn[x] = low[x] = ++dfn[0];S[++S[0]] = x; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dfn[v]) tarjan(v),low[x] = min(low[x],low[v]); else if(!col[v]) low[x] = min(low[x],dfn[v]); } if(low[x] == dfn[x]){ for(++cnum;S[S[0]] != x;--S[0]) col[S[S[0]]] = cnum; col[S[S[0]--]] = cnum; } } bool solve_sat(){ memset(dfn,0,sizeof(dfn)),memset(col,0,sizeof(col)); memset(S,0,sizeof(S)),memset(low,0,sizeof(low)); cnum = 0; for(int i = 1;i \u0026lt;= 2 * m;i++) if(!dfn[i]) tarjan(i); for(int i = 1;i \u0026lt;= m;i++) if(col[p(i,0)] == col[p(i,1)]) return 0; return 1; } set\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; Set; int u[MAXN],v[MAXN]; int vis[MAXN],pos[MAXN]; int judge(int i,int j){ if(vis[i] || vis[j]) return 0; if(make_pair(u[i],-v[i]) \u0026gt; make_pair(u[j],-v[j])) swap(i,j); if(v[j] \u0026lt;= v[i] || u[j] \u0026gt;= v[i]) return 0; else return 1; } void init(){ Set.clear(); scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u[i],\u0026amp;v[i]); if(u[i] \u0026gt; v[i]) swap(u[i],v[i]); } for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;s[i]); s[0] = s[n]; for(int i = 1;i\u0026lt;=n;i++){ int u = s[i-1],v = s[i]; if(u \u0026gt; v) swap(u,v); Set.insert(make_pair(u,v)); } for(int i = 1;i\u0026lt;=m;i++) vis[i] = Set.count(make_pair(u[i],v[i])); for(int i = 1;i\u0026lt;=n;i++) pos[s[i]] = i; for(int i = 1;i\u0026lt;=m;i++) { u[i] = pos[u[i]],v[i] = pos[v[i]]; if(u[i] \u0026gt; v[i]) swap(u[i],v[i]); } } void solve(){ if(m \u0026gt; 3 * n - 6) return (void)(printf(\u0026#34;NO\\n\u0026#34;)); for(int i = 1;i \u0026lt;= m;i++){ for(int j = i+1;j \u0026lt;= m;j++){ if(judge(i,j)) add_xor(i,j); } } printf(solve_sat()?\u0026#34;YES\\n\u0026#34;:\u0026#34;NO\\n\u0026#34;); } int main(){ int T;scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ clear(),init(); solve(); } return 0; }   ","description":"","id":32,"section":"posts","tags":["图论","2-SAT"],"title":"「HNOI2010」平面图判定-2-SAT","uri":"https://blog.chenqiqian.com/posts/hnoi2010-planarity/"},{"content":"有一张 $n \\times m$ 的数表，其第 $i$ 行第 $j$ 列（ $1 \\le i \\le n$， $1 \\le j \\le m$ ）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$ ，计算数表中不大于 $a$ 的数之和。\n$1 \\le n,m \\le 10^5$ ， $1 \\le Q \\le 2 \\times 10^4$\n链接 Luogu P3312\n题解 我们把这个东西写成公式：\n$$\n\\sum _ {i=1}^n \\sum _ {j = 1}^m (\\sum _ {d|\\gcd(i,j)} d)[\\sum _ {d|\\gcd(i,j)} d \\le a]\n$$\n不妨令 $n \u0026lt; m$ ，推推式子\u0026hellip;\n$$\n\\sum _ {d=1}^{n} (\\sum _ {k|d} k)[\\sum _ {k|d} k \\le a] \\sum _ {i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i,j) = 1]\n$$\n我们令\n$$\n\\sigma_1(n) = \\sum _ {d|n} d\n$$\n这是一个积性函数。\n那么就是\n$$\n\\sum _ {d=1}^{n} \\sigma_1(d)[\\sigma_1(d) \\le a] \\sum _ {i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i,j) = 1]\n$$\n我们知道：\n$$\n\\sum _ {i=1}^{n} \\sum _ {j=1}^{m} [\\gcd(i,j) = 1]\\\n= \\sum _ {i=1}^{n} \\sum _ {j=1}^{m} \\sum _ {k | \\gcd(i,j)} \\mu(k)\\\n= \\sum _ {k = 1}^n \\mu(k) \\lfloor \\frac{n}{k}\\rfloor \\lfloor \\frac{m}{k}\\rfloor\n$$\n那么代入就是：\n$$\n\\sum _ {d=1}^{n} \\sigma_1(d)[\\sigma_1(d) \\le a] \\sum _ {k = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(k) \\lfloor \\frac{n}{dk}\\rfloor \\lfloor \\frac{m}{dk}\\rfloor\n$$\n我们设 $T = dk$ ，就有：\n$$\n\\sum _ {T = 1}^n \\lfloor \\frac{n}{T}\\rfloor \\lfloor \\frac{m}{T}\\rfloor \\sum _ {d | T} [\\sigma_1(d) \\le a]\\sigma_1(d) \\mu(\\frac{T}{d})\n$$\n令\n$$\nf(T) = \\sum _ {d|T} \\sigma_1(d)[\\sigma_1(d) \\le a]\\mu(\\frac{T}{d})\n$$\n式子就变成：\n$$\n\\sum _ {T = 1}^n \\lfloor \\frac{n}{T}\\rfloor \\lfloor \\frac{m}{T}\\rfloor f(T)\n$$\n我们只要能获得 $f(T)$ 的前缀和，我们就能 $O(\\sqrt n)$ 出解了。\n那么我们怎么对不同的 $a$ 维护这个玩意呢？\n我们考虑把 $a$ 从小到大排序，然后我们只需要处理出改变的 $f$，用一个东西维护前缀和即可。\n我们考虑到加入一个 $\\sigma_0(x) = a+1$ 的 $a$ 会对 $f$ 产生什么影响。有且仅有 $x$ 的倍数会有更改，所以我们直接暴力枚举所有倍数，然后加入到f的前缀和的贡献当中就可以了。因为 $\\frac{n}{1} + \\frac{n}{2} + \\cdots + \\frac{n}{n} = O(n \\log n) $ ，所以最后的复杂度就是 $O(n \\log n + n \\log^2 n + q \\sqrt n \\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; int N = 110000,T; int sig[MAXN],prime[MAXN],mu[MAXN],vis[MAXN],ans[MAXN]; void sieve(int n){ mu[1] = 1; for(int i = 2;i\u0026lt;=n;i++){ if(!vis[i]){ prime[++prime[0]] = i; mu[i] = -1; } for(int j = 1;j \u0026lt;= prime[0] \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n;j++){ vis[i*prime[j]] = 1; if(i % prime[j] == 0){ mu[i*prime[j]] = 0; break; } else mu[i*prime[j]] = -mu[i]; } } for(int i = 1;i\u0026lt;=n;i++) for(int j = i;j\u0026lt;=n;j+=i) sig[j] += i; } struct Node{ int id,n,m,a; }q[MAXN]; bool cmp1(const Node \u0026amp;x,const Node \u0026amp;y){return x.a \u0026lt; y.a;} bool cmp2(const int \u0026amp;a,const int \u0026amp;b){return sig[a] \u0026lt; sig[b];} namespace BIT{// 维护 f 的前缀和  int sumn[MAXN],n; void init(int _n){n = _n;} int lowbit(int x){return x \u0026amp; (-x);} int query(int x){ int ans = 0; while(x \u0026gt;= 1) ans += sumn[x],x -= lowbit(x); return ans; } void modify(int x,int v){ while(x \u0026lt;= n) sumn[x] += v,x += lowbit(x); } } void update(int x){ for(int i = 1;i * x \u0026lt;= N;i++) BIT::modify(i*x,sig[x] * mu[i]); } int calc(int n,int m){ int ans = 0; if(n \u0026gt; m) swap(n,m); for(int l = 1,r;l\u0026lt;=n;l = r+1){ r = min(n/(n/l),m/(m/l)); ans = ans + (n/l) * (m/l) * (BIT::query(r) - BIT::query(l-1)); } return ans; } int main(){ sieve(N),BIT::init(N); scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); q[i] = (Node){i,a,b,c}; } sort(q+1,q+T+1,cmp1); static int t[MAXN]; for(int i = 1;i\u0026lt;=N;i++) t[i] = i; sort(t+1,t+N+1,cmp2); int now = 1; for(int i = 1;i\u0026lt;=T;i++){ while(t[now] \u0026lt;= N \u0026amp;\u0026amp; sig[t[now]] \u0026lt;= q[i].a) update(t[now]),now++; ans[q[i].id] = calc(q[i].n,q[i].m); } for(int i = 1;i\u0026lt;=T;i++) printf(\u0026#34;%d\\n\u0026#34;,ans[i] \u0026amp; 2147483647); return 0; }   ","description":"","id":33,"section":"posts","tags":["数学","数论"],"title":"「SDOI2014」数表-数论","uri":"https://blog.chenqiqian.com/posts/sdoi2014-table/"},{"content":"给定一个 $n$ 个点 $m$ 条边的无向连通图 $G$ 和若干个小集合 $S$，每个小集合包含 $c(1 \\le c \\le 4)$ 条边，对于每个集合，你需要确定将集合中的边删掉后改图是否保持联通。\n集合间的询问相互独立。\n链接 LuoguP5227\n题解 感觉现在有一点能感受到线段树分治的精华了。\n我们考虑到，维护一个无论啥玩意，一个图不断删去一条边之后我们不能知道这个图是否联通；但是如果我们用并查集维护联通性，那么我们可以在 $O(n\\log n)$ 的时间内加边，同时知道这个图是否联通。\n所以我们先将问题转化成类似加边的问题，实则其实是维护每条边的出现的区间。\n我们发现，任意时刻的删边，都会使这个边由一个大区间的出现变成两个小区间的出现，因为总共的删边在 $O(k)$ 量级，所以说我们就会产生 $O(k)$ 个区间，然后我们可以把这些区间撒到线段树上，就有总共 $O(k \\log k)$ 个操作。\n所以我们需要一个可以撤销的并查集？~~我只会可持久化 ，~~但是时间复杂度需要 $O(n \\log n)$ 一下，所以我们考虑想办法删除边即可。\n我们按秩合并，然后记录一下改了哪些，每次撤销即可。\n时间复杂度 ：$O(k \\log k \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 210000; struct Edge{int u,v;}e[MAXN]; int n,m,k,ans[MAXN]; namespace BCJ{ int f[MAXN],d[MAXN],r; pair\u0026lt;int,int\u0026gt; stack[MAXN];int cnt;// 第一个存id，第二个存原来的秩  void init(int n){for(int i = 1;i\u0026lt;=n;i++) f[i] = i,d[i] = 1;} int find(int x){return f[x] == x?x:find(f[x]);} void un(int x,int y){ int fx = find(x),fy = find(y); if(fx == fy) return; r++; if(d[fx] \u0026lt; d[fy]) swap(x,y),swap(fx,fy); stack[++cnt] = make_pair(fy,d[fy]); stack[++cnt] = make_pair(fx,d[fx]); f[fy] = fx; if(d[fy] == d[fx]) d[fx]+=1; } void undo(int lim){//  while(cnt \u0026gt; lim){ int i = cnt,x = stack[i].first,pred = stack[i].second; if(f[x] != x) r--; f[x] = x,d[x] = pred;cnt--; } } } namespace SegTree{ vector\u0026lt;int\u0026gt; v[MAXN\u0026lt;\u0026lt;2]; #define lson (x\u0026lt;\u0026lt;1)  #define rson (x\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void update(int x,int l,int r,int ql,int qr,int val){ if(ql \u0026gt; qr) return; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) v[x].push_back(val); else{ if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,val); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,val); } } void solve(int x,int l,int r,int *ans){ int lim = BCJ::cnt; for(int i = 0;i \u0026lt; int(v[x].size());i++) BCJ::un(e[v[x][i]].u,e[v[x][i]].v); if(l == r) ans[l] = (BCJ::r == n-1); else solve(lson,l,mid,ans),solve(rson,mid+1,r,ans); BCJ::undo(lim); } } void init(){ static int tim[MAXN]; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m);BCJ::init(n); int a,b; for(int i = 1;i\u0026lt;=m;i++) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b),e[i] = (Edge){a,b}; scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); for(int i = 1;i\u0026lt;=k;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); for(int w = 1;w\u0026lt;=a;w++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;b); SegTree::update(1,1,k,tim[b]+1,i-1,b); tim[b] = i; } } for(int i = 1;i\u0026lt;=m;i++) SegTree::update(1,1,k,tim[i]+1,k,i); } void solve(){ SegTree::solve(1,1,k,ans); for(int i = 1;i\u0026lt;=k;i++) printf(ans[i]?\u0026#34;Connected\\n\u0026#34;:\u0026#34;Disconnected\\n\u0026#34;); } int main(){ init(),solve(); return 0; }   ","description":"","id":34,"section":"posts","tags":["数据结构","线段树分治","并查集"],"title":"「AHOI2013」联通图-线段树分治+并查集","uri":"https://blog.chenqiqian.com/posts/ahoi2013-graph/"},{"content":"Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ ~ $n$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市)，保证任意两个城市都可以通过高速公路互达。\nAnihc 国正在筹划「八纵八横」的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在「八纵八横」计划建成之后，将「一带一路」扩展为「一带一路一环」，增加「内陆城市经济环」即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令「内陆城市经济环」的 GDP 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。\n现在 Anihc 在会议上讨论「八纵八横」的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的「八纵八横」的建设计划的方案「内陆城市经济环」的最大是多少。\n初始时，八纵八横计划中不包含任何—条高铁，有以下三种操作：\n  Add x y z ：在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$ ，如果这是第 $k$ 个 Add 操作，则将这条高铁命名为 $k$ 号高铁。\n  Cancel k ：将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。\n  Change k z ：表示将第 $k$ 号高铁的经济影响因子更改为 $z$ ，保证此时 $k$ 号高铁一定存在。\n  链接 LOJ2312\nLuogu P3733\n题解 P.S. 八纵八横赛艇啊！\n没有加边/删边/改权值的话，这个题就是 WC2011 最大 XOR 路径。\n有了修改怎么办？我们对时间分治/分块就会好很多。\n我们考虑对时间建立线段树，那么每条路都会有一个出现的时间区间，我们用线段树的方法把这个区间分到 $\\log Q$ 个节点上。这样总共有 $O(Q \\log Q)$ 个节点上存在一个修改。\n对于线性基的问题，我们考虑在线段树上解决这个问题。在一个长度为 $len$ 的线性基（ bitset 优化）里面插入一个数的复杂度是：$O(\\frac{len^2}{w})$ ，复制一个线性基的代价是 $O(\\frac{len^2}{w})$ 。我们考虑在线段树上dfs（感觉是），然后我们需要维护这个叶子到原点的链上的线性基即可。那么我们一共要复制 $O(Q)$ 次线性基，累计插入 $O(Q \\log Q)$ 次，查询一次的复杂度也是 $O(\\frac{len^2}{w})$ ，所以最后的主要的时间复杂度应该是 $O(Q \\log Q \\frac{len^2}{w})$ 。\n对于环的获得，我们考虑到可以先搞出原图的一个生成树（dfs 即可），然后把所有非树边加进去即可。每次改变一个边，我们都只加入一个环：dis[x]^dis[y]^v ，其实就是生成树上的环。其他的环都可以并出来。\n居然跑的这么快orz\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136  #include \u0026lt;bits/stdc++.h\u0026gt;#define bs bitset\u0026lt;MAXN\u0026gt; using namespace std; const int MAXN = 1500,LOGN = 15; void char_to_bs(char *s,bs \u0026amp;res){ int l = strlen(s);reverse(s,s+l); res.reset(); for(int i = 0;i\u0026lt;l;i++){ if(s[i] == \u0026#39;1\u0026#39;) res[i] = 1; else if(s[i] == \u0026#39;0\u0026#39;) res[i] = 0; else assert(0); } } void bs_to_char(bs \u0026amp;s){int flag = 0; for(int i = MAXN-1;i\u0026gt;=0;i--){ if(s[i] == 1) flag = 1; if(flag) putchar(s[i]+\u0026#39;0\u0026#39;); }if(!flag) putchar(\u0026#39;0\u0026#39;); } struct LB{ bs basis[MAXN]; void clear(){for(int i = 0;i\u0026lt;MAXN;i++) basis[i].reset();} void ins(bs x){ for(int i = MAXN-1;i\u0026gt;=0;--i){ if(x[i] == 0) continue; if(basis[i].any()) x ^= basis[i]; else {basis[i] = x;break;} } } bs query(){ bs res; for(int i = MAXN-1;i\u0026gt;=0;--i) if(!res[i]) res ^= basis[i]; return res; } }BS[LOGN]; namespace SegTree{ vector\u0026lt;bs\u0026gt; v[MAXN\u0026lt;\u0026lt;2]; #define lson (x\u0026lt;\u0026lt;1)  #define rson (x\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void update(int x,int l,int r,int ql,int qr,bs val){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) v[x].push_back(val); else{ if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,val); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,val); } } void solve(int x,int l,int r,int level,bs *ans){ BS[level] = BS[level-1]; for(int i = 0;i \u0026lt; (int)(v[x].size());i++) BS[level].ins(v[x][i]); if(l == r) ans[l] = BS[level].query(); else{ solve(lson,l,mid,level+1,ans); solve(rson,mid+1,r,level+1,ans); } } } struct Edge{ int to,nex;bs v; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,bs c){ edge[ecnt] = (Edge){b,fir[a],c},fir[a] = ecnt++; } int n,m,q,k; int a[MAXN],b[MAXN],tim[MAXN];bs c[MAXN]; int vis[MAXN];bs dis[MAXN]; bs ans[MAXN]; void dfs(int x,int fa){ vis[x] = 1; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(v == fa) continue; if(vis[v] == 1) SegTree::update(1,0,q,0,q,dis[x]^dis[v]^edge[e].v); else{ dis[v] = dis[x] ^ edge[e].v; dfs(v,x); } } } void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;q); static char ss[MAXN]; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i],\u0026amp;b[i]); scanf(\u0026#34;%s\u0026#34;,ss);char_to_bs(ss,c[i]); addedge(a[i],b[i],c[i]),addedge(b[i],a[i],c[i]); } } void solve(){ static char op[20],ss[MAXN];int t;bs tmp; for(int i = 1;i\u0026lt;=q;i++){ scanf(\u0026#34;%s\u0026#34;,op); if(op[0] == \u0026#39;A\u0026#39;){++k; // Add  tim[k] = i; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[k],\u0026amp;b[k]); scanf(\u0026#34;%s\u0026#34;,ss);char_to_bs(ss,c[k]); } else if(op[1] == \u0026#39;a\u0026#39;){// Cancel  scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); SegTree::update(1,0,q,tim[t],i-1,c[t]^dis[a[t]]^dis[b[t]]); tim[t] = -i; } else if(op[1] == \u0026#39;h\u0026#39;){// Change  scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); scanf(\u0026#34;%s\u0026#34;,ss);char_to_bs(ss,tmp); SegTree::update(1,0,q,tim[t],i-1,c[t]^dis[a[t]]^dis[b[t]]); c[t] = tmp,tim[t] = i; } else assert(0); } for(int i = 1;i\u0026lt;=k;i++)if(tim[i] \u0026gt; 0){ SegTree::update(1,0,q,tim[i],q,c[i]^dis[a[i]]^dis[b[i]]); } SegTree::solve(1,0,q,1,ans); } void output(){for(int i = 0;i\u0026lt;=q;i++) bs_to_char(ans[i]),putchar(\u0026#39;\\n\u0026#39;);} int main(){ init(); dfs(1,0); solve(); output(); return 0; }   ","description":"","id":35,"section":"posts","tags":["数据结构","线段树分治","线性基"],"title":"「HAOI2017」八纵八横-线段树分治+线性基","uri":"https://blog.chenqiqian.com/posts/haoi2017-railway/"},{"content":"有 $n$ 个商店，每个商店都有一个特殊商品，每个人在任何时间都可以买。第一天可能没有进货，有若干次询问，而之后的每天，都有一次进货和若干次询问，每次进货都是某个商店进了某个编号的货，每次询问都是询问在编号为 $l$ 到 $r$ 的商店中，在 $d$ 天内进的货的编号异或 $x$ 的最大值。\n链接 Luogu P4585\n题解 我们考虑如果没有天数限制，就是类似 「SCOI2016」美味 这样的题，我们用一个可持久化 Trie 就可以解决了。现在有时间的限制，我们用线段树套可持久化线段树貌似就可以了（，但是这个不优美qwq\n那让我们学习一下线段树分治。\n我们回想线段树的工作原理，本质上是将一个区间划分成 $O(\\log n)$ 个区间，对于这种贡献可以累加的题目，我们就可以分治询问的时间区间到线段树的节点上，然后在线段树上跑一些什么dfs之类的就可以解决这个问题（当然，贡献不独立也是可以做的，就是需要所有的 $d$ 都相同或者能够以物品的时间来确定一个查询的贡献来自于那些物品，也就是查询的贡献来自与查询无关的地方）。\n我们考虑对时间分治，线段树的下标是时间，然后每次都把询问分散到 $O(\\log n)$ 个区间上，最后对答案取 $\\max$ 即可。\n那么我们现在总共有 $O(n \\log n)$ 个询问在 $O(n)$ 个节点里面，我们考虑来处理新加进来的物品。\n我们把商品对于出现的位置排序，然后我们按照时间每次都把所有询问划分到两边去，每个线段树的节点都新建一个可持久化 Trie，我们可以证明这个东西的复杂度只有 $O(n \\log^2 n)$ ，因为每个物品最多出现 $O(\\log n)$ 次，每次插入都是 $O(\\log n)$ 的。我们再单独建立一个可持久化 Trie 处理特殊物品即可。每个线段树节点建立 Trie 的时候需要离散化保证时间复杂度正确性。\n时间复杂度： $O(n \\log^2 n)$ ，空间复杂度 $O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000,logn = 19; int c[MAXN*logn*2][2],sum[MAXN*logn*2],totp; struct Query{int id,l,r,x;}; struct Node{int tim,p,v;}; bool cmp(Node a,Node b){return a.p \u0026lt; b.p;} vector\u0026lt;Query\u0026gt; Q[MAXN\u0026lt;\u0026lt;2];// query vector\u0026lt;Node\u0026gt; N[MAXN\u0026lt;\u0026lt;2];// node / number  int query(int lc,int rc,int v){ int ans = 0; for(int i = logn-1;i\u0026gt;=0;--i){ ans \u0026lt;\u0026lt;= 1;int t = (v\u0026gt;\u0026gt;i) \u0026amp; 1; if(sum[c[rc][t^1]] - sum[c[lc][t^1]] \u0026gt; 0) lc = c[lc][t^1],rc = c[rc][t^1],ans ^= 1; else lc = c[lc][t],rc = c[rc][t]; } return ans; } void modify(int \u0026amp;x,int pre,int v){ int now = x = ++totp; for(int i = logn-1;i\u0026gt;=0;--i){ int t = (v\u0026gt;\u0026gt;i) \u0026amp; 1; c[now][t] = ++totp,c[now][t^1] = c[pre][t^1]; sum[now] = sum[pre]+1; now = c[now][t],pre = c[pre][t]; } sum[now] = sum[pre] + 1; } #define mid ((l+r)/2) #define lson (x\u0026lt;\u0026lt;1) #define rson (x\u0026lt;\u0026lt;1|1) void addq(int x,int l,int r,int ql,int qr,Query q){ if(qr \u0026lt; l || ql \u0026gt; r || ql \u0026gt; qr) return; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) Q[x].push_back(q); else{ if(ql \u0026lt;= mid) addq(lson,l,mid,ql,qr,q); if(qr \u0026gt;= mid+1) addq(rson,mid+1,r,ql,qr,q); } } int rt[MAXN],tmp[MAXN],ans[MAXN]; void solve(int x,int l,int r){ if(N[x].size() == 0) return; tmp[0] = totp = 0;// 清空 Trie  tmp[++tmp[0]] = 0,rt[1] = 0; for(int i = 0;i \u0026lt; (int)(N[x].size());i++){ tmp[++tmp[0]] = N[x][i].p; rt[tmp[0]] = 0,modify(rt[tmp[0]],rt[tmp[0]-1],N[x][i].v); if(l == r) continue; if(N[x][i].tim \u0026lt;= mid) N[lson].push_back(N[x][i]); else N[rson].push_back(N[x][i]); } for(int i = 0;i \u0026lt; (int)(Q[x].size());i++){ int L = upper_bound(tmp+1,tmp+tmp[0]+1,Q[x][i].l-1) - tmp - 1; int R = upper_bound(tmp+1,tmp+tmp[0]+1,Q[x][i].r) - tmp - 1; ans[Q[x][i].id] = max(ans[Q[x][i].id],query(rt[L],rt[R],Q[x][i].x)); } if(l == r) return; solve(lson,l,mid),solve(rson,mid+1,r); } int n,m,tott,totq; int val[MAXN]; int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;val[i]); totp = 0; for(int i = 1;i\u0026lt;=n;i++) rt[i] = 0,modify(rt[i],rt[i-1],val[i]); int op,L,R,x,d,s,v; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if(op == 0){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;s,\u0026amp;v); tott++; N[1].push_back((Node){tott,s,v}); } else if(op == 1){ scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;L,\u0026amp;R,\u0026amp;x,\u0026amp;d); ++totq; addq(1,1,m,tott-d+1,tott,(Query){totq,L,R,x}); ans[totq] = query(rt[L-1],rt[R],x); } } sort(N[1].begin(),N[1].end(),cmp); solve(1,1,m); for(int i = 1;i\u0026lt;=totq;i++) printf(\u0026#34;%d\\n\u0026#34;,ans[i]); return 0; }   ","description":"","id":36,"section":"posts","tags":["数据结构","线段树","线段树分治","可持久化线段树","Trie"],"title":"「FJOI2015」火星商店问题-线段树分治+可持久化Trie","uri":"https://blog.chenqiqian.com/posts/fjoi2015-shop/"},{"content":"Doris 刚刚学习了 fibnacci 数列，用 $f[i]$ 表示数列的第 $i$ 项，那么： $f[0] = 0,f[1] = 1,f[n] = f[n - 1] + f[n - 2](n \\geq 2)$ 。\nDoris 用老师的超级计算机生成了一个 $n \\times m$ 的表格，第 $i$ 行第 $j$ 列的格子中的数是 $f[\\gcd(i, j)]$，其中 $\\gcd(i, j)$ 表示 $i$ 与 $j$ 的最大公约数。\nDoris 的表格中共有 $n \\times m$ 个数，她想知道这些数的乘积是多少。\n这些数的乘积实在是太大了，所以 Doris 只想知道乘积对 $1000000007$ 取模后的结果。\n链接 Luogu P3704\n题解 令 $fib(i)$ 为斐波那契数列的第 $i$ 项，我们要求的是：\n$$\n\\prod _ {i=1}^n \\prod _ {j=1}^m fib(\\gcd(i,j))\n$$\n推推式子（不妨设 $n \\le m$）：\n$$\n\\prod _ {i=1}^n \\prod _ {j=1}^m fib(\\gcd(i,j))\\\n= \\prod _ {d=1}^n fib(d)^{g(d)}\n$$\n其中 ：\n$$\ng(d) = \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\sum _ {j=1}^{\\lfloor\\frac{m}{d}\\rfloor} [\\gcd(i,j) = 1]\\\n= \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\sum _ {j=1}^{\\lfloor\\frac{m}{d}\\rfloor} \\sum _ {k | \\gcd(i,j)} \\mu(k)\\\n= \\sum _ {k=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(k) \\lfloor \\frac{\\lfloor\\frac{n}{d}\\rfloor} {k}\\rfloor \\lfloor \\frac{\\lfloor\\frac{m}{d}\\rfloor} {k}\\rfloor\\\n= \\sum _ {k=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(k)\\lfloor\\frac{n}{dk}\\rfloor\\lfloor\\frac{m}{dk}\\rfloor\\\n$$\n以上是我会的全部\u0026hellip;\n我们令 $T = kd$ ，然后直接代到最外面：\n$$\nsum = \\prod _ {d=1}^{n} fib(d)^{\\sum _ {k=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(k)\\lfloor\\frac{n}{dk}\\rfloor\\lfloor\\frac{m}{dk}\\rfloor}\\\n= \\prod _ {k=1}^{n} \\prod _ {d = 1}^{\\lfloor\\frac{n}{k}\\rfloor}fib(d)^{\\mu(k)\\lfloor\\frac{n}{dk}\\rfloor\\lfloor\\frac{m}{dk}\\rfloor}\\\n=\\prod _ {T=1}^n \\prod _ {k | T} fib(\\frac{T}{k})^{\\mu(k)\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor}\n$$\n然后我们如果令：\n$$\nf(T) = \\prod _ {k|T} fib(\\frac{T}{k})^{\\mu(k)}\n$$\n原来的式子就表示为：\n$$\nsum = \\prod _ {T=1}^n {f(T)}^{\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor}\n$$\n$O(n\\log n)$ 搞出来 $f$ 的取值，然后胡逼分块即可。\n时间复杂度：$O(n \\log n + T \\sqrt n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 1010000,mod = 1e9+7; ll qpow(ll x,ll k){ ll ans = 1; for(lli= k;i;i\u0026gt;\u0026gt;=1,x = (x*x)%mod) if(i \u0026amp; 1) ans = ans * x % mod; return ans; } int mu[MAXN],f[MAXN],fib[MAXN],inv[MAXN]; int sum[MAXN],sinv[MAXN]; void sieve(int n){ // \\sum _ {d | n} \\mu(d) = [n=1]  // mu(n) = [n=1] - \\sum _ {d \u0026lt; n,d | n} mu(d)  mu[1] = 1; for(inti= 1;i\u0026lt;=n;i++){ for(intj= i+i;j\u0026lt;=n;j+=i) mu[j] -= mu[i]; } for(inti= 0;i\u0026lt;=n;i++){f[i] = 1;} for(inti= 1;i\u0026lt;=n;i++){ fib[i] = i==1? 1 : fib[i-1] + fib[i-2]; if(fib[i] \u0026gt;= mod) fib[i] -= mod; inv[i] = qpow(fib[i],mod-2); for(intj= i,k = 1;j\u0026lt;=n;j+=i,k++){ f[j] = 1LL * f[j] * (mu[k] == 1?fib[i]:(mu[k]==0?1:inv[i])) % mod; } } sum[0] = sinv[0] = 1; for(inti= 1;i\u0026lt;=n;i++){ sum[i] = 1LL * sum[i-1] * f[i] % mod; sinv[i] = 1LL * sinv[i-1] * qpow(f[i],mod-2) % mod; } } int calc(int n,int m){ if(n \u0026gt; m) swap(n,m); int ans = 1; for(int l = 1,r;l\u0026lt;=n;l = r+1){ r = min(n/(n/l),m/(m/l)); int A = 1LL * sum[r] * sinv[l-1] % mod; int B = 1LL * (n/l) * (m/l) % (mod-1); // printf(\u0026#34;l:%d A:%d B:%d\\n\u0026#34;,l,A,B);  ans = 1LL * ans * qpow(A,B) % mod; } return ans; } signed main(){ sieve(1000000); int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(inti= 1;i\u0026lt;=T;i++){ int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); printf(\u0026#34;%d\\n\u0026#34;,calc(n,m)); } return 0; }   ","description":"","id":37,"section":"posts","tags":["数论","数学"],"title":"「SDOI2017」数字表格-数论","uri":"https://blog.chenqiqian.com/posts/sdoi2017-product/"},{"content":"Bob 有一棵 $n​$ 个点的有根树，其中 $1​$ 号点是根节点。Bob 在每个节点上涂了颜色，并且每个点上的颜色不同。\n定义一条路径的权值是，这条路径上的点（包括起点和终点）共有多少种不同的颜色。\nBob 可能会进行这几种操作：\n 1 x，把点 $x$ 到根节点的路径上的所有的点染上一种没有用过的新颜色； 2 x y，求 $x$ 到 $y$ 的路径的权值； 3 x，在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。  Bob 一共会进行 $m$ 次操作。\n链接 Luogu P3703\n题解 我们注意到很重要的一点是：染上一种没有用过的新颜色。再加上每次染色都是从这个点到根节点，这意味着，有多少段颜色就有多少种颜色。\n我们如果令 $f(x)$ 为 $x$ 到根节点颜色的段数，$g(x,y)$ 为第二个操作的答案，不难发现如下性质：\n$$\ng(x,y) = f(x) + f(y) - 2*\\text{lca}(x,y) + 1\n$$\n这个其实可以通过考虑颜色段+1的本质是出现了一个分割点。\n然后我们考虑如何维护 $f(x)$ 的值。\n我们给一个点到根节点染上色，就是让这个点到根节点打通成为一条连通块。咦？似乎很像 access ？那我们岂不每次 access 一下就可以了，然后我们发现 access 的时候切换虚实边的次数就是这个点的答案。这样我们按照 dfs 序列构造一棵线段树，切换虚/实边的时候更新线段树+1/-1即可。\n时间复杂度：$O(n \\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; namespace SegTree{ #define ls (x\u0026lt;\u0026lt;1)  #define rs (x\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  int mx[MAXN\u0026lt;\u0026lt;2],lzy[MAXN\u0026lt;\u0026lt;2]; void add(int x,int v){mx[x] += v,lzy[x] += v;} void push_down(int x){if(lzy[x]) add(ls,lzy[x]),add(rs,lzy[x]),lzy[x] = 0;} void push_up(int x){mx[x] = max(mx[ls],mx[rs]);} void build(int x,int l,int r,int *a){ if(l == r) mx[x] = a[l]; else{ build(ls,l,mid,a),build(rs,mid+1,r,a); push_up(x); } } void update(int x,int l,int r,int ql,int qr,int v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) add(x,v); else{ push_down(x); if(ql \u0026lt;= mid) update(ls,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) update(rs,mid+1,r,ql,qr,v); push_up(x); } } int query(int x,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return mx[x]; else{ push_down(x); int ans = -0x3f3f3f3f; if(ql \u0026lt;= mid) ans = max(ans,query(ls,l,mid,ql,qr)); if(qr \u0026gt;= mid+1) ans = max(ans,query(rs,mid+1,r,ql,qr)); return ans; } } } struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]},fir[a] = ecnt++; } int n,m; int dfn[MAXN],f[MAXN],siz[MAXN],dep[MAXN],son[MAXN],top[MAXN]; void dfs0(int x,int fa,int depth){ siz[x] = 1,f[x] = fa,dep[x] = depth; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(v == fa) continue; dfs0(v,x,depth+1); siz[x] += siz[v]; if(siz[v] \u0026gt; siz[son[x]]) son[x] = v; } } void dfs1(int x,int topf){ top[x] = topf;dfn[x] = ++dfn[0]; if(!son[x]) return; dfs1(son[x],topf); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(v == son[x] || v == f[x]) continue; dfs1(v,v); } } int lca(int x,int y){ while(top[x] != top[y]){ if(dep[top[x]] \u0026lt; dep[top[y]]) swap(x,y); x = f[top[x]]; } if(dep[x] \u0026gt; dep[y]) swap(x,y); return x; } void update_tree(int x,int v){ if(!x) return; SegTree::update(1,1,n,dfn[x],dfn[x]+siz[x]-1,v); } int query_tree(int x){return SegTree::query(1,1,n,dfn[x],dfn[x]+siz[x]-1);} int query(int x){return SegTree::query(1,1,n,dfn[x],dfn[x]);} int query(int x,int y){return query(x)+query(y)-2*query(lca(x,y))+1;} namespace LCT{ int c[MAXN][2],f[MAXN],mn[MAXN]; void init(int n,int *fa){for(int i = 1;i\u0026lt;=n;i++) f[i] = fa[i],mn[i] = i;} bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void push_up(int x){mn[x] = c[x][0]?mn[c[x][0]]:x;} void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[y] = x,f[x] = z; push_up(y); } void splay(int x){ while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); push_up(x); } } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); update_tree(mn[c[x][1]],1),update_tree(mn[y],-1); c[x][1] = y,push_up(x); } } } void modify(int x){LCT::access(x);} void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 2;i\u0026lt;=n;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); } dfs0(1,0,1),dfs1(1,1); static int v[MAXN]; for(int i = 1;i\u0026lt;=n;i++) v[dfn[i]] = dep[i]; SegTree::build(1,1,n,v),LCT::init(n,f); } void solve(){ int op,x,y; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if(op == 1) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x),modify(x); else if(op == 2) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y),printf(\u0026#34;%d\\n\u0026#34;,query(x,y)); else if(op == 3) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x),printf(\u0026#34;%d\\n\u0026#34;,query_tree(x)); } } int main(){ init(),solve(); return 0; }   ","description":"","id":38,"section":"posts","tags":["树形结构","dfs序","LCT","线段树"],"title":"「SDOI2017」树点涂色-LCT+树链剖分","uri":"https://blog.chenqiqian.com/posts/sdoi2017-paint/"},{"content":"给定 $n,m,k$ ，计算\n$$\n\\sum _ {i=1}^n\\sum _ {j=1}^m {\\gcd(i,j)}^k\n$$\n对 $1000000007$ 取模的结果\n链接 Luogu P4449\n题解 我们来来来推推推式子吧qwq\n$$\n\\sum _ {i=1}^n\\sum _ {j=1}^m {\\gcd(i,j)}^k\n$$\n不妨令 $n\u0026lt;m$ ，枚举 $\\gcd(i,j) = d$ ：\n$$\nS = \\sum _ {d=1}^{n} d^k \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum _ {i=1}^{\\lfloor\\frac{m}{d}\\rfloor} [(i,j)=1]\\\n= \\sum _ {d=1}^{n} d^k \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum _ {i=1}^{\\lfloor\\frac{m}{d}\\rfloor} \\sum _ {t | \\gcd(i,j)} \\mu(t)\\\n= \\sum _ {d=1}^{n} d^k \\sum _ {t = 1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(t)\\sum _ {i=1}^{\\lfloor\\frac{n}{dt}\\rfloor}\\sum _ {i=1}^{\\lfloor\\frac{m}{dt}\\rfloor} 1\\\n= \\sum _ {d=1}^{n} d^k \\sum _ {t = 1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu(t) \\lfloor\\frac{n}{dt}\\rfloor \\lfloor\\frac{m}{dt}\\rfloor\\\n$$\n令 $dt = T$ ，我们有：\n$$\nS = \\sum _ {T=1}^{n} \\lfloor\\frac{n}{T}\\rfloor \\lfloor\\frac{m}{T}\\rfloor\\sum _ {d|T}d^k\\mu(\\frac{T}{d})\n$$\n我们令 $g(T) = \\sum _ {d|T}d^k\\mu(\\frac{T}{d})$，原式变为：\n$$\nS = \\sum _ {T=1}^{n} \\lfloor\\frac{n}{T}\\rfloor \\lfloor\\frac{m}{T}\\rfloor g(T)\n$$\n很明显这个可以整除分块，很明显 $g$ 是一个积性函数，所以我们考虑如何算出 $g$ 的前缀和。\n发现 $n,m$ 的范围比较小，可以考虑用线性筛解决这个问题。\n线性筛的本质是不断加入最小质因子，我们考虑一个质数的\n$$\ng(P^t) = \\sum _ {i=0}^t f(P^i) \\mu (P^{t-i})\n$$\n凡是有平方因子的数都是的莫比乌斯函数值都是 $0$ ，所以这个式子化成：\n$$\ng(P^t) = \\mu(1) f(P^t) + \\mu(P)f(P^{t-1})\\\n= f(P^t) - f(P^{t-1})\n= P^{kt} - P^{k(t-1)}\n= P^{k(t-1)}(P^{k}-1)\n$$\n可以注意到如果没有 $P$ 这个质因子，答案就是直接乘上 $P^k-1$ ，如果有就乘上 $P^k$ 即可。\n这大概也是线性筛筛未知积性函数的套路：算出来 $g(P^t)$ 并观察这个东西的性质，当然也可以记录最小质因子的大小。\n时间复杂度： $O(n + T \\sqrt n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 5100000,mod = 1e9+7; ll pow(ll x,ll k, ll p){ ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = (x*x)%p) if(i\u0026amp;1) ans = ans * x % p; return ans; } int g[MAXN],s[MAXN]; int noprime[MAXN],prime[MAXN]; void sieve(int n,int k){ g[1] = 1; for(int i = 2;i\u0026lt;=n;i++){ if(!noprime[i]){ prime[++prime[0]] = i,g[i] = pow(i,k,mod)-1; if(g[i] \u0026lt; 0) g[i] += mod;//容易出锅...  } for(int j = 1;j \u0026lt;= prime[0] \u0026amp;\u0026amp; i*prime[j] \u0026lt;= n;j++){ noprime[i*prime[j]] = 1; if(i % prime[j] == 0){ g[i*prime[j]] = 1LL * g[i] * (g[prime[j]]+1) % mod; break; } g[i*prime[j]] = 1LL * g[i] * g[prime[j]] % mod; } } for(int i = 1;i\u0026lt;=n;i++) { s[i] = s[i-1] + g[i]; if(s[i] \u0026gt;= mod) s[i] -= mod; } } int calc(int n,int m){ if(n \u0026gt; m) swap(n,m); int ans = 0; for(int l = 1,r;l \u0026lt;= n;l = r + 1){ r = min(n/(n/l),m/(m/l)); int tmp = (1LL * (n/l) * (m/l)) % mod; // 多加括号...  int sum = s[r] - s[l-1]; if(sum \u0026lt; 0) sum += mod; ans = (ans + 1LL * tmp * sum) % mod; } return ans; } int main(){ int T,k; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;T,\u0026amp;k); sieve(5000000,k); for(int i = 1;i\u0026lt;=T;i++){ int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); printf(\u0026#34;%d\\n\u0026#34;,calc(n,m)); } return 0; }   ","description":"","id":39,"section":"posts","tags":["数学","数论"],"title":"「Luogu4449」于神之怒加强版-数学","uri":"https://blog.chenqiqian.com/posts/luogu-4499/"},{"content":"给定一个由 $n$ 行数字组成的数字梯形如下图所示。梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。\n分别遵守以下规则：\n 从梯形的顶至底的 $m$ 条路径互不相交； 从梯形的顶至底的 $m$ 条路径仅在数字结点处相交； 从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。  链接 LOJ6010\n题解 费用流 3 in 1\u0026hellip;\n考虑把每个点拆点，然后限制如何满足呢？\n 我们把所有边和点之间的权值都设置成为 1 我们把拆点的两个点之间的容量设置成为 inf，其他地方都是 1 所有都是 inf  注意原点往最上面一层的每一个点都是容量为 1 的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 800,MAXM = MAXN*40; namespace MCMF{//最大费用  int S,T; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ edge[ecnt] = (Edge){a,b,c,0, d,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]},fir[b] = ecnt++; } void clear(){memset(fir,0,sizeof(fir)),ecnt = 2;} int dis[MAXN],inq[MAXN]; bool spfa(){ memset(dis,0x3f,sizeof(dis)); static queue\u0026lt;int\u0026gt; q; dis[S] = 0;q.push(S); while(!q.empty()){ int x = q.front();q.pop();inq[x] = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(edge[e].cap \u0026gt; edge[e].flow \u0026amp;\u0026amp; dis[v] \u0026gt; dis[x] + edge[e].cost){ dis[v] = dis[x] + edge[e].cost; if(!inq[v]) q.push(v),inq[v] = 1; } } } return dis[T] \u0026lt; dis[0]; } int dfs(int x,int limit = inf){ if(x == T || limit == 0) return limit; int sumf = 0;inq[x] = 1; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!inq[v] \u0026amp;\u0026amp; dis[v] == dis[x] + edge[e].cost){ int f = dfs(v,min(limit,edge[e].cap - edge[e].flow)); sumf += f,limit -= f; edge[e].flow += f, edge[e^1].flow -= f; if(limit == 0) break; } } return sumf; } pair\u0026lt;int,int\u0026gt; solve(int s,int t){ S = s,T = t; int ansf = 0,ansc = 0; while(spfa()){ int f = dfs(s); memset(inq,0,sizeof(inq)); ansf += f,ansc += f * dis[t]; } return make_pair(ansf,ansc); } } int m,n; int v[40][40]; int _h(int i,int j){return ((m+(m+i-2))*(i-1)/2)+j;} int in(int i,int j){return _h(i,j)*2-1;} int out(int i,int j){return _h(i,j)*2;} void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m+i-1;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;v[i][j]); } void solve(){ int S = 2*_h(n,m+n-1)+1,T = S+1; // question 1  MCMF::clear(); for(int j = 1;j\u0026lt;=m;j++) MCMF::addedge(S,in(1,j),1,0); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m+i-1;j++){ MCMF::addedge(in(i,j),out(i,j),1,-v[i][j]); if(i == n) MCMF::addedge(out(i,j),T,1,0); else MCMF::addedge(out(i,j),in(i+1,j),1,0), MCMF::addedge(out(i,j),in(i+1,j+1),1,0); } } printf(\u0026#34;%d\\n\u0026#34;,-(MCMF::solve(S,T).second)); // question 2  MCMF::clear(); for(int j = 1;j\u0026lt;=m;j++) MCMF::addedge(S,in(1,j),1,0); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m+i-1;j++){ MCMF::addedge(in(i,j),out(i,j),m,-v[i][j]); if(i == n) MCMF::addedge(out(i,j),T,m,0); else MCMF::addedge(out(i,j),in(i+1,j),1,0), MCMF::addedge(out(i,j),in(i+1,j+1),1,0); } } printf(\u0026#34;%d\\n\u0026#34;,-(MCMF::solve(S,T).second)); // question 3  MCMF::clear(); for(int j = 1;j\u0026lt;=m;j++) MCMF::addedge(S,in(1,j),1,0); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m+i-1;j++){ MCMF::addedge(in(i,j),out(i,j),m,-v[i][j]); if(i == n) MCMF::addedge(out(i,j),T,m,0); else MCMF::addedge(out(i,j),in(i+1,j),m,0), MCMF::addedge(out(i,j),in(i+1,j+1),m,0); } } printf(\u0026#34;%d\\n\u0026#34;,-(MCMF::solve(S,T).second)); } int main(){ init(); solve(); return 0; }   ","description":"","id":40,"section":"posts","tags":["图论","网络流","费用流"],"title":"「网络流 24 题」数字梯形-费用流","uri":"https://blog.chenqiqian.com/posts/loj6010/"},{"content":"某公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了一批共 $m$ 个补丁程序。每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。\n换句话说，对于每一个补丁 $i$ ，都有 $2$ 个与之相应的错误集合 $B_1(i)$ 和 $B_2(i)$ ，使得仅当软件包含 $B_1(i)$ 中的所有错误，而不包含 $B_2(i)$ 中的任何错误时，才可以使用补丁 $i$ 。补丁 $i$ 将修复软件中的某些错误 $F_1(i)$ ，而同时加入另一些错误 $F_2(i)$ 。另外，每个补丁都耗费一定的时间。\n试设计一个算法，利用公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。\n链接 loj6009\n题解 状态压缩之后直接按照约束跑最短路即可\u0026hellip;\n注意区分 ~ 和 ! 的区别。\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXM = 110,MAXN = (1\u0026lt;\u0026lt;20)+10; int n,m; int T[MAXM],B1[MAXM],B2[MAXM],F1[MAXM],F2[MAXM]; char s[MAXM],t[MAXM]; int dis[MAXN],inq[MAXN]; int spfa(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0x3f,sizeof(dis)); dis[s] = 0,q.push(s); while(!q.empty()){ int x = q.front();q.pop();inq[x] = 0; for(int i = 1;i\u0026lt;=m;i++){ if(!((~x) \u0026amp; B1[i]) \u0026amp;\u0026amp; !(x\u0026amp;B2[i])){ int v = (x \u0026amp; (~F1[i])) | (F2[i]); if(dis[v] \u0026gt; dis[x] + T[i]){ dis[v] = dis[x] + T[i]; if(!inq[v]) q.push(v),inq[v] = 1; } } } } return dis[t]; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %s %s\u0026#34;,\u0026amp;T[i],s,t); for(int j = 0;j\u0026lt;n;j++){ if(s[j] == \u0026#39;+\u0026#39;) B1[i] |= (1\u0026lt;\u0026lt;j); if(s[j] == \u0026#39;-\u0026#39;) B2[i] |= (1\u0026lt;\u0026lt;j); if(t[j] == \u0026#39;-\u0026#39;) F1[i] |= (1\u0026lt;\u0026lt;j); if(t[j] == \u0026#39;+\u0026#39;) F2[i] |= (1\u0026lt;\u0026lt;j); } } } void solve(){ int ans = spfa((1\u0026lt;\u0026lt;n)-1,0); printf(\u0026#34;%d\\n\u0026#34;,ans==inf ? 0 : ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":41,"section":"posts","tags":["图论","最短路"],"title":"「网络流 24 题」软件补丁-最短路","uri":"https://blog.chenqiqian.com/posts/loj6009/"},{"content":"一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 $P$ 分；或者把旧餐巾送到快洗部，洗一块需 $M$ 天，其费用为 $F$ 分；或者送到慢洗部，洗一块需 $n$ 天，其费用为 $S$ 分（$S \u0026lt; F$）。\n每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。\n试设计一个算法为餐厅合理地安排好 $n$ 天中餐巾使用计划,使总的花费最小。\n链接 LOJ6008\n题解 这道题可以用费用流来解决。（下面用一个有序列数对 $(cap,cost)$ 描述一条边的流量和价格）\n我们把每个点拆成两个点，$in(i)$ 和 $out(i)$，分别处理干净毛巾和脏的毛巾。\n我们从原点向每一个 $in$ 点连接一条 $(inf,P)$ 的边，表示购买的干净毛巾。\n从 $S$ 向每一个 $out(i)$ 连接一条 $(r_i,0)$ 的边，表示每天我可以收获这么多条脏毛巾；从每一个 $in(i)$ 向 $T$ 连接一条 $(r_i,0)$ 的边，表示我每天得用掉这么多条干净毛巾。上面的连边保证我们满足条件时的流是最大流。\n从 $out(i)$ 向 $out(i+1)$ 连边 $(inf,0)$ ，表示可以把脏毛巾留着不洗；然后就是快洗店/慢洗店，从 $out(i)$ 向 $in(i+M)/in(i+N)$ 连一条 $(inf,F/S)$ 的边。\n费用流的最小费用即为答案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;bits/stdc++.h\u0026gt;// #define int long long #define inf 0x3f3f3f3fLL using namespace std; const int MAXN = 2100,MAXM = MAXN*8*2; namespace MCMF{ int S,T; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ edge[ecnt] = (Edge){a,b,c,0, d,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]},fir[b] = ecnt++; } int dis[MAXN],inq[MAXN]; bool spfa(){ memset(dis,0x3f,sizeof(dis)); static queue\u0026lt;int\u0026gt; q; dis[S] = 0;q.push(S); while(!q.empty()){ int x = q.front();q.pop();inq[x] = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(edge[e].cap \u0026gt; edge[e].flow \u0026amp;\u0026amp; dis[v] \u0026gt; dis[x] + edge[e].cost){ dis[v] = dis[x] + edge[e].cost; if(!inq[v]) q.push(v),inq[v] = 1; } } } return dis[T] \u0026lt; dis[0]; } int dfs(int x,int limit = inf){ if(x == T || limit == 0) return limit; int sumf = 0;inq[x] = 1; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!inq[v] \u0026amp;\u0026amp; dis[v] == dis[x] + edge[e].cost){ int f = dfs(v,min(limit,edge[e].cap - edge[e].flow)); sumf += f,limit -= f; edge[e].flow += f, edge[e^1].flow -= f; if(limit == 0) break; } } return sumf; } pair\u0026lt;int,int\u0026gt; solve(int s,int t){ S = s,T = t; int ansf = 0,ansc = 0; while(spfa()){ int f = dfs(s); memset(inq,0,sizeof(inq)); ansf += f,ansc += f * dis[t]; } return make_pair(ansf,ansc); } } int n,P,fd,fp,sd,sp; int v[MAXN]; signed main(){ scanf(\u0026#34;%d %d %d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;P,\u0026amp;fd,\u0026amp;fp,\u0026amp;sd,\u0026amp;sp); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;v[i]); int S = 2*n+1,T = 2*n+2;// 1-\u0026gt; n,n+1-\u0026gt;n+n  for(int i = 1;i\u0026lt;=n;i++){ MCMF::addedge(S,i,inf/2,P); MCMF::addedge(S,i+n,v[i],0); MCMF::addedge(i,T,v[i],0); MCMF::addedge(i+n,i+n+1,inf/2,0); if(i+fd \u0026lt;= n) MCMF::addedge(i+n,i+fd,inf/2,fp); if(i+sd \u0026lt;= n) MCMF::addedge(i+n,i+sd,inf/2,sp); } pair\u0026lt;int,int\u0026gt; ans = MCMF::solve(S,T); printf(\u0026#34;%d\\n\u0026#34;,ans.second); return 0; }   ","description":"","id":42,"section":"posts","tags":["图论","网络流","费用流"],"title":"「网络流 24 题」餐巾计划-费用流","uri":"https://blog.chenqiqian.com/posts/loj6008/"},{"content":"昨天回家的路上，在海淀黄庄路口的西北角上，有一位街头歌手在弹唱着吉他。\n 我站在路边等着红灯，离他的音箱很近。以我微薄的音乐鉴赏能力来看，他唱的大约是那种最近被称为“民谣”的类型。声音很大，让我不得不摘下耳机，去尝试听一听他的弹唱。歌词是什么，我都已经忘记。\n那天晚上风很大，呼呼啦啦的吹着槐树的叶子。他只穿着一个短袖，却丝毫看不出来他有感觉到冷风的呼啸。一个吉他盒子摆在他面前，上面写着四个字“原创音乐”，还有零零散散的一些零钱。\n一切看起来都再普通不过了。\n但这里是海淀黄庄。这里的街头永远不会空旷，即使到了九点多也仍然人流如织。有刚刚放学的晚自习的学生，有手牵着手的情侣从新中关走向地铁，或只是在此处经过。尽管夜色早已覆盖了天穹，仍然有行色匆匆的人正在走向各自的目的地。\n他今天晚上将会怎么度过？他晚上住在哪里呢？他过的是什么样子的生活呢？我不知道。也许他是一个有钱人或者家境殷实，只是想要充实自己在这里唱歌；也许他是一个落魄的歌者，每日沉迷于音乐之中，晚上到这里来挣得生存的口粮。\n可这些又与我何干呢？\n吉他的和弦和低沉的人声经过音响的放大盖住了所有的一切。这是比用耳机听歌更加震颤人心的：明明整个世界都在你身旁，但是因为有音乐，那所有的一切都是那么的空虚，可以看见却无法触摸。他似乎也跟我一样沉浸在音乐当中，闭着眼睛，身体随着右手的上下舞动而动。\n很快就绿灯了。我走向马路对面，身后吉他乐声渐渐变小，最后变成轻轻的呢喃。公交车的引擎的轰鸣，小车的轮胎划过空气的声音，他们纷至沓来的出现，涌入我的身边。身边的一切事物，草木、车辆、人群都如从来没有过的真实一般。抬头望去，点点微微的星光无力的在闪烁都市灿烂的灯光之上。\n我真不知道，我是从虚幻走进真实，还是从真实走进了虚幻。\n 「我仍然在 无人问津的 阴雨霉湿之地 」\n「和着雨音 唱着没有听众的歌曲」\n「人潮仍是 漫无目的地 向目的地散去」\n「忙碌着 无为着 继续」\n","description":"","id":43,"section":"posts","tags":null,"title":"「随笔」无题","uri":"https://blog.chenqiqian.com/posts/essay-no-title/"},{"content":"在一个有 $m \\times n$ 个方格的棋盘中，每个方格中有一个正整数。\n现要从方格中取数，使任意 $2$ 个数所在方格没有公共边，且取出的数的总和最大。试设计一个满足要求的取数算法。\n链接 LOJ 6007\n题解 可以发现，这是一个二分图的带权最大独立集的问题。\n对于这个问题，我们可以这么解决：\n我们对于二分图的 $S$ 集和 $T$ 集，原点向 $S$ 集合上连边， $T$ 集合的所有点向汇点连边，边流量为点权；所有有约束的边直接连边，权值 $\\inf$ ；答案就是边权和减去最大流的流量。\n怎么证明？可以感性证明。\n求出来的最小割一定是一个合法方案。我们割掉了哪条边，意味着我们付出了一个代价，也就是我们不选了这个物品。如果我们同时选了在二分图两侧有连边的节点（没有割边），那么我们这个图就不可能被割开（中间是无穷大），这个图就不是一个合法的最小割了。反向应当也是可以证明的。\n所以这个算法的正确性是可以保障的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 10000,MAXM = 50000; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]},fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x] + 1,q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f,edge[e].flow += f,edge[e^1].flow -= f; if(limit == 0) break; } } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int m,n,val[110][110],sum; int _hash(int x,int y){return (x-1)*n+y;} bool judge(int x,int y){return (x+y)\u0026amp;1;} int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); for(int i = 1;i\u0026lt;=m;i++) for(int j = 1;j\u0026lt;=n;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;val[i][j]),sum += val[i][j]; int S = n*m+1,T = S + 1; for(int i = 1;i\u0026lt;=m;i++){ for(int j = 1;j\u0026lt;=n;j++){ if(judge(i,j)) addedge(S,_hash(i,j),val[i][j]); else addedge(_hash(i,j),T,val[i][j]); if(!judge(i,j)){ if(i \u0026gt; 1) addedge(_hash(i-1,j),_hash(i,j),inf); if(i \u0026lt; m) addedge(_hash(i+1,j),_hash(i,j),inf); if(j \u0026gt; 1) addedge(_hash(i,j-1),_hash(i,j),inf); if(j \u0026lt; n) addedge(_hash(i,j+1),_hash(i,j),inf); } } } printf(\u0026#34;%d\\n\u0026#34;,sum-dinic(S,T)); return 0; }   ","description":"","id":44,"section":"posts","tags":["图论","网络流","二分图"],"title":"「网络流 24 题」方格取数-二分图最大独立集","uri":"https://blog.chenqiqian.com/posts/loj6007/"},{"content":"假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。\n链接 LOJ 6006\n题解 对每道题建一个点，对每个类型建一个点，每道题向它能成为的类型连边，原点向题连边，类型向汇点连边，跑最大流即可。\n方案就看一下哪些边是满流输出即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 1100,MAXM = 1100*25*2; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]},fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1,q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x] + 1,q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; if(limit == 0) break; } } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int k,n,m; int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;k,\u0026amp;n); int S = k + n + 1,T = S + 1; for(int i = 1;i\u0026lt;=k;i++){ int tmp;scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp); addedge(S,i,tmp),m += tmp; } for(int i = 1;i\u0026lt;=n;i++){ int p,tmp; scanf(\u0026#34;%d\u0026#34;,\u0026amp;p); addedge(i+k,T,1); for(int x = 1;x \u0026lt;= p;x++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp); addedge(tmp,i+k,1); } } int ans = dinic(S,T); if(ans != m) printf(\u0026#34;No Solution!\\n\u0026#34;); else{ for(int i = 1;i\u0026lt;=k;i++){ printf(\u0026#34;%d: \u0026#34;,i); for(int e = fir[i];e;e = edge[e].nex){int v = edge[e].to; if(k+1\u0026lt;=v \u0026amp;\u0026amp; v\u0026lt;=k+n \u0026amp;\u0026amp; edge[e].flow == 1) printf(\u0026#34;%d \u0026#34;,v-k); } printf(\u0026#34;\\n\u0026#34;); } } return 0; }   ","description":"","id":45,"section":"posts","tags":["图论","网络流"],"title":"「网络流 24 题」试题库-网络最大流","uri":"https://blog.chenqiqian.com/posts/loj6006/"},{"content":"众所周知，最小费用最大流向来是一个算法很多的问题，下面总结了几个常用的最小费用最大流算法。\n增广路算法（EK算法） 每次都在原图的残余网络上进行一次最短路（ bellmanford 算法或者 spfa 算法）找出一条从原点到汇点的最短路，然后求出这条最短路上的最大可流流量并流满，直到找不出最短路为止。\n最广泛使用的费用流算法。\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int inf = 0x3f3f3f3f; const int MAXN = 510,MAXM = 100000; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ // printf(\u0026#34;add:%d %d %d %d\\n\u0026#34;,a,b,c,d);  edge[ecnt] = (Edge){a,b,c,0,d,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]}; fir[b] = ecnt++; } int dis[MAXN],vis[MAXN],minf[MAXN],pree[MAXN]; queue\u0026lt;int\u0026gt; q; bool spfa(int s,int t){ while(!q.empty()) q.pop(); memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); q.push(s);dis[s] = 0,minf[s] = inf; while(!q.empty()){ int nown = q.front();q.pop(); vis[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ Edge \u0026amp; e = edge[nowe]; if(dis[e.to] \u0026gt; dis[nown] + e.cost \u0026amp;\u0026amp; e.cap \u0026gt; e.flow){ dis[e.to] = dis[nown] + e.cost; minf[e.to] = min(minf[nown],e.cap - e.flow); pree[e.to] = nowe; if(vis[e.to] == 0){ q.push(e.to); vis[e.to] = 1; } } } } return dis[t] \u0026lt; inf; } int min_cost_flow(int s,int t,int k = inf){ int ans = 0; while(spfa(s,t) \u0026amp;\u0026amp; k \u0026gt; 0){ if(dis[t] \u0026gt; 0) break; for(int nown = t,nowe = 0;nown != s;nown = edge[nowe].from){ nowe = pree[nown]; edge[nowe].flow += minf[t],edge[nowe^1].flow -= minf[t]; } ans += dis[t] * minf[t]; } return ans; } int n,m,k; char s[MAXN]; char t[MAXN]; bool check(int pos,int len){ if(pos + len - 1 \u0026gt; n) return 0; for(int i = 1;i\u0026lt;=len;i++) if(s[pos + i - 1] != t[i]){ return 0; } return 1; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),scanf(\u0026#34;%s\u0026#34;,s+1); int S = 0,T = n+2; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ int p; scanf(\u0026#34;%s %d\u0026#34;,t+1,\u0026amp;p); int len = strlen(t+1); for(int i = 1;i\u0026lt;=n;i++){ if(check(i,len)) addedge(i,i+len,1,-p); } } scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); for(int i = 1;i\u0026lt;=n;i++){ addedge(i,i+1,inf,0); } addedge(S,1,k,0); addedge(n+1,T,k,0); printf(\u0026#34;%d\\n\u0026#34;,-min_cost_flow(S,T)); return 0; }   （CF717G）\n消圈算法 TBD。\n连续最短路算法（zkw费用流） TBD。\n原始对偶算法 实现1 每次进行 spfa ，然后在最短路上做dinic多路增广。\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 5100,MAXM = 51000; namespace MCMF{ int S,T; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ edge[ecnt] = (Edge){a,b,c,0, d,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]},fir[b] = ecnt++; } int dis[MAXN],inq[MAXN]; bool spfa(){ memset(dis,0x3f,sizeof(dis)); static queue\u0026lt;int\u0026gt; q; dis[S] = 0;q.push(S); while(!q.empty()){ int x = q.front();q.pop();inq[x] = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(edge[e].cap \u0026gt; edge[e].flow \u0026amp;\u0026amp; dis[v] \u0026gt; dis[x] + edge[e].cost){ dis[v] = dis[x] + edge[e].cost; if(!inq[v]) q.push(v),inq[v] = 1; } } } return dis[T] \u0026lt; dis[0]; } int dfs(int x,int limit = inf){ if(x == T || limit == 0) return limit; int sumf = 0;inq[x] = 1; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!inq[v] \u0026amp;\u0026amp; dis[v] == dis[x] + edge[e].cost){ int f = dfs(v,min(limit,edge[e].cap - edge[e].flow)); sumf += f,limit -= f; edge[e].flow += f, edge[e^1].flow -= f; if(limit == 0) break; } } return sumf; } pair\u0026lt;int,int\u0026gt; solve(int s,int t){ S = s,T = t; int ansf = 0,ansc = 0; while(spfa()){ int f = dfs(s); memset(inq,0,sizeof(inq)); ansf += f,ansc += f * dis[t]; } return make_pair(ansf,ansc); } } int n,m,s,t; int main(){ // scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s,\u0026amp;t);  scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m);s = 1,t = n; for(int i = 1;i\u0026lt;=m;i++){ int a,b,c,d; scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d); MCMF::addedge(a,b,c,d); } pair\u0026lt;int,int\u0026gt; ans = MCMF::solve(s,t); printf(\u0026#34;%d %d\\n\u0026#34;,ans.first,ans.second); return 0; }   实现2 简单来说，就是我们可以在残量网络上进行一次最短路操作（bellman ford），然后每次去维护一个label，每次扩展完（使用 dinic 仅在符合条件的道路上更改）更新最短路label（使用 dijkstra 算法），然后使用一个松弛操作，代码如下：\n1 2 3 4  void reduce(int s,int t){ for(int e = 2;e \u0026lt;= ecnt;e++) E0.cost += dis[E0.to] - dis[E0.from]; delta += dis[s]; }   然后就可以跑 dijkstra 了。\n完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;bits/extc++.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#define E0 edge[e] #define E1 edge[e^1] #define inf 0x3f3f3f3f using namespace std; const int MAXN = 410,MAXM = 15010; struct Edge{ int from,to,cap,flow,cost,nex; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ edge[ecnt] = (Edge){a,b,c,0, d,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]},fir[b] = ecnt++; } struct Node{ int x,d; bool operator \u0026lt; (const Node \u0026amp;_n)const{return d \u0026gt; _n.d;} Node(int _x,int _d):x(_x),d(_d){} }; // #define Node pair\u0026lt;int,int\u0026gt; // typedef __gnu_pbds::priority_queue\u0026lt;Node, less\u0026lt;Node\u0026gt;, __gnu_pbds::pairing_heap_tag\u0026gt; heap; // typedef priority_queue\u0026lt; Node ,vector\u0026lt; Node \u0026gt;,greater\u0026lt;Node\u0026gt;\u0026gt; heap; typedef priority_queue\u0026lt;Node\u0026gt; heap; int n,m; int dis[MAXN],inq[MAXN],vis[MAXN],ansf,ansc,delta; void reduce(int s,int t){ for(int e = 2;e \u0026lt;= ecnt;e++) E0.cost += dis[E0.to] - dis[E0.from]; delta += dis[s]; } bool bellman(int s,int t){// t 为起点  static queue\u0026lt;int\u0026gt; q; memset(dis,0x3f,sizeof(int)*(n+1));while(!q.empty()) q.pop(); dis[t] = 0,q.push(t);inq[t] = 1; while(!q.empty()){ int x = q.front();q.pop();inq[x] = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = E0.to,c = E1.cap,f = E1.flow,l = E1.cost; if(c \u0026gt; f \u0026amp;\u0026amp; dis[v] \u0026gt; dis[x] + l){ dis[v] = dis[x] + l; if(!inq[v]) inq[v] = 1,q.push(v); } } } return dis[s] \u0026lt; inf; } bool dijkstra(int s,int t){ memset(dis,0x3f,sizeof(int)*(n+1)); static heap q; dis[t] = 0;q.push(Node(t,0)); while(!q.empty()){ Node p = q.top();q.pop();int x = p.x; if(p.d != dis[x]) continue; for(int e = fir[x];e;e = edge[e].nex){ int v = E0.to,c = E1.cap,f = E1.flow,l = E1.cost; if(c \u0026gt; f \u0026amp;\u0026amp; dis[v] \u0026gt; dis[x] + l){ dis[v] = dis[x] + l,q.push(Node(v,dis[v])); } } } return dis[s] \u0026lt; inf; } int dfs(int x,int t,int limit = inf){ if(x == t || limit == 0) return limit; vis[x] = 1; // differ from dinic  int sumf = 0; for(int \u0026amp;e = cur[x];e;e = edge[e].nex){ int v = E0.to,c = E0.cap,f = E0.flow,l = E0.cost; if(!vis[v] \u0026amp;\u0026amp; c \u0026gt; f \u0026amp;\u0026amp; l == 0){ int newf = dfs(v,t,min(limit,c-f)); sumf += newf,limit -= newf; E0.flow += newf,E1.flow -= newf; if(limit == 0) break; } } return sumf; } void augment(int s,int t){ int curf = 0; while(memset(vis,0,sizeof(int)*(n+1)),(curf = dfs(s,t))){ ansf += curf,ansc += curf * delta; } } void primaldual(int s,int t){ if(!dijkstra(s,t)) return; ansf = ansc = delta = 0; do{ reduce(s,t),augment(s,t); }while(dijkstra(s,t)); } int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); int S = 1,T = n; for(int i = 1;i\u0026lt;=m;i++){ int a,b,c,d; scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d); addedge(a,b,c,d); } primaldual(S,T); printf(\u0026#34;%d %d\\n\u0026#34;,ansf,ansc); return 0; }   ","description":"","id":46,"section":"posts","tags":["图论","网络流","费用流","模板"],"title":"常见最小费用最大流算法学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-mfmc/"},{"content":"给定正整数序列 $x_1 \\sim x_n$ ，以下递增子序列均为非严格递增。\n  计算其最长递增子序列的长度 $s$ 。\n  计算从给定的序列中最多可取出多少个长度为 $s$ 的递增子序列。\n  如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列。\n  链接 LOJ6005\n题解 这个问题需要用dp和网络流搭配解决。\n第一问：直接 $O(n^2)$ dp 即可。\n第二问：在第一问的基础上，我们考虑网络流。\n我们把每个点拆成两个点： $(i,0)$ 和 $(i,1)$\n $S$ 向所有 $dp[i] = 1$ 的 $(i,0)$ 连边 所有 $dp[i] = s$ 的点向 T 连边 对于每个 $j$，向所有满足： $j \u0026lt; i \\le n,x[j] \\le x[i],dp[j] + 1 = dp[i]$ ，连一条 $(i,1)$ 向 $(j,0)$ 的边 最后每个 $(i,0)$ 向 $(i,1)$ 连边。  然后 dinic 大概就可以了。\n第三问：把四个边增加到正无穷：$(1,0) \\rightarrow (1,1)$ , $(n,0) \\rightarrow (n,1)$ , $S \\rightarrow (1,0)$ , $(n,1) \\rightarrow T$（如果有） 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 1100,MAXM = MAXN*MAXN; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]};fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]};fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1,q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x]+1;q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit =inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x]+1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; if(limit == 0) break; } } } return sumf; } int dinic(int s,int t){ static int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int n; int x[MAXN],dp[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x[i]); } void solve(){ int ans = 0,S = n+1,T = 2*n+3;// 0 -\u0026gt; n \u0026amp;\u0026amp; n+1 -\u0026gt; 2*n+1  for(int i = 1;i\u0026lt;=n;i++) addedge(i,i+n+1,1); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 0;j\u0026lt;i;j++)if(x[j] \u0026lt;= x[i]) dp[i] = max(dp[i],dp[j]+1); for(int j = 0;j\u0026lt;i;j++)if(x[j] \u0026lt;= x[i] \u0026amp;\u0026amp; dp[j] + 1 == dp[i]) addedge(j+n+1,i,1); ans = max(ans,dp[i]); } for(int i = 1;i\u0026lt;=n;i++) if(dp[i] == ans) addedge(i+n+1,T,1); printf(\u0026#34;%d\\n\u0026#34;,ans); printf(\u0026#34;%d\\n\u0026#34;,dinic(S,T)); addedge(1,1+n+1,n*n-1),addedge(n,n+n+1,n*n-1); addedge(S,1,n*n-1); if(dp[n] == ans) addedge(n+n+1,T,n*n-1); printf(\u0026#34;%d\\n\u0026#34;,dinic(S,T)); } int main(){ init(),solve(); return 0; }   ","description":"","id":47,"section":"posts","tags":["图论","网络流","动态规划"],"title":"「网络流 24 题」最长递增子序列-dp+网络最大流","uri":"https://blog.chenqiqian.com/posts/loj6005/"},{"content":"假设有来自 $m$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$ 。会议餐厅共有 $n$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。\n试设计一个算法，给出满足要求的代表就餐方案。\n链接 LOJ6004\n题解 我们可以把这个题转化成网络最大流解决。\n每个单位一个点 $1$ ～ $m$ ，每个餐桌一个点 $m+1$ ～ $m+n$ ，源点向单位连边，餐桌向汇点连边，分别是对应容量；每个单位向每个餐桌连边，容量为 $1$ 。 如果最大流等于人数，就有解，否则无解。\n输出方案我们考虑对每个单位的点，遍历出边，找出连向餐桌的有流量的边的另一段，对应餐桌的就是单位的每个人去的餐桌。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 500,MAXM = MAXN*MAXN*2; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]},fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]},fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1,q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x]+1;q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int n,m; int sa[MAXN],sb[MAXN]; vector\u0026lt;int\u0026gt; ANS[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); for(int i = 1;i\u0026lt;=m;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;sb[i]); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;sa[i]); } void solve(){ int S = n+m+1,T = S+1,sum = 0; for(int i = 1;i\u0026lt;=m;i++) addedge(S,i,sb[i]),sum += sb[i]; for(int i = 1;i\u0026lt;=n;i++) addedge(m+i,T,sa[i]); for(int i = 1;i\u0026lt;=m;i++){ for(int j = 1;j\u0026lt;=n;j++){ addedge(i,m+j,1); } } int ans = dinic(S,T); if(ans != sum) return (printf(\u0026#34;0\\n\u0026#34;),void(0)); printf(\u0026#34;1\\n\u0026#34;); for(int x = 1;x\u0026lt;=m;x++){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(edge[e].flow == 1) printf(\u0026#34;%d \u0026#34;,v-m); } printf(\u0026#34;\\n\u0026#34;); } } int main(){ init(); solve(); }   ","description":"","id":48,"section":"posts","tags":["图论","网络流"],"title":"「网络流 24 题」圆桌聚餐-网络最大流","uri":"https://blog.chenqiqian.com/posts/loj6004/"},{"content":"假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1, 2, 3, 4, \\cdots$ 的球。\n 每次只能在某根柱子的最上面放球。 在同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。  试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。\n链接 LOJ6003\n题解 其实这个本质上类似一个链覆盖的问题。\n我们每次考虑加入一个球，然后在二分图上连上可行的边（ $i+j$ 是平方数而且 $i \u0026lt; j$），每次直接接着跑 dinic ，直到不满足即可。\n输出方案就是枚举边，找链起点。同上一道题。\n其实应该二分，复杂度更好保证，不过这个比较好写（\n这题也可以贪心，懒得写了，题解粘贴过来：\n 贪心就是从小到大枚举编号，之后在已经有球的柱子里随便找一个能放的放。如果找不到，就新开一个柱子。\n但它是正确的吗？为什么？\n  可以证明。用数学归纳法证明贪心法每次的选择是唯一的(即，只能把球放到0或1个已经放了球的柱子上)，且答案为(一个简单式子，暂不剧透)。用dilworth定理可以证明这个是最优的(hint:柱子的顶端构成一个反链)。\n这个算法work是因为“加起来是平方数”的性质很好。改成其他条件就做不了了。\n 链接 ： UOJ BLOG\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;bits/stdc++.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 3200,MAXM = MAXN*100,N = MAXN/2; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]};fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]};fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x] + 1;q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ static int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int n,is_squ[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);for(int i = 1;i*i \u0026lt; MAXN;i++) is_squ[i*i] = 1; } int solve(){ int S = MAXN-1,T = MAXN-2; for(int i = 1;i\u0026lt;=MAXN;i++){ addedge(S,i,1),addedge(i+N,T,1); for(int j = 1;j\u0026lt;i;j++){ if(is_squ[i+j]) addedge(j,i+N,1); } int ans = i - dinic(S,T); if(ans \u0026gt; n) return i-1; } } void output(int x){ int S = MAXN-1,T = MAXN-2; memset(fir,0,sizeof(fir)),ecnt = 2; for(int i = 1;i\u0026lt;=x;i++){ addedge(S,i,1),addedge(i+N,T,1); for(int j = i+1;j\u0026lt;=x;j++){ if(is_squ[i+j]) addedge(i,j+N,1); } } dinic(S,T); static int pre[MAXN],nxt[MAXN]; for(int e = 2;e\u0026lt;=ecnt;e+=2){ int a = edge[e].from,b = edge[e].to,f = edge[e].flow; if(f == 1 \u0026amp;\u0026amp; 1 \u0026lt;= a \u0026amp;\u0026amp; a \u0026lt;= x \u0026amp;\u0026amp; N+1 \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= MAXN+x){ pre[b-N] = a,nxt[a] = b-N; } } printf(\u0026#34;%d\\n\u0026#34;,x); for(int i = 1;i\u0026lt;=x;i++){ if(pre[i] == 0){ for(int t = i;t;t = nxt[t]) printf(\u0026#34;%d \u0026#34;,t); printf(\u0026#34;\\n\u0026#34;); } } } int main(){ init(),output(solve()); return 0; }   ","description":"","id":49,"section":"posts","tags":["图论","网络流","二分图"],"title":"「网络流 24 题」魔术球-二分图最大匹配","uri":"https://blog.chenqiqian.com/posts/loj6003/"},{"content":"给定有向图 $G = (V, E)$。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。 $P$ 中路径可以从 $V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 $0$ 。 $G$ 的最小路径覆盖是 $G$ 的所含路径条数最少的路径覆盖。\n设计一个有效算法求一个有向无环图 $G$ 的最小路径覆盖。\n链接 LOJ6002\n题解 这个题可以转化成二分图匹配来做。\n因为顶点不相交，所以每个顶点至多有一个入度 \u0026amp; 出度，所以如果两个边能接上，我们的答案就可以减掉一个 1 。\n什么情况下答案可以减掉 1 ？就是我们能通过一条边连起来两个点的时候。然后放到原来的图上，连起来自然就是答案。那么这样的话，我们就可以构建一个二分图，把每个点拆成两个，原图上的边从左侧出，右侧入即可。\n输出方案的话，就遍历每条边（就是二分图里面满流的边），记录一下每个点的往后走和往前走的节点是什么，然后找到所有链头一路往后跳就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 410,MAXM = MAXN*MAXN*2; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]};fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]};fir[b] = ecnt++; } int dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x] + 1,q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int n,m,S,T; int pre[MAXN],nxt[MAXN]; void print_chain(){ for(int x = 1;x\u0026lt;=n;x++){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!(n \u0026lt;= v \u0026amp;\u0026amp; v \u0026lt;= 2*n)) continue; if(edge[e].flow == 1){ pre[v-n] = x,nxt[x] = v-n; } } } for(int x = 1;x\u0026lt;=n;x++){ if(pre[x] == 0){// 链子头  for(int t = x;t;t = nxt[t]) printf(\u0026#34;%d \u0026#34;,t); printf(\u0026#34;\\n\u0026#34;); } } } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m);S = 2*n+1,T = S + 1; for(int i = 1;i\u0026lt;=m;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b+n,1); } for(int i = 1;i\u0026lt;=n;i++) addedge(S,i,1),addedge(i+n,T,1); } void solve(){ int ans = n - dinic(S,T); print_chain(); printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(),solve(); return 0; }   ","description":"","id":50,"section":"posts","tags":["图论","网络流","二分图"],"title":"「网络流 24 题」最小路径覆盖-二分图最大匹配","uri":"https://blog.chenqiqian.com/posts/loj6002/"},{"content":"W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $E = { E_1, E_2, \\cdots, E_m }$ ，和进行这些实验需要使用的全部仪器的集合 $I = { I_1, I_2, \\cdots, I_n }$ 。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \\subseteq I$ 。配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。\n链接 LOJ6001\n题解 这种问题事实上是一个最大权闭合子图的问题。\n我们把一个实验抽象成一个点（编号 $1$ - $m$ ），一个仪器也抽象成一个点（编号 $m+1$ - $m+n$），再从每个实验往其需要的器材连一条有向边。\n这个时候我们需要求出的是一个最大权的闭合子图，节点的权值可正可负（实验正，仪器负）。\n这个时候我们怎么做呢？我们把 $S$ 向所有正权值的点连权值容量的边，所有原图中的边都连$\\inf$ ，所有负权值的点都向 $T$ 连一个权值的绝对值容量的边。\n这个时候所有正权值的和减去 $S$ 和 $T$ 的最小割就是答案。如何证明？我们考虑每次割都是一个代价，也就是选了负权和不选正权，都会带来一个代价，然后我们想让这个代价最小，所以就是最小割。\n这个时候可以发现，和 $S$ 联通（能够通过非满流边到达）的都是要选的实验和仪器， dfs 一次即可完成。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 110,MAXM = MAXN*MAXN; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]};fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]};fir[b] = ecnt++; } int n,m, dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x] + 1;q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(x == t || limit == 0) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x]+1 \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ int f = dfs(v,t,min(limit,edge[e].cap - edge[e].flow)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } vector\u0026lt;int\u0026gt; node[MAXN]; int val[MAXN],cost[MAXN]; vector\u0026lt;int\u0026gt; ans1,ans2; void dfs1(int x){ if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= m) ans1.push_back(x); if(m+1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= m+n) ans2.push_back(x-m); int t = 0;swap(t,dis[x]); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == t+1) dfs1(v); } } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); // 1 -\u0026gt; m 实验，m+1 -\u0026gt; m+n \u0008物品  static char s[MAXN*10]; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;val[i]); int t; while(scanf(\u0026#34;%[\\n\\r]\u0026#34;,s)!=1){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); node[i].push_back(t); } } for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;cost[i]); } void solve(){ int S = n+m+1,T = S+1,sum = 0; for(int i = 1;i\u0026lt;=m;i++) addedge(S,i,val[i]),sum += val[i]; for(int i = 1;i\u0026lt;=m;i++) for(auto x : node[i]) addedge(i,m+x,inf); for(int i = 1;i\u0026lt;=n;i++) addedge(m+i,T,cost[i]); int ans = sum - dinic(S,T); bfs(S,T); dfs1(S); sort(ans1.begin(),ans1.end()),sort(ans2.begin(),ans2.end()); for(unsigned i = 0;i\u0026lt;ans1.size();i++){ printf(\u0026#34;%d\u0026#34;,ans1[i]);putchar(i != ans1.size()-1?\u0026#39; \u0026#39;:\u0026#39;\\n\u0026#39;); } for(unsigned i = 0;i\u0026lt;ans2.size();i++){ printf(\u0026#34;%d\u0026#34;,ans2[i]);putchar(i != ans2.size()-1?\u0026#39; \u0026#39;:\u0026#39;\\n\u0026#39;); } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); }   ","description":"","id":51,"section":"posts","tags":["图论","最大权闭合子图","网络流"],"title":"「网络流 24 题」太空飞行计划-最大权闭合子图","uri":"https://blog.chenqiqian.com/posts/loj6001/"},{"content":"飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员，需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。\n因为驾驶工作分工严格，两个正驾驶员或两个副驾驶员都不能同机飞行。\n链接 LOJ6000\n题解 注意到这就是一个二分图匹配问题。\n我们把左侧放置正飞行员（ $1$ - $m$ ），右侧放置副飞行员（ $m+1$ - $n$ ），然后在可以配对的正副飞行员之间连边，二分图最大匹配即为答案。\n可以用网络最大流解决这个问题。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 110,MAXM = 110*110; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]};fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]};fir[b] = ecnt++; } int n,m,dis[MAXN]; bool bfs(int s,int t){ static queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis));while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int x = q.front();q.pop(); for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(!dis[v] \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[x]+1;q.push(v); } } } return dis[t]; } int dfs(int x,int t,int limit = inf){ if(limit == 0 || x == t) return limit; int sumf = 0; for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(dis[v] == dis[x] + 1 \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ int f = dfs(v,t,min(edge[e].cap - edge[e].flow,limit)); if(f){ sumf += f,limit -= f; edge[e].flow += f,edge[e^1].flow -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } int w[MAXN][MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m);int a,b; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b) == 2) w[a][b] = 1; } void solve(){ // 建图：每个飞行员一个点，正 1-\u0026gt; m ，副 m+1 -\u0026gt; n  int S = n+1,T = n+2; for(int i = 1;i\u0026lt;=m;i++) addedge(S,i,1); for(int i = 1;i\u0026lt;=m;i++) for(int j = m+1;j\u0026lt;=n;j++) if(w[i][j] == 1) addedge(i,j,1); for(int j = m+1;j\u0026lt;=n;j++) addedge(j,T,1); printf(\u0026#34;%d\\n\u0026#34;,dinic(S,T)); } int main(){ init(); solve(); return 0; }   ","description":"","id":52,"section":"posts","tags":["图论","网络流","二分图"],"title":"「网络流 24 题」搭配飞行员-二分图最大匹配","uri":"https://blog.chenqiqian.com/posts/loj6000/"},{"content":"你被给定一棵 $n$ 个点的树，点从 $1$ 到 $n$ 编号。每个点可能有两种颜色：黑或白。我们定义 $dist(a,b)$ 为点 $a$ 至点 $b$ 路径上的边个数。一开始所有的点都是黑色的。\n要求作以下操作：\n 0 i 将点 $i$ 的颜色反转（黑变白，白变黑） 1 v 询问 $dist(u,v)$ 的最小值。$u$ 点必须为白色（ $u$ 与 $v$ 可以相同），显然如果 $v$ 是白点，查询得到的值一定是 $0$ 。  特别地，如果作 1 操作时树上没有白点，输出 $-1$ 。\n链接 Luogu\n题解 我直接复制了 QTREE4 的代码\u0026hellip;\n主要改动如下：\n 把所有的 $\\max$ 改成了 $\\min$ 把所有的边权改成 $1$ 去除所有跟路径有关的东西  然后就ok了\u0026hellip;\n时间复杂度： $O(n \\log^2 n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 210000; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } inline int _f(multiset\u0026lt;int\u0026gt; \u0026amp;S){return S.size()?*S.begin():inf;} struct LCT{ int c[MAXN][2],w[MAXN],f[MAXN],sum[MAXN]; int lmin[MAXN],rmin[MAXN]; multiset\u0026lt;int\u0026gt; Ch[MAXN]; void init(int n){for(int i = 0;i\u0026lt;=n;i++) w[i] = lmin[i] = rmin[i] = inf;} bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void push_up(int x){assert(x); #define ls c[x][0]  #define rs c[x][1]  sum[x] = sum[ls] + sum[rs] + 1; int minc = min(w[x],_f(Ch[x])); int L = min(minc,rmin[ls] + 1),R=min(minc,lmin[rs]); lmin[x] = min(lmin[ls],R + sum[ls] + 1); rmin[x] = min(rmin[rs],L + sum[rs]); #undef ls  #undef rs  } void rotate(int x){ int y = f[x],z = f[y],t = c[y][1] == x,w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[y] = x,f[x] = z; push_up(y); } void splay(int x){ while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); if(c[x][1]) Ch[x].insert(lmin[c[x][1]]); if(y) Ch[x].erase(Ch[x].find(lmin[y])); c[x][1] = y,push_up(x); } } void modify(int x){ access(x),splay(x); w[x] = w[x]==0?inf:0; push_up(x); } int query(int x){ access(x),splay(x); return rmin[x]; } void add(int x,int v){Ch[x].insert(lmin[v]);} }T; void dfs1(int x,int fa){ for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == fa) continue; T.f[v] = x,dfs1(v,x); T.add(x,v); } T.push_up(x); } int n,q; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 2;i\u0026lt;=n;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); } T.init(n);dfs1(1,0); } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); int op, x; for(int i = 1;i\u0026lt;=q;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;op,\u0026amp;x); if(op == 1){ int ans = T.query(x); if(ans \u0026lt; inf) printf(\u0026#34;%d\\n\u0026#34;,ans); else printf(\u0026#34;-1\\n\u0026#34;); }else if(op == 0) T.modify(x); } } int main(){ init(); solve(); return 0; }   ","description":"","id":53,"section":"posts","tags":["数据结构","LCT"],"title":"「SPOJ26374」QTREE5-LCT","uri":"https://blog.chenqiqian.com/posts/spoj26374-qtree5/"},{"content":"一棵树,每个点初始有个点权和颜色(输入会给你)\n 0 u : 询问所有 $u,v$ 路径上的最大点权,要满足 $u,v$ 路径上所有点的颜色都相同 1 u : 反转 $u$ 的颜色 2 u w :把 $u$ 的点权改成 $w$  $color_i \\in [0,1],w_i \\in [-10^9,10^9],n,m \\le 10^5$\n链接 Luogu\n题解 我就是要用一个 LCT 做！\n这次在 BZOJ 上也没有被卡常！\n我们维护两个 multiset 维护每个点的虚子树（顶点不同颜色）的最大联通块（表现为 lmx[x]），每次 access 的时候更新一下就好了。\n一定记住，access的时候该删的删，该加的加，是相对于子树来说的！别搞错了(大哭\n时间复杂度：$O(n \\log^2 n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 110000; int _f(multiset\u0026lt;int\u0026gt; \u0026amp;S){return S.empty()?-inf:*(S.rbegin());} struct LCT{ int c[MAXN][2],f[MAXN],v[MAXN],w[MAXN],sum[MAXN][2]; int lc[MAXN],rc[MAXN],lmx[MAXN],rmx[MAXN]; multiset\u0026lt;int\u0026gt; vmx[MAXN][2]; void init(){lmx[0] = rmx[0] = -inf+1;} bool noroot(int x){return c[f[x]][0]==x||c[f[x]][1]==x;} void push_up(int x){ #define ls c[x][0]  #define rs c[x][1]  sum[x][0] = sum[ls][0] + sum[rs][0] + (w[x]==0); sum[x][1] = sum[ls][1] + sum[rs][1] + (w[x]==1); lc[x] = ls?lc[ls]:w[x],rc[x] = rs?rc[rs]:w[x]; int maxl = max(max(v[x],_f(vmx[x][w[x]])) , rc[ls] == w[x]?rmx[ls]:-inf); int maxr = max(max(v[x],_f(vmx[x][w[x]])) , lc[rs] == w[x]?lmx[rs]:-inf); lmx[x] = lmx[ls],rmx[x] = rmx[rs]; if(!ls || (!sum[ls][1-lc[x]] \u0026amp;\u0026amp; w[x] == lc[x])) lmx[x] = max(lmx[x],maxr);//!!!  if(!rs || (!sum[rs][1-rc[x]] \u0026amp;\u0026amp; w[x] == rc[x])) rmx[x] = max(rmx[x],maxl);//!!!  #undef ls  #undef rs  } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1]==x),w = c[x][1-t];//!!!  if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[y] = x,f[x] = z; push_up(y); } void splay(int x){ while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); vmx[x][ lc[c[x][1]] ].insert(lmx[ c[x][1] ]);//!!!  vmx[x][ lc[y] ].erase(lmx[y]);//!!!  c[x][1] = y,push_up(x);//!!!  } } void m_node(int x,int c,int val){w[x] = c,v[x] = val;} void m_fa(int x,int fa){f[x] = fa,vmx[fa][lc[x]].insert(lmx[x]);} void m_color(int x){access(x),splay(x),w[x]^=1,push_up(x);} void m_value(int x,int val){access(x),splay(x),v[x] = val,push_up(x);} int q_max(int x){access(x),splay(x);return rmx[x];} }T; int n,q; int col[MAXN],val[MAXN]; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } void dfs(int x,int fa){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(v == fa) continue; T.m_node(v,col[v],val[v]); dfs(v,x); T.push_up(v),T.m_fa(v,x); } } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);T.init(); for(int i = 1;i\u0026lt;=n-1;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); } for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;col[i]); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;val[i]); T.m_node(1,col[1],val[1]);dfs(1,0); } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++){ int op,x,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;op,\u0026amp;x); if(op == 0) printf(\u0026#34;%d\\n\u0026#34;,T.q_max(x)); else if(op == 1) T.m_color(x); else if(op == 2) scanf(\u0026#34;%d\u0026#34;,\u0026amp;v),T.m_value(x,v); } } int main(){ init(); solve(); return 0; }   ","description":"","id":54,"section":"posts","tags":["数据结构","LCT"],"title":"「SPOJ16580」QTREE7-LCT","uri":"https://blog.chenqiqian.com/posts/spoj16580-qtree7/"},{"content":"给你一棵 $n$ 个点的树，编号 $1$~$n$ 。每个点可以是黑色，可以是白色。初始时所有点都是黑色。有两种操作：\n 0 u ：询问有多少个节点 $v$ 满足路径 $u$ 到 $v$ 上所有节点（包括端点）都拥有相同的颜色 1 u ：翻转 $u$ 的颜色  链接 Luogu\n题解 我就不想用两个 LCT 做！\n然后在 BZOJ 上就被卡常了\u0026hellip;无所谓了！\n我们考虑类似 QTREE457 ，维护一下虚子的联通块情况即可。需要注意的是，代表一个 $splay$ 的颜色应该是最左侧的颜色，也就是代码中的 lc[x] 。\n套路也是相同的，push_up 会写的稍微麻烦点，access 要考虑虚子的变化对维护的虚子信息的影响。\n时间复杂度: $O(n\\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; struct LCT{ int c[MAXN][2],f[MAXN]; int w[MAXN];// 代表颜色 0白 1黑  int lc[MAXN],rc[MAXN];// 代表当前splay子树的最左侧和最右侧的颜色  int lsum[MAXN],rsum[MAXN];// 代表左侧的连痛块和右侧的联通块的大小，  int vsum[MAXN][2],siz[MAXN][2];// 根节点的虚子树，根节点颜色为 0/1 的大小  void init(int n){ for(int i = 1;i\u0026lt;=n;i++) w[i] = 1; } bool noroot(int x){return c[f[x]][0]==x||c[f[x]][1]==x;} void push_up(int x){ #define ls (c[x][0])  #define rs (c[x][1])  siz[x][0] = siz[ls][0] + siz[rs][0] + (w[x]==0); siz[x][1] = siz[ls][1] + siz[rs][1] + (w[x]==1); lc[x] = ls?lc[ls]:w[x],rc[x] = rs?rc[rs]:w[x]; int xl = 1 + vsum[x][w[x]] + (rc[ls]==w[x]?rsum[ls]:0); int xr = 1 + vsum[x][w[x]] + (lc[rs]==w[x]?lsum[rs]:0); lsum[x] = lsum[ls],rsum[x] = rsum[rs]; if(!ls || (!siz[ls][1-lc[ls]] \u0026amp;\u0026amp; lc[ls] == w[x])) lsum[x] += xr; if(!rs || (!siz[rs][1-rc[rs]] \u0026amp;\u0026amp; rc[rs] == w[x])) rsum[x] += xl; #undef ls  #undef rs  } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1]==x),w = (c[x][1-t]); if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[x] = z,f[y] = x; push_up(y); } void splay(int x){ while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); vsum[x][lc[c[x][1]]] += lsum[c[x][1]]; vsum[x][lc[y]] -= lsum[y]; c[x][1] = y,push_up(x); } } void modify(int x){access(x),splay(x),w[x] ^= 1,push_up(x);} int query(int x){access(x),splay(x);return rsum[x];} }T; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } void dfs(int x,int fa){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to; if(v == fa) continue; dfs(v,x); T.f[v] = x,T.vsum[x][T.w[v]] += T.lsum[v]; } T.push_up(x); } int n,m; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);T.init(n); for(int i = 1;i\u0026lt;=n-1;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); } dfs(1,0); } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ int op,x; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;op,\u0026amp;x); if(op == 0) printf(\u0026#34;%d\\n\u0026#34;,T.query(x)); else if(op == 1) T.modify(x); } } int main(){ init(),solve(); return 0; }   ","description":"","id":55,"section":"posts","tags":["数据结构","LCT"],"title":"「SPOJ16549」QTREE6-LCT","uri":"https://blog.chenqiqian.com/posts/spoj16549-qtree6/"},{"content":"给定一棵 $n$ 个点的树，边具有边权。要求作以下操作：\n  DIST a b 询问点 $a$ 至点 $b$ 路径上的边权之和\n  KTH a b k 询问点 $a$ 至点 $b$ 有向路径上的第k个点的编号\n  有多组测试数据，每组数据以 DONE 结尾。\n链接 Luogu\n题解 我们接着用LCT爆搞这个题。\n我们还是把边拆成点，分别向两边连边，然后距离就是路径点权和；查询第 $k$ 个点就是 split 之后在 $splay$ 上乱跑找 kth 。\n时间复杂度： $O(n \\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 21000; struct LCT{ int c[MAXN][2],f[MAXN],siz[MAXN],r[MAXN]; ll v[MAXN],sum[MAXN]; void init(int n){for(int i=1;i\u0026lt;=n;i++)c[i][0]=c[i][1]=f[i]=r[i]=v[i]=sum[i]=0,siz[i]=1;} bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void rev(int x){r[x]^=1,swap(c[x][0],c[x][1]);} void push_down(int x){if(r[x])rev(c[x][0]),rev(c[x][1]),r[x]=0;} void push_up(int x){ siz[x] = siz[c[x][0]] + siz[c[x][1]] + 1; sum[x] = sum[c[x][0]] + sum[c[x][1]] + v[x]; } void push_all(int x){ static int S[MAXN];S[0] = 0; while(noroot(x)) S[++S[0]] = x,x = f[x]; S[++S[0]] = x; for(int i = S[0];i\u0026gt;=1;--i) push_down(S[i]); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1]==x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[x] = z,f[y] = x; push_up(y); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]) splay(x),c[x][1] = y,push_up(x); } void makeroot(int x){access(x),splay(x),rev(x);} void m_node(int x,int fa,int val = 0){v[x] = sum[x] = val,f[x] = fa;} void split(int x,int y){makeroot(x),access(y),splay(y);} ll query_sum(int x,int y){return (split(x,y),sum[y]);} int query_kth(int x,int y,int k){ split(x,y);int t = y; if(k \u0026gt; siz[y]) return -1; while(true){ push_down(t); if(k \u0026lt;= siz[c[t][0]]) t = c[t][0]; else if(k == siz[c[t][0]] + 1) break; else k -= siz[c[t][0]]+1,t = c[t][1]; } if(t) splay(t);return t; } }T; struct Edge{ int id,to,len,nex; }edge[MAXN]; int fir[MAXN],ecnt = 2; void __clear(int n){ecnt = 2;for(int i = 1;i\u0026lt;=n;i++) fir[i] = 0;} void addedge(int id,int a,int b,int c){ edge[ecnt] = (Edge){id,b,c,fir[a]}; fir[a] = ecnt++; } //---------------// int n; void dfs(int x,int fa){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to,len = edge[e].len,id = edge[e].id; if(v == fa) continue; T.m_node(n+id,x,len),T.m_node(v,n+id); dfs(v,x); } } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);T.init(2*n),__clear(2*n); for(int i = 1;i\u0026lt;=n-1;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(i,a,b,c),addedge(i,b,a,c); } dfs(1,0); } void solve(){ char op[10];int x,y,k; while(true){ scanf(\u0026#34;%s\u0026#34;,op); if(op[1] == \u0026#39;O\u0026#39;) break; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y); if(op[0]==\u0026#39;K\u0026#39;) scanf(\u0026#34;%d\u0026#34;,\u0026amp;k),printf(\u0026#34;%d\\n\u0026#34;,T.query_kth(x,y,2*k-1)); else if(op[0] == \u0026#39;D\u0026#39;) printf(\u0026#34;%lld\\n\u0026#34;,T.query_sum(x,y)); } } int main(){ int T = 0;scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++)init(),solve(); return 0; }   ","description":"","id":56,"section":"posts","tags":["LCT","数据结构"],"title":"「SPOJ913」QTREE2-LCT","uri":"https://blog.chenqiqian.com/posts/spoj913-qtree2/"},{"content":"给定 $n$ 个点的树，边按输入顺序编号为 $1,2,\u0026hellip;,n-1$，要求作以下操作：\n CHANGE i v ：将第 $i$ 条边权值改为 $v$ QUERY a b ：询问从 $a$ 点到 $b$ 点路径上的最大边权  有多组测试数据，每组数据以 DONE 结尾。\n链接 Luogu\n题解 可以用 LCT 完成本题。\n我们考虑每个边和每个点建立一个 LCT 中的点，然后边的点的点权就是边的边权，这样就可以修改边的权值了。\n查询的话，直接 split 出来查询最大值即可，点对应的 LCT 中的点的权值为 $-\\inf$。\n时间复杂度： $O(n \\log n)$\n代码 Luogu 版本；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 210000; struct LCT{ int c[MAXN][2],f[MAXN],v[MAXN],mx[MAXN],r[MAXN]; void init(int n){for(int i = 0;i\u0026lt;=n;i++) v[i]=mx[i] = -inf, c[i][0]=c[i][1]=f[i]=r[i] = 0;} bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void push_up(int x){mx[x] = max(v[x],max(mx[c[x][0]],mx[c[x][1]]));} void rev(int x){r[x] ^= 1,swap(c[x][0],c[x][1]);} void push_down(int x){if(r[x]) rev(c[x][0]),rev(c[x][1]),r[x] = 0;} void push_all(int x){ static int S[MAXN];S[0] = 0; while(noroot(x)) S[++S[0]] = x,x = f[x]; S[++S[0]] = x; for(int i = S[0];i\u0026gt;=1;--i) push_down(S[i]); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[x] = z,f[y] = x; push_up(y); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1] == x) ^ (c[z][1] == y) ? rotate(x) : rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x),c[x][1] = y,push_up(x); } } void makeroot(int x){access(x),splay(x),rev(x);} void update(int x,int val){v[x] = val,push_up(x);} void modify(int x,int val){access(x),splay(x),update(x,val);} void split(int x,int y){makeroot(x),access(y),splay(y);} int query(int x,int y){return x == y ? 0 : (split(x,y),mx[y]);} void addedge(int x,int fa){f[x] = fa;} }T; struct Edge{ int id,to,len,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int id,int a,int b,int c){ edge[ecnt] = (Edge){id,b,c,fir[a]}; fir[a] = ecnt++; } void _clear(int n){ecnt = 2;for(int i = 1;i\u0026lt;=n;i++) fir[i] = 0;} int n,q; void dfs(int x,int fa){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to,l = edge[e].len,id = edge[e].id; if(v == fa) continue; T.update(n+id,l),T.addedge(v,n+id),T.addedge(n+id,x); dfs(v,x); } } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); _clear(2*n); T.init(2*n); for(int i = 1;i\u0026lt;=n-1;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(i,a,b,c),addedge(i,b,a,c); } dfs(1,0); } void solve(){ char op[10];int x,y; while(true){ scanf(\u0026#34;%s\u0026#34;,op); if(op[0] == \u0026#39;D\u0026#39;) break; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y); if(op[0] == \u0026#39;C\u0026#39;) T.modify(n+x,y); else if(op[0] == \u0026#39;Q\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,T.query(x,y)); } } int main(){ int T = 1; for(int i = 1;i\u0026lt;=T;i++) init(),solve(); return 0; }   SPOJ 版本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;stdio.h\u0026gt;#define inf 0x3f3f3f3f #define MAXN 210000  int max(int x,int y){return x \u0026gt; y ? x : y;} int swap(int *x,int *y){(*x) ^= (*y),(*y) ^= (*x),(*x) ^= (*y);} int c[MAXN][2],f[MAXN],v[MAXN],mx[MAXN],r[MAXN]; void _init_(int n){for(int i = 0;i\u0026lt;=n;i++) v[i]=mx[i] = -inf, c[i][0]=c[i][1]=f[i]=r[i] = 0;} int noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void push_up(int x){mx[x] = max(v[x],max(mx[c[x][0]],mx[c[x][1]]));} void rev(int x){r[x] ^= 1,swap(\u0026amp;c[x][0],\u0026amp;c[x][1]);} void push_down(int x){if(r[x]) rev(c[x][0]),rev(c[x][1]),r[x] = 0;} void push_all(int x){ static int S[MAXN];S[0] = 0; while(noroot(x)) S[++S[0]] = x,x = f[x]; S[++S[0]] = x; for(int i = S[0];i\u0026gt;=1;--i) push_down(S[i]); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[x] = z,f[y] = x; push_up(y); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1] == x) ^ (c[z][1] == y) ? rotate(x) : rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x),c[x][1] = y,push_up(x); } } void makeroot(int x){access(x),splay(x),rev(x);} void update(int x,int val){v[x] = val,push_up(x);} void modify(int x,int val){access(x),splay(x),update(x,val);} void split(int x,int y){makeroot(x),access(y),splay(y);} int query(int x,int y){split(x,y);return x == y ? 0 : mx[y];} void _addedge(int x,int fa){f[x] = fa;} struct Edge{ int id,to,len,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int id,int a,int b,int c){ edge[ecnt].id = id,edge[ecnt].to = b,edge[ecnt].nex = fir[a],edge[ecnt].len = c; fir[a] = ecnt++; } int n,q; void dfs(int x,int fa){ for(int e = fir[x];e;e = edge[e].nex){ int v = edge[e].to,l = edge[e].len,id = edge[e].id; if(v == fa) continue; update(n+id,l),_addedge(v,n+id),_addedge(n+id,x); dfs(v,x); } } void _clear(int n){ ecnt = 2;for(int i = 1;i\u0026lt;=n;i++) fir[i] = 0; } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); _clear(2*n); _init_(2*n); for(int i = 1;i\u0026lt;=n-1;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(i,a,b,c),addedge(i,b,a,c); } dfs(1,0); } void solve(){ char op[10];int x,y; while(1){ scanf(\u0026#34;%s\u0026#34;,op); if(op[0] == \u0026#39;D\u0026#39;) break; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y); if(op[0] == \u0026#39;C\u0026#39;) modify(n+x,y); else if(op[0] == \u0026#39;Q\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,query(x,y)); } } int main(){ int T = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++) init(),solve(); return 0; }   ","description":"","id":57,"section":"posts","tags":["数据结构","LCT"],"title":"「SPOJ375」QTREE1-LCT","uri":"https://blog.chenqiqian.com/posts/spoj375-qtree1/"},{"content":"你被给定一棵 $n$ 个点的带边权的树（边权可以为负）。每个点可能有两种颜色：黑或白。我们定义 $dist(a,b)$ 为点 $a$ 至点 $b$ 路径上的边权值之和。一开始所有的点都是白色的。\n要求作以下操作：\n  C a 将点a的颜色反转（黑变白，白变黑）\n  A 询问 $dist(a,b)$ 的最大值。$a,b$ 点都必须为白色（ $a$ 与 $b$ 可以相同），显然如果树上仍存在白点，查询得到的值一定是个非负数。\n特别地，如果进行 A 操作时树上没有白点，输出 They have disappeared.。\n  链接 Luogu\n题解 可以用LCT解决这个问题。\n我们先考虑链上的情况。如果这个问题在链上，我们可以用线段树维护若干个变量：区间左端点往右最远的白点，区间右端点往左最远的白点的距离，这个区间内部两个白点之间的距离。这样我们就可以在 $O(\\log n)$ 的时间内合并区间。\n我们考虑树上没有修改的问题。我们都会点分治：在考虑每个树的时候，我们找到不同子树里面最长的两个链，他们合并到一起 和 子树内部的最长链 取最大值，答案就是这个子树里面最长白点之间的距离，分治之后就是 $O(n \\log n)$。\n我觉得 LCT 的解法颇有 2 合 1 的意思。\n我们令 1 号节点为根，然后所有点的权值都是这个点到父亲的边的权值（ $1$ 号节点的权值为 $0$ ），这样两个节点之间的距离就是两个点上的简单路径的权值之和。\n每个节点我们需要维护以下信息：\n sum[x] ： $x$ 的 splay 上子树的链和（到链的父节点） lmax[x]，rmax[x] ： $x$ 所在 $splay$ 的子树上对应原树上最浅（深）的点（最浅的点的父亲）出发能够到达最远的白点（只在当前节点的 $splay$ 和虚子树的并里面走） maxs[x] ：我们只考虑这个 splay 和这个 splay 对应的节点的虚子树里面乱跑，能获得的最长的路径 两个 multiset ： chain[x] , path[x] 表示 $x$ 节点的虚子树里面到 $x$ 节点的最长链 和 最长路径  我们主要有两个特异的函数：\n 一个特别长的 push_up ：\n具体维护在代码里面里面看吧qwq 稍微有些不同的 access：\n其实是维护虚子树的常规操作：考虑消除和新添影响即可。  我们就 win 掉了。\n时间复杂度为 $O(n \\log^2 n)$ 。\n为什么跑的飞快啊\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 210000; struct Edge{ int to,len; int nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){b,c,fir[a]}; fir[a] = ecnt++; } inline int _f(multiset\u0026lt;int\u0026gt; \u0026amp;S){return S.size()?*S.rbegin():-inf;} inline int _s(multiset\u0026lt;int\u0026gt; \u0026amp;S){return S.size()\u0026gt;1?*(++S.rbegin()):-inf;} struct LCT{ int c[MAXN][2],w[MAXN],f[MAXN],sum[MAXN],len[MAXN]; int lmax[MAXN],rmax[MAXN],maxs[MAXN],ans; multiset\u0026lt;int\u0026gt; Ch[MAXN],Pa[MAXN]; void init(int n){for(int i = 0;i\u0026lt;=n;i++) lmax[i] = rmax[i] = maxs[i] = -inf;} bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void push_up(int x){assert(x); #define ls c[x][0]  #define rs c[x][1]  // sum[x] : 链子的长度，由左右加起来  sum[x] = sum[ls] + sum[rs] + len[x]; // maxc : 从虚子树里面 最长的到这个点的链的长度  // L/R ：从这个点左/右侧（或者虚子树）过来能够跑最远的距离  // l/rmax : 这个子 splay 里面最浅的节点的父节点 / 最深的点 能够走到最远的距离  int maxc = max(w[x],_f(Ch[x])); int L = max(maxc,rmax[ls]+len[x]),R=max(maxc,lmax[rs]); lmax[x] = max(lmax[ls],R + sum[ls] + len[x]); rmax[x] = max(rmax[rs],L + sum[rs]); maxs[x] = -inf; // 1 : 两个虚子树里面组合 2 : 虚子树里面的最长路径  // 3 \u0026amp; 4 : 一个虚子树和左/右 出来到 右/左侧 边中  // 5 \u0026amp; 6 ： 两个子 splay 中的最长路径  // 7 : 虚子树中的链到这个节点的距离  maxs[x] = max(maxs[x],max(_f(Ch[x])+_s(Ch[x]),_f(Pa[x]))); maxs[x] = max(maxs[x],max(rmax[ls]+len[x]+R,lmax[rs]+L)); maxs[x] = max(maxs[x],max(maxs[ls],maxs[rs])); if(w[x]==0) maxs[x] = max(maxs[x],_f(Ch[x])),maxs[x] = max(maxs[x],0); #undef ls  #undef rs  } void rotate(int x){ int y = f[x],z = f[y],t = c[y][1] == x,w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[y] = x,f[x] = z; push_up(y); } void splay(int x){ while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); }push_up(x); } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); if(c[x][1]) Ch[x].insert(lmax[c[x][1]]),Pa[x].insert(maxs[c[x][1]]); if(y) Ch[x].erase(Ch[x].find(lmax[y])),Pa[x].erase(Pa[x].find(maxs[y])); c[x][1] = y,push_up(x); } } void modify(int x){ access(x),splay(x); w[x] = w[x]==0?-inf:0; push_up(x); ans = maxs[x]; } void add(int x,int v){ Ch[x].insert(lmax[v]),Pa[x].insert(maxs[v]); } int query(){return ans;} void print(int n){ printf(\u0026#34;--------------------\\n\u0026#34;); for(int x = 1;x\u0026lt;=n;x++){ printf(\u0026#34;%d: c:%d %d f:%d | sum:%d len:%d w:%d | max: l:%d r:%d s:%d\\n\u0026#34;,x,c[x][0],c[x][1],f[x],sum[x],len[x],w[x],lmax[x],rmax[x],maxs[x]); printf(\u0026#34;Ch: \u0026#34;); for(auto x : Ch[x]) printf(\u0026#34;%d \u0026#34;,x); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;Pa: \u0026#34;); for(auto x : Pa[x]) printf(\u0026#34;%d \u0026#34;,x); printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;--------------------\\n\u0026#34;); } }T; void dfs1(int x,int fa){ for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(v == fa) continue; T.f[v] = x,T.len[v] = l,dfs1(v,x); T.add(x,v); } T.push_up(x); } int n,q; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 2;i\u0026lt;=n;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(a,b,c),addedge(b,a,c); } T.init(n);dfs1(1,0);T.ans = T.maxs[1]; } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); char op[10];int x; for(int i = 1;i\u0026lt;=q;i++){ scanf(\u0026#34;%s\u0026#34;,op); if(op[0] == \u0026#39;A\u0026#39;){ int ans = T.query(); if(ans \u0026gt;= 0) printf(\u0026#34;%d\\n\u0026#34;,ans); else printf(\u0026#34;They have disappeared.\\n\u0026#34;); }else if(op[0] == \u0026#39;C\u0026#39;) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x),T.modify(x); } } int main(){ init(); solve(); return 0; }   ","description":"","id":58,"section":"posts","tags":["数据结构","LCT"],"title":"「SPOJ2666」QTREE4-LCT","uri":"https://blog.chenqiqian.com/posts/spoj2666-qtree4/"},{"content":"小强要在 $N$ 个孤立的星球上建立起一套通信系统。这套通信系统就是连接 $N$ 个点的一个树。 这个树的边是一条一条添加上去的。在某个时刻，一条边的负载就是它所在的当前能够 联通的树上路过它的简单路径的数量。\n现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。\n链接 Luogu P4219\n题解 我们发现其实就是边两端的点的个数乘起来就可以了。\n我们在普通 LCT 的基础上多维护一个 $vsiz$ ，表示虚子树的 $siz$ 的大小之和。\n我们发现这个 $vsiz$ 的维护只需要在 access 和 link 函数里面完成，在这两个函数里面修改微小的一点，注意虚子树的增减即可。\n答案就是两个点对应的虚子树的 $vsiz + 1$ 再乘到一起即可，因为查询的两个点是连在一起的。\n时间复杂度 : $O(n \\log n)$\nLCT 细节一定注意！\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 110000; namespace LCT{ int c[MAXN][2],f[MAXN],siz[MAXN],vsiz[MAXN];bool r[MAXN]; bool noroot(int x){return c[f[x]][0] == x || c[f[x]][1] == x;} void rev(int x){swap(c[x][0],c[x][1]),r[x]^=1;} void push_down(int x){if(r[x]) rev(c[x][0]),rev(c[x][1]),r[x] = 0;} void push_all(int x){ static int S[MAXN];S[0] = 0; S[++S[0]] = x; while(noroot(x)) x = f[x],S[++S[0]] = x; for(int i = S[0];i\u0026gt;=1;--i) push_down(S[i]); } void push_up(int x){ siz[x] = siz[c[x][0]] + siz[c[x][1]] + vsiz[x] + 1; } void init(int n){for(int i = 1;i\u0026lt;=n;i++) push_up(i);} void rotate(int x){ int y = f[x],z = f[y],t = c[y][1] == x,w = (c[x][1-t]); if(noroot(y)) c[z][c[z][1]==y] = x; c[y][t] = w,c[x][1-t] = y; if(w) f[w] = y; f[y] = x,f[x] = z; push_up(y),push_up(x); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ (c[y][1] == x) ^ (c[z][1] == y) ? rotate(x) : rotate(y); }rotate(x); } } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x); vsiz[x] += siz[c[x][1]]; vsiz[x] -= siz[c[x][1] = y]; // 考虑到新接上来的 y 的 f[y] 一定是 x ， 相当于减去一堆虚子树  // push_up(x); 我们注意到 siz[x] 事实上不会变  } } void makeroot(int x){access(x),splay(x),rev(x);} void split(int x,int y){makeroot(x),access(y),splay(y);} void link(int x,int y){ split(x,y); f[x] = y,vsiz[y] += siz[x]; push_up(y); } ll query(int x,int y){ split(x,y); ll a = vsiz[x]+1,b = vsiz[y]+1;// 非子树 siz 就 win 了  return a * b; } } int n,q; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;q); LCT::init(n); } void solve(){ for(int i = 1;i\u0026lt;=q;i++){ char s[5];int x,y; scanf(\u0026#34;%s %d %d\u0026#34;,s,\u0026amp;x,\u0026amp;y); if(s[0] == \u0026#39;A\u0026#39;) LCT::link(x,y); else printf(\u0026#34;%lld\\n\u0026#34;,LCT::query(x,y)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":59,"section":"posts","tags":["数据结构","LCT"],"title":"「BJOI2014」大融合-LCT","uri":"https://blog.chenqiqian.com/posts/bjoi2014-mixture/"},{"content":"输入长度为 $n$ 的串 $S$ ，求 $S$ 的最长双回文子串 $T$,即可将 $T$ 分为两部分$X$ ， $Y$ ， （ $∣X∣,∣Y∣ \\geq 1$ ）且 $X$ 和 $Y$ 都是回文串。\n链接 Luogu P4555\n题解 几乎是模版题。\n正反跑一遍回文自动机，找出每个位置往两个方向的最长回文后缀，加起来就是答案。\n时间复杂度: $O(n)$ 。\n注意 $0$ 和 a 的混淆，务必加上 s[0] = -1 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; struct PAM{ int s[MAXN],c[MAXN][26],fa[MAXN],len[MAXN],tcnt,last; void init(){ s[0] = -1; last = 0,tcnt = 1; fa[0] = fa[1] = 1; len[0] = 0,len[1] = -1; } int getfail(int n,int p){ while(s[n-len[p]-1] != s[n]) p = fa[p]; return p; } int ins(int n,int x){// 返回最长回文后缀长度  s[n] = x; int p = getfail(n,last),\u0026amp;q = c[p][x]; if(!q){ int f = c[getfail(n,fa[p])][x]; q = ++tcnt,len[q] = len[p]+2,fa[q] = f; } last = q; return len[q]; } }A,B; int n;char s[MAXN]; int a[MAXN],b[MAXN]; int main(){ scanf(\u0026#34;%s\u0026#34;,s+1);n = strlen(s+1); A.init(),B.init(); for(int i = 1;i\u0026lt;=n;i++) a[i] = A.ins(i,s[i]-\u0026#39;a\u0026#39;);//,printf(\u0026#34;%d:%d\\n\u0026#34;,i,a[i]);  for(int i = n;i\u0026gt;=1;--i) b[i] = B.ins(n-i+1,s[i]-\u0026#39;a\u0026#39;);//,printf(\u0026#34;%d:%d\\n\u0026#34;,i,b[i]);  int ans = 0; for(int i = 1;i\u0026lt;=n-1;i++) ans = max(ans,a[i]+b[i+1]); printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; }   ","description":"","id":60,"section":"posts","tags":["字符串","回文自动机"],"title":"「国家集训队」最长双回文子串-回文自动机","uri":"https://blog.chenqiqian.com/posts/luogu-4555/"},{"content":"有两个快递员，分别在 $s_1, s_2(0\\le s_1,s_2\\le 10^9)$ 位置。现在有 $n(1\\le n\\le 100000)$ 个任务，需要依次完成，每个任务用一个整数 $x_i$ 表示要将货物送到 $x_i$ 位置，让任何一个快递员到 $x_i$ 都可以。\n由于快递员之间需要有对讲机联系，请你设计一种方案使得两个快递员之间的最长距离最短。\n链接 Codeforces\n题解 我们考虑二分，然后问题就变成了你能不能在二分的限制条件 $M$ 的间距内完成这个问题。\n我们考虑贪心的解决这个问题。如果我们令 $[l_i,r_i]$ 是在走到第 $i$ 个之前的时候，存在合法方案当且仅当存在快递员位于 $[l_i,r_i]$ 而且两个快递员之间距离不超过 $M$ （这样两个快递员都可以移动）。\n我们发现 $[l_n,r_n]$ 应该是 $[x_n-M,x_n+M]$ （比较显然）。\n那么，这个时候我们已经有了 $[l _ {i+1},r _ {i+1}]$ ，我们如何推出 $[l _ {i},r_i]$ 呢？\n我们考虑到进行完第 $i$ 个任务之后，必然会有一位老哥位于 $x_i$ ，那么这个时候如果 $x_i$ 在 $[l _ {i+1},r _ {i+1}]$ 之间，我们只需要满足保证在某老哥走的时候第二个条件时刻满足即可：也就是 $l_i = x_i - M,r_i = x_i+M$ 。 为什么这个是对的呢？我们可以发现，如果一位老哥在这个区间里面，然后剩下一位老哥无论在哪一定可以在满足 $M$ 的限制之下到达 $x_i$ ，然后我们下一轮也就是win的了。\n那如果 $x_i$ 不在 $[l _ {i+1},r _ {i+1}]$ 中呢？那我们考虑有一位老哥就必须在 $[l _ {i+1},r _ {i+1}]$ 中（因为他必然不动），但是他所在的位置还得满足能够让另一位老哥走到 $x_i$ 也能和他保持联系，所以他必须在 $[x_i-M,x_i+M]$。这两个区间求交之后就是答案。\n最后判一下 $[l_1,r_1]$ 就可以了。\n时间复杂度： $O(n \\log C)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; int n,s1,s2,x[MAXN]; bool check(int M){ int L = x[n]-M,R = x[n]+M; for(int i = n-1;i\u0026gt;=1;--i){ if(L \u0026lt;= x[i] \u0026amp;\u0026amp; x[i] \u0026lt;= R) L = x[i] - M,R = x[i] + M; else L = max(L,x[i]-M),R = min(R,x[i]+M); } return (L \u0026lt;= s1 \u0026amp;\u0026amp; s1 \u0026lt;= R) || (L \u0026lt;= s2 \u0026amp;\u0026amp; s2 \u0026lt;= R); } int main(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;s1,\u0026amp;s2); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x[i]); int L = abs(s1-s2),R = 1e9; while(L!=R){int mid = (L+R)/2; if(check(mid)) R = mid; else L = mid+1; } printf(\u0026#34;%d\\n\u0026#34;,L); }   ","description":"","id":61,"section":"posts","tags":["贪心"],"title":"「CF875E」Delivery Club-二分+贪心","uri":"https://blog.chenqiqian.com/posts/cf875e/"},{"content":"给定一个长度为 $n$ 的 $01$ 序列，第 $i$ 位是 $0$ 代表 节点 $i$ 到节点 $i \\bmod n + 1$ 有一条有向边，第 $i$ 位是 $1$ 代表 节点 $i \\bmod n + 1$ 到节点 i 有一条有向边。\n我们称一个节点对 $(u,v)$ 是妙的当且仅当不存在 $u$ 到 $v$ 和 $v$ 到 $u$ 的路径任何两者之一。\n现在你要从这个图里面挑出一个集合，使得集合中任意两个不同的节点 $u$ 和 $v$ 之间构成的节点对 $(u,v)$ 都是妙的。\n请你输出这个集合的大小的最大值。\n链接 Codeforces\n题解 不会做，看了题解也不会做\u0026hellip;看懂题解是不可能看懂的，只好去看看代码过过日子。\n于是研究了一番 rng_58 的代码，大概搞懂了这个题。\n我们把这 $n$ 个点复制一倍，放在一条直线上。我们把具有相同方向的称为一个连续段，其长度为连续的边的数量，然后我们找到一个位置切掉这个序列，相当于断环为链，然后我们发现这个东西可以贪心解决了。\n我们如果遇到一个长度大于等于 2 的，我们就把答案 + 1，然后在两个长度大于等于 2 的之间，全都是长度大于等于 1 的，我们发现这样的话，为了不影响到长度大于等于 2 的，我们能取的个数就是 $\\frac{len}{2}$ 。然后就可以计算答案了。\n如果不存在长度大于等于 2 的序列，那么我们的答案就是 $\\frac{n}{2}$\n贪心的去想一想，很有正确的道理。\n时间复杂度： $O(n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;bits/stdc++.h\u0026gt;#define ui unsigned using namespace std; ui n,st; string s,t; int main(){ cin \u0026gt;\u0026gt; s;n = s.length(); s = s+s; for(ui i = 1;i\u0026lt;s.length();i++){ if(s[i] != s[i-1]){st = i;break;} } s = s.substr(st,n); int ans = 0; for(ui i = 0;i \u0026lt; s.length();){ for(ui j = i+1;;j++){ if(j == s.length() || s[j] != s[i]){ t.push_back(j - i == 1?\u0026#39;1\u0026#39;:\u0026#39;2\u0026#39;); i = j; break; } } } int M = t.length(); t = t + t; for(int i = 1;i\u0026lt;=M;i++){ if(i == M || t[i] != t[i-1]){ t = t.substr(i,M); break; } } for(ui i = 0;i\u0026lt;t.length();){ for(ui j = i+1;;j++){ if(j == t.length() || t[j] != t[i]){ ans += (j-i) / (t[i]==\u0026#39;1\u0026#39;?2:1); i = j; break; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   ","description":"","id":62,"section":"posts","tags":["乱搞"],"title":"「CF353E」 Antichain-乱搞","uri":"https://blog.chenqiqian.com/posts/cf353e/"},{"content":"一棵树上有 $n$ 个节点，把每个节点染成黑色或白色，要求叶子节点一半是黑色，一半是白色（保证叶子节点的个数是偶数）。\n求在满足要求的情况下，最小的两端颜色不同的边的数量。\n链接 Codeforces\n题解 我们考虑树形dp，令 $dp[x][v][0/1]$ 表示节点 $x$ 代表的子树里面，为白色的叶子节点有 $v$ 个，$x$ 节点的颜色是白色（0）还是黑色（1）的情况下，最小的两端颜色不同的边的数量。\n然后我们可以用那种 $O(n^2)$ 完成树形 dp 的套路去搞它就可以了。\n然后转移的时候还要枚举第三维是 0 还是 1 ，然后计算贡献，不要忘掉（\n这个跟普通的树形dp不太一样，需要在开始的时候多特殊判断一些，而且你加入子树更新dp数组的时候不能遗传这个数组，只能用新算出来的数来更新。\n时间复杂度：$O(n^2)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 5100; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } int n; int in[MAXN],siz[MAXN],sum,rt = 0; int dp[MAXN][MAXN][2];// dp[x][v][0/1] v 个白色的 void dfs(int x,int fa){ if(in[x] == 1){ siz[x] = 1,dp[x][1][0] = 0,dp[x][0][1] = 0; return; } int f = 0; for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == fa) continue; dfs(v,x); if(f == 0){ for(int k = 0;k \u0026lt;= siz[v];k++){ dp[x][k][1] = min(dp[v][k][0]+1,dp[v][k][1]); dp[x][k][0] = min(dp[v][k][1]+1,dp[v][k][0]); } } else{ for(int j = siz[v] + siz[x];j \u0026gt;= 0;j--){ int tmp[2] = {0x3f3f3f3f,0x3f3f3f3f}; for(int k = 0;k \u0026lt;= min(j,siz[v]);k++){ // dp[x][j-k] 与 dp[v][k] 之间的碰撞和激情  tmp[1] = min(tmp[1],dp[x][j-k][1] + min(dp[v][k][0]+1,dp[v][k][1])); tmp[0] = min(tmp[0],dp[x][j-k][0] + min(dp[v][k][1]+1,dp[v][k][0])); } dp[x][j][0] = tmp[0],dp[x][j][1] = tmp[1]; } } f = 1; siz[x] += siz[v]; } } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 2;i\u0026lt;=n;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); in[a]++,in[b]++; } for(int i = 1;i\u0026lt;=n;i++){ if(in[i] == 1) sum++; if(in[i] \u0026gt; in[rt]) rt = i; } } void solve(){ if(n == 2){printf(\u0026#34;1\\n\u0026#34;);return;} memset(dp,0x3f,sizeof(dp)); dfs(rt,0); printf(\u0026#34;%d\\n\u0026#34;,min(dp[rt][sum/2][0],dp[rt][sum/2][1])); } int main(){ init(); solve(); return 0; }   ","description":"","id":63,"section":"posts","tags":["动态规划","树形dp"],"title":"「CF581F」 Zublicanes and Mumocrates - 树形dp","uri":"https://blog.chenqiqian.com/posts/cf581f/"},{"content":"我们定义\n$$\nJ(x) = \\sum _ {d | x} [\\gcd(x,\\frac{x}{d}) = 1] d\n$$\n请你求出 $J(x) = A$ 有多少个 $x$ 满足条件。\n链接 Codeforces\n题解 我们可以发现，这个 $J(x)$ 是一个积性函数。\n所以如果 $x = {p_1}^{k_1}{p_2}^{k_2}\\cdots{p_m}^{k_m}$ ，那么 $J(x) = J({p_1}^{k_1})J({p_2}^{k_2})\\cdots J({p_m}^{k_m}) = ({p_1}^{k_1}+1)({p_2}^{k_2}+1)({p_m}^{k_m}+1)$\n所以问题变成了我们有多少种对 $A$ 形如上面形式的不同分解。\n我们考虑求出所有 $A$ 的约数，记为 $d_1,d_2,\u0026hellip;,d_n$ 。我们考虑哪些 $p$ 可能用来组成 $A$ 。如果 $p$ 可以被用来组成 $A$ ，那么 $A$ 的约数里面肯定存在一个约数减去 $1$ 之后是 $p$ 的若干次方。\n我们把所有的约数减去 $1$ 之后直接分解质因数，这个过程的复杂度大概是：\n$$\n\\sqrt 1 + \\sqrt 2 + \u0026hellip; + \\sqrt{\\sqrt{n}} + \\sqrt \\frac{n}{1} + \\sqrt{\\frac{n}{2}} + \u0026hellip; + \\sqrt{\\frac{n}{n}}\n$$\n不会证明，但可以过吧（\n然后我们就得到了所有可以组成 A 的质数 $p_1,\u0026hellip;,p_k$，这样的质数不会很多，我们发现这样的质数不会超过 $\\sigma_0(n) \\approx \\sqrt[3]{n}$ 。\n我们考虑 $dp$ , 令 $dp[i][j]$ 表示使用前 $i$ 个质数拼出来第 $j$ 个约数的方案数。\n转移的话，每次加入一个质数，对于所有的 $j$，我们都乘上这个质数若干次，然后更新答案。什么？你说复杂度？不会证不会证，反正能过就行（\n最后 $dp[k][n]$ 就是答案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 10000; ll A; ll p[MAXN],k,d[MAXN],n; map\u0026lt;ll,int\u0026gt; div_pos;set\u0026lt;ll\u0026gt; vis; ll dp[MAXN];// 滚动数组  int main(){ cin \u0026gt;\u0026gt; A; for(ll i = 1;i*i\u0026lt;=A;i++) if(A % i == 0){ d[++n] = i; if(i * i != A) d[++n] = A/i; } sort(d + 1,d + n + 1); // for(int i = 1;i\u0026lt;=n;i++){  // printf(\u0026#34;%d:%lld\\n\u0026#34;,i,d[i]);  // }  for(int t = 1;t\u0026lt;=n;t++){ ll x = d[t]; div_pos[x] = t;x -= 1; bool flag = 0; for(ll i = 2;i * i \u0026lt;= x;i++){ if(x % i == 0){ flag = 1; while(x % i == 0) x /= i; if(x == 1 \u0026amp;\u0026amp; !vis.count(i)) p[++k] = i,vis.insert(i); break; } } if(flag == 0 \u0026amp;\u0026amp; x \u0026gt; 1 \u0026amp;\u0026amp; !vis.count(x)) p[++k] = x,vis.insert(x); } sort(p+1,p+k+1); dp[1] = 1; for(int i = 1;i\u0026lt;=k;i++){ for(int j = n;j\u0026gt;=1;j--){ if(dp[j] == 0) continue; for(ll w = p[i];log2(d[j]) + log2(w+1) \u0026lt;= log2(1.5*A);w *= p[i]){ if(div_pos.count(d[j]*(w+1))){ dp[div_pos[d[j]*(w+1)]] += dp[j]; } } } } printf(\u0026#34;%lld\\n\u0026#34;,dp[n]); return 0; }   ","description":"","id":64,"section":"posts","tags":["动态规划","数学"],"title":"「CF542D」Superhero's Job - dp + 数论","uri":"https://blog.chenqiqian.com/posts/cf542d/"},{"content":"  Stay simple. Stay naïve.\n自歌自舞自开怀。\n 恭喜你！发现了一个蒟蒻的小站。\ncqqqwq 是某高中开始学 OI 的蒟蒻，现已跳入计算机天坑。\n曾就读于北京市第一七二中学，现就读于五道口职业技工学校。\ncqqqwq 不定期更新博客，主要内容包括日常、算法、题解。\n邮箱  cqqqwq@outlook.com cqqqwq@gmail.com  ","description":"cqqqwq的自我介绍。","id":65,"section":"","tags":null,"title":"关于我","uri":"https://blog.chenqiqian.com/about/"},{"content":"Hi, my friends.\n","description":"cqqqwq的朋友们。","id":66,"section":"","tags":null,"title":"朋友们","uri":"https://blog.chenqiqian.com/friends/"},{"content":"给定一个含有 $n$ 个点， $m$ 条边的森林。有 $q$ 个询问，每次给出两个点 $u_i,v_i$ ，如果 $u_i$ 在联通块 $A$ 内，$v_i$ 在联通块 $B$ 内，我们随机选择两个点 $a \\in A,b \\in B$ ，我们在 $(a,b)$ 之间连一条边，如果这个连接成后新联通块不构成一个树，输出 $-1$ ，否则输出新联通块树的直径的期望。所有边权均为 $1$ 。\n链接 Codeforces\n题解 如果 $u,v$ 在同一个联通块里面，输出 $-1$ 。\n我们有一个结论：我们连接 $a,b$ 两点时，我们的直径只可能有两种可能：\n $\\max($ $A$ 联通块的直径，$B$ 联通块的直径 $)$ $a$ 点出发的最长路径 + $b$ 点出发的最长路径 + 1 （各联通块内）  我们考虑第一个很好求，设其为 $D$。那么我们的答案就是：\n$$\nans_i = \\frac{1}{siz[A] \\times siz[B]}\\sum _ {a \\in A,b \\in B} max(D,d(a) + d(b) + 1)\n$$\n我们令 $d(a) + d(b) + 1 \u0026gt;= D$ 的数对 $(a,b)$ 的数目为 $cnt_i$ ，其（$d(a) + d(b) + 1$）和为 $sum_i$ ，那么化简之后：\n$$\nans_i = \\frac{D \\times (siz[A] \\times siz[B]-cnt_i) + sum_i}{siz[A] \\times siz[B]}\n$$\n我们现在只需要求出 $cnt_i$ 和 $sum_i$ 。\n接下来就是玄幻的过程了。\n我们令两个联通块中比较小的联通块为 $A$ ，另一个为 $B$，我们计算 $d$ 数组前缀和之后用二分的办法计算答案，复杂度应当是 $O(siz[A] * log(siz[B]))$（并且用 map 进行记忆化）。\n如果 $siz[A] \u0026lt; \\sqrt n$ ，那么我们单次询问的复杂度不会超过 $O(\\sqrt n \\log n)$ ，总体复杂度是 $O(q \\sqrt n \\log n)$ 。\n否则 $siz[A] \u0026gt; \\sqrt n$，那么我们记忆化之后，我们注意到满足 $siz[A] \u0026gt; \\sqrt n$ 的树只会有少于 $\\sqrt n$ 个，所以我们每个$siz[A]$ 最多被计算 $O(\\sqrt n)$ 次，所以就可以做到 $O(\\sum siz[A] * \\sqrt n\\log n)$ ，也就是 $O(n \\sqrt n \\log n)$。\n所以最后的时间复杂度就是 $O((n+q) \\sqrt n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long #define db double using namespace std; const int MAXN = 110000; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } int n,m,q; int R[MAXN]; vector\u0026lt;int\u0026gt; d[MAXN]; vector\u0026lt;ll\u0026gt; s[MAXN]; int tmp[MAXN]; int dis[MAXN],vis[MAXN],col[MAXN],cnt; int maxid; void dfs(int nown,bool is_it_rated = 0,int f = 0){ if(dis[nown] \u0026gt; dis[maxid]) maxid = nown; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == f) continue; dis[v] = dis[nown] + 1; dfs(v,is_it_rated,nown); } if(is_it_rated){ vis[nown] = 1,col[nown] = cnt; tmp[nown] = max(tmp[nown],dis[nown]); } } void getv(int nown,int f = 0){ d[cnt].push_back(tmp[nown]); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == f) continue; getv(v,nown); } } void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;q); for(int i = 1;i\u0026lt;=m;i++){ int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); addedge(u,v),addedge(v,u); } } void cal(int x){ ++cnt; d[cnt].push_back(-1e9); int u,v; maxid = 0,dis[x] = 0,dfs(x);u = maxid; dis[u] = 0,dfs(u);v = maxid; R[cnt] = dis[v]; dis[u] = 0,dfs(u,1);dis[v] = 0,dfs(v,1); getv(x); sort(d[cnt].begin(),d[cnt].end()); s[cnt].resize(d[cnt].size()); s[cnt][0] = 0; for(unsigned i = 1;i\u0026lt;s[cnt].size();i++) s[cnt][i] = s[cnt][i-1] + d[cnt][i]; } void build(){ dis[0] = -1; for(int i = 1;i\u0026lt;=n;i++){ if(vis[i] == 0) cal(i); } } map\u0026lt;pair\u0026lt;int,int\u0026gt;,double\u0026gt; S; double query(int u,int v){ u = col[u],v = col[v]; if(d[u].size() \u0026gt; d[v].size()) swap(u,v); if(S.count(make_pair(u,v))) return S[make_pair(u,v)]; int D = max(R[u],R[v]); ll us = (int)(d[u].size())-1,vs = (int)(d[v].size())-1; double cnt = 0,sum = 0; for(int i = 1;i \u0026lt;= us;i++){ int T = D - d[u][i] - 1;// 只要大于等于 T 就可以算 cnt  int t = lower_bound(d[v].begin(),d[v].end(),T) - d[v].begin(); cnt += db(vs-t+1),sum += db(s[v][vs] - s[v][t-1]) + db(vs-t+1) * (d[u][i]+1); } return S[make_pair(u,v)] = (db(D)*(us*vs-cnt)+sum) / (us*vs); } void solve(){ for(int i = 1;i\u0026lt;=q;i++){ int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); if(col[u] == col[v]) printf(\u0026#34;-1\\n\u0026#34;); else printf(\u0026#34;%.10lf\\n\u0026#34;,query(u,v)); } } signed main(){ init(); build(); solve(); return 0; }   ","description":"","id":67,"section":"posts","tags":["乱搞","树的直径"],"title":"「CF804D」Expected diameter of a tree-树的直径+乱搞","uri":"https://blog.chenqiqian.com/posts/cf804d/"},{"content":"给定 $n$ 个长度均为 $m$ 的字符串，再给出一个 $n$ 行 $m$ 列的矩阵 ${a _ {nm}}$。\n矩阵元素 $a _ {ij}$ 代表把第 $i$ 个字符串第 $j$ 个字符改成其它任意字符所需要的代价。\n现在要求对于任意一个字符串，总存在某一位置 $j$ 使得该位置上的字符在任意其他字符串该位置的字符不同。\n即为对于第 x 个字符串 ，有 $\\exists j \\in [1,m] , \\forall i \\in [1,n],s _ {xj} \\neq s _ {ij}$ 。\n求把所有字符串修改成满足上述要求的字符串的最小代价是多少？\n数据范围： $1 \\le n,m \\le 20,1\\le a _ {ij} \\le 10^6$ 。\n题解 我们发现，无论其他字符串是什么情况，我们总能找到在这一位没有用过的字符，这也是后面dp正确性的保障。\n我们状态压缩一波，令 $dp[S]$ 表示在 $S$ 中为 $1$ 的这些都已经好记了的情况下，想要好记还需要多少代价。\n我们注意到，它们的更改应当是不会干扰的（我都改到从没人用过的），所以我们每次都考虑最靠左的不是 $1$ 的位置，把它变成 $1$ 。我们依次考虑每列，我们有两种办法：\n 把这个字符串的这个字符改了 把这个字符串这个位置上所有拥有和它一样的字符的字符串的这个位置都改掉，只剩下一个 $a$ 最大的  分类讨论转移即可。\n时间复杂度 $O(m 2 ^ n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int N = 21,MAXN = (1\u0026lt;\u0026lt;N); int n,m,dp[MAXN]; int a[N][N];char s[N][N]; int ss[N][N],ms[N][N];// ss 与 s[i][j] 同列相同的集合列表, ms ... 减去最大的  void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%s\u0026#34;,s[i]+1); for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m;j++){ ss[i][j] = (1\u0026lt;\u0026lt;(i-1)); ms[i][j] = a[i][j];int sum = a[i][j]; for(int k = 1;k\u0026lt;=n;k++)if(i != k){ if(s[i][j] == s[k][j]){ ss[i][j] |= (1\u0026lt;\u0026lt;(k-1)); ms[i][j] = max(a[k][j],ms[i][j]); sum += a[k][j]; } } ms[i][j] = sum - ms[i][j]; } } } int dfs(int S){ if(dp[S] \u0026lt; inf) return dp[S]; if(S == (1\u0026lt;\u0026lt;n)-1) return 0; int ans = inf,low; for(int i = 1;i\u0026lt;=n;i++){ if((S \u0026amp; (1\u0026lt;\u0026lt;(i-1))) == 0){ low = i;break; } } for(int j = 1;j\u0026lt;=m;j++) ans = min(ans,min( dfs(S|(1\u0026lt;\u0026lt;(low-1))) + a[low][j], dfs(S|ss[low][j]) + ms[low][j])); return dp[S] = ans; } int main(){ init(); memset(dp,0x3f,sizeof(dp)); printf(\u0026#34;%d\\n\u0026#34;,dfs(0)); return 0; }   ","description":"","id":68,"section":"posts","tags":["动态规划","状压dp"],"title":"「CF543C」Remembering Strings-状态压缩dp","uri":"https://blog.chenqiqian.com/posts/cf543c/"},{"content":"Ciel 狐狸在游乐园里排队等待上摩天轮。现在有 $n$ 个人按编号顺次在队列里，有 $m$ 条船，第 $i$ 条船到时，前 $q _ {i}$ 个人可以上船。保证 $\\sum q_i = n$。 人总是不愿意和陌生人上同一条船的，当第 $i$ 个人与第 $j$ 个人处于同一条船上时，会产生 $u _ {i,j}$ 的沮丧值。请你求出最小的沮丧值和。一条船上的人两两都会产生沮丧值，不会计算这个沮丧值两次。\n链接 Codeforces\n题解 我们注意到我们有一个简单的转移方程：\n$$\ndp[i][j] = \\min _ {1 \\le p \u0026lt; i}(dp[p][j-1] + g(p+1,j))\n$$\n其中 $g(i,j)$ 表示从 $i$ 到 $j$ 中选中所有人需要耗费的代价。\n这个东西的复杂度是 $O(n^2m)$ ， 我们可以用决策单调性优化到 $O(nm \\log n)$ ，但是这个不足以过掉该题，我们可以使用 wqs 二分 + 决策单调性优化到 $O(n \\log n \\log m)$ 。\n需要注意的是这里的代价应当是负的，也就是我们需要加上代价。（差不多啦\n需要读入优化。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; namespace fast_io { inline char read(){static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;} inline void read(int \u0026amp;x){static bool iosig;static char c;for (iosig=false,c=read();!isdigit(c);c=read()){if(c==\u0026#39;-\u0026#39;)iosig=true;if(c==-1)return;}for(x=0;isdigit(c);c=read())x=((x+(x\u0026lt;\u0026lt;2))\u0026lt;\u0026lt;1)+(c^\u0026#39;0\u0026#39;);if(iosig)x=-x;} }using namespace fast_io; const int MAXN = 4100; int n,m; char tmp[MAXN*2]; int a[MAXN][MAXN],s[MAXN][MAXN];// 前 i 个与前 j 个的答案  int G(int x,int y){// 第 x 个到第 y 个的答案，x \u0026lt;= y  return (s[y][y] - 2 * s[x-1][y] + s[x-1][x-1])/2; } int dp[MAXN],siz[MAXN],fi,la; struct Node{ int p,l,r; Node(int _p = 0,int _l = 0,int _r = 0){p = _p,l = _l,r = _r;} }; Node q[MAXN];//[fi,la]  void reset(){dp[0] = siz[0] = la = 0;fi = 1;} int cal(int now,int last,int k){return dp[last] + G(last+1,now) + k;} int check(int k){// k 为代价，每个都加上一个 k ，因为斜率是负数  // 不限分段个数，考虑 dp[i] 为前 i 个分若干段的最小值，每分一段要加一个 k x  reset(); q[++la] = Node(0,1,n); for(int i = 1;i\u0026lt;=n;i++){ while(fi \u0026lt; la \u0026amp;\u0026amp; q[fi].r \u0026lt; i) fi++; dp[i] = cal(i,q[fi].p,k),siz[i] = siz[q[fi].p] + 1; // 为什么对新来的这么不友好？？？  if(cal(n,q[la].p,k) \u0026lt;= cal(n,i,k)) continue; while(fi \u0026lt; la \u0026amp;\u0026amp; cal(q[la].l,q[la].p,k) \u0026gt; cal(q[la].l,i,k)) la--; int L = q[la].l,R = q[la].r + 1;// 二分决策点  while(L!=R){ int mid = (L+R)/2; if(cal(mid,q[la].p,k) \u0026gt; cal(mid,i,k)) R = mid; else L = mid+1; } q[la].r = L-1; q[++la] = Node(i,L,n); } // 最优分几段？  return siz[n]; } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=n;j++){ read(a[i][j]); s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]; } } void solve(){ int L = 0,R = s[n][n]; while(L != R){ int mid = (L+R)/2; if(check(mid) \u0026lt;= m) R = mid; else L = mid+1; } check(L); printf(\u0026#34;%d\\n\u0026#34;,dp[n] - L*m); } int main(){ init(); solve(); return 0; }   ","description":"","id":69,"section":"posts","tags":["动态规划","wqs二分","决策单调性"],"title":"「CF321E」Ciel and Gondolas-wqs二分+决策单调性","uri":"https://blog.chenqiqian.com/posts/cf321e/"},{"content":"有 $n$ 本书，第 $i$ 本书中有 $a_i$ 个问题，均属于第 $t_i$ 类问题。\n有 $q$ 次询问，每次询问给出一个区间 $[l_i,r_i]$ ，询问有多少个原序列的连续子区间是给出区间的子区间，且该子区间中所有书中问题的和满足第 $1$ 类的问题恰好比第 $2$ 类的问题恰好多 $k$ 个。\n数据范围： $1 \\le n \\le 10^5$ , $-10^9 \\le k \\le 10^9$, $t_i \\in {1,2}$ , $0 \\le a_i \\le 10^9$ , $1 \\le q \\le 10^5$ , $1 \\le l_i \\le r_i \\le n$\n链接 Codeforces\n题解 看到离线的区间询问让我们想到莫队（其实是前几天THUWC没做出来签到题让我想到的），然后我们发现我们可以做到相邻的区间转移。这个问题事实上就是前缀和相差 $k$ ，我们用个什么东西（比如 map ）离散化一下所有的 sum 前缀和，预处理出来每个位置的前缀和减掉和加上 $k$ 之后的离散化后的数字。在莫队的过程中维护一个 $cnt$ 数组，就可以 $O(1)$ 转移了。\n时间复杂度：$O(q \\sqrt n + n \\log n )$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 110000; int n,q,Q; int t[MAXN],a[MAXN]; ll k,sum[MAXN],A[MAXN],B[MAXN];// A -\u0026gt; -k / B -\u0026gt; +k map\u0026lt;ll,int\u0026gt; S;int tmpcnt = 0; struct Query{ int l,r,id; }qu[MAXN]; bool cmp(Query a,Query b){ if(a.l/Q != b.l/Q) return a.l / Q \u0026lt; b.l / Q; else return ((a.l/Q)\u0026amp;1)?a.r \u0026lt; b.r:a.r \u0026gt; b.r; } void init(){ scanf(\u0026#34;%d %lld\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;t[i]); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i = 1;i\u0026lt;=n;i++){ sum[i] = t[i] == 1?a[i]:-a[i]; sum[i] += sum[i-1]; S[sum[i]] = 0; } S[0] = 0; for(auto it = S.begin();it != S.end();it++) it-\u0026gt;second = ++tmpcnt; for(int i = 0;i\u0026lt;=n;i++){ if(S.count(sum[i]-k)) A[i] = S[sum[i]-k]; if(S.count(sum[i]+k)) B[i] = S[sum[i]+k]; sum[i] = S[sum[i]]; } Q = sqrt(n); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;qu[i].l,\u0026amp;qu[i].r),qu[i].id = i; sort(qu+1,qu+q+1,cmp); } static int cnt[MAXN],L = 1,R = 0;// 维护 [L-1,R] 的前缀和 ll ans = 0; void addL(int pos){ ans += cnt[B[pos-1]];cnt[sum[pos-1]]++; } void addR(int pos){ ans += cnt[A[pos]];cnt[sum[pos]]++; } void delL(int pos){ cnt[sum[pos-1]]--;ans -= cnt[B[pos-1]]; } void delR(int pos){ cnt[sum[pos]]--;ans -= cnt[A[pos]]; } ll ANS[MAXN]; void solve(){ cnt[S[0]] = 1; for(int i = 1;i\u0026lt;=q;i++){ while(qu[i].l \u0026lt; L) addL(--L); while(qu[i].r \u0026gt; R) addR(++R); while(qu[i].l \u0026gt; L) delL(L++); while(qu[i].r \u0026lt; R) delR(R--); ANS[qu[i].id] = ans; } for(int i = 1;i\u0026lt;=q;i++){ printf(\u0026#34;%lld\\n\u0026#34;,ANS[i]); } } int main(){ init(); solve(); return 0; }   ","description":"","id":70,"section":"posts","tags":["数据结构","莫队"],"title":"「CF877F」Ann and Books-莫队","uri":"https://blog.chenqiqian.com/posts/cf877f/"},{"content":"Dreamoon 有一个字符串 $s$ 和一个模式串 $p$ ，他会先从 $s$ 中删除恰好 $x$ 个字符来产生一个新的字符串 $s'$ 。然后他会计算 $occ(s',p)$，即从 $s'$ 中能找到的等于 pp 的不相交的子串数量的最大值。他想让 $occ(s',p)$ 的值尽可能大。\n更形式地说，让我们用 $ans(x)$ 表示所有可以从 $s$ 中删去恰好 $x$ 个字符得到的 $s'$ 中 $occ(s',p)$ 的最大值。Dreamoon 想要知道对于所有的 $x$ $(0 \\leq x \\leq |s|)$， $ans(x)$ 的值。\n题解 这题我用了一个极其麻烦的 $dp$，需要记录四个数组，有一大堆细节，我简略地说下。\n$f[i][j]$ 表示在 $s$ 串前 $i$ 位，当前匹配到 $p$ 串第 $j$ 位，$p$ 串最靠右时，第一位的位置。\n$h[i]$ 表示在 $s$ 串前 $i$ 位，匹配一个完整的 $p$ 串，$p$ 串最靠右时，需要使这个子序列变成子串的最小代价。\n$g[i][j]$ 表示在 $s$ 串的前 $i$ 位，前面出现完整的 $j$ 次 $p$ 串时，第一次出现的 $p$ 串最靠右时，第一次出现的 $p$ 串的第一个位置。\n$p[i][j]$ 表示如上条件下的代价是多少。\n计算出如上四个数组之后，我们计算出 $\\text{minlen}[i]$ ，意为搞出 $i$ 个 $p$ 串的最小代价。\n然后对于每一个 $i$ ，当 $t \\in [\\text{minlen}[i-1],\\text{minlen[i]-1]}$ ， $ans(t) = i$ 。后面还有一些就是逆序的递增数列，如 $\u0026hellip;444333222111000$ ，长度取决于最大能搞出来多少个。\n反正超级麻烦，但是过掉了2333\n时间复杂度和空间复杂度都是 $O(n^2)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 2100; int n,m; char s[MAXN],t[MAXN]; int last[MAXN][30]; int f[MAXN][MAXN],h[MAXN]; int g[MAXN][MAXN],p[MAXN][MAXN]; void init(){ scanf(\u0026#34;%s\u0026#34;,s+1),scanf(\u0026#34;%s\u0026#34;,t+1); n = strlen(s+1),m = strlen(t+1); } void build(){ static int l[30]; for(int i = 1;i\u0026lt;=n;i++){ for(int c = 0;c\u0026lt;26;c++) last[i][c] = l[c]; l[s[i]-\u0026#39;a\u0026#39;] = i; } } void solve(){ h[0] = 0x3f3f3f3f; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m;j++){ if(s[i] == t[j]){ f[i][j] = (j == 1?i:f[i-1][j-1]); if(j == m) h[i] = (i - f[i][m] + 1 - m); } else{ f[i][j] = f[i-1][j]; if(j == m) h[i] = h[i-1]; } if(f[i][j] == f[i-1][j]) h[i] = min(h[i],h[i-1]); } } static int minl[MAXN],ans[MAXN],maxn = 0; memset(minl,0x3f,sizeof(minl)); for(int j = 1;j\u0026lt;=n;j++){ for(int i = 1;i\u0026lt;=n;i++){ if(f[i][m]){ g[i][j] = (j == 1?f[i][m]:g[f[i][m]-1][j-1]); p[i][j] = (j == 1?h[i] :p[f[i][m]-1][j-1] + h[i]); } else{ g[i][j] = g[i-1][j]; p[i][j] = p[i-1][j]; } if(g[i-1][j]) p[i][j] = min(p[i][j],p[i-1][j]); if(g[i][j]){ minl[j] = min(minl[j],p[i][j]); maxn = max(maxn,j); if(p[i][j] == 0) ans[0] = max(ans[0],j); } } } minl[0] = 1,minl[n+1] = 0x3f3f3f3f; for(int i = 1;i\u0026lt;=n;i++){ for(int x = minl[i-1];x \u0026lt;= min(minl[i]-1,n);x++) ans[x] = i-1; } for(int i = n;i\u0026gt;=1;--i){ if((n-i+1) \u0026gt; maxn * (m)+1) break; ans[i] = ((i + m \u0026gt; n)?0:ans[i+m]+1); } for(int i = 0;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,ans[i]); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":71,"section":"posts","tags":["动态规划"],"title":"「CF476E」Dreamoon and Strings-动态规划","uri":"https://blog.chenqiqian.com/posts/cf476e/"},{"content":"给定长度为 $n$ 的整数序列 $h[n]$ ，有 $Q$ 个询问，每次给出 $l_1,r_1$ ，​询问有多少对 $l_2,r_2$ ，满足以下条件:\n $r_2 – l_2 = r_1 – l_1$ 区间 $[l_1, r_1]$ 与区间 $[l_2, r_2]$ 没有交集 对于任意 $i \\in [0,r_1 – l_1]$ ，满足 $h[l_1 + i] + h[l_2 + i] = h[l_1] + h[l_2]$  链接 Codeforces\n题解 注意到第三个条件可以转化成\n$$\nh[l_1 + i + 1] + h[l_2 + i + 1] = h[l_1 + i] + h[l_2 + i],\n\\ i \\in [0,r_i-l_i-1]\n$$\n也就是\n$$\nh[l_1 + i + 1] - h[l_1 + i] = - (h[l_2 + i + 1] - h[l_2 + i])\n\\ i \\in [0,r_i-l_i-1]\n$$\n我们令 $g[i] = h[i+1] - h[i]$，那么第三个条件的表述就变为：\n$$\ng[l_1+i] = -g[l_2+i]\n\\ i \\in [0,r_i-l_i-1]\n$$\n如果我们令 $len = r_i-l_i-1$ ，那么条件变成：\n$$\ng[l_1\u0026hellip;l_1+len] = - g[l_2\u0026hellip;l_2+len]\n$$\n后缀数组处理之后，就变成了一个二维数点的问题，随便怎么搞一搞就可以了。\n这里用了主席树实现。要特判 $l = r$ 的情况，答案是 $n-1$ 。注意要排除掉相交的情况，需要加一减一，这个地方比较容易错\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 210000,LOGN = 20; namespace SA{ int s[MAXN],sa[MAXN],ht[MAXN],x[MAXN],y[MAXN],rk[MAXN],cnt[MAXN]; void get_sa(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] == s[sa[i-1]]?m:++m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k = j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i] - j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]] == y[sa[i-1]] \u0026amp;\u0026amp; y[sa[i]+j] == y[sa[i-1]+j]?m:++m); } } void get_height(int n){ for(int i = 0,h = ht[0] = 0;i\u0026lt;n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n \u0026amp;\u0026amp; j+h\u0026lt;n \u0026amp;\u0026amp; s[i+h] == s[j+h]) h++; ht[rk[i]] = h; if(h) --h; } } void solve(int n,int m,int *a){ for(int i = 0;i\u0026lt;n;i++) s[i] = a[i]; s[n++] = 0; get_sa(n,m),get_height(n); } } namespace ST{ int minn[MAXN][LOGN]; void init(int n,int *a){ for(int i = 1;i\u0026lt;=n;i++) minn[i][0] = a[i]; for(int j = 1;j\u0026lt;LOGN;j++) for(int i = 1;i + (1\u0026lt;\u0026lt;(j-1)) \u0026lt;= n;i++) minn[i][j] = min(minn[i][j-1],minn[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } int query(int l,int r){ int t = log2(r-l+1); return min(minn[l][t],minn[r-(1\u0026lt;\u0026lt;t)+1][t]); } } int _q(int l,int r){ return l == r ? inf : ST::query(l+1,r); } int rt[MAXN]; namespace CMT{ int ls[MAXN*LOGN],rs[MAXN*LOGN],sumn[MAXN*LOGN],cnt; #define mid ((l+r)/2)  void insert(int \u0026amp;nown,int pre,int l,int r,int pos,int v){ nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre],sumn[nown] = sumn[pre]; if(l == r) sumn[nown] += v; else{ if(pos \u0026lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,v); if(pos \u0026gt;= mid+1) insert(rs[nown],rs[pre],mid+1,r,pos,v); sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]]; } } int query(int nown,int l,int r,int ql,int qr){ if(!nown) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sumn[nown]; else{ int ans = 0; if(ql \u0026lt;= mid) ans += query(ls[nown],l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans += query(rs[nown],mid+1,r,ql,qr); return ans; } } #undef mid } map\u0026lt;int,int\u0026gt; S; int n,len,m,q,h[MAXN],g[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0;i\u0026lt;n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;h[i]); if(i) g[i-1] = h[i] - h[i-1]; } g[n-1] = h[n]-h[n-1],g[n] = 2e9+1; len = 2*n+1; for(int i = 1;i\u0026lt;=n;i++) g[n+i] = -g[i-1]; for(int i = 0;i\u0026lt;len;i++) S[g[i]] = 0; for(auto it = S.begin();it != S.end();it++) it-\u0026gt;second = ++m; m++; for(int i = 0;i\u0026lt;len;i++) g[i] = S[g[i]]; } int query_cmt(int lb,int rb,int l,int r){ return CMT::query(rt[rb],0,len,l,r) - CMT::query(rt[lb-1],0,len,l,r); } int query(int L,int R){ if(L == R) return n-1; int pos = SA::rk[L],l = R-L,lb,rb; int LL = 0,RR = pos; while(LL != RR){ int mid = (LL+RR)/2; if(_q(mid,pos) \u0026gt;= l) RR = mid; else LL = mid+1; } lb = LL; LL = pos,RR = len; while(LL != RR){ int mid = (LL+RR+1)/2; if(_q(pos,mid) \u0026gt;= l) LL = mid; else RR = mid-1; } rb = LL; return query_cmt(lb,rb,n+1,len) - query_cmt(lb,rb,max(n+1,n+L-l+1),n+R+1); return 0; } void solve(){ SA::solve(len,m,g),ST::init(len,SA::ht); for(int i = 1;i\u0026lt;len;i++) CMT::insert(rt[i],rt[i-1],0,len,SA::sa[i],1); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++){ int l,r; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;l,\u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;,query(l-1,r-1)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":72,"section":"posts","tags":["后缀数组","主席树","字符串","数据结构"],"title":"「CF232D」Fence-后缀数组+主席树","uri":"https://blog.chenqiqian.com/posts/cf232d/"},{"content":"我们有 $n$ 个集合，第 $i$ 个集合有 $m_i$ 个数（$1$ 到 $n$ 中的整数），权值为 $w_i$ 。\n现在请你从中选出 $k$ （$k$ 为任意 $0$ 到 $n$ 中的整数）个集合，满足这 $k$ 个集合的并集的大小为 $k$ ，询问这 $k$ 个集合的权值和最小值。\n保证从这 $n$ 选出任意 $x$ 个集合，他们的并集大小不小于 $k$ 。\n链接 Codeforces\n题解 熟悉二分图那套理论的同学很快就会发现，题目中给出的条件：任意 $k(1 \\le k \\le n)$ 个集合的并集的大小都不小于 $k$ ，可以转化成霍尔定理的一方面的表述。\n我们建立一个二分图 $G_1$ ，左边放上所有的集合，右边放上所有的数，把左侧每个集合向其拥有的数连一条边，那么这个时候，根据霍尔定理，这个二分图存在一个左侧所有节点都在匹配中的匹配（这个图中右侧也只有 $n$ 个节点，所以事实上是一个完美匹配）。\n所以每一个集合 $i$ 都可以对应到一个数 $c_i$ ， 且任意两个数的 $c_i$ 都不相同。\n这个时候我们发现，任意选 $k$ 个集合，我们都可以得到这 $k$ 个集合并集的一个子集，就是由这 $k$ 个集合的 $c_i$ 构成的集合。这个时候我们已经不能有任何其他的数加入，如果我们选择了第 $i$ 个集合，那么我们对于第 $i$ 个集合，对于除了 $c_i$ 的元素 $t$ ，我们都必须选择 $c_j = t$ 的 $j$ 集合，才能保证不多出来元素。\n这个时候，我们就有了一个新模型， 仔细观察的话，就会发现其实是一个最小权闭合子图的模型，可以用最小割模型来解决，网上也有许多资料，在这里就不重复了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 610,inf = 0x3f3f3f3f; int n,w[MAXN]; vector\u0026lt;int\u0026gt; G[MAXN]; struct Edge{ int from,to; int cap,flow; int nex; }edge[MAXN*MAXN*2]; int fir[MAXN],ecnt = 2; int addedge(int a,int b,int c){ edge[ecnt] = (Edge){a,b,c,0,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,fir[b]}; fir[b] = ecnt++; return ecnt - 2; } int dis[MAXN]; queue\u0026lt;int\u0026gt; q; bool bfs(int s,int t){ memset(dis,0,sizeof(dis)); while(!q.empty()) q.pop(); dis[s] = 1;q.push(s); while(!q.empty()){ int nown = q.front();q.pop(); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dis[v] == 0 \u0026amp;\u0026amp; edge[nowe].cap \u0026gt; edge[nowe].flow){ dis[v] = dis[nown] + 1; q.push(v); } } } return dis[t] != 0; } int dfs(int nown,int t,int limit = inf){ if(nown == t || limit == 0) return limit; int sumf = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dis[v] == dis[nown] + 1 \u0026amp;\u0026amp; edge[nowe].cap \u0026gt; edge[nowe].flow){ int f = dfs(v,t,min(limit,edge[nowe].cap - edge[nowe].flow)); if(f){ edge[nowe].flow += f,edge[nowe^1].flow -= f; sumf += f,limit -= f; } if(limit == 0) break; } } return sumf; } int dinic(int s,int t){ int ans = 0; while(bfs(s,t)) ans += dfs(s,t); return ans; } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ int m; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); while(m--){ int x;scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); G[i].push_back(x); } } for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]); } vector\u0026lt;int\u0026gt; E[MAXN];int c[MAXN],back[MAXN]; void get_matching(){ int S = 0,T = 2*n+1; for(int i = 1;i\u0026lt;=n;i++){ addedge(S,i,1),addedge(i+n,T,1); for(auto j : G[i]) E[i].push_back(addedge(i,j+n,1)); } dinic(S,T); for(int i = 1;i\u0026lt;=n;i++){ for(unsigned x = 0;x \u0026lt; G[i].size();x++){ if(edge[E[i][x]].flow == 1){ c[i] = G[i][x]; back[G[i][x]] = i; break; } } } } void solve(){ get_matching(); ecnt = 2;memset(fir,0,sizeof(fir)); int S = n+1,T = S+1; int ans = 0; for(int i = 1;i\u0026lt;=n;i++){ w[i] = -w[i]; if(w[i] \u0026gt; 0) addedge(S,i, w[i]),ans += w[i]; else addedge(i,T,-w[i]); } for(int i = 1;i\u0026lt;=n;i++){ for(auto j : G[i])if(j != c[i]) addedge(i,back[j],inf); } ans -= dinic(S,T); printf(\u0026#34;%d\\n\u0026#34;,-ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":73,"section":"posts","tags":["网络流","图论"],"title":"「CF103E」Buying Sets-霍尔定理-网络流-最小权闭合子图","uri":"https://blog.chenqiqian.com/posts/cf103e/"},{"content":"给定一个长度为 $n$ 的数组，我们要从中找出两个不相交（不含邮相同元素的）的子序列，要求每个子序列的任意两个相邻元素的差的绝对值为 $1$ 或 在模 $7$ 意义下相同。请你求出这两个子序列长度和的最大值。\n题解 令 $dp[x][y]$ 表示第一个子序列最后一个元素取到 $x$ ，第二个子序列的最后一个元素取到 $y$ 的最大的和。\n $x \u0026lt; y$\n令 $dp[y] = dp[y]$ $x = y$\n显然 $dp[y] = 0$ $x \u0026gt; y$\n$$\ndp[y] = \\max _ {0 \\le i \u0026lt; x,i \\neq y}(dp[i][y]+1)\n$$\n其中 $i$ 到 $x$ 满足如上条件。  前两个的正确性很好理解，第三个的正确性如何保证呢？我们考虑到虽然我们只更新了第一个，但是我们第一种情况也就交换了两个子序列，所以事实上我们也可以算更新了两个子序列的。\n我们这样转移是 $O(n^3)$ 的，不能通过本题。\n我们可以优化这个 dp 。我们按照第一维 $y$ 从小到大，第二维 $x$ 从小到大更新。\n对于每个 y ，我们可以维护两个数组 $\\text{maxmod[j]},\\text{maxnum[j]}$，分别代表在当前 $y$ 中，（当前计算到 $dp[x][y]$），满足 $0 \\le i \u0026lt; x$ 且 $i \\neq y$ 的最大的 dp 值，而且这些 $a[i]$ 在模 7 的余数（或本身数值）为 $j$ 。\n我们发现这样的转移就变成了 $O(1)$ 的。\n所以，最后的时间复杂度就变成了 $O(n^2)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 5100,MAXC = 110000; int n,a[MAXN]; int dp[MAXN][MAXN];// dp[x][y] int maxnum[MAXC],maxmod[7]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } void solve(){ int ans = -1e9; for(int i = 0;i\u0026lt;MAXC;i++) maxnum[i] = -1e9; for(int y = 0;y\u0026lt;=n;y++){ for(int x = 1;x\u0026lt;=n;x++) maxnum[a[x]] = -1e9; for(int i = 0;i\u0026lt;7;i++) maxmod[i] = -1e9; dp[0][y] = dp[y][0]; for(int x = 1;x \u0026lt;= y-1;x++){ dp[x][y] = dp[y][x]; maxnum[a[x]] = max(maxnum[a[x]],dp[x][y]); maxmod[a[x] % 7] = max(maxmod[a[x] % 7],dp[x][y]); } for(int x = y+1;x\u0026lt;=n;x++){ dp[x][y] = -1e9; dp[x][y] = max(dp[x][y],maxnum[a[x]-1] + 1); dp[x][y] = max(dp[x][y],maxnum[a[x]+1] + 1); dp[x][y] = max(dp[x][y],maxmod[a[x]%7] + 1); dp[x][y] = max(dp[x][y],dp[0][y] + 1); maxnum[a[x]] = max(maxnum[a[x]],dp[x][y]); maxmod[a[x] % 7] = max(maxmod[a[x] % 7],dp[x][y]); } for(int x = 1;x\u0026lt;=n;x++){ ans = max(ans,dp[x][y]); } } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":74,"section":"posts","tags":["动态规划"],"title":"「CF813D」Two Melodies-简单dp","uri":"https://blog.chenqiqian.com/posts/cf813d/"},{"content":"新的技术正冲击着手机通讯市场，对于各大运营商来说，这既是机遇，更是挑战。THU 集团旗下的 CS\u0026amp;T 通讯公司在新一代通讯技术血战的前夜，需要做太多的准备工作，仅就站址选择一项，就需要完成前期市场研究、站址勘测、最优化等项目。\n在前期市场调查和站址勘测之后，公司得到了一共 $N$ 个可以作为通讯信号中转站的地址，而由于这些地址的地理位置差异，在不同的地方建造通讯中转站需要投入的成本也是不一样的，所幸在前期调查之后这些都是已知数据：建立第 $i$ 个通讯中转站需要的成本为 $P_i$ 。\n另外公司调查得出了所有期望中的用户群，一共 $M$ 个。关于第 i 个用户群的信息概括为 $A_i$ , $B_i$ 和 $C_i$ ：这些用户会使用中转站 $A_i$ 和中转站 $B_i$ 进行通讯，公司可以获益 $C_i$ 。\nTHU 集团的 CS\u0026amp;T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）\n题解 最大权闭合图问题。\n我们转化模型，我们把边和点都看成一个物品，那么我们有一些依赖关系：如果我们指定要选的边的集合，这个时候我们肯定希望选的点的权值和越小越好，然而我们必须要选的最少的点就是所有上文边集里面的每条边的端点的并。\n转化成这样的问题之后，我们就是一个最大权闭合图的问题了。所有原图中的点在新图中都是负权值，从该点在新图的点向汇点连一个该点代价为容量的边；所有原图中的边在新图中都是负权值，从源点向该边在新图的点连一个该边收益为容量的边；剩余原图的边向两个端点各连一条 inf 的边即可。\n跑出最大流即为答案。\n正确性？\n\u0026lt;copy part\u0026gt;\n如果割掉用户的边，那么就舍弃掉一部分收益，可以看做损失。\n如果割掉中转站的边，那么就付出一定代价，可以看做损失。\n又因为不会割掉INF的边，所以就巧妙的解决了选A必须选B的问题。\n\u0026lt;\\copy part\u0026gt;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int inf = 1e9+7; const int MAXN = 55100,MAXM = 4*MAXN; struct Edge{ int to,nex; int cap,flow; }edge[MAXM*2]; int fir[MAXN],cur[MAXN],ecnt = 2; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){b,fir[a],c,0}; fir[a] = ecnt++; edge[ecnt] = (Edge){a,fir[b],0,0}; fir[b] = ecnt++; } int S,T; int dis[MAXN]; queue\u0026lt;int\u0026gt; q; bool bfs(){ memset(dis,0,sizeof(dis)); memcpy(cur,fir,sizeof(cur)); while(!q.empty()) q.pop(); dis[S] = 1; q.push(S); while(!q.empty()){ int nown = q.front();q.pop(); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(edge[nowe].cap \u0026gt; edge[nowe].flow \u0026amp;\u0026amp; dis[v] == 0){ dis[v] = dis[nown] + 1; q.push(v); if(v == T) return 1; } } } return 0; } int dfs(int nown,int limit = inf){ if(limit == 0 || nown == T) return limit; for(int \u0026amp;nowe = cur[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(edge[nowe].cap \u0026gt; edge[nowe].flow \u0026amp;\u0026amp; dis[v] == dis[nown] + 1){ int f = dfs(v,min(limit,edge[nowe].cap - edge[nowe].flow)); if(f){ edge[nowe].flow+=f; edge[nowe^1].flow -= f; return f; } } } return 0; } int dinic(){ int ans = 0,f = 0; while(bfs()){ while(true){ f = dfs(S); if(f == 0) break; else ans+=f; } } return ans; } int n,m,a[MAXN]; int u[MAXN],v[MAXN],w[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;u[i],\u0026amp;v[i],\u0026amp;w[i]); } } void solve(){//边在前[1,m]，点在后 [m+1,m+n]  S = n+m+1,T = n+m+2; for(int i = 1;i\u0026lt;=n;i++)addedge(m+i,T,a[i]); for(int i = 1;i\u0026lt;=m;i++){ addedge(S,i,w[i]); addedge(i,m+u[i],inf),addedge(i,m+v[i],inf); } int ans = -dinic(); for(int i = 1;i\u0026lt;=m;i++){ ans += w[i]; } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":75,"section":"posts","tags":["网络流","最大权闭合子图","图论"],"title":"「NOI2006」最大获利-网络流-最大权闭合子图","uri":"https://blog.chenqiqian.com/posts/noi2006-benefit/"},{"content":"本游记是真的游玩过程记录。\n这篇文章每个阶段都是过完就直接写了\u0026hellip;有可能比较啰嗦，会有比较多的心理啥的吧\u0026hellip;\nDay-?,2019-12-xx 不可描述。\nupd on Day1 渐渐后悔。我也许就不应该接受的吧。\nDay-2,2019-01-19 若干天前订好了乘坐CA1315航班从北京飞往广州。今天十一点可以值机之后发现，竟然从原来的777-300ER换成了747-8I，感觉有一种中奖的意思。\n值机值了一个在飞机最后的位置，应该还算是比较宽敞，只不过是没有靠窗的位置。\n回家收拾行李，被训斥不会生活qwq就带了一个大的双肩背包就滚粗了。\nDay-1,2019-01-20 早早到机场，发现飞机早就在等我们了。\n还看到了一个汉莎的747-8降落，太美了。也看到了国航彩绘的 77W ，感觉十分舒适。上飞机前还看了一集空中浩劫，感觉十分舒适。\n上飞机之后不到五分钟就把自己的小电视搞坏了，于是开始写代码。\n写 SA 写到一半发现座位底下的插座充不上电，于是收起电脑开始玩手机，发现并没有单机游戏，于是就开始颓废，\n广州的云超级低 \u0026amp; 厚，到了 1200 米以下之后才能勉强看到地面，所以虽然我们从南侧进场五边下面经过广州市区，但是什么都看不见.jpeg，\n下飞机之后就是去酒店，从市区北边巨远到市区东边巨远的酒店先住一晚上。几天前就知道要和可爱的（并不）男孩子住一个大床房，还有些激动（并不）。\n到了酒店之后发现酒店有一个阳台，景色超级美丽的诶！直接促成了我决定在23号晚上溜出来在酒店住一晚上，\n晚饭之前另一屋在玩炉石，我过去开了一包搞出来个橙卡，据说rp\u0026ndash;？？？\n晚饭去吃了蒸汽火锅（也许不是），感到非常赛艇。\n这天晚上还有一场 8 点的 Div2 的 CF ，于是四人开黑局，结果是一个奇葩场，ABC三道SB题，D是个模拟，E是个爆搜？？？我学的算法有什么用吗？？？不会做 E，询问隔壁神仙，得到回复：“爆搜，” 然后就 PP 了，\n赛后特别搞笑，某人的 E 被同屋神仙 X 掉了，然而并没有FST，令人发指，\nDay1,2019-01-21 七点半起床，感到非常舒适，大概是近若干天睡的最多的一次..？早上吃饭，看到一车长郡的同学（忽然害怕），估计所有人都比我厉害（快哭了）\n吃完饭尾随长郡大军前往广州二中，长郡的人走的巨快，甚至完全跟不上他们的走路，巨佬们果然擅长走路\u0026hellip;\n到地方之后领了胸牌，领了衣服，领了袋子，然后去宿舍，宿舍是在旁边的实验学校，大概离考试的地方有一个大操场+一栋大楼那么远。\n这个大操场很nice，有10个跑道，还是天然草（虽然我们到的时候已经几乎只剩下土了），篮球场有10块，（简单寻觅），还有室内的带看台的篮球馆\u0026amp;羽毛球馆，比破校简直不知道高到哪里去了。\n然后就是试机，电脑还不错，有的时候有阳光真是非常emmm，VSCode环境妙啊，配完之后敲了个后缀数组和FWT，后缀数组还敲错了好多（捂脸）FWT甚至没有写完，感到非常不妙。\n一路围观神仙不敢搭话，于是回宿舍待了会。宿舍存在一个机器不断挖土（捣地）发出巨大的声音。在宿舍看了看 LCT 板子，和一大堆其他的板子，然后就要去吃饭了。\n吃饭的地方和一大堆广州二中的学生一起吃了饭，盛饭盛的巨多，甚至没有吃完\u0026hellip;\n下午的考试不提，大概就是均分200菜鸡分数40\u0026hellip;成为学校 rk-1 \u0026hellip;自己讲过的莫队都不会，把问题想成二维的然后就偏偏了\u0026hellip;心情不是很好，大概需要继续认清自己菜鸡的事实。\n开幕式没什么好玩的。讲话 * n。\n广东的妹子平均质量比北方高。嗯。\n感觉并不是非常好，在考场上坐了5个小时啥都不会的感觉真的让人自闭。第一次（也许省选的时候才是第一次）感到这么绝望\u0026hellip;你希望能够做好的事情却没有改变的能力\u0026hellip;也许三个月前根本就不应该继续呢\u0026hellip;\nDay2,2019-01-22 早饭没什么好玩的qwq\n早上八点钟到考场坐好，考试没啥好玩的\u0026hellip;A掉了T1之后不会求凸包，卡在T3不能动弹，又混了个比大众分\u0026ndash;的分数，令人不爽qaq\n发现这个学校的基础设施真是好啊，还有露天的游泳池\u0026hellip;不知道比我们高到哪里去了qaq\n吃完饭和本校选手谈笑风生，大家谈论自己挂的分emmm惨案现场\u0026hellip;\n晚上考试令人自闭\u0026hellip;又困又累\u0026hellip;\n一共八道题，3h。工程实现大赛，库函数实现大赛\u0026hellip;卡在T4发现要实现CRC，然后直到考试结束前30分钟才发现CRC可以暴力！真令人自闭\u0026hellip;\n","description":"","id":76,"section":"posts","tags":null,"title":"广州旅游记","uri":"https://blog.chenqiqian.com/posts/trip-thuwc2019/"},{"content":"为了有说服力地向阿米巴展示阿米巴的作文是多么让人觉得“眼熟”，小强想出了一个评定作文 “熟悉程度”的量化指标：$L_0$ .小强首先将作文转化成一个 $01$ 串。之后，小强搜集了各路名家的文章，同样分别转化成 $01$ 串后，整理出一个包含了 $M$ 个 $01$ 串的“ 标准作文库 ”。\n小强认为：如果一个 $01$ 串长度不少于 $L$ 且在 标准作文库 中的某个串里出现过（即，它是 标准作文库 的 某个串 的一个 连续子串 ），那么它是“ 熟悉 ”的。对于一篇作文（一个 $01$ 串）A，如果能够把 A 分割成若干段子串，其中“ 熟悉 ” 的子串的 长度总和 不少于 A 总长度的 $90%$，那么称 A 是 “ 熟悉的文章 ”。 $L_0$ 是能够让 $A$ 成为 “ 熟悉的文章 ” 的 所有 $L$ 的最大值 （如果不存在这样的 $L$ ，那么规定 $L_0 = 0$ ）。\n链接 Luogu P4022\n题解 我们注意到首先外面可以套一个二分，单调性显然成立。\n我们需要对这个地方所有的标准作文库建立一个广义 SAM （或者串一起也可以，基本上是等价的）。\n然后我们的问题变成了存在性问题：是否存在一种分割方案，其中熟悉的子串的长度均不小于 $L$ 且在标准作文库里面出现过，且和大于 $90%$ 。\n我们用一个 $dp[i]$ 表示在这种限制下在 $[1,i]$ 的子串的最大的熟悉的长度，然后我们明显有一个 $O(n^2)$ 的解法（需要预处理我们要判断的作文的每个位置在广义SAM上能够最长匹配的长度，这里用在SAM上跑+暴力跳 Fail 树，判断当前最长是不是在你要符合的区间，理论时间复杂度 $O(n \\log n)$，不会证明）。\n猜测存在决策单调性，事实上的确成立。用单调队列维护即可。\n所以时间复杂度大约是： $O(n \\log n)$ ~ $O(n \\log^2 n)$ $\\approx O(\\text{能过})$ 。\n后缀自动机的题啊，感觉时间复杂度对就行了，比如 NOID1T3 。多妙啊！\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 2100000; namespace SAM{ int c[MAXN][2],l[MAXN],fa[MAXN],cnt,last,rt; void init(){rt = last = ++cnt;} int newnode(int x){l[++cnt] = x;return cnt;} int ins(int p,int x){ if(c[p][x]){ int q = c[p][x]; if(l[q] == l[p] + 1) last = q; else{ int nq = newnode(l[p]+1);last = nq; memcpy(c[nq],c[q],sizeof(c[q])); fa[nq] = fa[q];fa[q] = nq; for(;c[p][x] == q;p = fa[p]) c[p][x] = nq; } } else{ int np = newnode(l[p]+1);last = np; for(;p \u0026amp;\u0026amp; (!c[p][x]);p = fa[p]) c[p][x] = np; if(!p) fa[np] = rt; else{ int q = c[p][x]; if(l[q] == l[p]+1) fa[np] = q; else{ int nq = newnode(l[p]+1); memcpy(c[nq],c[q],sizeof(c[q])); fa[nq] = fa[q];fa[q] = fa[np] = nq; for(;c[p][x] == q;p = fa[p]) c[p][x] = nq; } } } return last; } void ins(char *s){ int n = strlen(s),p = rt; for(int i = 0;i\u0026lt;n;i++) p = ins(p,s[i]-\u0026#39;0\u0026#39;); } void calmax(int n,char *s,int *res){ int now = rt,cur = 0; for(int i = 0;i\u0026lt;n;i++){ int x = s[i] - \u0026#39;0\u0026#39;; if(c[now][x]){ cur++,now = c[now][x]; } else{ while(now \u0026amp;\u0026amp; !c[now][x]) now = fa[now]; if(now == 0) now = rt,cur = 0; else cur = l[now] + 1,now = c[now][x]; } res[i+1] = cur; } } } int n,m; char s[MAXN]; int maxlen[MAXN]; int dp[MAXN]; int q[MAXN],fi,la; bool check(int n,int L){// 长度为 L 的情况下是否可以实现  fi = 0,la = -1; for(int i = 0;i \u0026lt; L;i++) dp[i] = 0; for(int i = L;i \u0026lt;= n;i++){ // printf(\u0026#34;%d:%d\\n\u0026#34;,i,maxlen[i]);  dp[i] = dp[i-1]; while(fi \u0026lt;= la \u0026amp;\u0026amp; dp[q[la]] + (i-q[la]) \u0026lt;= dp[i-L] + (i-(i-L))) la--; q[++la] = i-L; while(fi \u0026lt;= la \u0026amp;\u0026amp; q[fi] \u0026lt; i - maxlen[i]) fi++; if(fi \u0026lt;= la) dp[i] = max(dp[i],dp[q[fi]] + (i-q[fi])); } // printf(\u0026#34;%d\\n\u0026#34;,dp[n]);  return dp[n] * 10 \u0026gt;= n * 9; } int cal(char *s){ int n = strlen(s); SAM::calmax(n,s,maxlen); int L = 1,R = 1000000; while(L != R){ int mid = (L+R+1)/2; if(!check(n,mid)){ R = mid-1; } else{ L = mid; } } return L; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); SAM::init(); for(int i = 1;i \u0026lt;= m;i++){ scanf(\u0026#34;%s\u0026#34;,s); SAM::ins(s); } } void solve(){ for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s); printf(\u0026#34;%d\\n\u0026#34;,cal(s)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":77,"section":"posts","tags":["字符串","后缀自动机"],"title":"「CTSC2012」熟悉的文章-广义后缀自动机","uri":"https://blog.chenqiqian.com/posts/ctsc2012-familiar/"},{"content":"定义一个完全二叉树树高为根节点到叶子节点经过的边数。\n给定一个树高为 $h(1 \\le h \\le 30)$ 的完全二叉树，其中第 $x$ 个节点的左儿子为第 $2x$ 个节点，右儿子为第 $2x+1$ 个节点。\n现在有 $q(1 \\le q \\le 10^{5})$ 个，分为两种操作：\n add v e （ $1 \\le v \\le 2^{h+1}-1,1 \\le e \\le 10^4$ ）表示给第 $v$ 个节点的权值加 $e$ 。 decay 操作。我们在这个二叉树里面以等概率选择一个叶子节点，将这个叶子节点到根的路径上所有的边都删去。在删除后，树会形成若干个联通块，我们定义某个联通块的的权值为这个联通块内所有节点的权值之和。我们定义删除后的树的权值为形成的所有联通块的权值的最大值。请你求出这个值的期望。每次删除后会恢复所有删除的边。  链接 Codeforces\n题解 考虑我们在树上随机走出一个路径。我们发现，我们每个地方相当于有两个决策：往左走，往右走，两个的概率是相同的。\n我们如果设当前节点为为 $x$，那么往左走的话就会产生一个完全不会更改的联通块（$sum[rs[x]] +v[x]$）。如果存在 $sum[rs[x]] + v[x] \\ge sum[ls[x]]$ 这个时候我们发现，接下来我们怎么走，产生的联通块都不会比已经产生的这个 $sum[rs[x]] + v[x]$ 大。所以我们就不用走 $sum$ 较小的那边了，因为它们的贡献已经可以计算了。\n这样的话我们每次决策都可以只走一边，同时计算出剩下的一边的所有答案之和。在走的过程中维护一下已经存在的联通块的最大值即可。\n加的话直接暴力在树上维护一个子树和即可。\n时间复杂度：$O(q \\times h)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000,LOGN = 31; namespace Tree{ int sumn[MAXN*LOGN],ls[MAXN*LOGN],rs[MAXN*LOGN],cnt = 1; void upd(int nown,int v){ static int tmp[40];int ecnt = 0; for(int i = nown;i;i\u0026gt;\u0026gt;=1) tmp[++ecnt] = i\u0026amp;1; int now = 1; for(int i = ecnt-1;i\u0026gt;=0;--i){ sumn[now] += v; if(tmp[i] == 0){ if(!ls[now]) ls[now] = ++cnt; now = ls[now]; } else{ if(!rs[now]) rs[now] = ++cnt; now = rs[now]; } } } double decay(){ int now = 1,nowmax = -1e9; double ans = 0, p = 1; while(now != 0){// now 非空  int lson = sumn[ls[now]],rson = sumn[rs[now]],val = sumn[now] - lson - rson; p *= 0.5; ans += p * max(nowmax,max(lson,rson)+val); if(lson \u0026gt; rson){ nowmax = max(nowmax,rson+val); now = ls[now]; } else{ nowmax = max(nowmax,lson+val); now = rs[now]; } } ans += p * nowmax; return ans; } } int h,q; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;h,\u0026amp;q); } void solve(){ for(int i = 1;i\u0026lt;=q;i++){ char s[12]; int a,b; scanf(\u0026#34;%s\u0026#34;,s); if(s[0] == \u0026#39;a\u0026#39;){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); Tree::upd(a,b); } else if(s[0] == \u0026#39;d\u0026#39;){ printf(\u0026#34;%.8lf\\n\u0026#34;,Tree::decay()); } } } int main(){ init(); solve(); return 0; }   ","description":"","id":78,"section":"posts","tags":["期望","树形结构"],"title":"「CF68D」Half-decay tree-期望瞎搞题","uri":"https://blog.chenqiqian.com/posts/cf68d/"},{"content":"我们定义一个 DNA 序列为仅有 ATCG 四个字母的字符串。\n给出 $m(1 \\le m \\le 10)$ 个 DNA 序列模式串 $s_i$，每个长度均不超过 $10$ ，我们定义一个 DNA 序列 $w$ 是好的，当且仅当对于 $w$ 的每一个位置 $i$ ，都存在至少一个模式串 $s_j$ ， 使得 $w[l\u0026hellip;r] = s_j$（ $w[l\u0026hellip;r]$ 表示一个原字符串的一个子串） ， 其中 $1 \\le l \\le i \\le r \\le |w|$（ $|w|$ 为 DNA序列 $w$ 的长度） 。\n请你计算出所有长度为 $n(1 \\le n \\le 1000)$ 的好的 DNA 序列的个数。\n答案对 $1000000009(10^9+9)$ 取模。\n链接 Codeforces\n题解 我们对所有模式串建立 AC 自动机，获取 fail 指针，同时计算 fail 链上的最长的结束字符串的长度 $l[x]$ ，补全 Trie 图。\n设状态如 $dp[\\text{len}][\\text{nownode}][\\text{nowleft}]$ ，其中 $\\text{len}$ 表示还剩余的位数，$\\text{nownode}$ 表示当前在 AC 自动机的哪个点，$\\text{nowleft}$ 表示当前未匹配的后缀长度还有多少。\n我们每次枚举下一位填什么。如果我们发现到达的位置可以存在一个覆盖 $\\text{nowleft}$ 的模式串，我们就更新一下 $\\text{nowleft} = 0$ ，否则 $\\text{nowleft}$ 加 $1$ 即可。\n如果进行到某个状态，剩下的的后缀大于你最大的字符串的长度，就可以直接返回 $0$ 了。\n时间复杂度 $O(n m \\cdot \\text{maxlen}^2)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 1005,mod = 1e9+9; namespace AC{ int c[MAXN][5],len[MAXN],maxlen[MAXN],fail[MAXN],cnt,rt; void ins(char *s){ int n = strlen(s); int now = rt; for(int i = 0;i\u0026lt;n;i++){ int a = s[i] - \u0026#39;a\u0026#39;; if(!c[now][a]) c[now][a] = ++cnt; now = c[now][a]; } len[now] = max(len[now],n); } void getfail(){ queue\u0026lt;int\u0026gt; q; for(int i = 0;i\u0026lt;4;i++){ if(c[rt][i] != 0){ fail[c[rt][i]] = rt; q.push(c[rt][i]); } } while(!q.empty()){ int nown = q.front();q.pop(); for(int i = 0;i\u0026lt;4;i++){ int \u0026amp;v = c[nown][i]; if(v == 0){ v = c[fail[nown]][i]; } else{ fail[v] = c[fail[nown]][i]; len[v] = max(len[v],len[fail[v]]); q.push(v); } } } } } int n,m; int dp[MAXN][105][12]; char s[MAXN]; int dfs(int len,int nownode,int nowleft){ if(nowleft \u0026gt; 10) return 0; if(dp[len][nownode][nowleft] != -1){ return dp[len][nownode][nowleft]; } if(len == 0 \u0026amp;\u0026amp; nowleft == 0) return 1; else if(len == 0) return 0; int ans = 0; for(int i = 0;i\u0026lt;4;i++){ int v = AC::c[nownode][i]; ans += dfs(len-1,v,(AC::len[v] \u0026gt;= nowleft+1)?0:nowleft+1); ans %= mod; } return dp[len][nownode][nowleft] = ans; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%s\u0026#34;,s); int t = strlen(s); for(int i = 0;i\u0026lt;t;i++){ if(s[i] == \u0026#39;A\u0026#39;){s[i] = \u0026#39;a\u0026#39;;} else if(s[i] == \u0026#39;C\u0026#39;){s[i] = \u0026#39;b\u0026#39;;} else if(s[i] == \u0026#39;T\u0026#39;){s[i] = \u0026#39;c\u0026#39;;} else if(s[i] == \u0026#39;G\u0026#39;){s[i] = \u0026#39;d\u0026#39;;} else{printf(\u0026#34;-1\\n\u0026#34;);} } AC::ins(s); } } void solve(){ AC::getfail(); memset(dp,-1,sizeof(dp)); printf(\u0026#34;%d\\n\u0026#34;,dfs(n,0,0)); } int main(){ init(); solve(); return 0; }   ","description":"","id":79,"section":"posts","tags":["字符串","动态规划","AC自动机"],"title":"「CF86C」Genetic engineering-AC自动机+dp","uri":"https://blog.chenqiqian.com/posts/cf86c/"},{"content":"给出三个整数 $l,r,k (1 \\le l \\leq r \\le 2\\cdot10^9, 2 \\le k \\le 2 \\cdot 10^9)$ 。\n求在区间 $[l,r]$ 内满足 $k \\mid i$ ， 且对于任意 $j \\in [2,k-1]$ 都不满足 $k \\mid i$ 的数 $i$ 的个数。\n链接 Codeforces\n题解 可以发现，问题可以转化为在 $[l,r]$ 中最小质因数是 $k$ 的数的个数。\n现将问题差分，变成在 $[1,n]$ 以内最小质因数是 $k$ 的数的个数。\n我们考虑转化问题，如果我们令 $f[i]$ 为 $i$ 的最小质因数，那么显然这个可以在线性的时间内筛出来（我们预处理一些，假设到 $\\text{MAX}$ ）。\n我们的问题就可以变成：\n求出在 $[1,n]$ 中，$f[i] = k$ 的数的个数，明显发现，这个可以转化为在 $[1,\\lfloor\\frac{n}{k}\\rfloor]$ 内， $f[i] \\ge k$ 的数的个数。\n我们可以对数据进行分治，如果我们发现：\n我们可以对数据进行分治，如果我们发现：\n $\\lfloor\\frac{n}{k}\\rfloor \u0026lt; \\text{MAX}$，直接线性解决这个问题 $\\lfloor\\frac{n}{k}\\rfloor \\ge \\text{MAX}$，这个时候如果我们线性筛筛的比较大，剩下的 $k$ 应该会比较小。这个时候事实上我们要求的是所有 $[1,n]$ 当中有多少个数存在一个小于 $k$ 的质因数，这个东西可以容斥解决。容斥的复杂度是 $2^k$，那么我们应该让线性筛筛出来的东西尽量大即可。而且事实上我们可以加入一个剪枝，也就是一旦你现在要容斥的数已经超过了 $n$ ，就直接 break 掉。  这样的话，复杂度大约是可以过掉的。\n实际上可能要调一调线性筛的 $\\text{MAX}$ ，但这个题目时限比较宽松，也是可以过掉的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 10000000; int prime[MAXN],cnt; bool vis[MAXN]; int f[MAXN];// 最小质因数  void sieve(){ memset(vis,0,sizeof(vis)); f[1] = 1; for(int i = 2;i\u0026lt;MAXN;i++){ if(vis[i] == 0){ f[i] = i; prime[++cnt] = i; } for(int j = 1;i*prime[j]\u0026lt; MAXN \u0026amp;\u0026amp; j\u0026lt;=cnt;j++){ vis[i*prime[j]] = 1; f[i*prime[j]] = prime[j]; if(i%prime[j] == 0) break; } } } bool is_prime(int k){ int t = sqrt(k); for(int i = 2;i\u0026lt;=t;i++){ if(k % i == 0)return 0; } return 1; } int cal1(int n,int k){ int ans = 0; for(int i = 1;i\u0026lt;=n;i++){ if(i == 1 || f[i] \u0026gt;= k) ans++; } return ans; } int LIM = 0,lim = 0;// LIM 质数个数，lim 为 n/k #define ll long long ll ans = 0; void dfs(int p,ll now,ll f){ if(now \u0026gt; lim) return; if(p \u0026gt; LIM) { ans += f * (lim/now);return; } dfs(p+1,now,f); dfs(p+1,now*prime[p],-f); } int cal2(int n,int k){ LIM = 0,lim = n,ans = 0; for(int i = 1;prime[i] \u0026lt; k;i++)LIM++; dfs(1,1,1); return int(ans); } int calc(int n,int k){ if(!n || !is_prime(k)) return 0; if(n/k \u0026lt; MAXN) return cal1(n/k,k); else return cal2(n/k,k); } int l,r,k; int main(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;l,\u0026amp;r,\u0026amp;k); sieve(); printf(\u0026#34;%d\\n\u0026#34;,calc(r,k) - calc(l-1,k)); return 0; }   ","description":"","id":80,"section":"posts","tags":["数论","容斥原理"],"title":"「CF83D」Numbers-容斥原理","uri":"https://blog.chenqiqian.com/posts/cf83d/"},{"content":"现在有一个由所有正整数组成的无限递增序列： $p = {1,2,3,\u0026hellip;}$ 。\n对这个序列执行 $n$ 次交换操作。每次一个操作，给出两个整数 $a,b$，交换位置 $a$ 和 $b$ 处的元素。\n你的任务是在所有操作结束后，输出最终序列的逆序对个数，即满足 $i \u0026lt; j$ 且 $p_i \u0026gt; p_j$ 的有序数对 $(i,j)$ 的数量。\n链接 Codeforces\n题解 我们发现，两个没有经过任何交换的位置之间是不可能产生逆序对的，可能产生逆序对的只有：\n 换的与没换的 换的与换的  所以我们只需要考虑被换的能产生的逆序对即可，可以发现这样统计是完全的。\n我们考虑先用 $map$ 记录交换最后的结果和哪些位置有交换，这块非常简单，时间复杂度是 $O(n\\log n)$ 的。\n我们接下来考虑最后数列的逆序对个数。\n先考虑第一种情况：换的与没换的产生了逆序对。\n对于每一个交换的数，我们考虑两种情况：在其前面，比其大，在其后面，比其大。\n我们考虑到换的在 1e9 范围内比较小，可以开一个动态开点线段树维护哪些位置被x掉了，然后查询区间和就可以知道第一个问题的答案了。\n我们考虑第二种情况：两个换了的产生了逆序对。\n这种情况下，我们只需要考虑在前面的，比他大的个数即可，本质上是个二维数点问题。\n维护扫描线，和动态开点线段树，可以在 $O(n \\log V)$ 时间内解决。\n最后时间复杂度： $O(n (\\log V + \\log n))$，空间 $O(n \\log V)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 101000,logn = 35; struct SegTree{ int sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 0; #define mid ((l+r)/2)  void update(int \u0026amp;nown,int l,int r,int pos,int v){ if(!nown) nown = ++cnt; if(l == r) sumn[nown] += v; else{ sumn[nown] += v; if(pos \u0026lt;= mid) update(ls[nown],l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rs[nown],mid+1,r,pos,v); } } int query(int nown,int l,int r,int ql,int qr){ if(ql \u0026gt; qr) return qr - ql + 1;//以便后面和负数区间对掉，其余部分最多只会差1，返回0没有锅  if(!nown) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sumn[nown]; else{ int ans = 0; if(ql \u0026lt;= mid) ans += query(ls[nown],l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans += query(rs[nown],mid+1,r,ql,qr); return ans; } } }T1,T2; int n,MAX = 1e9; map\u0026lt;int,int\u0026gt; S; // pos-\u0026gt;val int getval(int x){return S.count(x)?S[x]:x;} void _swap(int a,int b){ int va = getval(a),vb = getval(b); S[a] = vb,S[b] = va; } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); _swap(a,b); } } ll ans = 0; int rt1,rt2; void solve(){ for(auto it = S.begin();it!=S.end();it++){ T1.update(rt1,1,MAX,it-\u0026gt;first,1); } for(auto it = S.begin();it!=S.end();it++){ int p = it-\u0026gt;first,v = it-\u0026gt;second; ans += ((p-1)-(v+1)+1) - T1.query(rt1,1,MAX,v+1,p-1);//前面比他大的  ans += ((v-1)-(p+1)+1) - T1.query(rt1,1,MAX,p+1,v-1);//后面比他小的  } for(auto it = S.begin();it!=S.end();it++){ int v = it-\u0026gt;second; ans += T2.query(rt2,1,MAX,v+1,MAX); T2.update(rt2,1,MAX,v,1); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":81,"section":"posts","tags":["数据结构","线段树"],"title":"「CF540E」Infinite Inversions-动态开点线段树","uri":"https://blog.chenqiqian.com/posts/cf540e/"},{"content":"给你一个长度为 $n$ 的序列 $a_1,a_2,\u0026hellip;,a_n$ ，你需要把这 $n$ 个元素分成三类：$1,2,3$，每类的条件如下：\n  所有的最长上升子序列都不包含这个元素\n  有但非所有的最长上升子序列包含这个元素\n  所有的最长上升子序列都包含这个元素\n  链接 Codeforces\n题解 由普通 $\\text{LIS}$ 的 $O(n \\log n)$ 算法扩展得到这个问题的 $O(n \\log n)$ 的解法。\n在原来的 LIS 过程中，我们只维护 $f[i]$ 为某值时， $a_i$ 的值最小为多少。现在我们将这些 $a_i$ 通通扔到 $n$ 个 vector 里面（而不是取 $\\max$ ），可以发现，在每个 vector 里面，我们的 $a[i]$ 应当是单调递减的（我们将每个 vector 里面最后一个数当作普通 LIS 里面的数组的数）。\n然后我们考虑如何计算方案数。\n我们二分得到应当考虑的 $f[i]$ 的值，然后在这个 vector 里面二分得到一个位置，然后用另一个 vector 里面维护的前缀和计算得到这个能从多少种 $f[i]-1$ 的方案转移过来。最后我们要扫一遍全数组，得到全部的 LIS 条数。\n为什么我们要计算方案数呢？因为这样可以计算出 $F1_i,F2_i$ （恰好以 $i$ 结尾、开始的最长 LIS 长度）， $G1_i,G2_i$ （上述 LIS 的个数）。这个时候我们就可以分类了。\n我们把这个数列的最长长度称为 $\\mathrm{MAXLEN}$ ，总共的 LIS 条数记作 $\\mathrm{tot_cnt}$ ：\n 如果 $F1[i] + F2[i] - 1 \u0026lt; \\mathrm{MAXLEN}$，则该类型是 $1$ ； 如果 $G1[i] * G2[i] = \\mathrm{tot_cnt}$，则该类型是 $3$ ； 否则，该类型是 $2$ 。  这里的 $G$ 会很大，如何判断相等？本来想用自然溢出，后来考虑到因为都是乘法，很有可能在 $\\bmod 2^{64}$ 意义下同余，所以对一个大质数 $10^9+9$ 取模。（事实上这里两个取模甚至更多会更好，但数据并不是很强）\n时间复杂度是 $O(n \\log n)$ 。\n代码 中间有一段复制的，所以事实上要写的也没多少呢\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const ll mod = 1e9+9; const int MAXN = 210000; int n; int a[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } namespace Solve1{ int f[MAXN],t[MAXN],now,MAXANS; vector\u0026lt;int\u0026gt; v[MAXN]; vector\u0026lt;ll\u0026gt; sum[MAXN];ll g[MAXN],tot[MAXN]; void output(int n,int *ff,ll *gg){ for(int i = 1;i\u0026lt;=n;i++)ff[i] = f[i],gg[i] = g[i]; } void solve(){ a[0] = 0,f[0] = 0,g[0] = 1,t[0] = 0; v[0].push_back(0),sum[0].push_back(1),tot[0] = 1; now = 0; for(int i = 1;i\u0026lt;=n;i++){ int tmp = lower_bound(t,t+now+1,a[i]) - t; if(tmp == now+1) ++now; f[i] = tmp,t[tmp] = a[i]; int w = upper_bound(v[f[i]-1].begin(),v[f[i]-1].end(),a[i],greater\u0026lt;int\u0026gt;()) - v[f[i]-1].begin(); ll ans = w == 0?0:sum[f[i]-1][w-1]; ans = (tot[f[i]-1] - ans)%mod; g[i] = ans \u0026lt; 0?ans+mod:ans; v[f[i]].push_back(a[i]); tot[f[i]] = (tot[f[i]] + g[i])%mod; sum[f[i]].push_back(tot[f[i]]); MAXANS = max(MAXANS,f[i]); } } } namespace Solve2{ int f[MAXN],t[MAXN],now,MAXANS; vector\u0026lt;int\u0026gt; v[MAXN]; vector\u0026lt;ll\u0026gt; sum[MAXN];ll g[MAXN],tot[MAXN]; void output(int n,int *ff,ll *gg){ for(int i = 1;i\u0026lt;=n;i++)ff[i] = f[i],gg[i] = g[i]; } void solve(){ a[n+1] = 1e9,f[n+1] = 0,g[n+1] = 1,t[0] = 1e9; v[0].push_back(1e9),sum[0].push_back(1),tot[0] = 1; now = 0; for(int i = n;i\u0026gt;=1;i--){// 这里相对上面有更改  int tmp = lower_bound(t,t+now+1,a[i],greater\u0026lt;int\u0026gt;()) - t;//这里相对上面有更改  if(tmp == now+1) ++now; f[i] = tmp,t[tmp] = a[i]; int w = upper_bound(v[f[i]-1].begin(),v[f[i]-1].end(),a[i]) - v[f[i]-1].begin();//这里相对上面有更改  ll ans = w == 0?0:sum[f[i]-1][w-1]; ans = (tot[f[i]-1] - ans)%mod; g[i] = ans \u0026lt; 0?ans+mod:ans; v[f[i]].push_back(a[i]); tot[f[i]] = (tot[f[i]] + g[i])%mod; sum[f[i]].push_back(tot[f[i]]); MAXANS = max(MAXANS,f[i]); } } } int F1[MAXN],F2[MAXN];ll G1[MAXN],G2[MAXN]; void solve(){ Solve1::solve(),Solve1::output(n,F1,G1); Solve2::solve(),Solve2::output(n,F2,G2); int maxans = Solve1::MAXANS;ll totans = 0; for(int i = 1;i\u0026lt;=n;i++){ if(F1[i] == maxans) totans+=G1[i]; totans %= mod; } for(int i = 1;i\u0026lt;=n;i++){ if(F1[i] + F2[i] - 1 \u0026lt; maxans) printf(\u0026#34;1\u0026#34;); else if(G1[i] * G2[i] % mod == totans) printf(\u0026#34;3\u0026#34;); else printf(\u0026#34;2\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":82,"section":"posts","tags":["动态规划","数据结构"],"title":"「CF486E」LIS of Sequence-简单数据结构","uri":"https://blog.chenqiqian.com/posts/cf486e/"},{"content":"给出三个仅由小写字母构成的串 $A, B, C$ ，对于每个 $L \\in [1, \\min(len_A,len_B,len_C)]$ ，求满足$A[a,a+L-1] = B[b,b+L-1] = C[c,c+L-1]$ 的三元组 $(a,b,c)$ 的数量。\n答案对 $1000000007 (10 ^ 9 + 7)$ 取模，字符总数小于 $3 \\times 10^5$。\n链接 Codeforces\n题解 把三个串接在一起（中间有间隔符），上后缀数组，求出 $ht$ 数组，然后用并查集按照 $ht$ 从大到小合并，合并过程中维护区间中属于第一个、第二个、第三个字符串的位置个数，然后合并时更新贡献即可。\n时间复杂度 $O(n \\log n)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int mod = 1e9+7; const int MAXN = 340000; namespace SA{ int s[MAXN],sa[MAXN],cnt[MAXN],rk[MAXN],x[MAXN],y[MAXN],ht[MAXN]; void get_sa(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i=n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] == s[sa[i-1]]?m:++m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i=0,k=j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i]-j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i =n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]] == y[sa[i-1]] \u0026amp;\u0026amp; y[sa[i]+j] == y[sa[i-1]+j])?m:++m; } } void getheight(int n){ for(int i = 0,h = ht[0] = 0;i\u0026lt;n;i++){ int j = sa[rk[i]-1]; while(i+h \u0026lt; n \u0026amp;\u0026amp; j+h \u0026lt; n \u0026amp;\u0026amp; s[i+h] == s[j+h]) h++; ht[rk[i]] = h; if(h) h--; } } void solve(int *str,int n){ for(int i = 0;i\u0026lt;n;i++) s[i] = str[i]; get_sa(++n,200); getheight(n); } } ll ANS = 0,ans[MAXN]; namespace BCJ{ int f[MAXN],num[MAXN][4]; void init(int n,int *own){ for(int i = 0;i\u0026lt;=n;i++) f[i] = i,num[i][own[i]] = 1; } int find(int x){ return f[x] == x?x:f[x] = find(f[x]); } int cal(int x){ return 1LL * num[x][1] * num[x][2] * num[x][3] % mod; } void merge(int x,int y){ int fx = find(x),fy = find(y); if(fx == fy) return; ANS -= cal(fx),ANS -= cal(fy); f[fx] = fy; for(int i = 1;i\u0026lt;=3;i++) num[fy][i] += num[fx][i]; ANS += cal(fy); ANS = (ANS%mod); if(ANS \u0026lt; 0) ANS += mod; } } int ss; int S[MAXN]; int own[MAXN]; void addchar(int c,int x = 0){own[ss] = x;S[ss] = c;ss++;} int l1,l2,l3; char s1[MAXN],s2[MAXN],s3[MAXN]; void init(){ scanf(\u0026#34;%s\u0026#34;,s1);l1 = strlen(s1); scanf(\u0026#34;%s\u0026#34;,s2);l2 = strlen(s2); scanf(\u0026#34;%s\u0026#34;,s3);l3 = strlen(s3); for(int i = 0;i\u0026lt;l1;i++) addchar(s1[i],1); addchar(\u0026#39;z\u0026#39;+1); for(int i = 0;i\u0026lt;l2;i++) addchar(s2[i],2); addchar(\u0026#39;z\u0026#39;+2); for(int i = 0;i\u0026lt;l3;i++) addchar(s3[i],3); addchar(\u0026#39;z\u0026#39;+3); } struct Node{ int pos,v; bool operator \u0026lt; (const Node \u0026amp;x)const{ return v \u0026gt; x.v; } }; vector\u0026lt;Node\u0026gt; v; void solve(){ BCJ::init(ss+1,own); SA::solve(S,ss); for(int i = 1;i\u0026lt;ss+1;i++){ v.push_back((Node){i,SA::ht[i]}); } sort(v.begin(),v.end()); int now = 0; int t = min(l1,min(l2,l3)); for(int i = t;i\u0026gt;=1;--i){ while(now \u0026lt; int(v.size())-1 \u0026amp;\u0026amp; v[now].v \u0026gt;= i){ int tmp = v[now].pos; BCJ::merge(SA::sa[tmp],SA::sa[tmp-1]); now++; } ans[i] = ANS; } for(int i = 1;i\u0026lt;=t;i++){ printf(\u0026#34;%lld \u0026#34;,ans[i]); } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":83,"section":"posts","tags":["字符串","后缀数组"],"title":"「CF452E」Three strings-后缀数组","uri":"https://blog.chenqiqian.com/posts/cf452e/"},{"content":"Inna 有一个一个长度为 $n$ 的数列 $a_1 [1],a_1 [2],\\dots,a_1 [n]$。\n她会进行如下操作，分为 $n$ 个阶段：\n在第一阶段，Inna 从数组 $a_1$中写出所有数字，在第 $i$ 个 $(i \\ge 2)$ 阶段 Inna 会写出数组的所有元素 $a_i$ ，由 $n - i + 1$ 个整数组成; 数组 $a_i$ 的第 $k$ 个数定义如下：$a _ {i} [k] = a _ {i-1} [k]\\ \\mathrm{AND}\\ a _ {i-1} [k + 1]$ 。 这里 $\\mathrm{AND}$ 是二进制的逐位与运算。\nDima 决定检验 Inna 的技能。 他要求 Inna 改变阵列，进行练习并说出她在当前练习中写出的所有元素的总和，即：\n$$\n\\sum _ {i=1}^n \\sum _ {j=1}^{n-i+1} a_i[j]\n$$\n请帮助 Inna 回答问题！\n链接 Codeforces\n题解 每位贡献独立，方便合并，一看就要分位考虑嘛。\n我们分位考虑后，就只剩下只包含 0/1 ，每次把一个位置 0-\u0026gt;1 或者 1-\u0026gt;0 ，然后重新计算这一位的贡献。\n事实上，我们在一位的情况下，我们只要计算出多少长度在 $[1,n]$ 的区间包含至少 1 个 0 。\n我们考虑用唯一性确定这个事情（用最先出现的 0 计算贡献），就是左端点从上一个 0 到这个 0 的区间，右端点在这个 0 以右的区间。\n用 set 维护每个 0 出现的位置，每次修改计算下贡献就好了。\n时间复杂度是 $O(n \\log n \\log V)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  #include \u0026lt;bits/stdc++.h\u0026gt;#define int long long using namespace std; const int MAXN = 210000,logn = 21; int n,m,ANS = 0; int num[MAXN]; set\u0026lt;int\u0026gt; S[logn];// 维护0出现的位置  int getpre(int pos,int x){// 小于 pos 的第一个 x  auto it = S[x].lower_bound(pos); return *(--it); } int getnex(int pos,int x){// 大于 pos 的第一个 x  auto it = S[x].upper_bound(pos); return *it; } int calc(int now,int last,int x){ return (now-last) * (n-now+1) * (1LL\u0026lt;\u0026lt;x); } void update(int p,int v){ for(int i = 0;i\u0026lt;logn;i++){ int tmp = (v\u0026amp;(1\u0026lt;\u0026lt;i))!=0; if(tmp != (int)(S[i].count(p))) continue; int last = getpre(p,i),nex = getnex(p,i); if(!tmp){ ANS += calc(nex,last,i); ANS -= calc(nex,p,i);ANS -= calc(p,last,i); S[i].insert(p); } else{ ANS -= calc(nex,last,i); ANS += calc(nex,p,i);ANS += calc(p,last,i); S[i].erase(p); } } } void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;n,\u0026amp;m); for(int x = 0;x\u0026lt;logn;x++) for(int i = 1;i\u0026lt;=n;i++) S[x].insert(i); for(int i = 0;i\u0026lt;logn;i++) S[i].insert(0),S[i].insert(n+1); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;num[i]); update(i,num[i]); } } void solve(){ int v,p; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;p,\u0026amp;v); update(p,v); printf(\u0026#34;%lld\\n\u0026#34;,ANS); } } signed main(){ init(); solve(); return 0; }   ","description":"","id":84,"section":"posts","tags":["数据结构"],"title":"「CF400E」Inna and Binary Logic-简单数据结构","uri":"https://blog.chenqiqian.com/posts/cf400e/"},{"content":"你是一个程序猿，现在有一棵新年树（并不是传统的带着叶子的树）——它有四个节点： $1$ ，$2$ ，$3$ ，$4$ . 其中$2$ ，$3$ ，$4$ 的父亲都是 $1$ .\n新年里，程序猿们往往会做一些有趣的事情。你则选择以往这棵树上加节点来取乐。 一个添加节点的操作是这样的：\n 找到树上的一个叶子结点 $v$ . 设现在树上有 $n$ 个节点，那么你现在会加入两个节点$n+1$ 和 $n+2$ ，它们都会成为 $v$ 的儿子.  你的任务是在做 $q$ 次这样的操作，并在每做完一次后计算一次树的直径。来吧，我们一起来解决这道新年问题吧！\n链接 Codeforces\n伪题解 我们考虑树形dp计算树的直径的过程。\n我们如果令 $f[i]$ 为以 $i$ 为根的子树中最长的链的长度，$g[i]$ 为以 $i$ 为根的子树中的直径长度（过根节点），那么就有如下转移：\n$$\nf[v] = \\max(f[v_1] + f[v_2]) + 1\\\ng[v] = f[v_1] + f[v_2] + 2\n$$\n如果我们令 $dep[v]$ 为 $v$ 的深度，那么我们可以将第一个改写如下：\n$$\nf[v] = \\max _ {v_i \\text{ is in the subtree of } v}(dep[v_i]) - dep[v]\n$$\n我们可以用倍增在 $O(\\log n)$ 的时间内找到第一个不需要更新的位置，然后在倍增上用 $O(\\log n)$ 的时间内更新 $f$ 值，计算得到 $delta$（每次深度只增加1，所以一定会只有一个delta），然后将 $g$ 修改维护即可。\n看了 Tutorial 之后有些自闭，题解给出了一个非常轻松愉悦的办法。\n题解 我们思考 $\\text{dfs}$ 计算直径的过程，从一个节点找到最远的一个节点，这个节点一定是直径的一个端点，然后我们再进行一遍 $\\text{dfs}$ 最远点就是直径的另一个的端点。\n所以我们考虑从根节点进行第一次 $\\text{dfs}$ ，找到最远的第一个节点（事实上是深度最大的节点之一皆可）。\n如果我们给一个节点新建了两个子节点，我们发现它们的父亲是当前最远的节点，那么答案一定增加且只增加了 $1$ ；\n否则，答案只有可能被当前最远的节点和新增加的节点之间的距离更新。\n那么就可以倍增维护 $\\text{LCA}$ 计算树上距离，在 $O(n \\log n)$ 的时间内解决这个问题。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 1001000,logn = 22; int q; int f[MAXN][logn],dep[MAXN],t[MAXN]; int lca(int x,int y){ if(dep[x] \u0026lt; dep[y]) swap(x,y); for(int i = logn-1;i\u0026gt;=0;--i){ if(dep[f[x][i]] \u0026gt;= dep[y]) x = f[x][i]; } if(x == y) return x; for(int i = logn-1;i\u0026gt;=0;--i){ if(f[x][i] != f[y][i]) x = f[x][i],y = f[y][i]; } return f[x][0]; } void addnode(int x,int fa){ f[x][0] = fa,dep[x] = dep[fa]+1; for(int i = 1;i\u0026lt;logn;i++){ f[x][i] = f[f[x][i-1]][i-1]; } } int caldis(int x,int y){ return dep[x] + dep[y] - 2 * dep[lca(x,y)]; } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;t[i]); } void solve(){ dep[1] = 1,dep[2] = dep[3] = dep[4] = 2; f[2][0] = f[3][0] = f[4][0] = 1; int maxdep = 2,maxnode = 2,ans = 2,n = 4; for(int i = 1;i\u0026lt;=q;i++){ int x = t[i]; addnode(++n,x),addnode(++n,x); if(dep[x] == maxdep){ maxdep++,maxnode = n,ans++; } else{ ans = max(ans,caldis(maxnode,n)); } printf(\u0026#34;%d\\n\u0026#34;,ans); } } int main(){ init(); solve(); return 0; }   ","description":"","id":85,"section":"posts","tags":["数据结构","树形结构","树的直径"],"title":"「CF379F」New Year Tree-树的直径-倍增","uri":"https://blog.chenqiqian.com/posts/cf379f/"},{"content":"有 $n$ 条线段，分别为 $[l_i,r_i]$ 。\n有 $m$ 个询问，分别为 $cnt_i,p_1,p_2,\u0026hellip;,p _ {cnt_i}$ 。\n对于每个询问，输出有多少线段至少覆盖这 $cnt_i$ ​个点中的一个。（$\\sum cnt_i \\le 3 \\cdot 10^5$）\n链接 Codeforces\n题解 我们可以考虑一个点的贡献会出现在哪些区间。\n我们最大的问题是每个区间可能被多个点在内，我们如果按照每个点在内（左端点在左，右端点在右）的话，会重复统计一些区间。\n我们考虑用唯一性确定这个贡献，用最左侧的点给区间计算贡献。所以我们每个点可能生发出贡献的区间是从左边的上一个点右边一直到这个点右边最右侧位置。\n我们可以考虑用扫描线计算这个东西，我们考虑对每次给出的点排序，然后扫描线维护即可。\n我们可以维护两个BIT/线段树，然后查询区间和即可。\n需要 KD Tree 或者树套树或者 CDQ 分治来完成二维数点的任务。\n可以线段树套 vector 解决这个问题。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 310000; int n,m,cnt = 0; struct Line{ int l,r; bool operator \u0026lt; (const Line x)const{ if(l != x.l) return l \u0026lt; x.l; else return r \u0026lt; x.r; } }a[MAXN]; int t[MAXN],back[MAXN]; map\u0026lt;int,int\u0026gt; S; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i].l,\u0026amp;a[i].r); S[a[i].l] = 0; } sort(a+1,a+n+1); for(auto it = S.begin();it!=S.end();it++){ it-\u0026gt;second = ++cnt; back[cnt] = it-\u0026gt;first; } } namespace SegTree{ vector\u0026lt;int\u0026gt; v[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void build(int nown,int l,int r,int *a){ for(int i = l;i\u0026lt;=r;i++) v[nown].push_back(a[i]); sort(v[nown].begin(),v[nown].end()); if(l == r) return; else build(lson,l,mid,a),build(rson,mid+1,r,a); } int a,b; void query(int nown,int l,int r,int ql,int qr,int \u0026amp;ans){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ ans += upper_bound(v[nown].begin(),v[nown].end(),b) - lower_bound(v[nown].begin(),v[nown].end(),a); } else{ if(ql \u0026lt;= mid) query(lson,l,mid,ql,qr,ans); if(qr \u0026gt;= mid+1) query(rson,mid+1,r,ql,qr,ans); } } int query(int n,int x1,int x2,int y1,int y2){ if(x1 \u0026gt; x2) return 0; a = y1,b = y2; int ans = 0; query(1,1,n,x1,x2,ans); return ans; } } void build(){ static int tmp[MAXN]; for(int i = 1;i\u0026lt;=n;i++){ tmp[i] = a[i].r; } for(int i = 1;i\u0026lt;=n;i++){ t[i] = back[S[a[i].l]]; } SegTree::build(1,1,n,tmp); } int s[MAXN]; int getval(int x){ return upper_bound(t+1,t+n+1,x) - t; } void solve_case(){ int p; scanf(\u0026#34;%d\u0026#34;,\u0026amp;p); for(int i = 1;i\u0026lt;=p;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;s[i]); sort(s+1,s+p+1); s[0] = -1e9; int ans = 0; for(int i = 1;i\u0026lt;=p;i++){ ans += SegTree::query(n,getval(s[i-1]),getval(s[i])-1,s[i],1e9); } printf(\u0026#34;%d\\n\u0026#34;,ans); } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ solve_case(); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":86,"section":"posts","tags":["数据结构","线段树","树套树"],"title":"「CF369E」Valera and Queries-线段树","uri":"https://blog.chenqiqian.com/posts/cf369e/"},{"content":"Zxr960115 是一个大农场主。他养了 $m$ 只可爱的猫子,雇佣了 $p$ 个铲屎官。这里有一条又直又长的道路穿过了农场，有 $n$ 个山丘坐落在道路周围，编号自左往右从1到n。山丘 $i$ 与山丘 $i-1$ 的距离是 $d_i$ 米。铲屎官们住在 $1$ 号山丘。\n一天，猫子们外出玩耍。猫子 $i$ 去山丘 $h_i$ 游玩，在 $t_i$ 时间结束他的游玩，然后在山丘 $h_i$ 傻等铲屎官。铲屎官们必须把所有的猫子带上。每个铲屎官都会从 $1$ 走到 $n$ 号山丘，可以不花费时间的把所有路途上游玩结束的猫子带上。每个铲屎官的速度为一米每单位时间，并且足够强壮来带上任意数量的猫子。\n你的任务是安排每个铲屎官出发的时间，最小化猫子们等待的时间之和。\n链接 Codeforces\n题解 我们令\n$$\nD[i] = \\sum _ {j=2}^i d[j]\n$$\n那我们可以吧所有的 $t[i]$ 减去 $D[h[i]]$ ，得到一个新的 $t[i]$ ，那么如果一个饲养员在 $t \\le t[i]$ 之前出发，就能够收集到这个猫，猫的等待时间为 $t[i] - t$。\n我们再令\n$$\nT[i] = \\sum _ {j = 1}^{i-1} t[j]\n$$\n我们把猫按照新获得 $t[i]$ 排序之后，我们如果令 $dp[i][j]$ 为恰好取到前 $i$ 只猫，用去 $j$ 个饲养员时候的最小代价。\n很明显有如下转移：\n$$\ndp[i][w] = \\max _ {0 \\le j \\le i-1}(dp[j][w-1] + t[i]\\times (i-j) - (T[i] - T[j]))\n$$\n我们当 $j \\le k$时，$k$ 比 $j$ 优等价于：\n$$\ndp[j][w-1] + t[i]\\times (i-j) - T[i] + T[j] \\ge dp[k][w-1] + t[i]\\times (i-k) - T[i] + T[k]\\\ndp[j][w-1] - t[i]\\times j + T[j] \\ge dp[k][w-1] - t[i]\\times k + T[k]\\\ndp[j][w-1] + T[j] -dp[k][w-1] - T[k] \\ge t[i]\\times j - t[i]\\times k \\\ndp[j][w-1] + T[j] -dp[k][w-1] - T[k] \\ge t[i]\\times (j - k) \\\n\\frac{dp[j][w-1] + T[j] -dp[k][w-1] - T[k]}{(j - k)} \\le t[i] \\\n\\frac{Y(j) - Y(k)}{X(j)-X(k)} \\le t[i]\n$$\n$t[i]$ 单调递增，那么我们一旦 $k$ 比 $j$ 优，那么 $k$ 就在之后会一直比 $j$ 优，我们就可以用单调队列（维护一个单调递增的队列？）优化这个问题，事实上是维护一个凸包..？\n时间复杂度 $O(n + mp)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long #define inf 1e18 using namespace std; const int MAXN = 110000; int n,m,p; int d[MAXN],h[MAXN],t[MAXN]; ll T[MAXN]; void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;p); for(int i = 2;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;d[i]); d[i] += d[i-1]; } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;h[i],\u0026amp;t[i]); t[i] -= d[h[i]]; } sort(t+1,t+m+1); for(int i = 1;i\u0026lt;=m;i++){ T[i] = T[i-1] + t[i]; } } ll a[MAXN],b[MAXN]; ll *dp,*last; int q[MAXN],fi,la; double caly(int x){return last[x] + T[x];} double calc(int j,int k){return (caly(j) - caly(k))/(j-k);} ll caldp(int i,int j){ return last[j] + 1LL * t[i] * (i-j) - (T[i] - T[j]); } void solve(){ dp = a,last = b; for(int i = 0;i\u0026lt;=m;i++) dp[i] = inf; dp[0] = 0; for(int w = 1;w\u0026lt;=p;w++){ fi = la = 0; q[0] = 0; swap(dp,last); for(int i = 1;i\u0026lt;=m;i++){ while(fi \u0026lt; la \u0026amp;\u0026amp; calc(q[fi],q[fi+1]) \u0026lt;= t[i]) fi++; dp[i] = caldp(i,q[fi]); while(fi \u0026lt; la \u0026amp;\u0026amp; calc(q[la-1],q[la]) \u0026gt;= calc(q[la],i)) la--; q[++la] = i; } } printf(\u0026#34;%lld\\n\u0026#34;,dp[m]); } int main(){ init(); solve(); return 0; }   ","description":"","id":87,"section":"posts","tags":["动态规划","斜率优化"],"title":"「CF311B」Cats Transport-斜率优化dp","uri":"https://blog.chenqiqian.com/posts/cf311b/"},{"content":"给定一个长度为 $n(1 \\le n \\le 77777)$ 的数列 $a$ ，初始的时候全为 0。\n给出一个 $3 \\times 3$ 的矩阵 $w _ {i,j}$ ，$w _ {i,j} = 1$ 时代表 $(i,j)$ 这个有序数对为和谐的数对，否则 $(i,j)$ 不为一个和谐数对。\n一个数列 $a$ 是和谐的当且仅当对于所有的 $1\\le i \\le n-1$ ， $(a_i,a _ {i+1})$ 均为和谐数对。\n有 $m(1\\le m \\le 77777)$ 次修改和询问，每次给出两个整数 $v_i,t_i$，将 $a _ {v_i} (1 \\le v_i \\le n)$ 修改为 $t_i(0\\le t_i \\le 3)$。\n每次修改后都询问，如果将数列里所有的 $0$ 都替换为任意 $1$ 到 $3$ 之间的整数（不同位置的 $0$ 可以替换为不同的数），那么最后产生的和谐的数列有多少种。每次修改后的查询并不会使数列发生任何改变。\n答案对 $777777777$ 取模。\n链接 Codeforces\n题解 我们维护一个线段树，每个区间上都维护一个 $f[i][j]$ 代表这个区间左端点数字为 $i$ 的时候，右端点为 $j$ 的时候，满足以上条件的方案数。\n合并直接枚举两边各九种组合合并即可。\n时间复杂度 $O(n \\log n \\times 81)$ ，貌似可以过。\n我想了一个麻烦死的线性动态 $dp$，好像也可以做，时间复杂度应该是一样的，但不想写了\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long #define mod 777777777LL using namespace std; const int MAXN = 80000; int w[3][3]; namespace SegTree{ struct Node{ ll f[3][3]; Node(){ f[0][0] = f[0][1] = f[0][2] = 0; f[1][0] = f[1][1] = f[1][2] = 0; f[2][0] = f[2][1] = f[2][2] = 0; } void clear(){ f[0][0] = f[0][1] = f[0][2] = 0; f[1][0] = f[1][1] = f[1][2] = 0; f[2][0] = f[2][1] = f[2][2] = 0; } ll *operator [](const int x){return f[x];} }tree[MAXN*4]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  Node merge(Node \u0026amp;l,Node \u0026amp;r){ Node ans; for(int i = 0;i\u0026lt;3;i++){ for(int j = 0;j\u0026lt;3;j++){ for(int x = 0;x\u0026lt;3;x++){ for(int y = 0;y\u0026lt;3;y++){ ans[i][j] += w[x][y] * l[i][x] * r[y][j]; } } ans[i][j] %= mod; } } return ans; } void build(int nown,int l,int r){ if(l == r){ tree[nown].clear(); tree[nown][0][0] = tree[nown][1][1] = tree[nown][2][2] = 1; } else{ build(lson,l,mid),build(rson,mid+1,r); tree[nown] = merge(tree[lson],tree[rson]); } } void update(int nown,int l,int r,int pos,int v){ // printf(\u0026#34;%d %d %d\\n\u0026#34;,l,r,pos);  if(l == r){ tree[nown].clear(); if(v == 0){tree[nown][0][0] = tree[nown][1][1] = tree[nown][2][2] = 1;} else {tree[nown][v-1][v-1] = 1;} // printf(\u0026#34;!!\\n\u0026#34;);  } else{ if(pos \u0026lt;= mid) update(lson,l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rson,mid+1,r,pos,v); tree[nown] = merge(tree[lson],tree[rson]); // printf(\u0026#34;a:%d %d %d\\n\u0026#34;,l,r,pos);  } } ll query(){ ll ans = 0; for(int i = 0;i\u0026lt;3;i++){ for(int j = 0;j\u0026lt;3;j++){ ans += tree[1][i][j]; } } return ans % mod; } } int n,m; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 0;i\u0026lt;3;i++){ for(int j = 0;j\u0026lt;3;j++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i][j]); } } SegTree::build(1,1,n); } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ int p,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;p,\u0026amp;v); SegTree::update(1,1,n,p,v); printf(\u0026#34;%lld\\n\u0026#34;,SegTree::query()); } } int main(){ init(); solve(); return 0; }   ","description":"","id":88,"section":"posts","tags":["数据结构","线段树"],"title":"「CF256E」Lucky Arrays-简单线段树","uri":"https://blog.chenqiqian.com/posts/cf256e/"},{"content":"给定一个长度为 $n$ 的数列 $a_1,a_2,\u0026hellip;,a_n$，定义 $f(x,k) = \\min _ {i=0}^{k-1} (a _ {x+i})$ ，请对于每一个 $k = 1$ 到 $n$ ，求出 $\\sum _ {i=1}^{n-k+1} f(i,k)$ 的值。\n链接 Codeforces\n题解 我拥有一个非常丑陋的做法（\n我们维护一个并查集，然后我们从大往小加入每个数 $a[i]$，每次插入 $a[i]$ 都尝试与 $i$ 左边/右边的集合合并。\n我们发现，合并的区间中间有一个区间最小的数 $a[i]$ ，那么我们发现会新出现一些区间，它们的最小值均为 $a[i]$ 。假设左边的集合大小为 $L$，右边的集合大小为 $R$，那么我们新增的区间就是：\n 加上长度为 $L+R+1$ 的区间的所有子区间，最小值为 $a[i]$ 减去长度分别为 $L$ 和 $R$ 的区间的所有子区间，最小值为 $a[i]$  我们发现长度为 $x$ 的区间的子区间事实上是：\n 长度为 $1$ 的子区间： $x$ 个 长度为 $2$ 的子区间： $x-1$ 个 $\\cdots$ 长度为 $x-1$ 的子区间：$2$ 个 长度为 $x$ 的子区间： $1$ 个  事实上是一个等差数列\u0026hellip;所以如果我们维护差分值的话，就相当于一个某位置单点加 $x$，其余位置区间减 $1$ 的操作 ..？（事实上还要乘上一个 $a[i]$ ）\n第一个操作我们维护一个差分数组，第二个操作我们维护一个二阶差分数组，这个题大概就可以做了？\n最后线性递推出所有的答案即可。\n常数巨大无比警告\u0026hellip;大约是 $O(n \\alpha(n))$ ..？\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include \u0026lt;bits/stdc++.h\u0026gt;#define int long long using namespace std; const int MAXN = 1100000; namespace BCJ{ int f[MAXN],siz[MAXN]; void init(int n){ for(int i = 1;i\u0026lt;=n;i++) f[i] = i,siz[i] = 1; } int find(int x){ return f[x] == x?x:f[x] = find(f[x]); } void merge(int x,int y){ int fx = find(x),fy = find(y); if(fx == fy) return; f[fx] = fy; siz[fy] += siz[fx]; } int getsize(int x){return siz[find(x)];} } int n,m; int num[MAXN],s[MAXN],vis[MAXN]; int c1[MAXN],c2[MAXN],ans[MAXN]; bool cmp(int a,int b){return num[a] \u0026gt; num[b];} void init(){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;num[i]); } BCJ::init(n); } void addc(int x,int v,int val){ if(x == 0) return; // printf(\u0026#34;add: x:%lld val:%lld v:%lld\\n\u0026#34;,x,val,v);  c1[1] += v*x*val; c2[1] -= v*1*val,c2[x+1] += v*1*val; } void calc(){ for(int i = 1;i\u0026lt;=n;i++) s[i] = i; sort(s+1,s+n+1,cmp); for(int i = 1;i\u0026lt;=n;i++){ int t = s[i]; vis[t] = 1; int L = 0,R = 0; if(vis[t-1]) L = BCJ::getsize(t-1),BCJ::merge(t,t-1); if(vis[t+1]) R = BCJ::getsize(t+1),BCJ::merge(t,t+1); addc(L+R+1,1,num[t]),addc(L,-1,num[t]),addc(R,-1,num[t]); } } void solve(){ for(int i = 1;i\u0026lt;=n;i++) c2[i] = c2[i-1] + c2[i]; for(int i = 1;i\u0026lt;=n;i++) c2[i] = c2[i-1] + c2[i]; for(int i = 1;i\u0026lt;=n;i++) c1[i] = c1[i-1] + c1[i]; ans[1] = c1[1]; for(int i = 1;i\u0026lt;=n;i++) ans[i+1] = c1[i] + c2[i]; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ int t; scanf(\u0026#34;%lld\u0026#34;,\u0026amp;t); printf(\u0026#34;%.10lf\\n\u0026#34;,double(ans[t])/(n-t+1)); } } signed main(){ init(); calc(); solve(); return 0; }   ","description":"","id":89,"section":"posts","tags":["数据结构"],"title":"「CF212D」Cutting a Fence-简单数据结构","uri":"https://blog.chenqiqian.com/posts/cf212d/"},{"content":"给你一片森林，每次询问一个点与多少个点拥有共同的 $K$ 级祖先。\n题解 用倍增处理出 $k$ 级祖先，然后离线所有询问到一个数对： $(x,d)$ 表示需要查询在 $x$ 为根的子树中深度为 $d$ 的节点个数，每个询问的答案就是这个节点个数减 $1$ 。\n我们可以用线段树合并解决这个问题。\n时间复杂度 $O((n+m) \\log n)$ ，空间复杂度 $O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000,logn = 20; struct Edge{ int v,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } namespace SegTree{ int sumn[MAXN*logn*5],ls[MAXN*logn*5],rs[MAXN*logn*5],cnt = 0; #define mid ((l+r)\u0026gt;\u0026gt;1)  void update(int \u0026amp;nown,int l,int r,int pos,int v){ if(!nown) nown = ++cnt; if(l == r) sumn[nown] += v; else{ if(pos \u0026lt;= mid) update(ls[nown],l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rs[nown],mid+1,r,pos,v); sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]]; } } int query(int nown,int l,int r,int pos){ if(!nown) return 0; if(l == r) return sumn[nown]; else{ if(pos \u0026lt;= mid) return query(ls[nown],l,mid,pos); else return query(rs[nown],mid+1,r,pos); } } void merge(int \u0026amp;lt,int rt,int l,int r){ if(lt == 0 || rt == 0){lt = lt + rt;return;} if(l == r) sumn[lt] += sumn[rt]; else{ merge(ls[lt],ls[rt],l,mid); merge(rs[lt],rs[rt],mid+1,r); sumn[lt] = sumn[ls[lt]] + sumn[rs[lt]]; } } } int n,m; int fa[MAXN][logn],dep[MAXN]; struct Q{int d,id;}; vector\u0026lt;Q\u0026gt; q[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;fa[i][0]); if(fa[i][0] != 0) addedge(fa[i][0],i); } } void dfs0(int nown,int depth){ dep[nown] = depth; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].v; dfs0(v,depth+1); } } int find_kth(int x,int k){ int t = dep[x] - k; for(int i = logn-1;i\u0026gt;=0;i--){ if(dep[fa[x][i]] \u0026gt;= t) x = fa[x][i]; } return x; } void build(){ for(int j = 1;j\u0026lt;logn;j++) for(int i = 1;i\u0026lt;=n;i++) fa[i][j] = fa[fa[i][j-1]][j-1]; for(int i = 1;i\u0026lt;=n;i++) if(fa[i][0] == 0) dfs0(i,1); } int ans[MAXN]; void pre_calc(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ int v,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;v,\u0026amp;p); int x = find_kth(v,p); if(x == 0) continue; q[x].push_back((Q){dep[x]+p,i}); } } int rt[MAXN]; void dfs1(int nown){ SegTree::update(rt[nown],1,n,dep[nown],1); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].v; dfs1(v); SegTree::merge(rt[nown],rt[v],1,n); } for(unsigned i = 0;i\u0026lt;q[nown].size();i++){ int id = q[nown][i].id,dd = q[nown][i].d; if(dd \u0026gt; n) continue; ans[id] = SegTree::query(rt[nown],1,n,dd) - 1; } } void solve(){ for(int i = 1;i\u0026lt;=n;i++) if(fa[i][0] == 0) dfs1(i); for(int i = 1;i\u0026lt;=m;i++) printf(\u0026#34;%d \u0026#34;,ans[i]); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); build(); pre_calc(); solve(); return 0; }   ","description":"","id":90,"section":"posts","tags":["数据结构","树形结构","线段树合并"],"title":"「CF208E」Blood Cousins-线段树合并","uri":"https://blog.chenqiqian.com/posts/cf208e/"},{"content":"Bertown 大街可以抽象为一条数轴。在数轴上有 $10^9$ 个巴士站。站点按照它们在数轴上的顺序从 $1$ 到 $10^9$ 的整数编号。这个城市有 $n$ 辆公共汽车。每天第 $i$ 个公共汽车从 $s_i$ 位置出发，到 $f_i$ 位置停止（ $s_i \u0026lt; f_i$ ），它在所有位于 $s_i$ 与 $f_i$ 的中间站点停靠并且仅在晚上返回。公共汽车在时间 $t_i$ 开始行驶，并且它也在时间 $t_i$ 完成行驶（行驶、停靠都是瞬间的）。所有公共汽车的开始时间 $t_i$ 都不同。公交车有无限的容量。\nBertown 有很多居民。今天第 $i$ 个人要从 $l_i$ 位置出发到 $r_i$ 位置结束（ $l_i \u0026lt; r_i$ ）；第 $i$ 个人在时间 $b_i$ 进入他的出发位置（ $l_i$ ）。一方面，每个人都希望尽快到达目的地，另一方面，他不想换乘公交车。\n也就是：为第 $i$ 个人挑选的公交汽车 $j$ ，满足 $s_j \\leq l_i$, $r_i \\leq f_j$ 和 $b_i \\leq t_j$ 的条件下，$t_j$ 最小。\n你的任务是确定每个人今天是否可以到达目的地，如果可以，找到每个人将乘坐的公交车的号码，不可以则输出 $-1$ 。\n题解 我只想到了一个线段树套set的 $O(n \\log^2 n)$ 的做法，但 tutorial 给出了一个 $O((n+m) \\log (n+m))$ 的优秀做法。\n我们在这里从 $t$ 从小往大处理，按时间顺序加入每个人；加入车的时候只需要判断哪些人可以被这个车带走，然后这个车就是这些人的答案。\n我们考虑使用一个线段树维护这个所有人。我们根据 $l[i]$ 从小到大建立这个树，每个位置放置一个人，维护区间的 $r[i]$ 最小值及出现位置。\n当我们加入一个 $s_i,f_i$ 的车的时候，我们只需要在所有 $l[i]$ 大于 $s[i]$ 的部分中，找到一个 $r[i]$ 最小的人，把它删掉，然后持续到找不到这个人即可。最后还在树里面的都是无法乘车的人。\n这个方法很好啊，比我树套树不知道高到哪里去了\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f using namespace std; typedef pair\u0026lt;int,int\u0026gt; pii; const int MAXN = 210000; struct B{ int l,r,t,id; bool operator \u0026lt; (const B \u0026amp;x)const{return t \u0026lt; x.t;} }bus[MAXN],p[MAXN]; bool cmp(B \u0026amp;x,B \u0026amp;y){return x.l \u0026lt; y.l;} struct Node{ int minn,pos,id; bool operator \u0026lt; (const Node \u0026amp;x)const{return minn \u0026lt; x.minn;} }; int n,m; pii LL[MAXN]; namespace SegTree{ Node t[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)/2)  void build(int nown,int l,int r,int *id){ if(l == r){ t[nown] = (Node){inf,l,id[l]}; } else{ build(lson,l,mid,id),build(rson,mid+1,r,id); t[nown] = min(t[lson],t[rson]); } } void update(int nown,int l,int r,int pos,int v){//change v  if(l == r) t[nown].minn = v; else{ if(pos \u0026lt;= mid) update(lson,l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rson,mid+1,r,pos,v); t[nown] = min(t[lson],t[rson]); } } Node query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return t[nown]; else{ Node ans = (Node){inf,0,0}; if(ql \u0026lt;= mid) ans = min(ans,query(lson,l,mid,ql,qr)); if(qr \u0026gt;= mid+1) ans = min(ans,query(rson,mid+1,r,ql,qr)); return ans; } } #undef lson  #undef rson  #undef mid } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;bus[i].l,\u0026amp;bus[i].r,\u0026amp;bus[i].t); bus[i].id = i; } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;p[i].l,\u0026amp;p[i].r,\u0026amp;p[i].t); LL[i] = make_pair(p[i].l,i); p[i].id = i; } sort(LL+1,LL+m+1); sort(p+1,p+m+1),sort(bus+1,bus+n+1); } int xx[MAXN]; int tmp[MAXN],pos[MAXN],ans[MAXN]; void build(){ for(int i = 1;i\u0026lt;=m;i++) tmp[i] = LL[i].second,xx[i] = LL[i].first,pos[LL[i].second] = i; SegTree::build(1,1,m,tmp); } void add_person(int now){ SegTree::update(1,1,m,pos[p[now].id],p[now].r); } void add_bus(int now){ int L = lower_bound(xx+1,xx+m+1,bus[now].l) - xx; if(L == m+1) return; while(true){ Node t = SegTree::query(1,1,m,L,m); if(t.minn \u0026gt; bus[now].r) break; else{ ans[t.id] = bus[now].id; SegTree::update(1,1,m,t.pos,inf); } } } void solve(){ int nx = 1,ny = 1; while(true){ if(nx == (n+1)) break; if((nx != n+1 \u0026amp;\u0026amp; ny == m+1) || bus[nx].t \u0026lt; p[ny].t ) add_bus(nx++);// 新加入人？新加入车？  else add_person(ny++); } for(int i = 1;i\u0026lt;=m;i++) printf(\u0026#34;%d \u0026#34;,ans[i] == 0?-1:ans[i]); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":91,"section":"posts","tags":["数据结构","线段树"],"title":"「CF160E」Buses and People-线段树","uri":"https://blog.chenqiqian.com/posts/cf160e/"},{"content":"你是一个赛车比赛的组织者，想在线性王国中安排一些比赛。\n线性王国有 $n$ 条连续的从左到右的道路。道路从左到右依次编号为从 $1$ 到 $n$ ，因此道路按照升序排列。在这些道路上可能会有几场比赛，每一场比赛都将使用这些道路的某个连续的子序列。而且，如果某场比赛举行了，你将获得一定数额的金钱。没有比赛在时间上重叠，所以每一段道路可以在多个比赛中使用。\n不幸的是，所有道路的状况都不佳，需要修理。每条路都有与之相关的维修费用，你需要支付这笔费用来修理道路。只有在某场比赛中需要使用的所有道路都进行了修复，才能进行比赛。你的任务是修复道路并使你的利润最大化。你的利润被定义为你从比赛中获得的总金额减去你花在修理道路上的钱。请注意，您可以决定不修任何道路，并获得利润 $0$ 。\n输出你能获得的最大利润。\n链接 Codeforces\n题解 考虑动态规划。我们令 $dp[i][j]$ 为只考虑前 $i$ 个路，上一个没修的路在 $j$ 位置处的答案。\n我们显然有以下状态转移：\n$$\ndp[i][j] = \\left {\n\\begin{aligned}{}\ndp[i-1][j] - c[i] + p[i][j]\u0026amp;,j \u0026lt; i\\\nmax(dp[i-1][k])\u0026amp;,j = i\\\n\\end{aligned}\n\\right.\n$$\n其中 $p[i][j]$ 由所有左端点在 $j$ 右侧，右端点在 $i$ 的赛道构成，事实上我们可以每个赛道的贡献出现在其左端点左侧，所以是一个区间加。\n我们考虑如何快速转移，针对第一个操作，只要支持区间加减即可。\n对于第二个只要支持区间最值查询，那么我们一个线段树就可以解决了。\n有趣的优化\u0026hellip;\n时间复杂度：$O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 0x3f3f3f3f3f3f3f3f #define ll long long using namespace std; const int MAXN = 210000; int n,m; ll num[MAXN]; namespace SegTree{ #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  ll maxn[MAXN\u0026lt;\u0026lt;2],addn[MAXN\u0026lt;\u0026lt;2]; void add(int nown,ll v){ maxn[nown] += v,addn[nown] += v; } void push_down(int nown){ if(addn[nown] != 0){ add(lson,addn[nown]),add(rson,addn[nown]); addn[nown] = 0; } } void update(int nown,int l,int r,int ql,int qr,ll v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ add(nown,v); } else{ push_down(nown); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,v); maxn[nown] = max(maxn[lson],maxn[rson]); } } ll query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return maxn[nown]; } else{ push_down(nown); ll ans = -inf; if(ql \u0026lt;= mid) ans = max(ans,query(lson,l,mid,ql,qr)); if(qr \u0026gt;= mid+1) ans = max(ans,query(rson,mid+1,r,ql,qr)); return ans; } } void _set(int nown,int l,int r,int pos,ll v){ if(l == r){ maxn[nown] = v; } else{ push_down(nown); if(pos \u0026lt;= mid) _set(lson,l,mid,pos,v); if(pos \u0026gt;= mid+1) _set(rson,mid+1,r,pos,v); maxn[nown] = max(maxn[lson],maxn[rson]); } } } typedef pair\u0026lt;ll,ll\u0026gt; pll; vector\u0026lt;pll\u0026gt; V[MAXN];//first-\u0026gt;pos,second-\u0026gt;val  void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;num[i]); } for(int i = 1;i\u0026lt;=m;i++){ ll a,b,c; scanf(\u0026#34;%lld %lld %lld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); V[b].push_back(make_pair(a,c)); } } void solve(){ // 线段树范围 [0,n]  SegTree::update(1,0,n,0,n,-inf); SegTree::_set(1,0,n,0,0); for(int i = 1;i\u0026lt;=n;i++){ ll tmp = SegTree::query(1,0,n,0,i-1); // printf(\u0026#34;%d:%d\\n\u0026#34;,i,tmp);  SegTree::_set(1,0,n,i,tmp); SegTree::update(1,0,n,0,i-1,-num[i]); for(int j = 0;j\u0026lt;int(V[i].size());j++){ ll L = V[i][j].first, val = V[i][j].second; SegTree::update(1,0,n,0,L-1,val); } } printf(\u0026#34;%lld\\n\u0026#34;,SegTree::query(1,0,n,0,n)); } int main(){ init(); solve(); return 0; }   ","description":"","id":92,"section":"posts","tags":["动态规划","数据结构","线段树"],"title":"「CF115E」Linear Kingdom Races-dp+线段树优化","uri":"https://blog.chenqiqian.com/posts/cf115e/"},{"content":"有 $n$ 个海象（编号为 $1$ 到 $n$ ）参加比赛建造自己的摩天大楼 。在 $t=0$ 时，第 $i$ 个海象的摩天大楼的高度为 $a_i$ 。每一时刻，编号为 $i$ 的海象会完成 $b_i$ 层楼的建造。\n在奥运会现场报道的记者向活动组织者提出了 $q$ 次询问。每次询问给出三个数字 $l_i$ ，$r_i$ ，$t_i$。活动组织者用数字 $x$ 回答每个查询，$x$ 满足：\n  数字 $x$ 位于从 $l_i$ 到 $r_i$ 的区间，即 $l_i \\leq x \\leq r_i$ 。\n  编号为 $x$ 的海象的摩天大楼在 $t_i$ 时刻拥有编号在 $[l_i,r_i]$ 中所有海象的摩天大楼中的最大高度。\n  对于每位记者的查询，输出符合上述标准的海象的编号 $x$ 。如果有多个可能的答案，请输出其中任何一个。\n链接 Codeforces\n题解 可以采用分块+离线的方法过掉这道题。\n每个海象的楼的高度都可以视作一条直线 $y = bx + a$ ，那么我们的问题就变成了找这段区间内的直线在 $x = t$ 处的最大值。\n我们注意到，如果我们将所有直线排在一起，那么我们在每一时刻最大值一定来自于一堆斜率递增的直线（就是一个下凸包）。\n我们要在块内处理出按照时间顺序可能取到的直线。我们先在块内按斜率 $b$ 从小到大排序，然后去掉 $b$ 相同的直线后。我们可以再用 $O(\\sqrt{n} \\times \\sqrt{n})$ 的时间枚举该条直线下一条应该是哪条后面的直线（判断谁的交点最靠左），然后我们就可以得到这 $O(\\sqrt{n})$ 条直线的下凸包。\n得到这个凸包之后，我们可以计算答案。\n我们把询问对时间排序，整块判断能不能更新该点的凸包是不是需要下一条直线，零散直接暴力即可。\n时间复杂度： $O((m+n) \\sqrt{n})$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  #include \u0026lt;bits/stdc++.h\u0026gt;#define inf 1e18 #define pii pair\u0026lt;int,int\u0026gt; using namespace std; const int MAXN = 110000; const int MAXQ = 500; struct Query{ int l,r,t,id; bool operator \u0026lt; (const Query \u0026amp;a)const{ return t \u0026lt; a.t; } }q[MAXN]; int n,m,Q; int lb[MAXN],rb[MAXN],bl[MAXN]; struct P{ int a,b,id; bool operator \u0026lt; (const P \u0026amp;x) const{ if(b != x.b) return b \u0026lt; x.b; if(a != x.a) return a \u0026gt; x.a; return 0; } }p[MAXN]; double calv(P x,int t){ return double(x.a) + double(x.b)*t; } bool cmp(P x,P y,int t){// 前面优，返回1，后面优秀，返回 0  if(calv(x,t) != calv(y,t)) return calv(x,t) \u0026gt; calv(y,t); else return x.b \u0026gt; y.b; } double calj(P x,P y){ if(x.b == y.b) return inf; return double(x.a-y.a)/(y.b-x.b); } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;p[i].a,\u0026amp;p[i].b); p[i].id = i; } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;q[i].l,\u0026amp;q[i].r,\u0026amp;q[i].t); q[i].id = i; } sort(q+1,q+m+1); } vector\u0026lt;P\u0026gt; V[MAXQ]; vector\u0026lt;P\u0026gt; tmp; void build(){ Q = sqrt(n); for(int i = 1;i\u0026lt;=n;i++){ bl[i] = (i-1)/Q + 1; if(bl[i] != bl[i-1]) lb[bl[i]] = i,rb[bl[i-1]] = i-1; } rb[bl[n]] = n; for(int x = 1;x\u0026lt;=bl[n];x++){ int L = lb[x],R = rb[x]; for(int i = L;i\u0026lt;=R;i++) V[x].push_back(p[i]); sort(V[x].begin(),V[x].end()); tmp.clear(); tmp.push_back(V[x][0]); for(int i = 1;i \u0026lt; int(V[x].size());i++){ if(V[x][i].b != V[x][i-1].b) tmp.push_back(V[x][i]); } V[x].clear(); V[x].push_back(tmp[0]); for(int i = 0;i \u0026lt; int(tmp.size())-1;){ int t = i; for(int j = i+1;j\u0026lt;int(tmp.size());j++) if(calj(tmp[i],tmp[j]) \u0026lt; calj(tmp[i],tmp[t])) t = j; V[x].push_back(tmp[i = t]); } V[x].push_back(tmp.back()); } } int now[MAXQ]; int ans[MAXN]; void solve(){ for(int i = 1;i\u0026lt;=m;i++){ int L = q[i].l,R = q[i].r,t = q[i].t; int BL = bl[L],BR = bl[R],tmp = 0; if(BL == BR){ for(int i = L;i\u0026lt;=R;i++) if(cmp(p[i],p[tmp],t)) tmp = i; ans[q[i].id] = tmp; continue; } for(int i = BL+1;i\u0026lt;=BR-1;i++){ while(now[i]+1 \u0026lt; int(V[i].size()) \u0026amp;\u0026amp; calv(V[i][now[i]],t) \u0026lt;= calv(V[i][now[i]+1],t)) now[i]++; if(cmp(V[i][now[i]],p[tmp],t)) tmp = V[i][now[i]].id; } for(int i = L;i\u0026lt;=rb[BL];i++) if(cmp(p[i],p[tmp],t)) tmp = i; for(int i = lb[BR];i\u0026lt;=R;i++) if(cmp(p[i],p[tmp],t)) tmp = i; ans[q[i].id] = tmp; } for(int i = 1;i\u0026lt;=m;i++){ printf(\u0026#34;%d\\n\u0026#34;,ans[i]); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":93,"section":"posts","tags":["数据结构","分块"],"title":"「CF91E」Igloo Skyscraper-分块","uri":"https://blog.chenqiqian.com/posts/cf91e/"},{"content":"求\n$$\n\\sum _ {i=1}^n\\sum _ {j=1}^n ij\\gcd(i,j))~mod~p\n$$\n其中 $n \u0026lt; 10^{10}$。\n题解 $$\nans =\\sum _ {i=1}^n\\sum _ {j=1}^n ij\\gcd(i,j))~mod~p\\\n=\\sum _ {d=1}^n d\\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum _ {j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ijd^2[\\gcd(i,j) == 1]\\\n=\\sum _ {d=1}^n d^3 \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum _ {j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ij[\\gcd(i,j) == 1]\\\n$$\n如果我们令\n$$\nf(d) = \\sum _ {i=1}^{n}\\sum _ {j=1}^{n}ij[\\gcd(i,j) == d]\\\ng(d) = \\sum _ {d|k} f(k) = d^2\\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum _ {j=1}^{\\lfloor\\frac{n}{d}\\rfloor} ij\\\ng(d) = d^2{\\left[\\frac{\\lfloor\\frac{n}{d}\\rfloor(\\lfloor\\frac{n}{d}\\rfloor + 1)}{2}\\right]}^2\n$$\n令 $sum(x) = \\frac{x(x+1)}{2}$，原式化为：\n$$\ng(d) = d^2 \\cdot sum(\\lfloor\\frac{n}{d}\\rfloor)^2\n$$\n就有：\n$$\nf(d) = \\sum _ {d|k} \\mu(k) g(\\frac{k}{d})\\\nf(1) = \\sum _ {i=1}^n \\mu (i) g(i)\\\nf(1) = \\sum _ {i=1}^n \\mu (i) i^2 sum(\\lfloor\\frac{n}{i}\\rfloor)^2\n$$\n那么：\n$$\nans = \\sum _ {d=1}^n d^3 \\sum _ {i=1}^{\\lfloor\\frac{n}{d}\\rfloor} \\mu (i) i^2 sum(\\lfloor\\frac{n}{di}\\rfloor)^2\n$$\n枚举 $id = T$，则有\n$$\nans = \\sum _ {T = 1}^n sum(\\lfloor\\frac{n}{T}\\rfloor)^2 \\sum _ {d|T} d^3 \\mu(\\frac{T}{d}) \\times {(\\frac{T}{d})}^2\\\n= \\sum _ {T=1}^n T^2 sum(\\lfloor\\frac{n}{T}\\rfloor)^2 \\sum _ {d|T} d \\mu(\\frac{T}{d}) \\\n$$\n有 $id*\\mu = \\varphi$ ， 所以\n$$\nans = \\sum _ {T=1}^n sum(\\lfloor\\frac{n}{T}\\rfloor)^2 T^2 \\varphi(T) \\\n$$\n令 $f(x) = x^2 \\varphi(x)$，我们就有\n$$\nans = \\sum _ {T=1}^n sum(\\lfloor\\frac{n}{T}\\rfloor)^2 f(T)\n$$\n注意到 $\\lfloor\\frac{n}{T}\\rfloor$ 只有根号个取值，所以我们想要处理出 $f(T)$ 的前缀和。\n杜教筛：\n$$\nS(n) = \\sum _ {i=1}^{n} h(i) - \\sum _ {d = 2}^{n} g(d)S(\\lfloor \\frac{n}{d} \\rfloor)\n$$\n如果我们令 $g(n) = n^2$ ，那么\n$$\nh(i) = (g*f)(i)=\\sum _ {d|i}f(d)g(\\frac{i}{d})=\\sum _ {d|i}d^2\\varphi(d){(\\frac{i}{d})}^2\\\n= \\sum _ {d|i}\\varphi(d)i^2 = i^3\\\n$$\n又因为\n$$\n\\sum _ {i=1}^n i^3 = \\left[\\frac{n(n+1)}{2}\\right]^2\n$$\n所以我们就有\n$$\nS(n) = \\sum _ {i=1}^{n} h(i) - \\sum _ {d = 2}^{n} g(d)S(\\lfloor \\frac{n}{d} \\rfloor)\\\n= \\left[\\frac{n(n+1)}{2}\\right]^2 - \\sum _ {d = 2}^{n} d^2S(\\lfloor \\frac{n}{d} \\rfloor)\\\n$$\n综上：\n$$\nans = \\sum _ {T=1}^n sum(\\lfloor\\frac{n}{T}\\rfloor)^2 f(T)\\\nS(n) = \\left[\\frac{n(n+1)}{2}\\right]^2 - \\sum _ {d = 2}^{n} d^2S(\\lfloor \\frac{n}{d} \\rfloor)\\\n$$\n代码实现一定要多取模\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 8500000; ll pow(ll x,ll k,ll p){ ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = (x*x)%p) if(i \u0026amp; 1) ans = (ans*x)%p; return ans; } ll inv(ll x,ll p){return pow(x,p-2,p);} ll p,n,rev_6,rev_2; map\u0026lt;ll,ll\u0026gt; s; ll pre_s[MAXN]; void sieve(){ static ll prime[MAXN],phi[MAXN],cnt = 0; static int vis[MAXN]; phi[1] = 1; for(int i = 2;i\u0026lt;=MAXN-1;i++){ if(vis[i] == 0){ prime[++cnt] = i; phi[i] = i-1; } for(int j = 1;i * prime[j] \u0026lt;= MAXN-1 \u0026amp;\u0026amp; j\u0026lt;=cnt;j++){ vis[i*prime[j]] = 1; if(i % prime[j] == 0){ phi[i*prime[j]] = phi[i] * (prime[j]); break; } else{ phi[i*prime[j]] = phi[i] * (prime[j]-1); } } } for(int i = 1;i\u0026lt;=MAXN-1;i++){ pre_s[i] = phi[i]%p * i % p * i % p; pre_s[i] += pre_s[i-1]; pre_s[i] %= p; } } ll sum(ll x){x%=p;return x%p *(x+1)%p *rev_2%p;} ll sums(ll x){x%=p;return x%p *(x+1)%p *(x+x+1)%p *rev_6%p;} ll S(ll n){ if(n \u0026lt; MAXN) return pre_s[n]; if(s.count(n))return s[n]; ll ans = sum(n)%p; ans = ans*ans%p; for(ll l = 2,r;l \u0026lt;= n;l = r+1){ r = (n/(n/l)); ans -= S(n/l)%p * (sums(r) - sums(l-1)+p)%p; ans = ans % p; } return s[n] = ans % p; } void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;p,\u0026amp;n); rev_6 = inv(6,p),rev_2 = inv(2,p); } ll calc(ll n){ ll ans = 0; for(ll l = 1,r;l \u0026lt;= n;l = r+1){ r = (n/(n/l)); ll tmp = (S(r) - S(l-1) + p) % p; ll summ = sum(n/l) %p; ans += summ%p * summ%p * tmp%p; ans %= p; } return ans; } int main(){ init(); sieve(); printf(\u0026#34;%lld\\n\u0026#34;,calc(n)); return 0; }   ","description":"","id":94,"section":"posts","tags":["数论","数论函数","杜教筛"],"title":"「Luogu3768」简单的数学题-杜教筛","uri":"https://blog.chenqiqian.com/posts/luogu-3768/"},{"content":"一家餐厅有 $n$ 道菜，编号 $1,\\dots,n$ ，大家对第 $i$ 道菜的评价值为 $a_i(1 \\leq i \\leq n)$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$ 。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\\ \\text{XOR}\\ (a_j+x_i)$ ，$\\text{XOR}$ 表示异或运算。\n第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。\n链接 Luogu P3293\n题解 我们观察到区间限制，很容易让我们想到主席树，再观察到异或运算、最大，很容易联想到 0/1 Trie 树。\n所以我们就按照主席树的方法建一颗 0/1 可持久化 Trie 树。\n如果没有 $x_i$ 的运算，上面的解法就可以解决了。我们直接按照 $a_j$ 从高往低每位贪心取反即可，但我们注意到有了一个 $(a_j + x_i)$ 的限制。\n这个问题中，我们需要建立一个权值线段树（可持久化），再每位贪心，但是我们需要再线段树上把那一段找出来，然后再走向左右区间。\n时间复杂度是两个 $log$ ，因为其特殊性不能在线段树上直接二分，因此复杂度：$O(m \\log^2 10^5 )$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAX = 210000; const int MAXN = 210000,logn = 19; int n,m,a[MAXN],rt[MAXN]; namespace prSegTree{ int sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt; #define mid ((l+r)\u0026gt;\u0026gt;1)  void update(int \u0026amp;nown,int pre,int l,int r,int pos,int v){ nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre],sumn[nown] = sumn[pre]; if(l == r) sumn[nown] += v; else{ if(pos \u0026lt;= mid) update(ls[nown],ls[pre],l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rs[nown],rs[pre],mid+1,r,pos,v); sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]]; } } int query(int nown,int l,int r,int ql,int qr){ if(!nown) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return sumn[nown]; } else{ int ans = 0; if(ql \u0026lt;= mid) ans += query(ls[nown],l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans += query(rs[nown],mid+1,r,ql,qr); return ans; } } int query(int lx,int rx,int ql,int qr){ ql = max(1,ql),qr = min(qr,MAX); if(ql \u0026gt; qr) return 0; return query(rx,1,MAX,ql,qr) - query(lx,1,MAX,ql,qr); } } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i = 1;i\u0026lt;=n;i++) prSegTree::update(rt[i],rt[i-1],1,MAX,a[i],1); } int query(int b,int x,int l,int r){ int ans = 0,tmp = 0; for(int i = 20;i\u0026gt;=0;i--){//该考虑 (1\u0026lt;\u0026lt;i) 的位置  if(b\u0026amp;(1\u0026lt;\u0026lt;i)){ if(prSegTree::query(rt[l-1],rt[r],tmp-x,tmp+(1\u0026lt;\u0026lt;i)-x-1) \u0026gt; 0) ans += (1\u0026lt;\u0026lt;i); else tmp += (1\u0026lt;\u0026lt;i); } else{ if(prSegTree::query(rt[l-1],rt[r],tmp+(1\u0026lt;\u0026lt;i)-x,tmp+(1\u0026lt;\u0026lt;(i+1))-x-1) \u0026gt; 0) ans += (1\u0026lt;\u0026lt;i),tmp += (1\u0026lt;\u0026lt;i); } } return ans; } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ int b,x,l,r; scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;b,\u0026amp;x,\u0026amp;l,\u0026amp;r); printf(\u0026#34;%d\\n\u0026#34;,query(b,x,l,r)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":95,"section":"posts","tags":["数据结构","线段树","可持久化主席树"],"title":"「SCOI2016」美味-可持久化线段树","uri":"https://blog.chenqiqian.com/posts/scoi2016-delicious/"},{"content":"共有 $m$ 部电影，编号为 $1$ 到 $m$，第 $i$ 部电影的好看值为 $w[i]$。在 $n$ 天之中（从 $1$ 到 $n$ 编号）每天会放映一部电影，第 $i$ 天放映的是第 $f[i]$ 部。你可以选择 $l,r(1 \\leq l \\leq r \\leq n)$ ，并观看第 $l,l+1,\\dots , r$ 天内所有的电影。如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。所以你希望最大化观看且仅观看过一次的电影的好看值的总和。\n链接 Luogu P3582\n题解 我们可以记录一个上一个出现这个电影的位置，然后我们可以用线段树维护一个后缀和的最大值，每次 $O(\\log n)$ 修改，然后 $O(\\log n)$ 查询即可。\n时间复杂度： $O(n \\log n)$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 1100000; int n,m; int f[MAXN],pre[MAXN],w[MAXN]; int last[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;f[i]); pre[i] = last[f[i]],last[f[i]] = i; } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]); } } namespace SegTree{ ll maxn[MAXN\u0026lt;\u0026lt;2],addn[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void addlabel(int nown,ll v){ maxn[nown] += v,addn[nown] += v; } void push_down(int nown){ if(addn[nown] != 0){ addlabel(lson,addn[nown]),addlabel(rson,addn[nown]); addn[nown] = 0; } } void push_up(int nown){ maxn[nown] = max(maxn[lson],maxn[rson]); } void update(int nown,int l,int r,int ql,int qr,ll v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ addlabel(nown,v); } else{ push_down(nown); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,v); push_up(nown); } } ll query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return maxn[nown]; } else{ ll ans = -0x3f3f3f3f3f3f; push_down(nown); if(ql \u0026lt;= mid) ans = max(ans,query(lson,l,mid,ql,qr)); if(qr \u0026gt;= mid+1) ans = max(ans,query(rson,mid+1,r,ql,qr)); return ans; } } } void update(int l,int r,int x){ if(l \u0026lt;= 0 || r \u0026gt;= n+1 || l \u0026gt; r) return; SegTree::update(1,1,n,l,r,x); } void solve(){ ll ans = -0x3f3f3f3f3f3f; for(int i = 1;i\u0026lt;=n;i++){ update(pre[i]+1,i,w[f[i]]); if(pre[i] != 0) update(pre[pre[i]]+1,pre[i],-w[f[i]]); ans = max(ans,SegTree::query(1,1,n,1,i)); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":96,"section":"posts","tags":["数据结构","线段树"],"title":"「POI2015」Kinoman-线段树","uri":"https://blog.chenqiqian.com/posts/poi2015-kinoman/"},{"content":"考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$ ，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 $\\text{XOR}$ 和最大。\n路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 $\\text{XOR}$ 和时也要被计算相应多的次数。\n图中可能有重边或自环。\n链接 Luogu P4151\n题解 一个有可能比较常见的套路：\n考虑 $1\\rightarrow n$ 的路径，一定由一条路径和一些环获得。\n我们注意到考虑挂在路径上的环的影响时，不必考虑环如何到达路径，因为我们必然有一条路径使得“去环”和“离开环”恰好抵消。因此我们可以随便加环。\n我们甚至还注意到，$1\\rightarrow n$ 路径也可以随便选，因为如果是另一条路径的话，事实上异或一个经过 $1$ 和 $n$ 的大环就可以得到另一条 $1 \\rightarrow n$ 的路径了。\n找环就用 dfs ，其中每一条返祖边都可以对应一个环。即使是有公共边的环也可以用小环异或出来，所以返祖边直接处理环即可。\n时间复杂度 $O(n \\times 64)$.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;cstdio\u0026gt;using namespace std; typedef long long ll; const int MAXN = 51000,MAXM = 110000,logn = 61; struct LB{ ll basis[logn]; void insert(ll x){ if(!x) return; for(int i = logn-1;i\u0026gt;=0;--i){ if((x \u0026amp; (1LL\u0026lt;\u0026lt;i)) == 0) continue; if(basis[i] == 0){ basis[i] = x; break; } else{ x ^= basis[i]; } } } ll getmax(ll ans = 0){ for(int i = logn-1;i\u0026gt;=0;--i){ if((ans^basis[i]) \u0026gt; ans){ ans ^= basis[i]; } } return ans; } }B; struct Edge{ int to,nex; ll len; }edge[MAXM*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,ll c){ edge[ecnt] = (Edge){b,fir[a],c}; fir[a] = ecnt++; } int n,m; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); int a,b;ll c; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %lld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(a,b,c); addedge(b,a,c); } } ll dis[MAXN];bool vis[MAXN]; void dfs(int nown){ vis[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to;ll len = edge[nowe].len; if(vis[v] == 1){ B.insert(dis[nown]^dis[v]^len); } else{ dis[v] = dis[nown] ^ len; dfs(v); } } } void solve(){ dfs(1); printf(\u0026#34;%lld\\n\u0026#34;,B.getmax(dis[n])); } int main(){ init(); solve(); return 0; }   ","description":"","id":97,"section":"posts","tags":["数学","线性基"],"title":"「WC2011」最大XOR路径-dfs+线性基","uri":"https://blog.chenqiqian.com/posts/wc2011-xor/"},{"content":"每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。\n请你从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且使得这支骑士军团最具有战斗力。\n为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。\n链接 LuoguP2607\n题解 先考虑一个 $n$ 条边、 $n$ 个点的无向连通图的情况。这个环中只有一个环，我们在任意位置断掉这个环（并查集），让这个图成为一个树，记两端点为 $X$,$Y$。\n注意到由于 $X$ 和 $Y$ 不能同时取得，如果我们分别以 $X$ 和 $Y$ 作为树根进行一次树形 dp ，那么我们的答案肯定在第一次的 $dp[X][0]$ 和第二次的 $dp[Y][0]$ 中的某一个，因为不可能两个都选，我们令一个不选之后，剩下的就只剩下树的限制，我们也一定能够达成最大的情况。\n不是特别好理解，但好好理一下也不是特别难吧。\n这里没有保证联通，但对于任意一个联通块由于其特殊的建图方式，导致也均为基环树或树。\n时间复杂度： $O(n)$.\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; const int MAXN = 1e6+10; struct Edge{ int to,nex; }edge[MAXN*2]; int fir[MAXN],ecnt = 2; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } int n; namespace BCJ{ int f[MAXN]; void init(int n){ for(int i = 1;i\u0026lt;=n;i++){ f[i] = i; } } int find(int x){ return f[x] == x ? x : f[x] = find(f[x]); } } int X[MAXN],Y[MAXN],cnt; bool vis[MAXN]; ll p[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); BCJ::init(n); int a,b; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld %d\u0026#34;,\u0026amp;p[i],\u0026amp;b); a = i; int fa = BCJ::find(a),fb = BCJ::find(b); if(fa == fb){ X[++cnt] = a, Y[cnt] = b; } else{ addedge(a,b),addedge(b,a); BCJ::f[fa] = fb; } } } ll dp[MAXN][2]; void dfs(int nown,int fa){ dp[nown][0] = dp[nown][1] = 0; vis[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == fa) continue; dfs(v,nown); dp[nown][1] += dp[v][0]; dp[nown][0] += max(dp[v][0],dp[v][1]); } dp[nown][1] += p[nown]; } void solve(){ ll ans = 0; for(int i = 1;i\u0026lt;=cnt;i++){ ll tmp = 0; dfs(X[i],0); tmp = max(dp[X[i]][0],tmp); dfs(Y[i],0); tmp = max(dp[Y[i]][0],tmp); ans += tmp; } for(int i = 1;i\u0026lt;=n;i++){ if(vis[i] == 0){ dfs(i,0); ans += max(dp[i][0],dp[i][1]); } } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":98,"section":"posts","tags":["基环树","动态规划"],"title":"「ZJOI2008」骑士-基环树+dp","uri":"https://blog.chenqiqian.com/posts/zjoi2008-knight/"},{"content":"有一个球形空间产生器能够在 $n$ 维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$ 维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。\n提示：给出两个定义：\n 球心：到球面上任意一点距离都相等的点。 距离：设两个n为空间上的点A, B的坐标为$(a_1, a_2, \\cdots , a_n)$ , $(b_1, b_2, \\cdots , b_n)$，则 AB 的距离定义为：$dist = \\sqrt{ \\sum _ {i=1}^{n}(a_i - b_i)^2 }$  链接 Luogu P4035\n题解 设圆心为 $(x_1,x_2, \\cdots ,x_n)$ 。\n则我们有 $n$ 个式子，形如\n$$\n\\sum _ {i=1}^{n}(p[j][i] - x_i)^2 = \\sum _ {i=1}^{n}(p[j+1][i] - x_i)^2\n$$\n化简得到\n$$\n\\sum _ {i=1}^{n}(p[j][i]^2 - 2p[j][i] \\cdot x_i) = \\sum _ {i=1}^{n}(p[j+1][i]^2 - 2p[j+1][i] \\cdot x_i)\\\n\\sum _ {i=1}^{n} [2(p[j+1][i]-p[j][i]) \\cdot x_i] = - \\sum _ {i=1}^{n}(p[j][i]^2 - p[j+1][i]^2)\n$$\n高斯消元即可\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const double eps = 1e-8; double squ(double x){return x * x;} const int MAXN = 410; int n; double p[MAXN][MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n+1;i++){ for(int j = 1;j\u0026lt;=n;j++){ scanf(\u0026#34;%lf\u0026#34;,\u0026amp;p[i][j]); } } } bool gauss(int n,double a[MAXN][MAXN]){ for(int i = 1;i\u0026lt;=n;i++){ int r = i; for(int j = i+1;j\u0026lt;=n;j++){ if(fabs(a[j][i]) \u0026gt; fabs(a[r][i])) r = j; } if(fabs(a[r][i]) \u0026lt;= eps) return false; if(r != i){ for(int j = 1;j\u0026lt;=n+1;j++) swap(a[i][j],a[r][j]); } for(int j = 1;j\u0026lt;=n;j++)if(j!=i){ double d = a[j][i]/a[i][i]; for(int k = 1;k\u0026lt;=n+1;k++){ a[j][k] -= d * a[i][k]; } } } for(int i = 1;i\u0026lt;=n;i++){ a[i][n+1] /= a[i][i]; a[i][i] = 1; } return true; } void solve(){ static double a[MAXN][MAXN]; for(int j = 1;j\u0026lt;=n;j++){ for(int i = 1;i\u0026lt;=n;i++){ a[j][i] = 2 * (p[j+1][i] - p[j][i]); a[j][n+1] -= squ(p[j][i]) - squ(p[j+1][i]); } } gauss(n,a); for(int i = 1;i\u0026lt;=n;i++){ printf(\u0026#34;%.3lf \u0026#34;,a[i][n+1]); } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":99,"section":"posts","tags":["数学","高斯消元"],"title":"「JSOI2008」球形空间产生器-高斯消元","uri":"https://blog.chenqiqian.com/posts/jsoi2008-sphere/"},{"content":"垃圾 CCF\n毁我青春\nDay 0 讲评试卷，旷掉了。在机房刷模板题，晚上刷不动了就开始疯狂预测后两天的题目：\n胡乱预测了一些非常神奇的东西：T1数论/模拟，T2/T3背包、树形dp、基环树、图论+缩点+倍增。\n我是不是要被禁赛一年了啊。\nDay 1 sb Day1，不做评论。\nT1：铺设道路 题面 春春是一名道路工程师，负责铺设一条长度为 $n$ 的道路。\n铺设道路的主要工作是填平下陷的地表。整段道路可以看作是 $n$ 块首尾相连的区域，一开始，第 $i$ 块区域下陷的深度为 $d_i$ 。\n春春每天可以选择一段连续区间 $[L,R]$ ，填充这段区间中的每块区域，让其下陷深度减少 $1$ 。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 $0$ 。\n春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为 $0$ 。\n题解 开始看题居然早了一些，被喝止关上题面的时候已经记下来这道题了，于是在开考前就脑补出了这道题的解法\u0026hellip;开考5分钟敲完过大样例\u0026hellip;\n我们维护一个差分数组 $c[i] = d[i] - d[i-1]$ ，如果 $c[i] \u0026gt; 0$ 我们就将其累加到贡献中。\n正确性似乎十分显然，你不可能找到一个更小的方案来覆盖了。\n赛后得知该题是NOIp2013原题，似乎模拟赛里我还做过这道题（不过当时还WA了\n耗时5分钟。\n期望得分：100，实际得分：100\nT2：货币系统 题面 在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$ ，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$ 、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。\n在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$ ，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \\times t[i]$ 的和为 xx。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。\n两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。\n现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。\n题解 开始还往数论的方面考虑了一波，甚至想到刚学的线性基，事实上并没有什么卵用\u0026hellip;\u0026hellip;本质上就是一个贪心+类似背包dp的东西吧。\n首先考虑一些性质。\n首先发现不可能出现在这 $n$ 个货币面额之外面额的货币，其次发现最小的货币必然要取到，然后我们考虑到，取一个更小的货币一定对于你凑出一个大的面值更有帮助，所以我们从小往大的贪心。\n维护一个数组 $vis[i]$，表示 $i$ 面值能不能被之前的货币凑出来。首先判断新加入的数能不能用已经有的面额凑出，如果能就可以跳过这个面值，否则就必须加入新的最小货币系统。\n我们如何更新 $vis$ 数组呢？稍有背包dp经验（或者满脑子背包的人）就会通过物品无限联想到完全背包。\n扫描数组用低位更新高位即可。\n时间复杂度$O(T \\times n \\cdot \\text{MAXV})$。\n此时刚刚 9:05 。\n期望得分：100，实际得分：100\nT3：赛道修建 也还算一道好题吧，只不过位置非常尴尬\u0026hellip;(来自一个几乎想对算法然后挂掉的选手的怨念)\n题意 C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 $m$ 条赛道。\nC 城一共有 $n$ 个路口，这些路口编号为 $1,2,…,n$，有 $n−1$ 条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 $i$ 条道路连接的两个路口编号为 $a_i$ 和 $b_i$​，该道路的长度为 $l_i$。借助这 $n-1$ 条道路，从任何一个路口出发都能到达其他所有的路口。\n一条赛道是一组互不相同的道路 $e_1,e_2,…,e_k$​，满足可以从某个路口出发，依次经过 道路 $e_1,e_2,…,e_k$​（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。\n目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的 $m$ 条赛道中长度最小的赛道长度最大（即 $m$ 条赛道中最短赛道的长度尽可能大）\n题解 考场上的做法有锅以至于大样例都过不了\u0026hellip;然后信仰rand交上去了\u0026hellip;发现数据随机的话很难卡掉\u0026hellip;所以我事实上应该少rand几次\u0026hellip;没准还能混到95\u0026hellip;\n正解的做法如下：\n二分非常显然，然后就变成判断不小于 $x$ 的不相交路径有多少条。\n对于每一个子树分别考虑的话，发现每个子树最多只有一条从根出发的路径能被祖先节点使用，再加上菊花图的暗示，大概能够得到以下的思路，贪心的使仅在子树里能够拼出来的路径最多的情况下，能往上传递的链的长度最大。\n这个可以用一个 pair\u0026lt;int,int\u0026gt; 维护。我们注意到我们在考虑每个子树返回的路径时，如果 f[v] + len \u0026gt;= TAR ，那么说明这个路径可以自己成一条赛道，直接累加贡献即可；剩下的扔到一个multiset/vector里面，现在我们就有了若干条长度小于 TAR 的路径，我们要组合出最多的不小于 TAR 的路径，而且还要求出这个情况下能返回的最长的过当前子树根节点的链的长度。\n我们有两种处理方法：\n一种是 multiset 处理，我们从短往长贪心的考虑每条边，lower_bound 查出最小能不小于 TAR 的另一条链，然后把他们俩都删掉，计算贡献。直到找不到能匹配的边，就将 multiset 里面的最大值作为返回最长链的答案。（正确性不显然，但是我们机房讨论没有叉掉，所以大约是对的）。\n还有一种是再二分的处理。\n先考虑如何线性计算出最多的贡献，就是用双指针贪心即可，固定的是大的链。然后我们二分往回的边是哪条，显然有单调性，然后每次线性计算下是否贡献能达到最大值就可以了。\n时间复杂度：$O(n \\log^2 n)$。\n期望得分： $55-80$，实际得分：50\nDay1总结 做完前两题恍然觉得自己变强了好多啊，轻松一天200+\u0026hellip;结果第三题死活没调出来。回家写了写，发现考场上错误的算法（又写了一遍仍然没过大样例\u0026hellip;）Luogu/nowcoder自测也能拿95\u0026hellip;我为什么要rand\u0026hellip;我是不是傻子\u0026hellip;\nDay 2之后刷知乎发现出题人 immortalCO 又说数据很弱\u0026hellip;\n暴怒\u0026hellip;\n期望得分：100+100+55~80 = 255~280，实际得分：100+100+50 = 250\nDay 2 考试前某神仙在pyq里面调侃：Day1 一时爽，Day2 火葬场。\n感觉又要被禁赛一年了。\nT1：旅行 题面 小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。\n小Y了解到， X 国的 $n$ 个城市之间有 $m(m \\leq n)$ 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。\n小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。\n为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 $n$ 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？ 对于两个长度均为 $n$ 的序列 $A$ 和 $B$，当且仅当存在一个正整数 $x$，满足以下条件时， 我们说序列 $A$ 的字典序小于 $B$。\n 对于任意正整数 $1 \\leq i \u0026lt; x$，序列 $A$ 的第 $i$ 个元素 $A_i$ 和序列 $B$ 的第 $i$ 个元素 $B_i$​ 相同。 序列 $A$ 的第 $x$ 个元素的值小于序列 $B$ 的第 $x$ 个元素的值。  题解 开始没看见 $m \\leq n$，恍然以为不可做\u0026hellip;\n然后又没看见 $n \\leq 5000$，再次觉得不可做\u0026hellip;\n据说有线性做法\u0026hellip;我只想到一个 $n^2$ 做法\n发现小 Y 事实上就是在dfs\u0026hellip;我们熟悉树上的那套理论，我们发现树上的这个东西是很好求的，贪心dfs即可\u0026hellip;\n带环的树也可以用类似的贪心做到 $O(n)$ 的复杂度，只不过我还不太会\u0026hellip;\n$O(n^2)$ 的话，枚举断边，dfs即可\u0026hellip;最后判下全部到达即可。\n我们还发现一点，这里需要对边排序来保证复杂度，如果我们每次都遍历在sort很有可能TLE\u0026hellip;所以我们在外面逆序sort好后再加边即可\u0026hellip;\n然后赛后自测的是否发现自己很有可能有个地方忘开两倍数组\u0026hellip;感觉自己要凉\u0026hellip; -= 32 分\u0026hellip;不过luogu自测上面都能过最后三个点，也不知道为什么\u0026hellip;\n期望分数：68-100（万一我开了2倍呢\u0026hellip;），实际得分：100\nT2：填数游戏 题面 麻烦死了，不复制了，链接：Luogu P5023 填数游戏\n题解 考场上一看数据范围：高啊，一看就是状压dp+矩阵快速幂\u0026hellip;于是推了推转移矩阵 码码码 * n\u0026hellip;然后发现 n=3,m=3 都过不了\u0026hellip;纠结一个小时也没能调完\u0026hellip;咕咕咕\u0026hellip;最后写了一个暴力搜索和 n = 2 的特殊情况\u0026hellip;考后听各路神仙做法都不太一样\u0026hellip;\n目前听到的一种做法是这样的\u0026hellip;\n首先你发现一个规律\u0026hellip;当 $m \\geq n+2$ 时， $F(n,m) = 3F(n,m-1)$。\n然后你暴搜出来 $F(n,n+1)$ 的答案即可。直接暴力搜索会TLE，考虑一些微小的优化，比如对角线的单调性，比如子矩阵的必然合法啥的。\n具体没写呢\u0026hellip;最好的方法貌似是打表？等过几天再来填。\n考场上大概只有50分可以拿到。其实机灵点可以发现 n = 3,m=4和n=3,m=5 的规律的，然后大概可以多拿 $15$ 分..?\nwxh的做法\n期望得分：50，实际得分：20（模数多打一个0的悲伤QAQ）\nT3：保卫王国 又tm一道树形dp\u0026hellip;\n题面： Z 国有 $n$ 座城市，$n - 1$ 条双向道路，每条双向道路连接两座城市，且任意两座城市 都能通过若干条道路相互到达。\nZ 国的国防部长小 Z 要在城市中驻扎军队。驻扎军队需要满足如下几个条件：\n 一座城市可以驻扎一支军队，也可以不驻扎军队。 由道路直接连接的两座城市中至少要有一座城市驻扎军队。 在城市里驻扎军队会产生花费，在编号为i的城市中驻扎军队的花费是 $p_i$。  小 Z 很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小 Z 提出 了 $m$ 个要求，每个要求规定了其中两座城市是否驻扎军队。小 Z 需要针对每个要求逐一 给出回答。具体而言，如果国王提出的第 $j$个要求能够满足上述驻扎条件（不需要考虑 第 $j$ 个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果 国王提出的第 $j$个要求无法满足，则需要输出 $-1$ ($1 \\leq j \\leq m$)。现在请你来帮助小 Z。\n题解 怎么说呢，感觉是道好题，就是放在NOIp的位置并不是特别合适\u0026hellip;而且确切的说是放在这么恐怖的 Day 2 并不是很合适。\n该题貌似目前还没有人能给我完全讲明白\u0026hellip;机房学长讲了一遍动态dp但是我也没太搞懂只听明白链上的情况，也就是线段树维护转移矩阵（一般比较小）做到快速的修改。\n好像还可以倍增做，也可以用虚树的思想。我都不会，以后慢慢补（咕咕.jpeg）。\n写了个最坏 $O(n^2)$ 暴力也不知道对不对。\n期望得分：44，实际得分：44\nDay2总结 完全没有区分度的一天\u0026hellip;偏偏我还挂题了\u0026hellip;太年轻了啊\u0026hellip;考试结束一个小时前开始佛系检查\u0026hellip;还没发现自己的数组开小\u0026hellip;\n实名举报T2和T3样例太小\u0026hellip;感觉很虚啊qaq\n期望得分：68~100 + 50 + 44 = 162~194，实际得分：100 + 20 + 44 = 164\n总结 难度大约是 $T1-T2-T4-T3-T5-T6$ 递增吧\u0026hellip;\n这个 noip 咋回事啊\u0026hellip;感觉区分度简直跟 NOI Day2 似的，会的大家都能打，不会的（基本上）没人能做\u0026hellip;\n某神仙：“这不就是比谁FST少吗？”\n可我偏偏就挂题了啊\u0026hellip;\n写了这么多，似乎也是想体现一下自己对于 OI 的热爱吧\u0026hellip;可是当比赛完成后，热情一点点消退，冰冷的分数让你不得不作出两难的选择。恐怕一切都不那么简单吧。\n赛前反复担心自己会卡在简单题上，最后发现还是难题攻坚能力不行。赛时心态恐怕也有些过于紧张，也没能多检查几遍数组有没有开小的问题\u0026hellip;也可以说是自己埋葬了自己吧。\n如果一切都按照最好的实力发挥，我是有希望上500的，可现在也只能在 400 下挣扎。恐怕也是自己太年轻老作死吧，这种事情也怨不得别人，但是组题人还是可以骂的\u0026hellip;\n考试结束前紧张了一会，发现自己挂题后紧张了一会\u0026hellip;不过现在也都释然了\u0026hellip;这算什么大事啊，省选AK照样A队稳稳的2333况且文化课也不是上不了清华啊233\n最后大概期望得分：255+162 = 417\u0026hellip;这个分数好尴尬啊\u0026hellip;估计省选什么的是要凉了23333等出分了再来upd吧\n另，CCF换少爷机了\u0026hellip;这就是报名费+=200的理由吗233333\n出分后update 自己菜也不能怪别人啊qaq\n不过打错模数50-\u0026gt;20分\u0026hellip;大样例不过80分硬让我调成50的事情嘛\u0026hellip;也不知道该说什么\u0026hellip;如果IOI赛制恐怕不会有这些奇怪的事情\u0026hellip;不过也没那么多如果啊qaq\n省选大约还要继续划水\u0026hellip;现在还是十分迷茫\u0026hellip;\n","description":"","id":100,"section":"posts","tags":null,"title":"NOIp2018 游记\u0026题解","uri":"https://blog.chenqiqian.com/posts/trip-noip2018/"},{"content":"给你 $N$ 颗宝石，每颗宝石都有重量 $w_i$ 和价值 $v_i$。要你从这些宝石中选取一些宝石，保证其总重量不超过 $W$ ，且总价值最大。\n请你输出最大的总价值。\n数据范围：$N \\leq 100;W \\leq 2^{30}$，并且保证每颗宝石的重量符合 $w_i = a \\cdot 2^b$（ $a \\leq 10;b \\leq 30$ ）。\n题解 先按照 $w_i = a_i \\cdot 2^{b_i}$ 中 $b_i$ 为第一关键字， $a_i$ 为第二关键字均从大到小给物品排序。\n我们发现，如果 $dp$ 过程中考虑当前物体的重量是 $a_i \\cdot 2^{b_i}$ ，（因为剩下的物体不可能超过 $n \\leq 100$ 个，每个物体的重量又不超过 $a_i \\cdot 2^{b_i}$，又 $a_i \\leq 10$，）那么剩下所有的物品的重量之和也不可能超过 $n \\times a_i \\cdot 2^{b_i} \\leq 1024 \\cdot 2^{b_i}$ 。（因为剩下的物品的重量之和不超过 $2^{10} \\cdot 2^{b_i}$，）这意味着剩余的重量只有在比 $b_i$ 高的前 $10$ 个二进制位置（也就是代表 $2^{b _ {i+1}},\u0026hellip;,2^{b _ {i+10}}$ 的二进制位）是可能有用的，否则如果剩余重量在（比 $b_i$ 高的）第 $11$ 个位置（或更高位）存在一个 $1$，（也就是剩下的重量大于等于 $2^{11} \\cdot 2^{b_i}$ ，也就大于 $2^{10} \\cdot 2^{b_i}$ ，你剩下的所有物品的重量），那么这个时候的最优策略一定是把剩下的全取完，重量还可以有剩余，（这样对答案的贡献计算是 $O(1)$ 的）。\n正常的背包中我们的状态有两个维度，当前考虑的物品和剩余的背包容积。但是这里的 $W$ 过于大，以至于这种表示方法不能成立。但上面提到我们事实上只需要比 $b_i$ 高的那 $10$ 个二进制位的状况，否则我们就可以直接更新最后的答案。\n所以状态就可以表示为 $dp[i][s]$，表示考虑完前 $i$ 个物品时， $s$ 为考虑到当前物品时剩余的 $W$ 在 $b_i$ 前 $10$ 个二进制位（压缩成一个 $1 到 1024$ 的十进制整数）的情况。我们注意到我们考虑到第 $i$ 个物品的时候，对于所有比 $b_i$ 低的二进制位我们不可能在前 $i$ 个物品中改变，所以剩余重量比 $2^{b_i}$ 低的二进制位事实上就是 $W$ 的这些二进制位，我们不在 dp 状态中显性表示罢了。\n我们考虑这个物体决策取或者不取，转移是非常简单的，就是普通背包的转移就可以了。\n当我们考虑完了当前的物品，考虑下一个物品之前，我们需要做一些变换。\n现在我们有两种情况，第一种是 $w _ {i+1}$ 和 $w_i$ 的二进制非 $0$ 最低位相同，那我们就不需要做什么特殊的处理，直接用 $w_i$ 转移得到数组即可。\n第二种情况是 $w _ {i+1}$ 的最低非 $0$ 二进制位比 $w_i$ 的低，那么这个时候我们就遍历所有1024种状态，如果左移到最低位之后这个状态的剩余价值大于等于 $2^{10} \\cdot 2^{b _ {w+1}}$ ，那么直接处理掉这个状态，否则就加上 $W$ 的低位之后转移即可。\n时间复杂度大约是 $O((n+30) \\times 2^{10})$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  #include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;#define inf 0x3f3f3f3f #define maxn 1024 using namespace std; const int MAXN = 1100; int n,W; struct wupin{ int a,b,v; bool operator \u0026lt; (const wupin \u0026amp;x)const{ if(b != x.b) return b \u0026gt; x.b; else return a \u0026gt; x.a; } }w[MAXN]; bool init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;W); if(n == -1 \u0026amp;\u0026amp; W == -1) return 0; for(int i = 1;i\u0026lt;=n;i++){ int weight,val,cnt = 0; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;weight,\u0026amp;val); while((weight \u0026amp; 1) == 0) weight \u0026gt;\u0026gt;= 1,cnt++; w[i] = (wupin){weight,cnt,val}; } return 1; } void solve(){ sort(w+1,w+n+1); static int sum[MAXN], dp[MAXN],tmp[MAXN];//dp[j] -\u0026gt; dp[i][j]，后10位的状况  int noww = 31,ans = 0;; for(int i = 1;i\u0026lt;=n;i++) sum[i] = sum[i-1] + w[i].v; for(int j = 0;j\u0026lt;maxn;j++) dp[j] = -inf; dp[0] = 0; for(int i = 1;i\u0026lt;=n;i++){ while(noww \u0026gt; w[i].b){ for(int j = 0;j\u0026lt;maxn;j++) tmp[j] = -inf; for(int j = 0;j\u0026lt;maxn;j++){ if((j\u0026lt;\u0026lt;1) \u0026gt;= maxn) ans = max(ans,dp[j] + sum[n] - sum[i-1]); else{ int newn = (j\u0026lt;\u0026lt;1) | ((W\u0026gt;\u0026gt;(noww-1))\u0026amp;1); tmp[newn] = max(tmp[newn],dp[j]); } } for(int j = 0;j\u0026lt;maxn;j++) dp[j] = tmp[j]; noww--; } for(int j = 0;j\u0026lt;maxn;j++) tmp[j] = -inf; for(int j = 0;j\u0026lt;maxn;j++){//(111111111)_2  tmp[j] = max(tmp[j],dp[j]); if(j - w[i].a \u0026gt;= 0) tmp[j-w[i].a] = max(tmp[j-w[i].a],dp[j] + w[i].v); } for(int j = 0;j\u0026lt;maxn;j++) dp[j] = tmp[j]; } for(int j = 0;j\u0026lt;maxn;j++) ans = max(ans,dp[j]); printf(\u0026#34;%d\\n\u0026#34;,ans); } signed main(){ while(init()) solve(); return 0; }   ","description":"","id":101,"section":"posts","tags":["动态规划","背包"],"title":"「HNOI2007」梦幻岛宝珠-背包dp","uri":"https://blog.chenqiqian.com/posts/hnoi2007-diamond/"},{"content":"一个由自然数组成的数列按下式定义：\n对于 $i \\leq k$ ：$a_i = b_i$\n对于 $i \u0026gt; k$ : $a_i = c_1a _ {i-1} + c_2a _ {i-2} + \u0026hellip; + c_ka _ {i-k}$\n其中 $b_j$ 和 $c_j$ （ $1 \\leq j \\leq k$）是给定的自然数。写一个程序，给定自然数 $m \\leq n$, 计算 $a_m + a _ {m+1} + a _ {m+2} + \u0026hellip; + a_n$, 并输出它除以给定自然数 $p$ 的余数的值。\n对于 100% 的测试数据：\n$1 \\leq k \\leq 15,1 \\leq m \\leq n \\leq 10^{18},0 \\le b_1, b_2,\u0026hellip; b_k, c_1, c_2,\u0026hellip;, c_k \\leq 10^9,1 \\leq p \\leq 10^8$\n链接 Luogu P2461\n题解 $$\na_i = \\sum _ {j=1}^{k} c_k a _ {j-k}\n$$\n构造一个矩阵\n$$\nM_i\n=\\begin{bmatrix}\nS_i \\\na_i \\\na _ {i-1}\\\n\\vdots\\\na _ {i-k+2}\\\na _ {i-k+1}\\\n\\end{bmatrix}\n$$\n转移矩阵为：\n$$\nZ\n=\\begin{bmatrix}\n1 \u0026amp; c _ {1} \u0026amp; c _ {2} \u0026amp; \\cdots \u0026amp; c _ {k-1} \u0026amp; c _ {k} \\\n0 \u0026amp; c _ {1} \u0026amp; c _ {2} \u0026amp; \\cdots \u0026amp; c _ {k-1} \u0026amp; c _ {k} \\\n0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0\\\n\\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; 0 \u0026amp; 0\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\n\\end{bmatrix}\n$$\n初始的矩阵为\n$$\nC\n=\\begin{bmatrix}\nS_k\\\nb_k \\\nb _ {k-1}\\\n\\vdots\\\nb _ {2}\\\nb _ {1} \\\n\\end{bmatrix}\n$$\n$$\nZ \\times C = M _ {k+1}\\\nZ \\times M_i = M _ {i+1}\\\n$$\n我们有\n$$\nZ^{n-k} \\times C = M _ {n}\n$$\n矩阵快速幂即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; const int MAXN = 20; ll N,M,K,P,S; ll b[MAXN],c[MAXN]; struct Matrix{ ll num[MAXN][MAXN]; Matrix(int op = 0){ memset(num,0,sizeof(num)); if(op){for(int i = 1;i\u0026lt;MAXN;i++) num[i][i] = 1;} } ll* operator [] (const int n){ return num[n]; } }; Matrix mul(Matrix \u0026amp;_x,Matrix \u0026amp;_y){ Matrix ans; for(int i = 1;i\u0026lt;=S;i++){ for(int j = 1;j\u0026lt;=S;j++){ for(int k = 1;k\u0026lt;=S;k++){ ans[i][j] += _x[i][k] * _y[k][j]; } ans[i][j] %= P; } } return ans; } Matrix pow(Matrix x,ll k){ Matrix ans(1); for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = mul(x,x)){ if(i \u0026amp; 1) ans = mul(ans,x); } return ans; } Matrix Z,C; void init(){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;K); S = K+1; for(int i = 1;i\u0026lt;=K;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;b[i]); for(int i = 1;i\u0026lt;=K;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;c[i]); scanf(\u0026#34;%lld %lld %lld\u0026#34;,\u0026amp;M,\u0026amp;N,\u0026amp;P); for(int i = 1;i\u0026lt;=K;i++) b[i] %= P,c[i] %= P; } ll query(ll x){ ll ans = 0; if(x \u0026lt;= K){ for(int i = 1;i\u0026lt;=x;i++) ans += b[i]; } else{ Matrix a = pow(Z,x-K); for(int i = 1;i\u0026lt;=S;i++) ans += C[i][1] * a[1][i]; } return ans % P; } void build(){ ll sum = 0; for(int i = 1;i\u0026lt;=K;i++){ C[S-i+1][1] = b[i]; sum += b[i]; } C[1][1] = sum % P; Z[1][1] = 1; for(int i = 1;i\u0026lt;=K;i++){ Z[1][i+1] = c[i]; Z[2][i+1] = c[i]; } for(int i = 2;i\u0026lt;=K;i++){ Z[i+1][i] = 1; } } int main(){ init(); build(); printf(\u0026#34;%lld\\n\u0026#34;,((query(N)-query(M-1))%P+P)%P); return 0; }   ","description":"","id":102,"section":"posts","tags":["矩阵快速幂","数学"],"title":"「SDOI2008」递归数列-矩阵快速幂","uri":"https://blog.chenqiqian.com/posts/sdoi2008-sequence/"},{"content":"在2016年，佳媛姐姐刚刚学习了树，非常开心。现在他想解决这样一个问题：给定一颗有根树（根为 $1$），有以下两种操作：\n  标记操作：对某个结点打上标记（在最开始，只有结点1有标记，其他结点均无标记，而且对于某个结点，可以打多次标记。）\n  询问操作：询问某个结点最近的一个打了标记的祖先（这个结点本身也算自己的祖先）\n  你能帮帮她吗?\n链接 Luogu P4092\n题解 我们按照 dfs 序维护一棵标记永久化的线段树。\n每次查询直接查询该位置上所有标记的最大值即可，修改直接在线段树上打上 $\\log n$ 个标记，更新标记取 $\\max$ 即可。\n时间复杂度 $O(n \\log n)$ 。\n这个题也可以考虑离线逆序处理即为删除标记，用并查集维护能到达的最上方（没有标记）的节点，然后删除标记是 $\\text{union}$ 标记两侧集合即可，维护一个当前集合的最小值。\n时间复杂度 $O(n \\alpha(n))$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 110000; struct Edge{ int to,nex; }edge[MAXN*2];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b){ edge[ecnt] = (Edge){b,fir[a]}; fir[a] = ecnt++; } int n,q,id[MAXN],siz[MAXN],cnt; int back[MAXN]; namespace SegTree{ #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  int maxn[MAXN\u0026lt;\u0026lt;2]; void build(int nown,int l,int r){ maxn[nown] = 1; if(l == r) return; build(lson,l,mid); build(rson,mid+1,r); } void modify(int nown,int l,int r,int ql,int qr,int v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ maxn[nown] = max(maxn[nown],v); } else{ if(ql \u0026lt;= mid) modify(lson,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) modify(rson,mid+1,r,ql,qr,v); } } int query(int nown,int l,int r,int pos){ if(l == r){ return maxn[nown]; } else{ if(pos \u0026lt;= mid) return max(maxn[nown],query(lson,l,mid,pos)); if(pos \u0026gt;= mid+1) return max(maxn[nown],query(rson,mid+1,r,pos)); } return 1; } } void dfs(int nown,int fa){ id[nown] = ++cnt; back[cnt] = nown; siz[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(v == fa) continue; dfs(v,nown); siz[nown] += siz[v]; } } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;q); for(int i = 2;i\u0026lt;=n;i++){ int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); addedge(a,b),addedge(b,a); } } void solve(){ dfs(1,0); SegTree::build(1,1,n); for(int i = 1;i\u0026lt;=q;i++){ char s[5];int x; scanf(\u0026#34;%s %d\u0026#34;,s,\u0026amp;x); if(s[0] == \u0026#39;C\u0026#39;){ SegTree::modify(1,1,n,id[x],id[x]+siz[x]-1,id[x]); } if(s[0] == \u0026#39;Q\u0026#39;){ int t = SegTree::query(1,1,n,id[x]); printf(\u0026#34;%d\\n\u0026#34;,back[t]); } } } int main(){ init(); solve(); return 0; }   ","description":"","id":103,"section":"posts","tags":["线段树","树形结构"],"title":"「HEOI2016/TJOI2016」树-线段树","uri":"https://blog.chenqiqian.com/posts/heoi2016-tjoi2016-tree/"},{"content":"Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。\nAlice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？\n链接 Luogu P4568\n题解 建出 $k+1$ 层图，$i$ 层往 $i+1$ 层在原图边上的位置加边权为 $0$ 的边，其余每层正常加边，第一层的 $s$ 向 $k+1$ 层的 $t$ 跑最短路即可。\n数组要开够emmm\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 510000,MAXM = 4010000; struct Edge{ int to,len,nex; }edge[MAXM];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){b,c,fir[a]}; fir[a] = ecnt++; } int n,m,k,s,t; int _hash(int nown,int c){ return (c-1) * n + nown; } void init(){ scanf(\u0026#34;%d %d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k,\u0026amp;s,\u0026amp;t); s++,t++; for(int i = 1;i\u0026lt;=m;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); a++,b++; for(int w = 1;w\u0026lt;=k+1;w++){ addedge(_hash(a,w),_hash(b,w),c); addedge(_hash(b,w),_hash(a,w),c); if(w != k+1){ addedge(_hash(a,w),_hash(b,w+1),0); addedge(_hash(b,w),_hash(a,w+1),0); } } } } int dis[MAXN],vis[MAXN]; struct Node{ int x,d;\tbool operator \u0026lt; (const Node \u0026amp;_n)const{ return d \u0026gt; _n.d; } }; priority_queue\u0026lt;Node\u0026gt; q; void dij(){ while(!q.empty()) q.pop(); memset(dis,0x3f,sizeof(dis)); memset(vis,0,sizeof(vis)); int ss = _hash(s,1),tt = _hash(t,k+1); dis[ss] = 0; q.push((Node){ss,0}); while(!q.empty()){ Node now = q.top();q.pop(); int nown = now.x,nowd = now.d; if(vis[nown] == 1) continue; vis[nown] = 1,dis[nown] = nowd; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,len = edge[nowe].len; if(nowd + len \u0026lt; dis[v]){ dis[v] = nowd + len; q.push((Node){v,dis[v]}); } } } } void solve(){ dij(); printf(\u0026#34;%d\\n\u0026#34;,dis[_hash(t,k+1)]); } int main(){ init(); solve(); return 0; }   ","description":"","id":104,"section":"posts","tags":["图论","最短路","分层图"],"title":"「JLOI2011」飞行路线-分层图最短路","uri":"https://blog.chenqiqian.com/posts/jloi2011-flight/"},{"content":" 2018年10月25日，农历戊戌年九月十七。\n 前几日的月，似乎格外的圆。\n最近几乎每天晚上都在操场上跑步，由西向东的直道上，抬头就是一轮明月。亮晃晃的月晕照亮了天际的薄云，也不知道是明月的缘故，还是灯光的污染，城市的夜空竟显得如此的亮。\n要说起为什么要跑步，其实也可以说是年轻人的一时冲动。同学在班里忽悠着大家一起去跑步，何乐而不为呢？但其实更多的大约还是看中了跑步的一些优点，但仔细想来，也不能完全算是优点。\n跑步其实是一项非常无趣的运动。你所要做的全部就是不断的推动你的双腿，在操场上一圈一圈又一圈的跑着，脑子里不需要想什么，甚至可以空空如也，沉浸在空荡的操场，胶红的跑道之中。平时的那些琐事、不快、理想和现实，仿佛都在这种看似励志的跑步中离我而去了。\n其实吧，时间难再来。曾记得初三的时候，接连的考试让我频频想到我的小学或者初中低年级时候的生活。那个时候恐怕也不会想到，到了高二以后，却反而却会频频想起初三的生活吧。\n也就是前两天，语文考试。突然就感觉这界面似曾相识。连忙观察四周，记录下最多可能的细节。教室里很安静，笔划过纸面的刷刷声仍然在背景声音中游荡，同桌已经做完了卷子，放下了笔；而老师正在讲台上数着卷子，奇妙的卷子摩擦的声音也间歇的发出。\n当你的生活中所做的事情可能带来的代价不再以一节课、一个工作日、一周、一个学期能够衡量时，当你的生活中的压力不再能用跑几圈步、和人谈谈心能够解决的时候，人恐怕才真正长大。\n到现在，和同学在操场上放着奇怪的歌曲，不管别人的眼神和“卧槽”，一圈圈的在操场上跑步的情景还是能记得明明白白，那种双腿酸痛但是睡的沉沉的满足也难以忘却。\n只是如此的圆月，恐怕是再难见到了。\n","description":"","id":105,"section":"posts","tags":null,"title":"「随笔」月圆","uri":"https://blog.chenqiqian.com/posts/essay-moon/"},{"content":"猪王国的文明源远流长，博大精深。\niPig 在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为 $N$ 。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。\niPig 打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的 $k$ 分之一，其中 $k$ 是 $N$ 的一个正约数（可以是 $1$ 和 $N$ ）。不过具体是哪 $k$ 分之一，以及 $k$ 是多少，由于历史过于久远，已经无从考证了。\niPig觉得只要符合文献，每一种能整除 $N$ 的 $k$ 都是有可能的。他打算考虑到所有可能的 $k$ 。显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $\\frac{N}{k}$。然而从 $N$ 个文字中保留下 $\\frac{N}{k}$ 个的情况也是相当多的。iPig预计，如果所有可能的 $k$ 的所有情况数加起来为 $P$ 的话，那么他研究古代文字的代价将会是 $G$ 的 $P$ 次方。\n现在他想知道猪王国研究古代文字的代价是多少。由于iPig觉得这个数字可能是天文数字，所以你只需要告诉他答案除以999911659的余数就可以了。\n链接 题解 依据题意推出式子\n$$\nt = \\sum _ {k|N} C^{k} _ {N}\\\nans = G^t\n$$\n我们有指数的一个性质\n$$\na ^ b \\equiv a ^ {b\\ \\bmod\\ p-1} \\pmod p\n$$\n也就是指数的循环节是 $p-1$ 。\n所以我们只需要\n$$\nans = G^t = G^{t\\ \\bmod\\ (p-1)} \\pmod p\n$$\n所以我们只需要算出 $t \\bmod p-1$ 即可。\n我们注意到 $p-1 = 999911659-1 = 2 \\times 3 \\times 4679 \\times 35617$ ，分别 $Lucas$ 再 $CRT$ 合并即可。\n事实上我们可以只做一次 $CRT$ ，即我们每次都算出在模某数意义下的 $t$ ，最后合并一次即可。\n还要特判 $G = P$ 的情况。\n时间复杂度大约是 $O(\\sqrt n \\times \\log n )$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdlib\u0026gt;#define ll long long using namespace std; const ll P = 999911659; const int MAXN = 100000; ll pow(ll x,ll k,ll p){ ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = x*x%p) if(i \u0026amp; 1) ans = (ans * x) % p; return ans; } ll inv(ll x,ll p){return pow(x,p-2,p);} ll mod[5] = {2,3,4679,35617},pw[MAXN]; void init(ll p){ pw[0] = 1; for(int i = 1;i\u0026lt;p;i++) pw[i]= pw[i-1] * i % p; } ll c(ll n,ll m,ll p){//C_n^m mod mod[num]  if(m \u0026gt; n) return 0; return (pw[n] * inv(pw[m],p) % p) * inv(pw[n-m],p) % p; } ll lucas(ll n,ll m,ll p){ if(!m) return 1; return c(n%p,m%p,p) * lucas(n/p,m/p,p) % p; } ll N,G,ans[5]; ll CRT(){ ll sum = 0; for(int i = 0;i\u0026lt;4;i++){ ll now = (P-1)/mod[i]; sum = sum + ans[i] * now * inv(now,mod[i]); sum %= (P-1); } return sum; } ll solve(){ for(int num = 0;num\u0026lt;4;num++){ ll p = mod[num],q = sqrt(N); init(p); ans[num] = 0; for(int i = 1;i\u0026lt;=q;i++){ if(N % i != 0) continue; ans[num] = ans[num] + lucas(N,i,p); if(i * i == N) continue; ans[num] = ans[num] + lucas(N,N/i,p); ans[num] %= p; } } return CRT(); } int main(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;N,\u0026amp;G); if(G == P) printf(\u0026#34;%d\\n\u0026#34;,0); else printf(\u0026#34;%lld\\n\u0026#34;,pow(G,solve(),P)); return 0; }   ","description":"","id":106,"section":"posts","tags":["中国剩余定理","Lucas定理","数论"],"title":"「SDOI2010」古代猪文-Lucas+CRT","uri":"https://blog.chenqiqian.com/posts/sdoi2010-pig/"},{"content":" 很多事，虽说「人定胜天」，但天命毕竟不可违。\n 很短的一篇随笔，记念逝去之斯人。\n说起来，我不是一个特别容易感伤的人。一直以来，我一直不能厘清生离与死别，天涯海角的离人感情之间的丝毫片缕关系。\n其实也不奇怪。如果这些都那么轻易都能得到一个结论的话，哪里会有古今中外的诗人歌者世世代代在歌咏，寻求这些看起来很明显的问题呢？\n我想，我对于生与死的观念，大约是在我的小学时光里形成的。一个人只有有了闲情逸致，恐怕才会去寻思这些虚无缥缈的东西。一个小孩子躺在黑漆漆空荡荡的屋子里，心里都会想些什么呢？大多我都不记得了。\n也许是小时的时光太过悠闲，以至于上初中后到现在前前后后也 4 年多了，忙来忙去之间，也没有什么时间再去思考生死这样的问题。以至于现在，竟然需要再深夜思考这样的问题而毫无回忆。\n而且仔细想来，小时在身边亲近的人似乎也没有什么大的变故，一切都那么美好，就像童话里说的那样「他们从此过上了幸福的生活」，仿佛没有人会变老，一切都可以维持在小学三四年级，写完作业之后牵着一双大大的手，一起走在斑驳的白石板砖上，时时刻刻想要挣脱那一双大手的管辖，到自己的天地里去驰骋。\n有许多熟识的人、和那些不怎么熟悉的人；有一些人让你记忆犹新，更多人则是已经几近忘却；而无论这些人是谁、在哪、在做什么，他们都在渐渐离我而去了。\n人不能一直活在童话里，童话里的小男孩或许也应该长大了。\n","description":"","id":107,"section":"posts","tags":null,"title":"「随笔」天命 人事","uri":"https://blog.chenqiqian.com/posts/essay-r.i.p./"},{"content":"世界树的形态可以用一个数学模型来描述：世界树中有 $n$ 个种族，种族的编号分别从 $1$ 到 $n$，分别生活在编号为 $1$ 到 $n$ 的聚居地上，种族的编号与其聚居地的编号相同。有的聚居地之间有双向的道路相连，道路的长度为 $1$。保证连接的方式会形成一棵树结构，即所有的聚居地之间可以互相到达，并且不会出现环。定义两个聚居地之间的距离为连接他们的道路的长度；例如，若聚居地 $a$ 和 $b$ 之间有道路，$b$ 和 $c$ 之间有道路，因为每条道路长度为 $1$ 而且又不可能出现环，所以 $a$ 与 $c$ 之间的距离为 $2$。\n出于对公平的考虑，第 $i$ 年，世界树的国王需要授权 $m_i$ 个种族的聚居地为临时议事处。对于某个种族 $x$（$x$ 为种族的编号），如果距离该种族最近的临时议事处为 $y$（$y$ 为议事处所在聚居地的编号），则种族 $x$ 将接受 $y$ 议事处的管辖（如果有多个临时议事处到该聚居地的距离一样，则 $y$ 为其中编号最小的临时议事处）。\n现在国王想知道，在 $q$ 年的时间里，每一年完成授权后，当年每个临时议事处将会管理多少个种族（议事处所在的聚居地也将接受该议事处管理）。 现在这个任务交给了以智慧著称的灵长类的你：程序猿。请帮国王完成这个任务吧。\n链接 Luogu P3233\n题解 我们可以对于每次询问先构造出虚树。\n对于虚树上的节点，我们可以用 $O(m_i)$ 的时间求出虚树上的每个节点距离最近的点。（树形 dp 求出每个节点上方和下方的节点的最近距离然后取 min）\n然后我们对于每条边分类讨论，我们可以计算出来所有连接到这个虚树边上的点的个数，也就是 $siz[u] - siz[v]$。如果这个时候我们的 $u,v$ 能够到达的最近关键点相同，那么这个时候我们就把连到这个边上的点全部都划分给这个相同的关键点；否则我们求出两个点到关键的距离差，然后找到划分最近关键点，用倍增找到这个点，然后划分出两部分分别累加至对应关键点即可。（看起来没几句话，调起来emmm）\n时间复杂度大约是 $O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 310000,logn = 19; struct Graph{ struct Edge{ int to,nex; }edge[MAXN*2];int ecnt; int fir[MAXN]; void addedge(int u,int v){ edge[ecnt] = (Edge){v,fir[u]}; fir[u] = ecnt++; } Edge \u0026amp; operator [](int e){ return edge[e]; } Graph(){ ecnt = 2; } }G1,G2; int n,q,m; struct Node{ int x; }h[MAXN]; int f[MAXN][logn],vis[MAXN],dfn[MAXN],ans[MAXN],siz[MAXN],dep[MAXN],cnt; bool cmp(Node a,Node b){ return dfn[a.x] \u0026lt; dfn[b.x]; } int lca(int x,int y){ if(x == 0 || y == 0) return 0; if(dep[x] \u0026lt; dep[y]) swap(x,y); for(int j = logn-1;j\u0026gt;=0;j--){ if(dep[f[x][j]] \u0026gt;= dep[y]) x = f[x][j]; } if(x == y) return x; for(int j = logn-1;j\u0026gt;=0;j--){ if(f[x][j] != f[y][j]) x = f[x][j],y = f[y][j]; } return f[x][0]; } int find_fa(int x,int t){ int tar = dep[x]-t; for(int j = logn-1;j\u0026gt;=0;--j){ if(dep[f[x][j]] \u0026gt;= tar) x = f[x][j]; } return x; } int dis(int x,int y){ return dep[x] + dep[y] - 2*dep[lca(x,y)]; } void dfs0(int nown,int fa,int depth){ f[nown][0] = fa,dfn[nown] = ++cnt,siz[nown] = 1; dep[nown] = depth; for(int nowe = G1.fir[nown];nowe;nowe = G1[nowe].nex){ int v = G1[nowe].to; if(v == fa) continue; dfs0(v,nown,depth+1); siz[nown] += siz[v]; } } void build(){ dfs0(1,0,1); for(int j = 1;j\u0026lt;=logn-1;j++){ for(int i = 1;i\u0026lt;=n;i++){ f[i][j] = f[f[i][j-1]][j-1]; } } } void build_tree(){ if(vis[1] == 0) h[++m] = (Node){1}; G2.ecnt = 2; sort(h+1,h+m+1,cmp); static int stk[MAXN];int top = 0;//[0,top]  for(int i = 1;i\u0026lt;=m;i++){ int L = lca(h[i].x,stk[top]); if(L == stk[top]){ stk[++top] = h[i].x; } else{ while(top \u0026gt;= 1 \u0026amp;\u0026amp; dep[stk[top-1]] \u0026gt;= dep[L]){ int nown = stk[top-1],v = stk[top]; G2.addedge(nown,v); top--; } if(stk[top] != L){ G2.addedge(L,stk[top]); stk[top] = L; } stk[++top] = h[i].x; } } while(top \u0026gt;= 1){ G2.addedge(stk[top-1],stk[top]); top--; } } int near[MAXN],dist[MAXN]; void dfs1(int nown,int fa){ if(vis[nown] == 1) near[nown] = nown,dist[nown] = 0; else dist[nown] = 0x3f3f3f3f; for(int nowe = G2.fir[nown];nowe;nowe = G2[nowe].nex){ int v = G2[nowe].to; dfs1(v,nown); int d = dist[v] - dep[nown] + dep[v]; if(d \u0026lt; dist[nown] || (d == dist[nown] \u0026amp;\u0026amp; near[v] \u0026lt; near[nown])){ near[nown] = near[v]; dist[nown] = d; } } } void dfs2(int nown,int fa,int nst){ int d = dis(nst,nown); if(nst != -1 \u0026amp;\u0026amp; (d \u0026lt; dist[nown] || (d == dist[nown] \u0026amp;\u0026amp; nst \u0026lt; near[nown]))){ near[nown] = nst; dist[nown] = d; } else{ nst = near[nown]; } for(int nowe = G2.fir[nown];nowe;nowe = G2[nowe].nex){ int v = G2[nowe].to; if(v == fa) continue; dfs2(v,nown,nst); } } int id[MAXN]; void dfs3(int nown,int fa){ int _siz = 0; for(int nowe = G2.fir[nown];nowe;nowe = G2[nowe].nex){ int v = G2[nowe].to,len = dep[v] - dep[nown]; dfs3(v,nown); _siz += siz[find_fa(v,len-1)]; } ans[id[near[nown]]] += siz[nown] - _siz; // 直接与当前节点相邻的子树（不在虚树路径上）都属于该节点  for(int nowe = G2.fir[nown];nowe;nowe = G2[nowe].nex){ int v = G2[nowe].to,len = dep[v] - dep[nown]; int tmp = siz[find_fa(v,len-1)] - siz[v];// 所有可能被这两个节点掌控的节点  if(len == 1) continue; if(near[nown] == near[v]){ ans[id[near[nown]]] += tmp; continue; } else{ int ww = dist[nown] - dist[v] + len;// 理论上第 ww/2 个祖先相同距离  if(ww == 0){ ans[id[near[nown]]] += tmp;continue; } if(ww == 2*len){ ans[id[near[v]]] += tmp; continue; } if((ww \u0026amp; 1) == 0){ int x = find_fa(v,ww/2-1),y = f[x][0]; ans[id[min(near[v],near[nown])]] += siz[y] - siz[x]; tmp -= (siz[y] - siz[x]); } int xx = find_fa(v,(ww-1)/2),tt = siz[xx] - siz[v]; ans[id[near[v]]] += tt,ans[id[near[nown]]] += tmp - tt; } } G2.fir[nown] = 0; } void calc(){ build_tree(); dfs1(1,0); dfs2(1,0,-1); dfs3(1,0); } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n-1;i++){ int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); G1.addedge(u,v),G1.addedge(v,u); } } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int j = 1;j\u0026lt;=m;j++){ int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); h[j] = (Node){x}; ans[j] = 0,id[x] = j; vis[x] = 1; } int mm = m; calc(); for(int j = 1;j\u0026lt;=mm;j++){ printf(\u0026#34;%d \u0026#34;,ans[j]); vis[h[j].x] = 0; } vis[h[m].x] = 0; printf(\u0026#34;\\n\u0026#34;); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":108,"section":"posts","tags":["虚树","树形结构","树形dp"],"title":"「HNOI2014」世界树-虚树+树形dp","uri":"https://blog.chenqiqian.com/posts/hnoi2014-worldtree/"},{"content":"著名的电子产品品牌 SHOI 刚刚发布了引领世界潮流的下一代电子产品—— 概率充电器：\n“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”\nSHOI 概率充电器由 $n-1$ 条导线连通了 $n$ 个充电元件。进行充电时，每条导 线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率 决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电。\n作为 SHOI 公司的忠实客户，你无法抑制自己购买 SHOI 产品的冲动。在排 了一个星期的长队之后终于入手了最新型号的 SHOI 概率充电器。你迫不及待地将 SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？\n链接 Luogu P4284\n题解 我们注意到这道题可以用树形dp的方法来解决。\n设 $f[x]$ 表示 $x$ 节点由不被其子节点（含本身）点亮的概率，那么我们有如下转移：\n对于每个子节点， $f[x]$ 分为这几部分：子节点不被点亮 或 该节点的边 不被点亮，用公式表示即为：\n我们令 $s(i,j) = i+j-i \\times j$， 令 $w[x] = s(f[v],1-q _ {(fa[x],x)})$，那么：\n$$\nf[x] = (1-p[x]) \\prod _ {\\text{v is x\u0026rsquo;s son}} w[v]\n$$\n我们定义该节点不被其父节点点亮的概率为 $g[x]$。 $g[x]$ 即为 父节点不被其父节点点亮 且 父节点不被其他子节点（含本身）点亮 或 导线不通，可以得到 $g[x]$ 表达式为：\n$$\ng[x] = s(q _ {(fa[x],x)} , g[fa[x]] \\times \\frac{f[x]}{w[x]} )\n$$\n（此处若 $w[x] = 0$，则直接令 $g[x] = 0$ 即可）\n答案即为\n$$\nans[x] = 1 - f[x] \\times g[x]\n$$\n树形 $dp$ 即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN= 510000; struct Edge{ int to,nex; double q; }edge[MAXN*2];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b,double q){ edge[ecnt] = (Edge){b,fir[a],q}; fir[a] = ecnt++; } int n; double p[MAXN]; double f[MAXN],g[MAXN],w[MAXN]; double s(double i,double j){ return i+j-i*j; } void dfs1(int x,int fa){ f[x] = 1; for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to;double q = edge[nowe].q; if(v == fa) continue; dfs1(v,x); w[v] = s(f[v],1-q); f[x] *= w[v]; } f[x] *= (1-p[x]); } void dfs2(int x,int fa){ for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to;double q = edge[nowe].q; if(v == fa) continue; if(w[v] != 0){ g[v] = s(1-q,g[x] * f[x] / w[v]); } dfs2(v,x); } } void solve(){ g[1] = 1; dfs1(1,0),dfs2(1,0); double ans = 0; for(int i = 1;i\u0026lt;=n;i++){ //printf(\u0026#34;f:%lf g:%lf\\n\u0026#34;,f[i],g[i]);  ans += 1-f[i]*g[i]; } printf(\u0026#34;%.6lf\\n\u0026#34;,ans); } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 2;i\u0026lt;=n;i++){ int a,b,p; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;p); addedge(a,b,double(p)/100); addedge(b,a,double(p)/100); } for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lf\u0026#34;,\u0026amp;p[i]); p[i]/=100; } } int main(){ init(); solve(); return 0; }   ","description":"","id":109,"section":"posts","tags":["树形dp","期望","树形结构"],"title":"「SHOI2014」概率充电器-树形dp","uri":"https://blog.chenqiqian.com/posts/shoi2014-charger/"},{"content":"L 公司有 $N$ 个工厂，由高到底分布在一座山上。工厂 $1$ 在山顶，工厂 $N$ 在山脚。\n由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 $i$ 个工厂目前已有成品 $P_i$ 件，在第 $i$ 个工厂位置建立仓库的费用是 $C_i$ 。\n对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 L 公司产品的对外销售处设置在山脚的工厂 $N$ ，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 $1$ 个单位距离的费用是 $1$ 。\n假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：\n 工厂 $i$ 距离工厂 $1$ 的距离 $X_i$（其中 $X_1=0$ ）; 工厂 $i$ 目前已有成品数量 $P_i$ ; 在工厂 $i$ 建立仓库的费用 $C_i$ ;  请你帮助 L 公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。\n链接 Luogu P2120\n题解 暴力搞搞式子：\n$$\ndp[i] = \\min _ {j=0}^{i-1}(dp[j] + c_i +\\sum _ {w=j+1}^{i} (x_i - x_w)\\times p_w)\\\ndp[i] = \\min _ {j=0}^{i-1}(dp[j] + c_i +\\sum _ {w=j+1}^{i} (x_i \\times p_w - x_w \\times p_w) )\\\ndp[i] = \\min _ {j=0}^{i-1}(dp[j] +x_i \\sum _ {w=j+1}^{i}p_w - \\sum _ {w=j+1}^{i} x_w \\times p_w) ) + c_i $$\n令 $a_i = \\sum _ {w=1}^{i} p_w$ ， $b_i = \\sum _ {w=1}^{i} x_w \\times p_w$，原式化为\n$$\ndp[i] = \\min _ {j=0}^{i-1}(dp[j] +x_i \\times(a_i-a_j) - (b_i-b_j) ) + c_i\n$$\n如果令 $j \u0026lt; k \u0026lt; i$ ，则 $k$ 比 $j$ 优等价于：\n$$\ndp[j] +x_i \\times(a_i-a_j) - (b_i-b_j) \\geq dp[k] +x_i \\times(a_i-a_k) - (b_i-b_k)\\\ndp[j] - x_i \\times a_j + b_j \\geq dp[k] -x_i \\times a_k + b_k\\\n(dp[j]+b_j) - (dp[k] + b_k) \\geq x_i(a_j-a_k)\n$$\n因为 $a_j \u0026lt; a_k$ ，即 $a_j - a_k \u0026lt; 0$ ，所以有\n$$\n\\frac{(dp[j]+b_j) - (dp[k] + b_k)}{a_j-a_k} \\leq x_i\n$$\n注意到 $x_i$ 单调递增，即如果在某个时刻 $k$ 比 $j$ 优，则以后其会一直更优，单调队列维护即可。\n代码 1    ","description":"","id":110,"section":"posts","tags":["动态规划","斜率优化"],"title":"「ZJOI2007」仓库建设-斜率优化","uri":"https://blog.chenqiqian.com/posts/zjoi2007-warehouse/"},{"content":"小 R 热衷于做黑暗料理，尤其是混合果汁。\n商店里有 $n$ 种果汁，编号为 $0,1,\\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$ ，每升价格为 $p_i$​ 。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。\n现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$ ，体积不小于 $L_j$​ 。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。\n链接 Luogu P4602\n题解 这个题可以整体二分。\n对 $d$ 进行 $\\text{sort}$ 后，我们可以用 $\\text{multiset}$ 维护前缀的果汁按照 $p$ 排序之后的顺序，然后把当前询问按照 $g$ 排序，逐步加入每种果汁，判断是否可以达成 $l$ 的体积作为二分依据。\n假装复杂度大约是 $O(n \\log^2 n)$。\n反正可过。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  // Code By Chen Qiqian on 2018.10.16 #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long using namespace std; const int MAXN = 210000; int n,m; struct Node{ ll d,p,l; bool operator \u0026lt; (const Node \u0026amp;a)const{ if(d != a.d) return d \u0026gt; a.d; else return p \u0026lt; a.p; } }t[MAXN]; bool cmp(const int \u0026amp;a,const int \u0026amp;b){ if(t[a].p != t[b].p) return t[a].p \u0026lt; t[b].p; else return t[a].l \u0026lt; t[b].l; } struct Query{ ll g,l,id; }q[MAXN]; int ans[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ ll a,b,c; scanf(\u0026#34;%lld %lld %lld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); t[i] = (Node){a,b,c}; } sort(t+1,t+n+1); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;q[i].g,\u0026amp;q[i].l); q[i].id = i; } } int a1[MAXN],a2[MAXN]; struct T{ ll p,l; bool operator \u0026lt; (const T \u0026amp;w)const{ if(p != w.p) return p \u0026lt; w.p; else return l \u0026lt; w.l; } }; multiset\u0026lt;T\u0026gt; K; int pos = 0;//[1,pos]  bool cmp2(const int a,const int b){ return q[a].g \u0026lt; q[b].g; } void solve(int *a,int n1,int l,int r){// *a 存储询问编号 在 [l,r] 果汁内二分  if(n1 == 0) return; if(l == r){ for(int i = 0;i\u0026lt;n1;i++) ans[q[a[i]].id] = t[l].d; return; } // 寻找到最小的需要的 n  // d 按从大到小排序  int mid = (l+r)\u0026gt;\u0026gt;1; //判断 1 -\u0026gt; mid 区间是否可以满足限制 (g_i,l_i)  //维护multiset使其可以包括 [1,mid] 所有果汁  while(pos \u0026lt; mid){ pos++; K.insert((T){t[pos].p,t[pos].l}); } while(pos \u0026gt; mid){ K.erase(K.lower_bound((T){t[pos].p,t[pos].l})); pos--; } ll G = 0,L = 0,acnt = 0,bcnt = 0; sort(a,a+n1,cmp2); multiset\u0026lt;T\u0026gt;::iterator it = K.begin(); #define xp it-\u0026gt;p  #define xl it-\u0026gt;l  for(int i = 0;i\u0026lt;n1;i++){ while(it != K.end() \u0026amp;\u0026amp; G + xp * xl \u0026lt;= q[a[i]].g){ G += xp * xl,L += xl; it++; } if(L \u0026gt;= q[a[i]].l || (it != K.end() \u0026amp;\u0026amp; (q[a[i]].l-L) * xp + G \u0026lt;= q[a[i]].g)) a1[acnt++] = a[i]; else a2[bcnt++] = a[i]; } memcpy(a,a1,sizeof(int)*acnt),memcpy(a+acnt,a2,sizeof(int)*bcnt); solve(a,acnt,l,mid),solve(a+acnt,bcnt,mid+1,r); #undef xp  #undef xl } void solve(){ static int qq[MAXN]; for(int i = 1;i\u0026lt;=m;i++) qq[i] = i; t[n+1].d=-1;t[n+1].p=0;t[n+1].l=1e18;++n; solve(qq+1,m,1,n); for(int i = 1;i\u0026lt;=m;i++) printf(\u0026#34;%d\\n\u0026#34;,ans[i]); } signed main(){ init(); solve(); return 0; }   ","description":"","id":111,"section":"posts","tags":["整体二分","set"],"title":"「CTSC2018」混合果汁-整体二分","uri":"https://blog.chenqiqian.com/posts/ctsc2018-mix/"},{"content":"在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。\n假设一开始，荷官拿出了一副新牌，这副牌有 $N$ 张不同的牌，编号依次为 $1$ 到 $N$ 。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为 $1, 2, \\dots$ 直到$N$ ，$N$ 号牌在牌库底。为了发完所有的牌，荷官会进行$N$ 次发牌操作，在第 $i$ 次发牌之前，他会连续进行 $R_i$ 次销牌操作， $R_i$ 由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？\n链接 Luogu P3988\n题解 $\\text{fhq Treap}$ 模拟即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 800000; namespace treap{ int val[MAXN],fhq[MAXN],siz[MAXN],c[MAXN][2]; int cnt,root; void push_up(int x){ if(!x) return; siz[x] = siz[c[x][0]] + siz[c[x][1]] + 1; } int newnode(int v){ int x = ++cnt; val[x] = v;fhq[x] = rand(); push_up(x); return x; } void split(int x,int k,int \u0026amp;l,int \u0026amp;r){ if(!x){ l = r = 0; return; } if(siz[c[x][0]] + 1 \u0026lt;= k) l = x,split(c[x][1],k-siz[c[x][0]]-1,c[l][1],r); else r = x,split(c[x][0],k,l,c[r][0]); push_up(l),push_up(r); } int merge(int l,int r){//小根堆  if(l == 0 || r == 0) return l+r; int x; if(fhq[l] \u0026lt;= fhq[r]){ x = l,c[x][1] = merge(c[l][1],r);\t} else{ x = r,c[x][0] = merge(l,c[r][0]); } push_up(x); return x; } void build(int n){ for(int i = 1;i\u0026lt;=n;i++){ root = merge(root,newnode(i)); } } int del(int k){// 删除并返回 rnk = k 的数字的值  int a,b; int l,m,r; split(root,k,a,b); split(a,k-1,l,m),r = b; root = merge(r,l); return val[m]; } } int n; void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); treap::build(n); for(int i = 1;i\u0026lt;=n;i++){ int r; scanf(\u0026#34;%d\u0026#34;,\u0026amp;r); r %= (n-i+1); printf(\u0026#34;%d\\n\u0026#34;,treap::del(r+1)); } } int main(){ solve(); return 0; }   ","description":"","id":112,"section":"posts","tags":["数据结构","平衡树","Treap"],"title":"「SHOI2013」发牌-fhq Treap","uri":"https://blog.chenqiqian.com/posts/shoi2013-card/"},{"content":"给定一个 $n$ 个点，以 $1$ 为根的有根树，砍断第 $i$ 条边的代价为 $c_i$。有 $m$ 次询问，每次给出 $k_i$ 个关键点（保证关键点不含 $1$ 号节点），询问能够使 $1$ 号节点不能到达任何关键点，所要砍断边的代价和最小是多少。\n数据范围：$n,m \\leq 250000,\\sum {k_i} \\leq 5 \\times 10^5$\n链接 Luogu P2495\n题解 可以先思考只有一个询问的情况。\n如果设 $i$ 到 $1$ 的路径上所有边代价最小的边的代价为 $w[i]$，使 $i$ 的子树里面的所有点都不能到达 $1$ 节点的最小代价为 $f[i]$ ，那么有如下的转移（ $v$ 是 $i$ 的子节点）：\n$$\nf[i] = \\min(w[i],\\sum {f[v]})\n$$\n这个 $\\text{dp}$ 的正确性好像并不是那么显然\u0026hellip;简单证明可以这样：$\\min$ 中的第一个是非常显然的一个可行解，第二个有这么几种情况：如果存在某个 $f[v]$ 由 $w[v]$ 转移而来，那么如果存在 $w[v] = w[i]$，那么必然就是第一种情况再加上若干条边，取 $\\min$ 之后显然不影响答案。\n我们注意到以上 $\\text{dp}$ 的复杂度为 $O(\\text{树的节点数})$，而我们的 $\\sum{k_i}$ 是 $500000$ 。如果 $O(n)$ 的 $\\text{dfs}$ 预处理出树链剖分和 $w[i]$ ，对于每次询问用 $O(k_i \\log n)$ 的时间建出虚树（虚树上只需要维护 $w[i]$ ），再 $O(k_i)$ 的做一次树形 $\\text{dp}$，最后时间复杂度就是 $O( n + \\sum k_i \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152  // Code By Chen Qiqian on 2018.10.13 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;unistd.h\u0026gt;#define ll long long #define inf 0x3f3f3f3f3f3f using namespace std; const int MAXN = 610000; struct Edge{ int to,len,nex; }edge[MAXN];int ecnt = 2,fir[MAXN]; void addedge(int a,int b,int c){ edge[ecnt] = (Edge){b,c,fir[a]}; fir[a] = ecnt++; } int n,m; ll w[MAXN]; int dep[MAXN],siz[MAXN],son[MAXN],fa[MAXN],top[MAXN],dfn[MAXN],tot; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n-1;i++){ int u,v,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;c); addedge(u,v,c),addedge(v,u,c); } } void dfs1(int nown,int f,int depth){ dep[nown] = depth,fa[nown] = f; siz[nown] = 1,son[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(v == fa[nown]) continue; w[v] = min(w[nown],(ll)l); dfs1(v,nown,depth+1); siz[nown] += siz[v]; if(siz[v] \u0026gt; siz[son[nown]]) son[nown] = v; } } void dfs2(int nown,int topf){ dfn[nown] = ++tot;top[nown] = topf; if(!son[nown]) return; dfs2(son[nown],topf); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to;//l = edge[nowe].len;  if(v == fa[nown] || v == son[nown]) continue; dfs2(v,v); } } int lca(int x,int y){ if(x == 0 || y == 0) return 0; while(top[x] != top[y]){ if(dep[top[x]] \u0026lt; dep[top[y]]) swap(x,y); x = fa[top[x]]; } if(dep[x] \u0026gt; dep[y]) swap(x,y); return x; } void build(){ w[1] = inf; dfs1(1,0,1); dfs2(1,1); } int k,kp[MAXN],type[MAXN]; bool cmp(int a,int b){ return dfn[a] \u0026lt; dfn[b]; } Edge _edge[MAXN];int _ecnt = 2,_fir[MAXN]; void _addedge(int a,int b,int c = 0){ _edge[_ecnt] = (Edge){b,c,_fir[a]}; _fir[a] = _ecnt++; } ll _dfs(int nown){ ll tmp = 0; if(type[nown]) return (ll)w[nown]; for(int nowe = _fir[nown];nowe;nowe = _edge[nowe].nex){ int v = _edge[nowe].to; tmp += _dfs(v); } return min(tmp,(ll)w[nown]); } void solve_tree(){ sort(kp+1,kp+k+1,cmp); _ecnt = 2; static int stk[MAXN];int top = 0,cnt = k;//[0,top]  for(int i = 1;i\u0026lt;=k;i++){ type[kp[i]] = 1; int L = lca(kp[i],stk[top]); if(L == stk[top]) stk[++top] = kp[i]; else{ while(top \u0026gt;= 1 \u0026amp;\u0026amp; dep[stk[top-1]] \u0026gt;= dep[L]){ int nown = stk[top-1],v = stk[top]; _addedge(nown,v); top--; } if(stk[top] != L){ _addedge(L,stk[top]); stk[top] = L; kp[++cnt] = L; } stk[++top] = kp[i]; } } while(top \u0026gt;= 1) _addedge(stk[top-1],stk[top]),top--; type[1] = 0; printf(\u0026#34;%lld\\n\u0026#34;,_dfs(1)); for(int i = 1;i\u0026lt;=k;i++) type[kp[i]] = 0; for(int i = 1;i\u0026lt;=cnt;i++) _fir[kp[i]] = 0; } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); for(int j = 1;j\u0026lt;=k;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;kp[j]); kp[++k] = 1; solve_tree(); } } signed main(){ init(); build(); solve(); return 0; }   ","description":"","id":113,"section":"posts","tags":["树形结构","虚树","树形dp","动态规划"],"title":"「SDOI2011」消耗战-虚树+树形dp","uri":"https://blog.chenqiqian.com/posts/sdoi2011-war/"},{"content":"有一个 $n$ 行 $m$ 列的棋盘，棋盘上可以放很多特殊的棋子，每个棋子的攻击范围是 $3$ 行 $p$ 列。输入数据用一个 $3 \\times p$ 的矩阵给出了棋子攻击范围的模板，棋子被默认在模板中的第 [二] 行，第 [$k+1$] 列，模板中棋子能攻击到的位置标记为 1，不能攻击到的位置是 0 $(1 \\leq p \\leq m, 0 \\leq k \u0026lt; p)$。输入数据保证模板中的第 [二] 行第 [$k+1$] 列是 1。\n打开门的密码是这样的：在要求棋子互相不能攻击到的前提下，摆放棋子的方案数。注意什么棋子都不摆也算作一种可行方案。请求出方案对 $2^{32}$ 取余的结果即可。\n注：为使题面符合正常人的思维，对其做了微小的修改，已经用粗体标出。\n题解 很显然， $m$ 那么小，我们肯定可以状态压缩了。\n我们注意到，相当于你在某一行放置的棋子，都只会对本行和前后各一行行产生影响，所以事实上如果我们记录前一行就可以完成状态的记录。\n我们可以得到一个状态转移方程，令 $i$ 为还剩下的行数， $S$ 为上一行的状态：\n$$\ndp[i][S] =\n\\left{\n\\begin{aligned}{}\n\u0026amp;[S\\text{为合法状态}]\u0026amp;,\u0026amp;i = 0\\\n\u0026amp;\\sum dp[i-1][S'] ,SS'\\text{满足条件A} \u0026amp;,\u0026amp;i \\neq 0 \\\n\\end{aligned}\n\\right.\n$$\n其中条件 $A$ 为 $S,S\u0026rsquo;均合法 且 SS' 不冲突$。\n计算合法、不冲突就直接状压按照规则来就可以了，枚举每个位置，然后计算不能放棋子的位置，在取一个与即可。\n注意到复杂度有些高\u0026hellip;貌似是 $O(n(2^m)^2) = 10^6 \\times 64 \\times 64 \\approx 4 \\times 10^9$ ，再加上我们对于任意的 $i$ ，我们的转移是一样，就可以套上矩阵快速幂，复杂度即为 $O((2^m)^3 \\times \\log n) \\approx 5 \\times 10^6$ 可过\u0026hellip;\n取模使用 unsigned int 自然溢出即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ui unsigned int using namespace std; const int MAXN = 70; int n,m,p,k,M; int limit[3]; struct Matrix{ ui num[MAXN][MAXN]; Matrix(int op = 0){ memset(num,0,sizeof(num)); for(int i = 0;i\u0026lt;MAXN;i++){num[i][i] = op;} } ui * operator [](int n){return num[n];} }; Matrix mul(Matrix \u0026amp;_x,Matrix \u0026amp;_y){ Matrix ans; for(int i = 0;i\u0026lt;M;i++) for(int j = 0;j\u0026lt;M;j++) for(int k = 0;k\u0026lt;M;k++) ans[i][j] += _x[i][k] * _y[k][j]; return ans; } Matrix pow(Matrix x,int k){ Matrix ans(1); for(int i = k;i;i\u0026gt;\u0026gt;=1,x = mul(x,x)) if(i\u0026amp;1) ans = mul(ans,x); return ans; } int getv(int x,int op){ int ans = 0; for(int i = 0;i\u0026lt;m;i++) if(x\u0026amp;(1\u0026lt;\u0026lt;i)) ans |= (i\u0026lt;=k?limit[op]\u0026gt;\u0026gt;(k-i):limit[op]\u0026lt;\u0026lt;(i-k)); return ans; } bool judge_self(int x){return x \u0026amp; getv(x,1);} bool judge_next(int L,int R){return (L \u0026amp; getv(R,0)) || (R \u0026amp; getv(L,2));} void init(){ scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;p,\u0026amp;k);M = 1 \u0026lt;\u0026lt; m; for(int i = 0;i\u0026lt;3;i++){ for(int j = 0;j\u0026lt;p;j++){ int t;scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); limit[i] |= t * (1\u0026lt;\u0026lt;j); } } limit[1] -= (1\u0026lt;\u0026lt;k); } void solve(){ Matrix a; for(int i = 0;i\u0026lt;M;i++){ if(judge_self(i)) continue; for(int j = 0;j\u0026lt;M;j++){ if(judge_self(j)) continue; if(!judge_next(j,i)){ a[i][j]++; } } } a = pow(a,n); ui ans = 0; for(int i = 0;i\u0026lt;M;i++){ if(!judge_self(i)) ans += a[0][i]; } printf(\u0026#34;%u\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":114,"section":"posts","tags":["状压dp","动态规划","矩阵快速幂"],"title":"「TJOI2015」棋盘-状压dp+矩阵快速幂","uri":"https://blog.chenqiqian.com/posts/tjoi2015-board/"},{"content":"方伯伯正在做他的 OJ 。现在他在处理 OJ 上的用户排名问题。 OJ 上注册了 $n$ 个用户，编号为 $1$ ～ $n$ ，一开始他们按照编号排名。\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号 ，共有 $m$ 次操作：\n  操作格式为 1 x y ，意味着将编号为 $x$ 的用户编号改为 $y$ ，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时， $y$ 是一个当前不在排名中的编号。\n  操作格式为 2 x ，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n  操作格式为 3 x ，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n  操作格式为 4 k，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。\n  对于 $100%$ 的数据， $1 \\leq n \\leq 10^8,1 \\leq m \\leq 10^5$。\n强制在线。\n链接 Luogu P3285\n题解 一道有(du)趣(liu)的数据结构题。\n注意到 $n$ 的范围比较大， $m$ 的范围比较小，所以不能直接把平衡树建出来，要不然空间/时间咕咕咕\u0026hellip;\n所以我们需要想办法优化一下。注意到 $m$ 的范围是 $10^5$ ，而且只有在两端添加的操作，所以我们可以用动态开点线段树代替平衡树。\n NOIP 2017 D2T3 告诉我们，如果一个平衡树只有在末尾/开头添加和删除操作，那么我们完全可以用动态开点线段树取代它。实现复杂度和时间复杂度都会大幅优化。\n 我们用一个很大很大的动态开点线段树取代平衡树，具体来说就是我们假装我们线段树的 $[1,10^8]$ 之间都塞满了数，但是事实上一个都没有，只有我们要对它进行修改的时候才去把某个位置到根的路径变成真实存在的即可。\n把一个数放到头部就相当于在原位置标记我们已经删除了这个数，然后在 $(- \\infty,0]$ 这个区间里顺次往外插入即可；放到尾部同理，就相当于从内向外在 $[n+1,+\\infty)$ 往里插入数即可。\n然后我们还要记录一个数在线段树重的位置，这里使用一个 map ，在线段树中 $x$ 数出现的位置，没有该 key 则为没有动过，仍在 $x$ 位置。\n由于 $m$ 较 $n$ 比较小，所以时间复杂度 $O(m \\log n)$ ，空间复杂度 $O(m \\log n)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 100000,logn = 35; const int L = -1e7,R=1e8+1e7; struct SegTree{ int siz[MAXN*logn],val[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn]; int root,cnt; #define mid ((l+r)\u0026gt;\u0026gt;1)  void update(int \u0026amp;nown,int l,int r,int pos,int v){ if(!nown) nown = ++cnt; if(l == r) val[nown] = v,siz[nown] = 0; else{ if(pos \u0026lt;= mid) update(ls[nown],l,mid,pos,v); if(pos \u0026gt;= mid+1) update(rs[nown],mid+1,r,pos,v); siz[nown] = siz[ls[nown]] + siz[rs[nown]]; } } void remove(int \u0026amp;nown,int l,int r,int pos){ if(!nown) nown = ++cnt; if(l == r) siz[nown] = -1; else{ if(pos \u0026lt;= mid) remove(ls[nown],l,mid,pos); if(pos \u0026gt;= mid+1) remove(rs[nown],mid+1,r,pos); siz[nown] = siz[ls[nown]] + siz[rs[nown]]; } } int kth(int nown,int l,int r,int k,int \u0026amp;v){ if(k \u0026gt; (r-l+1) + siz[nown]) return -1; if(l == r){ v = val[nown]; return l; } else{ int sz = (mid-l+1) + siz[ls[nown]]; if(k \u0026lt;= sz) return kth(ls[nown],l,mid,k,v); if(k \u0026gt; sz) return kth(rs[nown],mid+1,r,k-sz,v); return -1; } } int getsum(int nown,int l,int r,int ql,int qr){ if(!nown) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return siz[nown]; } else{ int ans = 0; if(ql \u0026lt;= mid) ans += getsum(ls[nown],l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans += getsum(rs[nown],mid+1,r,ql,qr); return ans; } } void update(int pos,int v){update(root,L,R,pos,v);} void remove(int pos){remove(root,L,R,pos);} int kth(int k){int v=0,t = kth(root,L,R,k,v);return v!=0?v:t;} int getsum(int l,int r){return getsum(root,L,R,l,r);} }T; int n,m,nowl,nowr; map\u0026lt;int,int\u0026gt; M;//在线段树中 x 出现的位置，没有则为没有动过  int getpos(int x){ return M.count(x)?M[x]:x; } int push_top(int x){ int pos = getpos(x),ans = (pos-nowl+1) + T.getsum(nowl,pos); T.remove(pos),T.update(--nowl,x); M[x] = nowl; return ans; } int push_bottom(int x){ int pos = getpos(x),ans = (pos-nowl+1) + T.getsum(nowl,pos); T.remove(pos),T.update(++nowr,x); M[x] = nowr; return ans; } int change_id(int x,int y){ int pos = getpos(x),ans = (pos-nowl+1) + T.getsum(nowl,pos); T.update(pos,y); M[y] = pos; return ans; } int query_id(int k){ return T.kth((nowl-L)+k); } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); nowl = 1,nowr = n; } void solve(){ int lastans = 0; for(int i = 1;i\u0026lt;=m;i++){ int op,x,y,k; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if(op == 1){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;y); x -= lastans,y -= lastans; lastans = change_id(x,y); } else if(op == 2){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x);x -= lastans; lastans = push_top(x); } else if(op == 3){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x);x -= lastans; lastans = push_bottom(x); } else if(op == 4){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;k);k -= lastans; lastans = query_id(k); } printf(\u0026#34;%d\\n\u0026#34;,lastans); } } int main(){ init(); solve(); return 0; }   ","description":"","id":115,"section":"posts","tags":["数据结构","线段树"],"title":"「SCOI2014」方伯伯的OJ-动态开点线段树","uri":"https://blog.chenqiqian.com/posts/scoi2014-onlinejudge/"},{"content":"给定一个无向连通图，其节点编号为 $1$ 到 $N$，其边的权值为非负整数。试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得该路径上经过的边的权值的 “ $\\text{XOR}$ 和” 最大。该路径可以重复经过某些节点或边，当一条边在路径中出现多次时，其权值在计算 “$\\text{XOR}$ 和” 时也要被重复计算相应多的次数。\n直接求解上述问题比较困难，于是你决定使用非完美算法。具体来说，从 $1$ 号节点开始，以相等的概率，随机选择与当前节点相关联的某条边，并沿这条边走到下一个节点，重复这个过程，直到走到 $N$ 号节点为止，便得到一条从 $1$ 号节点到 $N$ 号节点的路径。显然得到每条这样的路径的概率是不同的，并且每条这样的路径的 “ $\\text{XOR}$ 和” 也不一样。现在请你求出该算法得到的路径的 “ $\\text{XOR}$ 和” 的期望值。\n链接 Luogu P3211\n题解 注意到每位独立，所以我们可以考虑分别考虑每位再进行相加。\n具体来说，如果我们用 $P[i]$ 表示在 $i$ 号节点时，到达 $N$ 号节点时该位为 $1$ 的概率，那么我们有如下转移：\n$$\nP[i] =\n\\left{\n\\begin{aligned}{}\n\u0026amp;\\sum _ {\\text{i,j have a edge}} \\frac{P[j]}{d[i]}\u0026amp;,i \\neq N\\\n\u0026amp;1\u0026amp;,i = N\n\\end{aligned}\n\\right.\n$$\n其中 $d[i]$ 为 $i$ 节点度数。\n高斯消元即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const double eps = 1e-7; const int MAXN = 110,MAXM = 11000; struct Edge{ int to,len; int nex; }edge[MAXM*2];int ecnt = 2; int fir[MAXN]; void addedge(int u,int v,int c){ edge[ecnt] = (Edge){v,c,fir[u]}; fir[u] = ecnt++; } int n,m; double de[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ int u,v,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;c); addedge(u,v,c);de[u]++; if(u!=v){ addedge(v,u,c);de[v]++; } } } bool gauss(double a[MAXN][MAXN],int n){ for(int i = 1;i\u0026lt;=n;i++){ int r = i; for(int j = i+1;j\u0026lt;=n;j++){ if(fabs(a[j][i]) \u0026gt; fabs(a[r][i])) r = j; } if(r != i){ for(int j = 1;j\u0026lt;=n+1;j++) swap(a[i][j],a[r][j]); } if(fabs(a[i][i]) \u0026lt; eps) return 0; for(int j = 1;j\u0026lt;=n;j++)if(j!=i){ double t = a[j][i]/a[i][i]; for(int k = 1;k\u0026lt;=n+1;k++){ a[j][k] -= a[i][k] * t; } } } for(int i = 1;i\u0026lt;=n;i++) a[i][n+1]/=a[i][i],a[i][i] = 1; return 1; } double ju[MAXN][MAXN]; int num[MAXN]; void solve(){ double ans = 0; for(int i = 0;i\u0026lt;30;i++){ // printf(\u0026#34;i:%d\\n\u0026#34;,i);  memset(ju,0,sizeof(ju)); for(int nown = 1;nown\u0026lt;=n;nown++){ int cnt = 0; ju[nown][nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if((l \u0026amp; (1\u0026lt;\u0026lt;i)) == 0) ju[nown][v] += -1/de[nown]; else ju[nown][v] += 1/de[nown],cnt++; } ju[nown][n+1] = cnt/de[nown]; } for(int i = 1;i\u0026lt;=n;i++) ju[n][i] = 0; ju[n][n] = 1,ju[n][n+1] = 0; gauss(ju,n); ans += ju[1][n+1] * pow(2,i); // printf(\u0026#34;--------------------\\n\u0026#34;);  } printf(\u0026#34;%.3lf\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":116,"section":"posts","tags":["期望","高斯消元"],"title":"「HNOI2011」XOR和路径-高斯消元","uri":"https://blog.chenqiqian.com/posts/hnoi2011-xor/"},{"content":"给定一个 $n$ 个点， $m$ 条边的无向图。聪聪开始的时候在 S，可可在节点 T 处。以后的每个时间单位，可可都会选择去相邻的景点(可能有多个)中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 M 相邻，它们分别是景点 R、 景点 S，……，景点 Q，在时刻 $i$ 可可处在景点 M，则在 $i+1$ 时刻，可可有 $\\frac{1}{1+P}$ 的可能在景点 R，有 $\\frac{1}{1+P}$ 的可能在景点 S，……，有 $\\frac{1}{1+P}$ 的可能在景点 Q，还有 $\\frac{1}{1+P}$ 的可能停在景点 M。\n当聪聪在景点 C 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。如果走完第一次移动以后仍然没吃到可可，她还可以在本段时间内再向可可进行一次移动。\n在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。\n请求出平均情况下，聪聪用几个时间单位就可能吃到可可。\n链接 Luogu P4206\n题解 有趣的期望dp。\n我们注意到，如果我们知道可可和聪聪的位置，那么聪聪的两次移动我们都是唯一的。\n所以我们用 $n$ 次 $\\text{bfs}$ 处理出所有点对间的最短路，然后针对 $n$ 个可可可能在的点，对每个节点进行一次遍历（边），找到最近的出度。以上两个过程都是 $O(n^2)$ 的。\n现在我们就可以进行转移了。\n设 $dp[u][v]$ 为聪聪在 $u$ ，可可在 $v$ 时的期望步数，然后转移即可。注意到我们需要遍历 $v$ 这个点对应的所有的边，但是无向图的话，所有的边会被遍历两遍，所以对于每个 $v$ ，转移是 $O(n)$ 的，然后转移的复杂度也是 $O(n^2)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;unistd.h\u0026gt;using namespace std; const int MAXN = 1100; int n,m,s,t; vector\u0026lt;int\u0026gt; edge[MAXN]; int dis[MAXN][MAXN],near[MAXN][MAXN]; double dp[MAXN][MAXN]; queue\u0026lt;int\u0026gt; q; void init(){ scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s,\u0026amp;t); for(int i = 1;i\u0026lt;=m;i++){ int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); edge[u].push_back(v); edge[v].push_back(u); } } void bfs(int st){ while(!q.empty()) q.pop(); q.push(st);dis[st][st] = 0; while(!q.empty()){ int nown = q.front();q.pop(); // printf(\u0026#34;%d\\n\u0026#34;,nown);  for(unsigned i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; // printf(\u0026#34; v:%d\\n\u0026#34;,v);  if(dis[st][v] == 0 \u0026amp;\u0026amp; v != st){ dis[st][v] = dis[st][nown] + 1; q.push(v); } } } } void get_near(int to){ for(int nown = 1;nown\u0026lt;=n;nown++){ if(nown == to) continue;//cautious  near[nown][to] = 0x3f3f3f3f; for(unsigned i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(dis[v][to] \u0026lt; dis[nown][to] \u0026amp;\u0026amp; near[nown][to] \u0026gt; v){ near[nown][to] = v; } } } } double dfs(int u,int v){ int uu = u,vv = v; if(dp[uu][vv] != 0) return dp[u][v]; if(u == v) return 0; if(near[u][v] == v || near[near[u][v]][v] == v){ return dp[u][v] = 1; } u = near[near[u][v]][v]; double ans = 0; for(unsigned i = 0;i\u0026lt;edge[v].size();i++){ int to = edge[v][i]; ans += (dfs(u,to)+1); } ans += dfs(u,v)+1; return dp[uu][vv] = ans/(edge[v].size()+1); } void solve(){ for(int i = 1;i\u0026lt;=n;i++) bfs(i); for(int i = 1;i\u0026lt;=n;i++) get_near(i); double ans = dfs(s,t); printf(\u0026#34;%.3lf\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":117,"section":"posts","tags":["动态规划","期望dp"],"title":"「NOI2005」聪聪与可可-期望dp","uri":"https://blog.chenqiqian.com/posts/noi2005-clever-and-cute/"},{"content":"给一个数字串 $s$ 和正整数 $d$ , 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$ ）。\n链接 Luogu P4163\n题解 简单状压dp。\n我们先考虑每个数字都不同的情况，然后在除掉每个数字出现次数的阶乘即可。\n我们令 $s$ 的长度为 $n$，设状态 $dp[S][r]$ 为目前选了集合 $S$ ，模 $d$ 余数为 $r$ 的情况数，有如下转移方程：\n$$\ndp[S][r] = \\sum dp[S | 2^i][r*10 + s[i]],\\text{if } S \u0026amp; 2^i = 0\n$$\n边界情况就是 $dp[2^{n+1}-1][0] = 1$ 其余均为 $0$。\n$\\text{dfs}$ 即可，时间复杂度为 $O(n2^n \\times d)$，事实上跑不满\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXN = 11; char str[MAXN];int n,d; int dp[1\u0026lt;\u0026lt;MAXN][1001]; void init(){ scanf(\u0026#34;%s\u0026#34;,str); n = strlen(str); scanf(\u0026#34;%d\u0026#34;,\u0026amp;d); memset(dp,-1,sizeof(dp)); // printf(\u0026#34;str:%s d:%d\\n\u0026#34;,str,d); } int dfs(int now,int r){ if(now == (1\u0026lt;\u0026lt;n)-1) return r == 0; if(dp[now][r] != -1) return dp[now][r]; int ans = 0; for(int i = 0;i\u0026lt;n;i++){ if((now \u0026amp; (1\u0026lt;\u0026lt;i)) == 0){ ans += dfs(now|(1\u0026lt;\u0026lt;i),(r*10+(str[i]-48))%d); } } return dp[now][r] = ans; } void solve(){ dfs(0,0); int t[MAXN],power[MAXN]; for(int i = 0;i\u0026lt;=9;i++) t[i] = 0; for(int i = 0;i\u0026lt;n;i++) t[int(str[i]-48)]++; power[0] = 1; for(int i = 1;i\u0026lt;=n;i++) power[i] = power[i-1] * i; int ans = dp[0][0]; for(int i = 0;i\u0026lt;=9;i++) ans /= power[t[i]]; printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ init(); solve(); } return 0; }   ","description":"","id":118,"section":"posts","tags":["状压dp","动态规划"],"title":"「SCOI2007」排列-状压dp","uri":"https://blog.chenqiqian.com/posts/scoi2007-permutation/"},{"content":"给定一个 $n$ 个节点的有根树，开始时每个节点的权值都为 $0$ 。一共有 $q$ 个时刻，每个时刻可能有如下两个操作之一：\n  给定一个节点 $x$ ，从下一个时刻起每个时刻都给该节点的权值 $+1$（每个节点只会有一次该操作）；\n  给定两个节点 $x,y$ 以及一个数 $C$ ，求这两个节点的简单路径上权值大于 $C$ 的节点个数，以及简单路径上的所有节点个数。\n  链接 Luogu P4216\n题解 设目前时刻 $t$，那么第二个操作事实上可以转化成进行一操作时间在 $t-C$ 之前的节点个数，那么我们可以离线操作，建一棵以树链剖分 $\\text{dfs}$ 序为序列下标的主席树，在结合树链剖分，我们可以在 $O(log^2 n)$ 的时间内回答询问。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 200100,logn = 17; int n,q; vector\u0026lt;int\u0026gt; edge[MAXN]; int rt,fa[MAXN]; int dep[MAXN],siz[MAXN],son[MAXN]; int top[MAXN],id[MAXN],last[MAXN],cnt; int ti[MAXN]; struct Query{ int t,x,y,c; }Q[MAXN*2];int qcnt; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int p; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;p); if(p != 0){ edge[p].push_back(i); fa[i] = p; } else{ rt = i; } } scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); for(int i = 1;i\u0026lt;=q;i++){ int op,x,y,c; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if(op == 1){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;c); Q[++qcnt] = (Query){i,x,y,c}; } else{ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); ti[x] = i; } } } void dfs1(int nown,int depth){ siz[nown] = 1,dep[nown] = depth; for(unsigned i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; dfs1(v,depth+1); siz[nown] += siz[v]; if(siz[v] \u0026gt; siz[son[nown]]) son[nown] = v; } } void dfs2(int nown,int topf){ top[nown] = topf;id[nown] = ++cnt; last[cnt] = nown; if(!son[nown]) return; dfs2(son[nown],topf); for(unsigned i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(v == son[nown]) continue; dfs2(v,v); } } namespace prSegTree{ int ls[MAXN*logn],rs[MAXN*logn],sumn[MAXN*logn],cnt; #define mid ((l+r)\u0026gt;\u0026gt;1)  void insert(int \u0026amp;nown,int pre,int l,int r,int pos,int val){ nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre],sumn[nown] = sumn[pre]; if(l == r){ sumn[nown] += val; } else{ if(pos \u0026lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,val); if(pos \u0026gt;= mid+1) insert(rs[nown],rs[pre],mid+1,r,pos,val); sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]]; } } int query(int nown,int l,int r,int ql,int qr){ if(ql \u0026gt; qr) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return sumn[nown]; } else{ int ans = 0; if(ql \u0026lt;= mid){ ans += query(ls[nown],l,mid,ql,qr); } if(qr \u0026gt;= mid+1){ ans += query(rs[nown],mid+1,r,ql,qr); } return ans; } } } int root[MAXN]; int query_tree(int l,int r,int c){ return prSegTree::query(root[r],1,q+1,1,c) - prSegTree::query(root[l-1],1,q+1,1,c); } void build(){ dfs1(rt,1); dfs2(rt,rt); for(int i = 1;i\u0026lt;=n;i++){ if(ti[last[i]]) prSegTree::insert(root[i],root[i-1],1,q+1,ti[last[i]]+1,1); else root[i] = root[i-1]; } } void query(int x,int y,int c,int \u0026amp;tot,int \u0026amp;ans){ ans = 0;tot = 0; while(top[x] != top[y]){ if(dep[top[x]] \u0026lt; dep[top[y]]) swap(x,y); tot += dep[x] - dep[top[x]] + 1; ans += query_tree(id[top[x]],id[x],c); x = fa[top[x]]; } if(dep[x] \u0026gt; dep[y]) swap(x,y); tot += dep[y] - dep[x] + 1; ans += query_tree(id[x],id[y],c); } void solve(){ int ans = 0,tot = 0; for(int i = 1;i\u0026lt;=qcnt;i++){ Query \u0026amp; qq = Q[i]; query(qq.x,qq.y,qq.t-qq.c,tot,ans); printf(\u0026#34;%d %d\\n\u0026#34;,tot,ans); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":119,"section":"posts","tags":["数据结构","树链剖分","主席树"],"title":"「SCOI2015」情报传递-树链剖分-主席树","uri":"https://blog.chenqiqian.com/posts/scoi2015-intelligence/"},{"content":"有 $n$ 家洗车店从左往右排成一排，每家店都有一个正整数价格 $p_i$ 。有 $m$ 个人要来消费，第 $i$ 个人会驶过第 $a_i$ 个开始一直到第 $b_i$ 个洗车店，且会选择这些店中最便宜的一个进行一次消费。但是如果这个最便宜的价格大于 $c_i$，那么这个人就不洗车了。\n请给每家店指定一个价格，使得所有人花的钱的总和最大。\n链接 Luogu P3592\n题解 首先我们可以明显的发现一个结论：所有 $p_i$ 都只可能是给定的 $c_i$ 中的数。\n所以我们可以先对 $c_i$ 离散化，这样我们的 $c_i$ 的范围就是 $[1,4000]$ 了。我们只要计算出每个人以哪个 $c_i$ 作为最小值，一样可以求得答案。\n如果我们知道一个区间的最小值在什么位置，那么我们事实上可以把所有经过这个点的人的花费直接计算，剩下的人选择的区间（假设我们只考虑被 $[l,r]$ 包含的线段 ）都不会跨过中间的最小值，那么完全可以递归子问题解决。\n所以我们 $dp$ 解决这个问题。\n我们设 $f[i][j][k]$ 表示所有被 $[l,r]$ 包含的线段中，区间中存在最小值为 $k$ （离散化后）的点。\n那么我们可以枚举值为 $k$ 的点的出现位置 $p$ ，就可以得到以下的方程：\n$$\nf[l][r][k] = \\max _ {p=l}^{r}(g[l][p-1][k] + g[p+1][r][k] + v[k] \\times c[p][k])\n$$\n其中：\n$g[l][r][k] = \\max _ {w = k}^{n} (f[l][r][w])$意为这个区间中最小值大于等于 $k$ 的情况下，收费的最大值；$c[p][k]$ 意为在所有被 $[l,r]$ 包含且穿过 $p$ 位置而且 $c_i \\geq k$ 的线段的个数； $v[k]$ 代表 $k$ 的真实大小。\n最后答案即为 $g[1][n][1]$。\n分析下复杂度：\n枚举区间 $[l,r]$ 为 $O(n^2)$ ，对于每一个区间，我们计算 $c[p][k]$ 复杂度为 $O(nm)$ ；我们枚举断点、最小价格的复杂度也是 $O(nm)$；$g$ 数组计算的复杂度明显可以在一个较低的复杂度下进行，最后的时间复杂度就是 $O(n^3m)$；空间复杂度 $O(n^2m)$ 。\n计算路径的时候，我们记录每个 $f[l][r][k]$ 对应的最优分割位置 $p$ 以及 $g[l][r][k]$ 的最优权值选择 $k$ ，就可以递归计算了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 60,MAXM = 4100; int n,m; int A[MAXM],B[MAXM],C[MAXM]; map\u0026lt;int,int\u0026gt; S;int val[MAXM],cnt; int f[MAXN][MAXN][MAXM],g[MAXN][MAXN][MAXM]; int pp[MAXN][MAXN][MAXM],gk[MAXN][MAXN][MAXM]; // pp 记录 f 的位置， gk 记录 g 的权值（记录路径用） int c[MAXN][MAXM]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;A[i],\u0026amp;B[i],\u0026amp;C[i]); S[C[i]] = 0; } for(map\u0026lt;int,int\u0026gt;::iterator it = S.begin();it != S.end();it++){ it-\u0026gt;second = ++cnt; val[cnt] = it-\u0026gt;first; } for(int i = 1;i\u0026lt;=m;i++){ C[i] = S[C[i]]; } } void solve(){ for(int len = 1;len\u0026lt;=n;len++){ for(int l = 1,r = len;r\u0026lt;=n;l++,r++){ //计算c  for(int pos = l;pos\u0026lt;=r;pos++){ for(int i = 1;i\u0026lt;=m;i++) c[pos][i] = 0; for(int s = 1;s\u0026lt;=m;s++){ if(l \u0026lt;= A[s] \u0026amp;\u0026amp; B[s] \u0026lt;= r \u0026amp;\u0026amp; A[s] \u0026lt;= pos \u0026amp;\u0026amp; pos \u0026lt;= B[s]){ c[pos][C[s]]++; } } for(int i = m;i\u0026gt;=1;i--) c[pos][i] += c[pos][i+1]; } // 转移 f 以及 pp  for(int k = 1;k\u0026lt;=m;k++){ for(int p = l;p\u0026lt;=r;p++){ int t = g[l][p-1][k]+g[p+1][r][k]+val[k]*c[p][k]; if(t \u0026gt; f[l][r][k]) pp[l][r][k] = p; //最优的转移位置 p  f[l][r][k] = max(f[l][r][k],t); } g[l][r][k] = f[l][r][k]; } // 计算 k 以及 gk  for(int k = m;k\u0026gt;=1;k--){ gk[l][r][k] = g[l][r][k] \u0026gt; g[l][r][k+1]?k:gk[l][r][k+1]; g[l][r][k] = max(g[l][r][k],g[l][r][k+1]); } } } printf(\u0026#34;%d\\n\u0026#34;,g[1][n][1]); } int ans[MAXN]; void output(int l,int r,int k){ if(l\u0026gt;r) return; if(g[l][r][k] == 0){ for(int i = l;i\u0026lt;=r;i++) ans[i] = val[cnt];// 这里要设置成最大值  // 因为这个区间不存在可能的贡献，所以我们就直接赋权值最大，防止对其他造成影响  } else{ int _k = gk[l][r][k],_p = pp[l][r][_k]; ans[_p] = val[_k]; output(l,_p-1,_k),output(_p+1,r,_k); } } void output(){ output(1,n,1); for(int i = 1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,ans[i]); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); output(); return 0; }   ","description":"","id":120,"section":"posts","tags":["动态规划","区间dp"],"title":"「POI2015」Myjnie-区间dp","uri":"https://blog.chenqiqian.com/posts/poi2015-myjnie/"},{"content":"佳媛姐姐过生日的时候，她的小伙伴从某宝上买了一个有趣的玩具送给他。玩具上有一个数列，数列中某些项的值可能会变化，但同一个时刻最多只有一个值发生变化。\n现在佳媛姐姐已经研究出了所有变化的可能性，她想请教你，能否选出一个子序列，使得在任意一种变化中，这个子序列都是不降的？请你告诉她这个子序列的最长长度即可 。\n注意：每种变化最多只有一个值发生变化。\n链接 Luogu P4093\n题解 我们可以发现，如果 $x$ 位置的变化能够影响到经过它的最长不降子序列，那么需要关心的只有两个值：该点可能变化到的最小值 $\\min_x$ 与可能变化到的最大值 $\\max_x$ 。所以我们只需要存储每个位置的 $\\min_x$ 和 $\\max_x$ 即可。\n然后我们发现这个东西可以用 $O(n^2)$ 的朴素 $dp$ 来完成对 $\\text{LIS}$ 的计算。\n方程为（其中 $a_0 = max_0 = min_0 = - \\inf$）：\n$$\ndp[i] =\n\\left{\n\\begin{aligned}{}\n\u0026amp;0\u0026amp;,;\u0026amp;\\text{if } i = 0\\\n\u0026amp;\\max _ {j=0}^{i-1}{(dp[j] + 1)}\u0026amp;,;\u0026amp; \\text{if } \\text{max} _ j \\leq a_i \\text{ and } a_j \\leq \\text{min} _ i\n\\end{aligned}\n\\right.\n$$\n发现 $\\text{max} _ j \\leq a_i$ 且 $a_j \\leq \\text{min} _ i$ 事实上是一个二维的偏序关系，所以我们可以用 $\\text{CDQ}$ 分治计算满足该条件的 $dp$ 最大值。\n但是这里有一个与普通 $\\text{CDQ}$ 不相同的地方，我们必须要计算完在 $i$ 前面的 $dp$ 值，才能开始计算 $dp[i]$。\n所以这里的 $\\text{CDQ}$ 分治应当做一些微小的更改。\n我们不用归并完成对 $2d$ 的排序，而是直接调用 $sort$ 。\n对于区间 $[l,r]$ ，我们先递归完成 $[l,mid]$ ，排序第二关键字后处理左半对右半的贡献，然后重新按照第一关键字排序后再递归解决 $[mid+1,r]$ 子问题。\n最近 $\\text{CDQ}$ 老写错字母emmm 大约没救了\u0026hellip;\n时间复杂度 $O(n \\log ^2 n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  // luogu-judger-enable-o2 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;#define inf 0x3f3f3f3f using namespace std; const int MAXN = 210000; struct T{ int id,op,a,b; T(){id=op=a=b=0;} T(int _id,int _op,int _a,int _b){ id = _id,op = _op,a = _a,b = _b; } // op = 1 -\u0026gt; (max_j,a_j) 修改  // op = 2 -\u0026gt; (a_i,min_i) 查询 }q[MAXN];int tot; struct BIT{ int maxn[MAXN]; int lowbit(int x){ return x \u0026amp; (-x); } void update(int x,int v){ while(x \u0026lt;= 100000){ maxn[x] = max(maxn[x],v); x += lowbit(x); } } int query(int x){ int ans = 0; while(x \u0026gt;= 1){ ans = max(ans,maxn[x]); x -= lowbit(x); } return ans; } void clear(int x){ while(x \u0026lt;= 100000){ if(maxn[x] == 0) break; maxn[x] = 0; x += lowbit(x); } } }S; int n,m; int dp[MAXN]; int num[MAXN],maxn[MAXN],minn[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); maxn[i] = minn[i] = num[i]; } for(int i = 1;i\u0026lt;=m;i++){ int x,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;x,\u0026amp;v); minn[x] = min(minn[x],v); maxn[x] = max(maxn[x],v); } q[++tot] = T(0,1,-inf,1); for(int i = 1;i\u0026lt;=n;i++){ q[++tot] = T(i,2,num[i],minn[i]); q[++tot] = T(i,1,maxn[i],num[i]); } } bool cmp1d(int x,int y){ if(q[x].a != q[y].a){ return q[x].a \u0026lt; q[y].a; } else{ return q[x].id \u0026lt; q[y].id; } } bool cmpid(int x,int y){ if(q[x].id != q[y].id){ return q[x].id \u0026lt; q[y].id; } else{ return q[x].op \u0026gt; q[y].op; } } int cdq[MAXN]; int tmp1d[MAXN]; void CDQ(int *w,int l,int r){ #define ql q[w[L]]  #define qr q[w[R]]  if(l == r) return; int mid = (l+r)\u0026gt;\u0026gt;1; CDQ(w,l,mid); sort(w+l,w+mid+1,cmp1d),sort(w+mid+1,w+r+1,cmp1d); int L = l,R = mid+1,c = l; while(c \u0026lt;= r){ if(R \u0026gt; r ||(L \u0026lt;= mid \u0026amp;\u0026amp; ql.a \u0026lt;= qr.a)){ if(ql.op == 1) S.update(ql.b,dp[ql.id]); tmp1d[c++] = L++; } else{ if(qr.op == 2){ //printf(\u0026#34;%d qr.id:%d\\n\u0026#34;,w[R],qr.id);  int t = S.query(qr.b); dp[qr.id] = max(dp[qr.id],t+1); } tmp1d[c++] = R++; } } for(int i = l;i\u0026lt;=mid;i++) S.clear(q[w[i]].b); sort(w+l,w+r+1,cmpid); CDQ(w,mid+1,r); #undef ql  #undef qr } void solve(){ for(int i = 1;i\u0026lt;=tot;i++) cdq[i] = i; CDQ(cdq,1,tot); int ans = 0; for(int i = 1;i\u0026lt;=n;i++){ ans = max(ans,dp[i]); } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":121,"section":"posts","tags":["CDQ分治","动态规划"],"title":"「HEOI2016/TJOI2016」序列-CDQ分治优化dp","uri":"https://blog.chenqiqian.com/posts/heoi2016-tjoi2016-sequence/"},{"content":"某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。\n我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。\n链接 Luogu P2487\n题解 ​ $\\text{CDQ}$ 分治优化 $dp$​ 。\n这是一个三维偏序问题。\n如果我们令 $a_i$ 为第 $i$ 个导弹的高度， $b_i$ 为第 $i$ 个导弹的速度，$dp[i]$ 为以第 $i$ 个结尾的导弹能拦截的最大数量， $sum[i]$ 为以第 $i$ 个导弹为结尾能够拦截最大导弹数的方案数，那么我们有如下的转移：\n$$\ndp[i] =\n\\left{\n\\begin{aligned}{}\n\u0026amp;0\u0026amp;,;\u0026amp;\\text{if } i = 0\\\n\u0026amp;\\max _ {j=0}^{i-1}{(dp[j] + 1)}\u0026amp;,;\u0026amp; \\text{if } a_j \\geq a_i \\text{ and } b_j \\geq b_i\n\\end{aligned}\n\\right.\n$$\n$$\nsum[i] =\n\\left{\n\\begin{aligned}{}\n\u0026amp;1\u0026amp;,;\u0026amp;\\text{if } i = 0\\\n\u0026amp;\\sum _ {j=0}^{i-1}{sum[j]}\u0026amp;,;\u0026amp; \\text{if } a_j \\geq a_i \\text{ and } b_j \\geq b_i \\text{ and }dp[j] = dp[i]-1\n\\end{aligned}\n\\right.\n$$\n我们设 $M = \\max _ {i=1}^n dp[i]$，那么我们可以计算出所有的长度为最长值的序列的个数，就是：\n$$\ntot = \\sum _ {i=1}^{n} [dp[i] = M] \\times sum[i]\n$$\n然后我们只要计算出每个点经过的路径条数就可以了。\n对于 $sum[i]$ ，其实我们可以在 $\\text{CDQ}$ 分治的途中一并计算。\n注意到，每个位置上我事实上都维护了一个最大值，它标记着从 $（i-\\text{lowbit}(i),i]$ 的最大值，我们在同样的位置维护一个 $sum$ 即可。\n我们把数字取反，数组翻转，再做一遍 $\\text{CDQ}$ 分治，然后得到的两个对应位置上，如果有 $dp1[i] + dp2[i] - 1 = M$ ，那么我们的 $path[i] = sum1[i] \\times sum2[i]$ ，否则就是 $0$。\n注意这题要离散化。\n这道题得到的启示：\n我们有的时候计算经过某点的路径可以按照该点分别计算两个路径然后乘法原理。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; const int MAXN = 100000; struct T{ int a,b; }q[MAXN]; int cnt = 0; int n; struct BIT{ int maxn[MAXN];double sumn[MAXN]; int lowbit(int x){ return x \u0026amp; (-x); } void update(int x,int mx,double g){ while(x \u0026lt;= n){ if(maxn[x] == mx) sumn[x] += g; else if(mx \u0026gt; maxn[x]) sumn[x] = g; maxn[x] = max(maxn[x],mx); x += lowbit(x); } } void query(int x,int \u0026amp;mx,double \u0026amp;s){ mx = s = 0; while(x \u0026gt;= 1){ if(maxn[x] == mx) s += sumn[x]; else if(maxn[x] \u0026gt; mx) s = sumn[x]; mx = max(mx,maxn[x]); x -= lowbit(x); } } void clear(int x){ while(x \u0026lt;= n){ maxn[x] = 0,sumn[x] = 0; x += lowbit(x); } } }T; int nowa[MAXN],nowb[MAXN]; map\u0026lt;int,int\u0026gt; A,B; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;q[i].a,\u0026amp;q[i].b); A[q[i].a] = 0; B[q[i].b] = 0; } for(map\u0026lt;int,int\u0026gt;::iterator it = A.begin();it!=A.end();it++) it-\u0026gt;second = ++cnt; cnt = 0; for(map\u0026lt;int,int\u0026gt;::iterator it = B.begin();it!=B.end();it++) it-\u0026gt;second = ++cnt; for(int i = 1;i\u0026lt;=n;i++){ q[i].a = n-A[q[i].a]+1; q[i].b = n-B[q[i].b]+1; } } bool cmpa(int x,int y){return nowa[x] \u0026lt; nowa[y];} bool cmpid(int x,int y){return x \u0026lt; y;} int cdq[MAXN]; int tmp1d[MAXN]; int dp[MAXN];double sum[MAXN]; int dp1[MAXN],dp2[MAXN],mx; double ans1[MAXN],ans2[MAXN],tot; void CDQ1d(int *w,int l,int r){ if(l == r) return; int mid = (l+r)\u0026gt;\u0026gt;1; CDQ1d(w,l,mid); sort(w+l,w+mid+1,cmpa),sort(w+mid+1,w+r+1,cmpa); int L = l,R = mid+1,c = l; while(c \u0026lt;= r){ if(R \u0026gt; r || (L \u0026lt;= mid \u0026amp;\u0026amp; nowa[w[L]] \u0026lt;= nowa[w[R]])){ T.update(nowb[w[L]],dp[w[L]],sum[w[L]]); c++;L++; } else{ int mx = 0;double g = 0; T.query(nowb[w[R]],mx,g); mx++; if(mx == dp[w[R]]) sum[w[R]] += g; else if(mx \u0026gt; dp[w[R]]) sum[w[R]] = g; dp[w[R]] = max(mx,dp[w[R]]); sum[w[R]] = max(1.0,sum[w[R]]); c++;R++; } } for(int i = l;i\u0026lt;=mid;i++) T.clear(nowb[w[i]]); sort(w+l,w+r+1,cmpid); CDQ1d(w,mid+1,r); } void solve(){ memset(dp,0,sizeof(dp)),memset(sum,0,sizeof(sum)); dp[1] = 1,sum[1] = 1; for(int i = 1;i\u0026lt;=n;i++) cdq[i] = i,nowa[i] = q[i].a,nowb[i] = q[i].b; CDQ1d(cdq,1,n); for(int i = 1;i\u0026lt;=n;i++) mx = max(mx,dp[i]); for(int i = 1;i\u0026lt;=n;i++){ if(dp[i] == mx) tot += sum[i]; dp1[i] = dp[i]; ans1[i] = sum[i]; } memset(dp,0,sizeof(dp)),memset(sum,0,sizeof(sum)); dp[1] = 1,sum[1] = 1; for(int i = 1;i\u0026lt;=n;i++) cdq[i] = i,nowa[i] = n - q[n-i+1].a + 1,nowb[i] = n - q[n-i+1].b + 1; CDQ1d(cdq,1,n); for(int i = 1;i\u0026lt;=n;i++){ dp2[i] = dp[n-i+1]; ans2[i] = sum[n-i+1]; } printf(\u0026#34;%d\\n\u0026#34;,mx); for(int i = 1;i\u0026lt;=n;i++){ if(dp1[i] + dp2[i] - 1 == mx) printf(\u0026#34;%.10lf \u0026#34;,double(ans1[i]) * ans2[i] / tot); else printf(\u0026#34;%.10lf \u0026#34;,0.0); } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":122,"section":"posts","tags":["CDQ分治","树状数组","动态规划"],"title":"「SDOI2011」拦截导弹-CDQ分治优化dp","uri":"https://blog.chenqiqian.com/posts/sdoi2011-missile/"},{"content":"在定位系统中，世界被认为是一个 $W \\times W$ 的正方形区域，由 $1 \\times 1$ 的方格组成。每个方格都有一个坐标 $(x,y)$ ， $1 \\leq x,y \\leq W$。\n有三种命令，意义如下：\n 0 W 初始化一个全零矩阵。本命令仅开始时出现一次。 1 x y A 向方格 $(x,y)$ 中添加A个用户。A是正整数。 2 X1 Y1 X2 Y2 查询 $X1 \\leq x \\leq X_2$ ， $Y_1 \\leq y \\leq Y_2$ 所规定的矩形中的用户数量 3 无参数 结束程序。本命令仅结束时出现一次。  链接 Luogu P4390\n题解 二维动态数点问题。\n有很多种解法，树套树，$\\text{CDQ}$ 分治 + 树状数组，$\\text{CDQ}$ 分治套 $\\text{CDQ}$ 分治。\n这里选择了最后一种方法，练习一下 $\\text{CDQ}$ 分治。\n首先要明确，第 $x$ 个维度的 $\\text{CDQ}$ 分治解决的是所有在前 $x-1$ 次分治中划分的（左/右）都相同的询问中，左-\u0026gt;右的贡献。\n在这里叙述一下 $\\text{CDQ}$ 套 $\\text{CDQ}$ 解决三维偏序问题（也可以推广到更高维的一个过程）：\n以三维偏序为例子，我们的三元组令其为 $(a,b,c)$ 。\n预处理（相当于消掉一个维度）：\n 对第一维 $a$ 进行排序  对第一维分治 CDQ1d(L,R)：\n对第一维 $a$ 进行分治，递归处理 CDQ1d(L,mid) 和 CDQ1d(mid,R) 按第二维 $b$ 进行归并，此时不计算答案，只记录在这次分治中，该询问/修改属于左半区间 $\\text{LEFT}$ 或者 右半区间 $\\text{RIGHT}$ 。 复制一份归并后的该区间 $[l,r]$ 的询问数组，用其进行第二维的分治。  对第二维分治 CDQ2d(L,R)：\n对第二维 $b$ 进行分治，递归处理 CDQ2d(L,mid) 和 CDQ2d(mid,R) 按第三维 $c$ 进行归并，此时需要计算答案，记录一个临时变量 $\\text{tmp}$ （树状数组）。如果归并左侧新加入的查询/修改在之前维度的分治中均属于左半区间 $\\text{LEFT}$ ，则给 $\\text{tmp}$ （树状数组）做对应的修改； 如果归并右侧新加入的查询/修改在之前维度的分治中均属于右半区间 $\\text{RIGHT}$ ，则计算相关贡献。  可以发现，这个递归是可以再次嵌套的，只有最外面一维是需要计算贡献的，前面只要记录每一维的 $\\text{LEFT}$ 或 $\\text{RIGHT}$，在最后计算即可。\n事实上，我们在最后一层递归需要计算的只有 $(\\text{LEFT},\u0026hellip;,\\text{LEFT},x_1)$ 对 $(\\text{RIGHT},..,\\text{RIGHT},x_2)$ 的贡献。\n为什么这样就可以计算完全呢？\n我们考虑到，如果在前 $x-1$ 个维度其有任意一个维度被划分到了一个区间，那么他们就会共同进入一次分治，那么这两个询问/查询之间的影响就会在子问题里面被解决，所以我们这样做的正确性是可以保证的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 300000; int n,qaq; struct T{ int id,op,a,b,add,ans,part; //add = 1/-1  T(){ id = op = a = b = add = ans = part = 0; } T(int _id,int _op,int _a,int _b,int _add,int _ans = 0,int _p = 0){ id = _id,op = _op,a = _a,b = _b,add = _add,ans = _ans,part = _p; } }t[MAXN];int tot; int ans[MAXN],vis[MAXN]; int cdq[MAXN],tmp1d[MAXN],tmp2d[MAXN]; const int LEFT = 0,RIGHT = 1; void CDQ2d(int *w,int l,int r){//对第二维(a) 分治，对第三维 (b) 合并  // 这里给出序列 w 的时候应该其第一维坐标 (a) 已经有序  if(l == r) return; int mid = (l+r)\u0026gt;\u0026gt;1; CDQ2d(w,l,mid),CDQ2d(w,mid+1,r);//递归解决子问题  int L = l,R = mid+1,c = l;//现在左边第二维全部小于右边  int tmp = 0; // 跨越维度的分治只需要考虑 (L,b1) 对 (R,b2) 的影响，剩余的在1d的分治里面已经解决  // 更高维度的分治同理，只需要考虑 (L,...,L,b1) 对 (R,...,R,b2) 的影响；  // 第一维相同的在 1d 里面解决，第二维相同的在 2d 里面解决  while(c \u0026lt;= r){// 对第三维度进行归并排序  if(R \u0026gt; r || (L\u0026lt;=mid \u0026amp;\u0026amp; t[w[L]].b \u0026lt;= t[w[R]].b)){ if(t[w[L]].part == LEFT \u0026amp;\u0026amp; t[w[L]].op == 1) tmp += t[w[L]].add; tmp2d[c++] = w[L++]; } else{ if(t[w[R]].part == RIGHT \u0026amp;\u0026amp; t[w[R]].op == 2) t[w[R]].ans += tmp; tmp2d[c++] = w[R++]; } } for(int i = l;i\u0026lt;=r;i++) w[i] = tmp2d[i]; } void CDQ1d(int *w,int l,int r){//对第一维（隐去）分治，对第二维合并  if(l == r) return; int mid = (l+r)\u0026gt;\u0026gt;1; CDQ1d(w,l,mid),CDQ1d(w,mid+1,r);// 递归解决子问题  int L = l,R = mid+1,c = l; while(c \u0026lt;= r){ if(R \u0026gt; r || (L \u0026lt;= mid \u0026amp;\u0026amp; t[w[L]].a \u0026lt;= t[w[R]].a))// 对第二维进行归并  t[w[L]].part = LEFT,tmp1d[c++] = w[L++]; else t[w[R]].part = RIGHT,tmp1d[c++] = w[R++]; } for(int i = l;i\u0026lt;=r;i++) w[i] = tmp1d[i];// tmp1d相当于复制的一份  CDQ2d(tmp1d,l,r); } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;qaq,\u0026amp;n); for(int i = 1;;i++){ int op,x,y,x1,y1,v; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); if(op == 3){break;} if(op == 1){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;v); t[++tot] = T(i,1,x,y,v); } else if(op == 2){ vis[i] = 1; scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;x1,\u0026amp;y1); t[++tot] = T(i,2,x-1,y-1,1); t[++tot] = T(i,2,x-1,y1,-1); t[++tot] = T(i,2,x1,y-1,-1); t[++tot] = T(i,2,x1,y1,1); } else{return;} } } void solve(){ for(int i = 1;i\u0026lt;=tot;i++){ cdq[i] = i; } CDQ1d(cdq,1,tot); for(int i = 1;i\u0026lt;=tot;i++){ if(vis[t[i].id]) ans[t[i].id] += t[i].add * t[i].ans; } for(int i = 1;i\u0026lt;=tot;i++){ if(vis[i]){ printf(\u0026#34;%d\\n\u0026#34;,ans[i]); } } } int main(){ init(); solve(); return 0; }   ","description":"","id":123,"section":"posts","tags":["CDQ分治","数据结构"],"title":"「BOI2007」Mokia-CDQ分治套CDQ分治","uri":"https://blog.chenqiqian.com/posts/boi2007-mokia/"},{"content":"给定了一个长度为 $n$ 的数列和 $m$ 个询问。\n每个询问给定数列的一个区间 $[l,r]$ ，你要回答两个问题：\n 该区间内大于等于 $a$ ，小于等于 $b$ 的数的个数， 所有大于等于 $a$ ，小于等于 $b$ 的，且在该区间中出现过的数值的个数。  链接 Luogu P4396\n题解 接近莫队模版题\u0026hellip;\n这个题的关键在于，你维护每一个数出现的 $times[i]$ 和是否出现 $vis[i]$ 都可以做到 $O(1)$ 更新，但是这个时候你要 $O(1)$ 查询这两个的数列的 $[a,b]$ 区间内的和就比较困难。\n我们想到可以用树状数组来维护，但是这样的话 $O( (n+m) \\sqrt n \\log n)$ 的复杂度有点虚\u0026hellip;\n注意到我们总共有 $O((n+m) \\sqrt n)$ 次修改，但只有 $O(m)$ 次查询，所以我们如果维护一个支持 $O(1)$ 单点修改， $O(1)$ 单点求和， $O(\\sqrt n)$ 区间求和的值域分块，那么复杂度就降到 $O((n+m) \\sqrt n)$ ，充分可过。\n注意需要离散化。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; const int MAXN = 110000,MAXQ = 4000; struct FQ{ int num[MAXN],sumn[MAXQ],n,Q; int block[MAXN],lb[MAXQ],rb[MAXQ]; void init(int _n){ memset(num,0,sizeof(num)); memset(block,0,sizeof(block)); memset(lb,0,sizeof(lb)); memset(rb,0,sizeof(rb)); memset(sumn,0,sizeof(sumn)); n = _n,Q = sqrt(n)+1; for(int i = 1;i\u0026lt;=n;i++){ block[i] = (i/Q)+1; if(block[i] != block[i-1]){ lb[block[i]] = i; rb[block[i-1]] = i-1; } } rb[block[n]] = n; } void build(int n,int *_num = NULL){ init(n); if(_num){ for(int i = 1;i\u0026lt;=n;i++){ num[i] = _num[i]; sumn[block[i]] += num[i]; } } } void update(int pos,int v){ num[pos] += v; sumn[block[pos]] += v; } int query(int l,int r){ int ll = block[l],rr = block[r],ans = 0; if(l \u0026gt; r) return 0; if(ll == rr){ for(int i = l;i\u0026lt;=r;i++) ans += num[i]; return ans; } else{ for(int i = ll + 1;i\u0026lt;rr;i++) ans += sumn[i]; for(int i = l;i\u0026lt;=rb[ll];i++) ans += num[i]; for(int i = lb[rr];i\u0026lt;=r;i++) ans += num[i]; } return ans; } }A,B; int n,m,Q; int num[MAXN]; int back[MAXN]; int ans1[MAXN],ans2[MAXN]; map\u0026lt;int,int\u0026gt; S; struct Query{ int id,l,r,a,b; }q[MAXN]; bool cmp(Query \u0026amp;_a,Query \u0026amp;_b){ if(_a.l/Q == _b.l/Q) return _a.r \u0026lt; _b.r; else return _a.l/Q \u0026lt; _b.l/Q; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); Q = sqrt(n)+1; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); S[num[i]] = 0; } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;q[i].l,\u0026amp;q[i].r,\u0026amp;q[i].a,\u0026amp;q[i].b); q[i].id = i; } int cnt = 0; for(map\u0026lt;int,int\u0026gt;::iterator it = S.begin();it!=S.end();it++){ it-\u0026gt;second = ++cnt; back[cnt] = it-\u0026gt;first; } for(int i = 1;i\u0026lt;=n;i++){ num[i] = S[num[i]]; } for(int i = 1;i\u0026lt;=m;i++){ q[i].a = lower_bound(back+1,back+cnt+1,q[i].a) - (back); q[i].b = upper_bound(back+1,back+cnt+1,q[i].b) - (back+1); } sort(q+1,q+m+1,cmp); } void add(int pos){ if(A.query(num[pos],num[pos]) == 0) B.update(num[pos],1); A.update(num[pos],1); } void del(int pos){ A.update(num[pos],-1); if(A.query(num[pos],num[pos]) == 0) B.update(num[pos],-1); } void solve(){ A.build(n),B.build(n); int L = 1,R = 0; for(int i = 1;i\u0026lt;=m;i++){ while(q[i].l \u0026lt; L) add(--L); while(R \u0026lt; q[i].r) add(++R); while(L \u0026lt; q[i].l) del(L++); while(q[i].r \u0026lt; R) del(R--); ans1[q[i].id] = A.query(q[i].a,q[i].b); ans2[q[i].id] = B.query(q[i].a,q[i].b); } for(int i = 1;i\u0026lt;=m;i++){ printf(\u0026#34;%d %d\\n\u0026#34;,ans1[i],ans2[i]); } } int main(){ init(); solve(); return 0; }   ","description":"","id":124,"section":"posts","tags":["莫队","数据结构"],"title":"「AHOI2013」作业-莫队","uri":"https://blog.chenqiqian.com/posts/ahoi2013-homework/"},{"content":"给出正整数 $n$ 和 $k$ ，计算\n$$\n\\sum _ {i=1}^{n} k \\bmod i\n$$\n链接 Luogu P2261\n题解 推一发式子：\n$$\n\\sum _ {i=1}^{n} k \\bmod i\\\n= \\sum _ {i=1}^{n} k - \\lfloor \\frac{k}{i} \\rfloor \\cdot i\\\n= n k - \\sum _ {i=1}^{n} \\lfloor \\frac{k}{i} \\rfloor \\cdot i\\\n$$\n那么，问题就变成我们要求出下式的值：\n$$\n\\sum _ {i=1}^{n} \\lfloor \\frac{k}{i} \\rfloor \\cdot i\n$$\n我们发现，这个式子当 $i \u0026gt; k$ 时没啥意义，所以化成：\n$$\n\\sum _ {i=1}^{\\min(n,k)} \\lfloor \\frac{k}{i} \\rfloor \\cdot i\n$$\n我们注意到 $\\lfloor \\frac{k}{i} \\rfloor$ 最多只有 $2\\sqrt{n}$ 种取值，所以可以进行数论分块，对于相同的一段取值，我们计算出这段里面的 $\\sum i$ ，就可以在 $O(\\sqrt{\\min(n,k)})$ 的时间内计算出结果了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; ll n,k; void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;n,\u0026amp;k); } void solve(){ ll ans = n*k; for(ll l = 1,r;l \u0026lt;= n \u0026amp;\u0026amp; l \u0026lt;= k;l = r+1){ r = min((k/(k/l)),n); ans -= (k/l) * (r+l)*(r-l+1)/2; } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":125,"section":"posts","tags":["数学","分块"],"title":"「CQOI2007」余数求和-数论+分块","uri":"https://blog.chenqiqian.com/posts/cqoi2007-sum/"},{"content":"简单题意：\n给定一个质数 $P$ 和其原根 $g$，给定 $X$ 求 $g^x \\equiv X \\pmod p$ 的非负整数解 $x$。\n假定通讯双方名为 $\\text{Alice}$ 和 $\\text{Bob}$ ，协议的工作过程描述如下(其中 $\\bmod$ 表示取模运算) :\n  协议规定一个固定的质数 $P$ ，以及模 $P$ 的一个原根 $g$ 。 $P$ 和 $g$ 的数值都是公开的，无需保密。\n  $\\text{Alice}$ 生成一个随机数 $a$ ，并计算 $A=g^a \\bmod P$, 将 $A$ 通过不安全信道发送给Bob。\n  $\\text{Bob}$ 生成一个随机数 $b$ ，并计算 $B=g^b \\bmod P$ ，将 $B$ 通过不安全信道发送给 $\\text{Alice}$ 。\n  $\\text{Bob}$ 根据收到的 $A$ 计算出 $K=A^b\\bmod P$ ，而 Alice 根据收到的 $B$ 计算出$K=B^a\\bmod P$。\n  双方得到了相同的 $K$ 即 $g^{ab} \\bmod P$。 $K$ 可以用于之后通讯的加密密钥。\n  可见，这个过程中可能被窃听的只有 $A,B$ ，而 $a,b,K$ 是保密的。并且根据 $A,B,P,g$ 这 $4$ 个数，不能轻易计算出 $K$ ，因此 $K$ 可以作为一个安全的密钥。\n当然安全是相对的，该协议的安全性取决于数值的大小，通常 $a,b,P$ 都选取数百位以上的大整数以避免被破解。然而如果 $\\text{Alice}$ 和 $\\text{Bob}$ 编程时偷懒，为了避免实现大数运算，选择的数值都小于 $2^{31}$ ，那么破解他们的密钥就比较容易了。\n链接 Luogu P4454\n题解 $\\text{BSGS}$ 模版题，甚至连分类讨论都没有\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;map\u0026gt;#define ll long long using namespace std; ll gcd(ll a,ll b){ return b==0?a:gcd(b,a%b); } ll pow(ll x,ll k,ll p){ x %= p; ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x=x*x%p) if(i \u0026amp; 1) ans = ans * x % p; return ans; } ll bsgs(ll a,ll b,ll p){ //printf(\u0026#34;a:%lld b:%lld P:%lld\\n\u0026#34;,a,b,p);  a %= p,b %= p; if(b == 1) return 0; ll cnt = 0,t = 1; for(ll g = gcd(a,p);g!=1;g = gcd(a,p)){ if(b % g) return -1; a /= g,p /= g, t = t * a/g % p; cnt++; if(t == b) return cnt; } map\u0026lt;ll,ll\u0026gt; S; ll m = (ll)(sqrt(p)) + 1; ll base = b; for(ll i = 0;i\u0026lt;m;i++){ S[base] = i; base = base * a % p; } ll now = t; base = pow(a,m,p); for(ll i = 1;i\u0026lt;=m+1;i++){ now = now * base % p; if(S.count(now)){ return i*m-S[now]+cnt; } } return -1; } ll n; ll p,G; ll cal(ll A,ll B){ ll a = bsgs(G,A,p),b = bsgs(G,B,p); //printf(\u0026#34;a:%lld b:%lld\\n\u0026#34;,a,b);  return pow(G,a*b,p); } void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;G,\u0026amp;p); } void solve(){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ ll a,b; scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%lld\\n\u0026#34;,cal(a,b)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":126,"section":"posts","tags":["数学","数论","BSGS算法"],"title":"「CQOI2018」破解D-H协议-BSGS算法","uri":"https://blog.chenqiqian.com/posts/cqoi2018-crack/"},{"content":"已知一个长度为 $n$ 的整数数列 $a_1,a_2,\u0026hellip;,a_n$ ，给定查询参数 $l$ 、 $r$ ，问在 $a_l,a _ {l+1},\u0026hellip;,a_r$ ​区间内，有多少子序列满足异或和等于 $k$ 。也就是说，对于所有的 $x,y$ $(l \\leq x \\leq y \\leq r)$ ，能够满足 $a_x \\bigoplus a _ {x+1} \\bigoplus \u0026hellip; \\bigoplus a_y = k$ 的 $x,y$ 有多少组。\n链接 Luogu P4462\n题解 考虑到这题没有修改，而且是区间查询问题，所以我们可以考虑一下莫队算法。\n如果我们用莫队的话，那么应该让这个数对 $(x,y)$ 的数目能够在 $O(1)$ 的时间维护。\n因为异或有结合律，以及 $a\\bigoplus a = 0$ ，所以如果我们令 $S_i = a_1 \\bigoplus a_2 \\bigoplus \u0026hellip; \\bigoplus a_i$ ，那么 $a_x \\bigoplus a _ {x+1} \\bigoplus \u0026hellip; \\bigoplus a_y$ 就等于 $S_y \\bigoplus S _ {x-1}$。\n这个时候如果我们令 $T_i = S _ {i-1} \\bigoplus k(S_0 = 0)$ ， 那么 $(x,y)$ 是合法数对的条件就化作 $S_y = T_x$ 。\n那么问题转化为在 $l \\leq x\\leq y \\leq r$ 的区间内，有多少对 $(x,y)$ 满足 $T_x = S_y$ ，其中的 ${T_n}$ 和 ${S_n}$ 都可以 $O(n)$ 的计算。\n莫队套套套，记录一下在当前区间每个数在 ${T_n}$ 和 ${S_n}$ 中出现次数，转移的时候注意分左右讨论一下就好了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95  // luogu-judger-enable-o2 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; const int MAXN = 110000; int n,m,k,Q; int num[MAXN]; int xor1[MAXN],xor2[MAXN]; ll ans[MAXN]; struct Query{ int l,r,id; bool operator \u0026lt;(const Query _q)const{ if(l/Q != _q.l/Q){ return l/Q \u0026lt; _q.l/Q; } else{ return r \u0026lt; _q.r; } } }q[MAXN]; void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k); Q = sqrt(n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); } for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;q[i].l,\u0026amp;q[i].r); q[i].id = i; } sort(q+1,q+m+1); } void build(){ for(int i = 1;i\u0026lt;=n;i++){ xor1[i] = xor1[i-1] ^ num[i]; xor2[i] = xor2[i-1] ^ num[i]; } for(int i = 0;i\u0026lt;=n;i++) xor2[i] ^= k; for(int i = n;i\u0026gt;=0;i--) xor2[i+1] = xor2[i]; } ll ANS = 0; ll num1[MAXN],num2[MAXN]; void addl(int pos){ num1[xor1[pos]]++; num2[xor2[pos]]++; ANS += num1[xor2[pos]]; } void addr(int pos){ num1[xor1[pos]]++; num2[xor2[pos]]++; ANS += num2[xor1[pos]]; } void dell(int pos){ ANS -= num1[xor2[pos]]; num1[xor1[pos]]--; num2[xor2[pos]]--; } void delr(int pos){ ANS -= num2[xor1[pos]]; num1[xor1[pos]]--; num2[xor2[pos]]--; } void solve(){ int L = 1,R = 0; for(int i = 1;i\u0026lt;=m;i++){ while(q[i].l \u0026lt; L) addl(--L); while(R \u0026lt; q[i].r) addr(++R); while(L \u0026lt; q[i].l) dell(L++); while(q[i].r \u0026lt; R) delr(R--); ans[q[i].id] = ANS; } for(int i = 1;i\u0026lt;=m;i++){ printf(\u0026#34;%lld\\n\u0026#34;,ans[i]); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":127,"section":"posts","tags":["莫队","分块"],"title":"「CQOI2018」异或序列-莫队","uri":"https://blog.chenqiqian.com/posts/cqoi2018-xor-sequence/"},{"content":"喜欢钻研问题的 $JS$ 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。\n例如 JSOI07 ，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 ，把它们按照字符串的大小排序：\n 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J  读出最后一列字符：I0O7SJ，就是加密后的字符串。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？\n链接 Luogu P4051\n题解 复制字符串，然后跑 $SA$ ，得到 $sa$ 数组，然后在上面顺序扫描，扫描到最前面 $n$ 个在 $1$ 到 $n$ 之间开始的后缀，然后获取其第 $n$ 个字符即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXN = 210000; namespace SA{ int s[MAXN],sa[MAXN],rk[MAXN],x[MAXN],y[MAXN],cnt[MAXN]; void get_sa(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]] ++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] == s[sa[i-1]] ? m : ++m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) return; //printf(\u0026#34;!!!\\n\u0026#34;);  for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k=j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i] - j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]]==y[sa[i-1]]\u0026amp;\u0026amp;y[sa[i]+j]==y[sa[i-1]+j])?m:++m; } } void solve(char *str,int n){ for(int i = 0;i\u0026lt;n;i++){ s[i] = str[i]; } s[n] = 0; get_sa(++n,127); } void get_ans(char *ans,int n){ int cnt = 0; for(int i = 1;i\u0026lt;=2*n;i++){ int t = sa[i]; if(t \u0026lt; n){ ans[cnt++] = s[t+n-1]; } } } } int n; char s[MAXN]; char ans[MAXN]; void init(){ scanf(\u0026#34;%s\u0026#34;,s); n = strlen(s); } void solve(){ for(int i = 0;i\u0026lt;n;i++) s[n+i] = s[i]; SA::solve(s,2*n); SA::get_ans(ans,n); printf(\u0026#34;%s\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":128,"section":"posts","tags":["字符串","后缀数组"],"title":"「JSOI2007」字符加密-后缀数组","uri":"https://blog.chenqiqian.com/posts/jsoi2007-character/"},{"content":"你被要求设计一个计算器完成以下三项任务：\n  给定 $y,z,p$ ，计算 $y^z \\bmod p$ 的值；\n  给定 $y,z,p$ ，计算满足 $xy \\equiv z \\pmod p$ 的最小非负整数 $x$；\n  给定 $y,z,p$ ，计算满足 $y^x \\equiv z \\pmod p$ 的最小非负整数 $x$。\n  保证 $p$ 为质数。\n链接 Luogu P2485\n题解 第一个快速幂，第二个扩展欧几里得，第三个 $\\text{BSGS}$ 算法。\n模版题，不说了。\nBSGS算法介绍： Miskcoo\u0026rsquo;s Blog\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;cmath\u0026gt;#define ll long long using namespace std; ll gcd(ll a,ll b){ return b == 0?a:gcd(b,a%b); } ll pow(ll x,ll k,ll p){ ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = (x*x)%p) if(i \u0026amp; 1) ans = (ans * x)%p; return ans; } ll exgcd(ll a,ll b,ll \u0026amp;x,ll \u0026amp;y){ if(b == 0){ x = 1,y = 0; return a; } else{ ll d = exgcd(b,a%b,y,x); y -= (a/b) * x; return d; } } ll module_formation(ll a,ll b,ll p){ ll x,y,d = exgcd(a,p,x,y); //printf(\u0026#34;%lld*%lld+%lld*%lld=%lld\\n\u0026#34;,a,x,p,y,d);  if(b%d) return -1; x *= b/d; return (x % (p/d) + (p/d)) % (p/d); } ll bsgs(ll a,ll b,ll p){ // 求解 A^x \\equiv B (mod p)  a %= p,b %= p;// 利用同余性质对 p 取模  if(b == 1) return 0; ll t = 1,cnt = 0; for(ll g = gcd(a,p);g != 1;g = gcd(a,p)){// 排除所有公因数，使 (a,p) = 1  if(b % g) return -1; b/=g,p/=g,t = t * a/g % p; cnt++; if(b == t) return cnt; } map\u0026lt;ll,ll\u0026gt; hash; int m = int(sqrt(p)) + 1; ll base = b; for(int i = 0;i\u0026lt;m;i++){ // 计算 A 的 0 -\u0026gt; m-1 次方  hash[base] = i; base = base * a % p; } ll now = t;base = pow(a,m,p); for(int i = 1;i\u0026lt;=m+1;i++){// 枚举 A^{im} 次方，寻找相等的 A^j  // 这里的枚举上限是 m+1 因为后面的 j 是减过去的  now = now * base % p; if(hash.count(now)) // 答案即为 A^{im-j(+cnt)}  return i * m - hash[now] + cnt; } return -1; } ll n,k,a,b,p; void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;n,\u0026amp;k); } void solve(){ for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld %lld %lld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;p); ll ans = -1; if(k == 1) ans = pow(a,b,p); if(k == 2) ans = module_formation(a,b,p); if(k == 3) ans = bsgs(a,b,p); if(ans == -1) printf(\u0026#34;Orz, I cannot find x!\\n\u0026#34;); else printf(\u0026#34;%lld\\n\u0026#34;,ans); } } int main(){ init(); solve(); return 0; }   ","description":"","id":129,"section":"posts","tags":["数论","快速幂","扩展欧几里得","BSGS算法"],"title":"「SDOI2011」计算器-快速幂+扩展欧几里得+BSGS算法","uri":"https://blog.chenqiqian.com/posts/sdoi2011-calculator/"},{"content":"小 $W$ 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。最近小W准备读一本新书，这本书一共有 $P$ 页，页码范围为 $0 \u0026hellip; P-1$。\n小 $W$ 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 $\\text{NOI2012}$ 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。\n我们用 $X_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 $W$ 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,X_1$ ，满足 $0 \\leq a,b,X_1 \\leq p-1$ ，且 $a,b,X_1$ 都是整数。按照下面的公式生成出来一系列的整数：$X _ {i+1} =(aX_i+b)\\bmod p$ 其中 $\\bmod$ 表示取余操作。\n但是这种方法可能导致某两天读的页码一样。\n小 $W$ 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。\n链接 Luogu P3306\n题解 先忽略模数，求 $X_n$ 的通项公式。\n刚学的高中数学必修五，我们可以知道，这个函数可以变形成类等比数列。\n因为 $a,b$ 都是常数，所以我们可以设：\n$$\nX _ {i+1} + \\lambda= a(X_i + \\lambda)\\\nX _ {i+1} = aX_i + \\lambda(a-1)\\\n$$\n所以：\n$$\n\\lambda(a-1) = b\\\n\\lambda = \\frac{b}{a-1}\n$$\n设 $Y_i = X_i+\\lambda$ ，则有：\n$$\nY _ {i+1} = a Y_i\n$$\n又 $Y_1 = X_1 + \\lambda$，所以得到 $Y_i$ 的通项公式：\n$$\nY_i = (X_1+\\lambda) \\times a^{i-1}\n$$\n则：\n$$\nX_i = Y_i - \\lambda = (X_1+\\lambda) \\times a^{i-1} - \\lambda\n$$\n那么问题就转换成求：\n$$\n(X_1+\\lambda) \\times a^{i-1} - \\lambda \\equiv t \\pmod p\n$$\n的最小正整数解 $i$。\n如果我们用 $x$ 代表 $i-1$，那么就变成求：\n$$\na^{x} \\equiv (t + \\lambda) \\times (X_1+\\lambda)^{-1} \\pmod p\n$$\n然后这里的 $\\lambda = b \\times a^{-1}$ 。\n如果令 $A = a, B = (t + \\lambda) \\times (X_1+\\lambda)^{-1}$ ，那么这个式子就变成了 $\\text{BSGS}$ 的标准式：\n$$\nA^x \\equiv B \\pmod p\n$$\n套用 $\\text{BSGS}$ 算法解出 $x$，$x+1$ 即是答案。\n注意处理无解和特殊情况。\n当 $a = 1$ 时，这个东西不再能化成类等比数列，就是一个类等差数列，用逆元求解即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;map\u0026gt;#define ll long long using namespace std; ll pow(ll x,ll k,ll p){ x %= p; ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x=x*x%p) if(i\u0026amp;1) ans = ans*x%p; return ans; } ll inv(ll x,ll p){ return pow(x%p,p-2,p); } ll gcd(ll a,ll b){ return b == 0?a:gcd(b,a%b); } ll bsgs(ll a,ll b,ll p){ //printf(\u0026#34;bsgs a:%lld b:%lld p:%lld\\n\u0026#34;,a,b,p);  a %= p,b %= p; ll t = 1,cnt = 0; if(b == 1) return 0; for(ll g = gcd(a,p);g != 1;g = gcd(a,p)){ if(b % g) return -2; a /= g,p /= g,t = t * a/g % p; ++cnt; if(b == t) return cnt; } map\u0026lt;ll,ll\u0026gt; S; ll m = (ll)(sqrt(p)) + 1; ll base = b; for(int i = 0;i\u0026lt;m;i++){ S[base] = i; base = base * a % p; } base = pow(a,m,p); ll now = t; for(int i = 1;i\u0026lt;=m+1;i++){ now = now * base % p; if(S.count(now)) return i * m - S[now] + cnt; } return -2; } ll cal(ll p,ll a,ll b,ll x_1,ll t){ if(x_1 == t) return 1; if(a == 0){ if(x_1==t) return 1; else if(b==t) return 2; else return -1; } if(a == 1){ //X_i = X_1 + (n-1) * b  if(b == 0){ if(x_1 == t) return 1; else return -1; } else{ return (((t-x_1+p)%p) * inv(b,p) % p)%p + 1; } } else{ ll lam = b * inv(a-1,p); ll A = a, B = ((t + lam)%p) * inv(x_1+lam,p) % p; return bsgs(A,B,p)+1; } } void solve(){ ll p,a,b,x_1,t; scanf(\u0026#34;%lld %lld %lld %lld %lld\u0026#34;,\u0026amp;p,\u0026amp;a,\u0026amp;b,\u0026amp;x_1,\u0026amp;t); printf(\u0026#34;%lld\\n\u0026#34;,cal(p,a,b,x_1,t)); } int main(){ int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ solve(); } return 0; }   ","description":"","id":130,"section":"posts","tags":["数论","BSGS算法"],"title":"「SDOI2013」随机数生成器-BSGS算法","uri":"https://blog.chenqiqian.com/posts/sdoi2013-random/"},{"content":"作为体育委员， $C$ 君负责这次运动会仪仗队的训练。仪仗队是由学生组成的 $N \\times N$ 的方阵，为了保证队伍在行进中整齐划一， $C$ 君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。\n现在， $C$ 君希望你告诉他队伍整齐时能看到的学生人数。\n链接 Luogu P2158\n题解 学了一年 $\\text{OI}$ 才会做这道题，退役退役QAQ\n我们观察右下三角形的情况，答案只要再做一些简单的加减乘除就可以了。\n$(x,y)$ 从 $(0,0)$ 能被看见的条件，就是在这两个点之间没有其他整点。可以发现，如果有不少于一个整点，那么必然这个区间会被整点若干等分（这若干个整点之间斜率相同），所以也就是满足 $\\gcd(x,y) \u0026gt; 1$ ，所以我们只需要求：\n$$\n\\sum _ {i = 1}^{n-1} \\sum _ {j=1}^{n-1} [\\gcd(i,j) = 1]\n$$\n两个循环相同，直接用欧拉函数求解就好。\n时间复杂度：$O(n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 100000; bool flag[MAXN]; int prime[MAXN],cnt; int phi[MAXN]; void sieve(int n){ phi[1] = 1;flag[1] = 1; for(int i = 2;i\u0026lt;=n;i++){ if(flag[i] == 0){ prime[++cnt] = i,phi[i] = i-1; } for(int j = 1;j\u0026lt;=cnt \u0026amp;\u0026amp; i * prime[j] \u0026lt;= n;j++){ flag[i*prime[j]] = 1; if(i % prime[j]){ phi[i * prime[j]] = phi[i] * (prime[j]-1); } else{ phi[i * prime[j]] = phi[i] * prime[j]; break; } } } } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); sieve(n); long long ans = 0; for(int i = 2;i\u0026lt;=n-1;i++){ ans += phi[i]; } printf(\u0026#34;%lld\\n\u0026#34;,n==1?0:ans*2+3); return 0; }   ","description":"","id":131,"section":"posts","tags":["数学","数论","欧拉函数"],"title":"「SDOI2008」仪仗队-欧拉函数","uri":"https://blog.chenqiqian.com/posts/sdoi2008-guard/"},{"content":"一段文章 $T$ 是由若干小写字母构成。一个单词 $W$ 也是由若干小写字母构成。一个字典 $D$ 是若干个单词的集合。我们称一段文章 $T$ 在某个字典 $D$ 下是可以被理解的，是指如果文章 $T$ 可以被分成若干部分，且每一个部分都是字典 $D$ 中的单词。\n给定一个字典 $D$ ，你的程序需要判断若干段文章在字典 $D$ 下是否能够被理解。并给出其在字典 $D$ 下能够被理解的最长前缀的位置。\n链接 Luogu P2292\n题解 可以想到一个简单的 $\\text{dp}$ ，用 $dp[i]$ 表示以 $i$ 为结尾的后缀能否被理解：\n$$\ndp[i] = \\max(dp[i-\\text{len} _ j]) ,\\text{if} ; \\text{str} _ j \\text{在 i 位置上出现}\n$$\n然后用模版串 $\\text{AC}$ 自动机跑一遍母串，得到每个模版串在母串中出现的位置，然后刷表 $dp$ 即可。\n注意往回不能暴力跳 $fail$ ，一个简单的优化是记录最近的 $\\text{end}$ 节点 $g_i$ ，然后每次都按照 $g_i$ 跳，统计出现位置即可。\n时间复杂度 $O(n \\times \\text{玄学})$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int MAXN = 1000,sigma_size = 26; vector\u0026lt;int\u0026gt; pos[MAXN]; namespace AC{ int c[MAXN][sigma_size],fail[MAXN],g[MAXN]; int end[MAXN]; int root,cnt,wcnt; void insert(char *s){ int n = strlen(s),nown = root; for(int i = 0;i\u0026lt;n;i++){ if(c[nown][s[i]-\u0026#39;a\u0026#39;] == 0){ c[nown][s[i]-\u0026#39;a\u0026#39;] = ++cnt; } nown = c[nown][s[i]-\u0026#39;a\u0026#39;]; } end[nown] = ++wcnt; } void build(){ queue\u0026lt;int\u0026gt; q; for(int i = 0;i\u0026lt;sigma_size;i++){ if(c[root][i]){ fail[c[root][i]] = root; q.push(c[root][i]); } } while(!q.empty()){ int nown = q.front();q.pop(); for(int i = 0;i\u0026lt;sigma_size;i++){ g[nown] = end[fail[nown]]?fail[nown]:g[fail[nown]]; if(c[nown][i] == 0){ c[nown][i] = c[fail[nown]][i]; } else{ fail[c[nown][i]] = c[fail[nown]][i]; q.push(c[nown][i]); } } } } void query(char *s){ for(int i = 1;i\u0026lt;=20;i++){ pos[i].clear(); } int n = strlen(s),nown = root; for(int i = 0;i\u0026lt;n;i++){ nown = c[nown][s[i] - \u0026#39;a\u0026#39;]; for(int t = nown;t;t = g[t]){ if(end[t]){ pos[end[t]].push_back(i); } } } } } int n,m; int now[MAXN],l[MAXN]; char s[1100000]; bool dp[1100000]; int cal(char *s){ memset(now,0,sizeof(now)); memset(dp,0,sizeof(dp));//dp -\u0026gt; len  int len = strlen(s),ans = 0; AC::query(s); dp[0] = 1; for(int i = 1;i\u0026lt;=len;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(now[j] != pos[j].size() \u0026amp;\u0026amp; pos[j][now[j]] == (i-1)){ dp[i] |= dp[i-l[j]]; now[j] ++; } if(dp[i] == 1){ ans = max(ans,i); continue; } } } return ans; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s); l[i] = strlen(s); AC::insert(s); } AC::build(); } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%s\u0026#34;,s); printf(\u0026#34;%d\\n\u0026#34;,cal(s)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":132,"section":"posts","tags":["字符串","AC自动机"],"title":"「HNOI2004」L语言-AC自动机","uri":"https://blog.chenqiqian.com/posts/hnoi2004-language/"},{"content":"给定一个长度为 $N$ 的数列，每次一个操作或询问：\n 把闭区间 $[L, R]$ 内的数全部加上一个整数 $W$ 问闭区间 $[L, R]$ 内有多少英雄身高大于等于 $C$  链接 Luogu P2801\n题解 分块，每块维护一个 $\\text{add}$ 标记，保证块内有序。\n整块的修改直接打标记，零散数先减去标记后逐个修改，块内重排。\n整块查询减去标记后二分，零散数暴力判断。\n注意边界。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 1100000,MAXQ = 50000; void read(int \u0026amp;x){scanf(\u0026#34;%d\u0026#34;,\u0026amp;x);} void read(char *x){scanf(\u0026#34;%s\u0026#34;,x);} int n,m,a[MAXN],Q; int add[MAXN]; int num[MAXN]; bool cmp(int a,int b){return a \u0026gt; b;} void cpy(int q){memcpy(num+q*Q,a+q*Q,sizeof(int)*Q);} void sort(int q){sort(num+q*Q,num+min(n,(q+1)*Q),cmp);} int query(int q,int c){ int t = upper_bound(num+q*Q,num+min(n,(q+1)*Q),c,cmp) - (num+q*Q); // printf(\u0026#34;q:%d c:%d t:%d\\n\u0026#34;,q,c,t);  return t; } void init(){ read(n),read(m);Q = sqrt(n)+1; for(int i = 0;i\u0026lt;n;i++){ read(a[i]); if(i/Q != (i+1)/Q || i == n-1) cpy(i/Q),sort(i/Q); } } void modify(int l,int r,int w){ int lq = l/Q,rq = r/Q; if(lq == rq || lq + 1 == rq){ for(int i = l;i\u0026lt;=r;i++) a[i] += w; cpy(lq),sort(lq); cpy(rq),sort(rq); } else{ for(int i = lq+1;i\u0026lt;=rq-1;i++) add[i] += w; for(int i = l;i\u0026lt;(lq+1)*Q;i++) a[i] += w; for(int i = rq*Q;i\u0026lt;=r;i++) a[i] += w; cpy(lq),sort(lq); cpy(rq),sort(rq); } } int query(int l,int r,int c){ int lq = l/Q,rq = r/Q,ans = 0; if(lq == rq || lq + 1 == rq){ for(int i = l;i\u0026lt;=r;i++) if(a[i] + add[i/Q] \u0026gt;= c) ans ++; return ans; } else{ for(int i = lq+1;i\u0026lt;=rq-1;i++) ans += query(i,c-add[i]); for(int i = l;i\u0026lt;(lq+1)*Q;i++) if(a[i] + add[i/Q] \u0026gt;= c) ans ++; for(int i = rq*Q;i\u0026lt;=r;i++) if(a[i] + add[i/Q] \u0026gt;= c) ans ++; return ans; } } void solve(){ char op[10]; int l,r,c; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(l),read(r),read(c); if(op[0] == \u0026#39;M\u0026#39;) modify(l-1,r-1,c); if(op[0] == \u0026#39;A\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,query(l-1,r-1,c)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":133,"section":"posts","tags":["分块","数据结构"],"title":"「Luogu 2801」教主的魔法-分块","uri":"https://blog.chenqiqian.com/posts/luogu-2801/"},{"content":"在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而他经常研究关于序列的一些奇奇怪怪的问题，现在他在研究一个难题，需要你来帮助他。这个难题是这样子的：给出一个 $1$ 到 $n$ 的全排列，现在对这个全排列序列进行 $m$ 次局部排序，排序分为两种：\n $(0,l,r)$表示将区间 $[l,r]$ 的数字升序排序 $(1,l,r)$表示将区间 $[l,r]$ 的数字降序排序\n最后询问第 $q$ 位置上的数字。  链接 Luogu P2824\n题解 好题啊。\n因为这个问题只有一个询问，所以我们考虑二分答案。\n假设当前的考虑要判定的答案是 $mid$ 与 $p$ 位置上数的大小关系，通过 $O(\\log n)$ 次二分，就可以求出最后这个位置上的数字。\n所以问题转化为：求出 $p$ 位置上的数与 $k$ 的大小关系。我们关注到，如果我们只关心其位置上的数相对于某一个数的大小关系，那我们就可以将小于等于 $k$ 的数设置成 $0$ ，大于 $k$ 的数设置成 $1$，那么排序就比较容易了，只需要一个 $0/1$ 线段树，维护区间和，支持区间覆盖即可。每次我们查询到 $sum(l,r)$，然后根据这个 $sum$ 的值和排序的种类对区间进行覆盖，升序即为 $0\u0026hellip;01\u0026hellip;1$，降序则为 $1\u0026hellip;10\u0026hellip;0$。\n最后查询 $q$ 这个位置上的值，如果是 $0$ ，就说明这个位置上的数小于等于 $k$ ，否则就是大于 $k$ 。\n二分答案即可。\n时间复杂度： $O(n \\log^2 n)$\n这题也有用可合并、分裂的线段树的做法，可以处理多组询问。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 31000; namespace SegTree{ #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  int sumn[MAXN\u0026lt;\u0026lt;2],lazy[MAXN\u0026lt;\u0026lt;2];// -1 -\u0026gt; no label  void add_label(int nown,int l,int r,int op){ lazy[nown] = op,sumn[nown] = (r-l+1)*op; } void push_down(int nown,int l,int r){ if(lazy[nown] != -1){ add_label(lson,l,mid,lazy[nown]); add_label(rson,mid+1,r,lazy[nown]); lazy[nown] = -1; } } void push_up(int nown){ sumn[nown] = sumn[lson] + sumn[rson]; } void build(int nown,int l,int r,int k,int *a){ lazy[nown] = -1; if(l == r){ sumn[nown] = k \u0026lt; a[l];// 满足条件（\u0026lt;=）的 sumn 为 0  } else{ build(lson,l,mid,k,a),build(rson,mid+1,r,k,a); push_up(nown); } } int query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ return sumn[nown]; } else{ push_down(nown,l,r); int ans = 0; if(ql \u0026lt;= mid) ans += query(lson,l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans += query(rson,mid+1,r,ql,qr); return ans; } } void update(int nown,int l,int r,int ql,int qr,int op){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ add_label(nown,l,r,op); } else{ push_down(nown,l,r); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,op); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,op); push_up(nown); } } void print(int nown,int l,int r){ printf(\u0026#34;nown:%d l,r:%d %d sumn:%d lazy:%d\\n\u0026#34;,nown,l,r,sumn[nown],lazy[nown]); if(l == r) return; print(lson,l,mid); print(rson,mid+1,r); } void sort(int n,int l,int r,int op){// op 为 0 正序 ， op 为 1 逆序  int b = query(1,1,n,l,r),a = (r-l+1) - b; //printf(\u0026#34;a:%d b:%d\\n\u0026#34;,a,b);  if(op == 0){ if(a) update(1,1,n,l,l+a-1,0); if(b) update(1,1,n,r-b+1,r,1); } else{ if(b) update(1,1,n,l,l+b-1,1); if(a) update(1,1,n,r-a+1,r,0); } } #undef lson  #undef rson  #undef mid } int n,m,q; int a[MAXN]; int o[MAXN],l[MAXN],r[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i = 1;i\u0026lt;=m;i++) scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;o[i],\u0026amp;l[i],\u0026amp;r[i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); } bool check(int k){//检查 q 位置上的数是不是小于等于 k  SegTree::build(1,1,n,k,a); for(int i = 1;i\u0026lt;=m;i++) SegTree::sort(n,l[i],r[i],o[i]); return SegTree::query(1,1,n,q,q) == 0; } void solve(){ int b = 1,e = n; while(b!=e){ int mid = (b+e)\u0026gt;\u0026gt;1; //printf(\u0026#34;%d %d:%d\\n\u0026#34;,b,e,mid);  if(check(mid)) e = mid; else b = mid+1; } printf(\u0026#34;%d\\n\u0026#34;,b); } int main(){ init(); solve(); return 0; }   ","description":"","id":134,"section":"posts","tags":["线段树","排序","二分答案"],"title":"「HEOI2016/TJOI2016」排序-线段树","uri":"https://blog.chenqiqian.com/posts/heoi2016-tjoi2016-sort/"},{"content":"小 $Y$ 最近在一家金券交易所工作。该金券交易所只发行交易两种金券：$A$ 纪念券（以下简称 $A$ 券）和 $B$ 纪念券（以下简称 $B$ 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 $A$ 券 和 $B$ 券的价值分别为 $A_K$ 和 $B_K$（元/单位金券）。为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。比例交易法分为两个方面：\n（a）卖出金券：顾客提供一个 $[0,100]$ 内的实数 $OP$ 作为卖出比例，其意义为：将 $OP%$ 的 $A$ 券和 $OP%$ 的 $B$ 券以当时的价值兑换为人民币；\n（b）买入金券：顾客支付 $IP$ 元人民币，交易所将会兑换给用户总价值为 $IP$ 的金券，并且，满足提供给顾客的 $A$ 券和 $B$ 券的比例在第 $K$ 天恰好为 $Rate_K$ ；\n注意到，同一天内可以进行多次操作。小 $Y$ 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $N$ 天内的 $A$ 券和 $B$ 券的价值以及 $Rate$ 。他还希望能够计算出来，如果开始时拥有 $S$ 元钱，那么 $N$ 天后最多能够获得多少元钱。\n例如，假定接下来 $3$ 天内的 $A_k$、$B_k$、$Rate_K$ 的变化分别为：\n假定在第一天时，用户手中有 $100$ 元 人民币但是没有任何金券。用户可以执行以下的操作：\n提示：\n 输入文件可能很大，请采用快速的读入方式。 必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币；每次卖出操作卖出所有的金券。  链接 LOJ 2353\nBZOJ 1492\nLuogu P4027\n题解 最优策略肯定是只有两种状态：全仓/空仓，然后每天我们只有若干种选择：全买，全卖，全买+全卖，啥都不做。\n注意到我们可以 $dp$ \u0026hellip;\n先写暴力转移\u0026hellip;注意到我们事实上只需要记录我们有多少钱，在哪天买入的话就会有多少的比例。\n所以我们令 $dp[i]$ 为在第 $i$ 天拥有的最多钱，假设我们上次全部卖出+全部买入在第 $j$ 天，状态转移：\n$$\ndp[i] = \\max\\left(\\max _ {j=1}^{i-1}(dp[j]\\times \\frac{r[j]*a[i] + b[i]}{r[j]*a[j]+b[j]}),dp[i-1]\\right)\n$$\n很好理解嘛\u0026hellip;就是一个决策在哪天全买/全卖的问题。\n暴力转移可以拿到 $60$ 分…上古时代的暴力分还是很好拿的。\n正解的话，需要我们深入挖掘这个式子。\n我们先忽略最后一个不买不卖的情况，来继续看：\n$$\ndp[i] = \\max _ {j=1}^{i-1}(dp[j]\\times \\frac{r[j]\\cdot a[i] + b[i]}{r[j] \\cdot a[j]+b[j]})\n$$\n对于给定的决策点 $j$ ，则有：\n$$\ndp[i] = dp[j] \\times \\frac{r[j]\\cdot a[i] + b[i]}{r[j]\\cdot a[j]+b[j]}\\\ndp[i] = (r[j]\\cdot a[i] + b[i])\\times \\frac{dp[j]}{r[j]\\cdot a[j]+b[j]}\\\ndp[i] = b[i]\\times \\frac{dp[j]}{r[j]\\cdot a[j]+b[j]} + a[i] \\times \\frac{r[j]\\cdot dp[j]}{r[j]\\cdot a[j]+b[j]}\n$$\n如果我们令：\n$$\nx[j] = \\frac{r[j]\\cdot dp[j]}{r[j]*a[j]+b[j]}, y[j] = \\frac{dp[j]}{r[j]\\cdot a[j]+b[j]}\n$$\n那么式子就会变成：\n$$\ndp[i] = a[i] \\times x[j] + b[i] \\times y[j]\n$$\n略微变换：\n$$\ny[j] = - \\frac{a[i]}{b[i]} \\cdot x[j] + \\frac{dp[i]}{b[i]}\n$$\n我们注意到，这里面的斜率仅与 $i$ 相关，$x,y$ 均只与 $j$ 相关，最后的截距下面除的是一个常数，那么只要截距最大， $dp[i]$ 就会最大。\n而且，只要 $x[j]$ 和 $y[j]$ 一经确定，便不改变。\n所以现在问题变成：支持插入点，查询某个给定斜率的直线且经过某个点，使得这条直线的截距最大。\n在以往的斜率优化问题里面，我们一般有两个单调性：插入的点的 $x$ 坐标单调，直线的斜率单调。那么我们用单调队列就可以维护凸包，然而这里我们这两个性质全都没有，所以我们只能用更高级的东西，比如 $\\text{CDQ}$ 分治，比如 $\\text{Splay}$ 。\n我用了 $\\text{Splay}$ 来维护这个上凸包。\n具体实现的话，就是需要处理两个问题：找到第一个斜率较给定值大的点，和插入一个点。\n  在 $\\text{Splay}$ 上二分即可。最好是每个点代表这个点到前一个点的斜率。\n  先判断在不在凸包里，再根据x坐标插入，然后在向两边pop，维护凸包性质。注意pop的条件比较容易写错。\n  不知道为啥，BZOJ 上过不了。本地下下来数据、传到 luogu 上都可以过。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;ctime\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstring\u0026gt;#define eps 1e-10 #define inf 1e10 using namespace std; const int MAXN = 1100000; int n,s; double a[MAXN],b[MAXN],r[MAXN]; double dp[MAXN]; int last[MAXN]; double calx(int j){if(j == 0) return inf;return dp[j]*r[j] / (r[j]*a[j] + b[j]);} double caly(int j){return dp[j] / (r[j]*a[j]+b[j]);} double calc(int i,int j){return calx(j) * a[i] + caly(j) * b[i]; } double cals(int i,int j){ if(j == 0) return -inf; if(i == 0) return inf; double _x = calx(i)-calx(j); double _y = caly(i)-caly(j); //if(fabs(_x) \u0026lt; eps) return _y\u0026gt;0?inf:-inf;  return _y/_x; } namespace Splay{ int p[MAXN\u0026lt;\u0026lt;2];double v[MAXN\u0026lt;\u0026lt;2]; int f[MAXN\u0026lt;\u0026lt;2],c[MAXN\u0026lt;\u0026lt;2][2],cnt; int root;//v 向左连  int newnode(int point,double val = 0){ int x = ++cnt; v[x] = val,p[x] = point; c[x][0] = c[x][1] = 0; return x; } void rotate(int x){ if(!x) return; int y = f[x],z = f[y],t = c[y][1] == x,w = c[x][1-t]; if(z) c[z][c[z][1]==y] = x; c[y][t] = w,c[x][1-t] = y; if(w) f[w] = y; f[x] = z;f[y] = x; if(!f[x]) root = x; } void splay(int x,int tar = 0){ while(f[x]!=tar){ int y = f[x],z = f[y]; if(f[y] != tar){ (c[y][1]==x)^(c[z][1]==y)?rotate(x):rotate(y); }rotate(x); } } int find(int x,double _v){ if(!x) return 0; if(_v \u0026gt; v[x]) return find(c[x][0],_v); else{ int j = find(c[x][1],_v); return j!=0?j:x; } } int nxt(int x,int tmp){ if(!x) return 0; splay(x); int r = c[x][tmp]; if(!r) return 0; while(1){ if(c[r][1-tmp]) r = c[r][1-tmp]; else return r; } } int insert(int x,int fa,int point){ if(!x){ int w = newnode(point); if(fa == 0) root = w; c[fa][calx(point) \u0026gt; calx(p[fa])] = w,f[w] = fa; int _x = nxt(w,0),_y = nxt(w,1); v[w] = cals(p[_x],p[w]); if(_y) v[_y] = cals(p[w],p[_y]); return w; } int tmp = calx(point) \u0026gt; calx(p[x]); return insert(c[x][tmp],x,point); } void erase(int x){ int _x = nxt(x,0),_y = nxt(x,1); if(!_x \u0026amp;\u0026amp; !_y) root = 0; else if(!_x || !_y){ int t = _x == 0?_y:_x,tmp = _x==0?0:1; splay(t),c[t][tmp] = 0; } else{ splay(_x),splay(_y,_x); c[_y][0] = 0; } if(_y) v[_y] = cals(p[_x],p[_y]); } void update(int i){ int w = insert(root,0,i); int x,y; x = nxt(w,0),y = nxt(w,1); if(y \u0026amp;\u0026amp; cals(p[x],p[y]) \u0026lt; v[y]){ erase(w);return; } x = nxt(w,1),y = nxt(x,1); while(y!=0){ if(cals(i,p[x]) \u0026gt; cals(i,p[y])) break; erase(x); x = y; y = nxt(x,1); } x = nxt(w,0),y = nxt(x,0); while(y!=0){ if(cals(p[y],i) \u0026gt; cals(p[x],i)) break; erase(x); x = y; y = nxt(x,0); } } int query(int i){ return find(root,-a[i]/b[i]); } }; int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;s); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%lf %lf %lf\u0026#34;,\u0026amp;a[i],\u0026amp;b[i],\u0026amp;r[i]); dp[1] = s; Splay::update(1); for(int i = 2;i\u0026lt;=n;i++){ dp[i] = dp[i-1],last[i] = i; int j = Splay::query(i); if(calc(i,j) \u0026gt; dp[i]) last[i] = j,dp[i] = calc(i,j); Splay::update(i); } printf(\u0026#34;%.6lf\\n\u0026#34;,dp[n]); return 0; }   ","description":"","id":135,"section":"posts","tags":["Splay","平衡树","斜率优化","动态规划"],"title":"「NOI2007」货币兑换-Splay+斜率优化","uri":"https://blog.chenqiqian.com/posts/noi2007-cash/"},{"content":"为了庆祝 $NOI$ 的成功开幕，主办方为大家准备了一场寿司晚宴。小 $G$ 和小 $W$ 作为参加 $NOI$ 的选手，也被邀请参加了寿司晚宴。\n在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,⋯,n-1$ ，其中第种寿司的美味度为 $i+1$（即寿司的美味度为从 $2$ 到 $n$ ）。\n现在小 $G$ 和小 $W$ 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 $G$ 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 $W$ 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。\n现在小 $G$ 和小 $W$ 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。\n链接 Luogu P2150\n题解 难死了qaq\n对于没有什么特殊背景的计数题，很大可能上都是 $dp$ ，所以我们来如何 $dp$ 。\n这里面最难满足的条件是：\n 小 $G$ 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 $W$ 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。\n 两个数不互质的情况即为：两个数分解质因数之后有相同的质因子，而且与该质因子出现 $1$ 次还是 $2$ 次无关。\n然后我们有注意到所有的 $n$ 均小于 $500$ ，这意味着最多只会有一个质因子大于 $\\sqrt {500} \\approx 22.36 \u0026lt; 23$ ，小于 $23$ 的质数一共有 $8$ 个： $2,3,5,7,11,13,17,19$ ，所以我们可以压位存储这些质因数有没有出现，对于可能出现的最后一个大质因数，我们再用一个 int 存储（没有则为 $1$ ），这样的话我们就用一个简单比较的方式存储了这个数所有对选取造成影响的内容。\n然后我们思考如何表示状态。\n显然，我们不可能将大质数表示进状态里面，否则的话是非常难以转移而且空间大约是开不下的。\n所以我们思考一下如何避免大质数的影响。\n如果某些数字都具有一个大质因子，那么这些数字必然是不能同时选的，那么只有两种可能性：\n 只有小 $\\text{G}$ 选了具有这个大质因子的数中的某些数 只有小 $\\text{W}$ 选了具有这个大质因子的数中的某些数 两个人都没选这两个组中的任何一个数  那么我们考虑这样分类。\n那么我们分别对每一个大质因数进行讨论（没有大质因数的时候，就是每一个数就相当于大质因数的改变，因为一个数不能被两个人同时选）：\n设 $g[k][0/1][S_i][S_j]$ 为当前已经考虑完该组的前 $k-1$ 个数，由小 $\\text{G}$ 或者小 $\\text{W}$ 取具有这个大质数的数，目前的小 $\\text{G}$ 的小质数集合是 $S_i$ ，小 $\\text{W}$ 的小质数集合是 $S_j$ ，第 $k$ 个数的小质数集合为 $N_k$，那么我们有如下的转移：\n$$\ng ([k+1])[0][S_i \\cap N_k][S_j] = g([k])[0][S_i \\cap N_k][S_j] + g([k])[0][S_i][S_j]\\\ng ([k+1])[1][S_i][S_j \\cap N_k] = g([k])[1][S_i][S_j \\cap N_k] + g([k])[1][S_i][S_j]\n$$\n也就是对于两种情况都有两种决策：取或者不取这个数。\n这里需要用滚动数组，所以第一维都打上了括号，这里需要逆序转移。\n为了从分组计算转换到最后的答案，我们需要再设计一组状态，就是表达在这若干组之间的一个关系。\n比如我们设 $f[k][S_i][S_j]$ 表示考虑完前 $k-1$ 组，由小 $\\text{G}$ 或者小 $\\text{W}$ 取具有这个大质数的数，目前的小 $\\text{G}$ 的小质数集合是 $S_i$ ，小 $\\text{W}$ 的小质数集合是 $S_j$ ，第 $k$ 组的数的数目是 $num _ {k}$ 那么我们有如下的转移：\n$$\nf([k])[S_i][S_j] = g([num_k])[0][S_i][S_j] + g([num_k])[1][S_i][S_j] - f([k-1])[S_i][S_j]\n$$\n而且这个时候**$g([0])[0/1][S_i][S-j] = f([k-1])[S_i][S_j]$** ，这个意思就是：让小 $\\text{G}$ 选这一组，或者让小 $\\text{W}$ 选这一组。但是它们都有可能很谦虚一个都不选，那么我们最后要剪掉一个两个都不选的数目。\n$f$ 数组也可以用滚动数组优化。\n最后空间复杂度是 $O(n \\times 2^{16})$ ，空间复杂度 $O(2\\times 2^{16})$ 。\n代码 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; #define pii pair\u0026lt;int,int\u0026gt; #define ll long long const int MAXN = 256; int prime[8] = {2,3,5,7,11,13,17,19}; ll n,p; ll f[MAXN][MAXN],g[2][MAXN][MAXN]; pii s[MAXN*2]; void init(){ scanf(\u0026quot;%lld %lld\u0026quot;,\u0026amp;n,\u0026amp;p); for(int i = 2;i\u0026lt;=n;i++){ int t = i; for(int j = 0;j\u0026lt;8;j++){ while(t % prime[j] == 0){ s[i].second |= (1\u0026lt;\u0026lt;j); t/=prime[j]; } } s[i].first = t; } sort(s+2,s+n+1); //\tfor(int i = 2;i\u0026lt;=n;i++){ //\tprintf(\u0026quot;%d:%d %d\\n\u0026quot;,i,s[i].first,s[i].second); //\t} } void calc(){ f[0][0] = 1; for(int i = 2;i\u0026lt;=n;i++){ if(i==2||s[i].first==1||s[i].first != s[i-1].first){ memcpy(g[0],f,sizeof(f)),memcpy(g[1],f,sizeof(f)); } for(int j = MAXN-1;~j;--j){ for(int k = MAXN-1;~k;--k){ if((k \u0026amp; s[i].second) == 0) (g[0][j|s[i].second][k] += g[0][j][k])%=p; if((j \u0026amp; s[i].second) == 0) (g[1][j][k|s[i].second] += g[1][j][k])%=p; } } if(i==n || s[i].first==1||s[i].first != s[i+1].first){ for(int j = 0;j\u0026lt;MAXN;j++){ for(int k = 0;k\u0026lt;MAXN;k++){ if((j\u0026amp;k)==0) f[j][k] = (g[0][j][k] + g[1][j][k] - f[j][k])%p; } } } } } void output(){ ll ans = 0; for(int i = 0;i\u0026lt;MAXN;i++){ for(int j = 0;j\u0026lt;MAXN;j++){ if((i\u0026amp;j)==0) (ans += f[i][j])%=p; } } printf(\u0026quot;%lld\\n\u0026quot;,(ans%p+p)%p); } int main(){ init(); calc(); output(); return 0; } ","description":"","id":136,"section":"posts","tags":["动态规划","状压dp"],"title":"「NOI2015」寿司晚宴-状压dp","uri":"https://blog.chenqiqian.com/posts/noi2015-dinner/"},{"content":"以下有几道莫比乌斯反演入门题的详尽版的题解（公式推演）。\n[POI2007]ZAP-Queries 题意 求：\n$$\n\\sum _ {i=1}^n \\sum _ {j=1}^m [\\gcd(i,j)=d]\n$$\n解法1 倒一倒式子：\n$$\n\\text{ans} = \\sum _ {i=1}^n \\sum _ {j=1}^m [\\gcd(i,j)=d]\\\n=\\sum _ {i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i,j)=1]\\\n$$\n设\n$$\nf(d) = \\sum _ {i=1}^{x}\\sum _ {j=1}^{y} [\\gcd(i,j)=d]\\\n$$\n若：\n$$\ng(d) = \\sum _ {d|k} f(k)\n$$\n则可以发现 $g(d) = \\lfloor \\frac{x}{d} \\rfloor \\cdot \\lfloor \\frac{y}{d} \\rfloor$\n反演得：\n$$\nf(d) = \\sum _ {d|k} \\mu(\\frac{k}{d}) g(k)\n$$\n那么：\n$$\nf(1) = \\sum _ {k=1}^{\\min(x,y)} \\mu(k) g(k)\n$$\n所以：\n$$\n\\text{ans} = f(1) = \\sum _ {k=1}^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} \\mu(k) g(k)\\\n= \\sum _ {k=1}^{\\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor)} \\mu(k) \\cdot \\lfloor \\frac{x}{d} \\rfloor \\lfloor \\frac{y}{d} \\rfloor\\\n$$\n可以利用整除分块，单次查询时间时间复杂度 $O(\\sqrt n)$。所以时间复杂度是 $O(n + T\\sqrt n)$ 。\n[HAOI2011]Problem b 题意 求：\n$$\n\\sum _ {x=a}^b \\sum _ {y=c}^d [gcd(x,y)=d]\n$$\n解法 设：\n$$\n\\text{ans} = F(a,b,c,d) = \\sum _ {x=a}^b \\sum _ {y=c}^d [gcd(x,y)=d],\\\nG(n,m) = \\sum _ {x=1}^n \\sum _ {y=1}^m [gcd(x,y)=d]\n$$\n利用容斥原理，可以发现这个式子可以转化成\n$$\nF(a,b,c,d) \\= G(b,d) - G(a-1,d) - G(b,c-1) + G(a-1,c-1)\n$$\n然后每一个 $G(n,m)$ 都可以按照上题的单次 $O(\\sqrt n)$ 的做法求出。所以时间复杂度是 $O(n + T\\sqrt n)$ 。\nYY的GCD 题意 求：\n$$\n\\sum _ {i=1}^{k} \\sum _ {x=1}^n \\sum _ {y=1}^m [gcd(i,j)=p_i]\\\n$$\n解法1 $$\n\\sum _ {i=1}^{k} \\sum _ {x=1}^n \\sum _ {y=1}^m [gcd(i,j)=p_i]\\\n= \\sum _ {i=1}^k \\sum _ {x=1}^{\\lfloor \\frac{n}{p_i} \\rfloor} \\sum _ {y=1} ^{\\lfloor \\frac{m}{p_i}\\rfloor}\n[gcd(i,j)=1]\n$$\n设\n$$\nf(k) = \\sum _ {i=1}^n \\sum _ {j=1}^m [gcd(i,j)=k]\n$$\n若\n$$\ng(k) = \\sum _ {k|d} f(d)\n= \\lfloor \\frac{n}{k} \\rfloor \\cdot \\lfloor \\frac{m}{k} \\rfloor\n$$\n莫比乌斯反演得\n$$\nf(k) = \\sum _ {k|d} \\mu(\\frac{d}{k}) g(d)\n= \\sum _ {i = 1}^{\\lfloor \\frac{\\min(n,m)}{k} \\rfloor}\\mu(i)g(ik)\\\n= \\sum _ {i = 1}^{\\lfloor \\frac{\\min(n,m)}{k} \\rfloor}\\mu(i) \\lfloor \\frac{n}{ik} \\rfloor \\cdot \\lfloor \\frac{m}{ik} \\rfloor\n$$\n所以\n$$\nf(1) = \\sum _ {i = 1}^{ \\min(n,m) }\\mu(i) \\cdot \\lfloor \\frac{n}{i} \\rfloor \\cdot \\lfloor \\frac{m}{i} \\rfloor\n$$\n则原式：\n$$\n\\sum _ {i=1}^k \\sum _ {x=1}^{\\lfloor \\frac{n}{p_i} \\rfloor} \\sum _ {y=1} ^{\\lfloor \\frac{m}{p_i}\\rfloor}\n[gcd(i,j)=1]\\\n= \\sum _ {i=1}^k \\sum _ {d=1}^{\\min(\\lfloor \\frac{n}{p_i} \\rfloor,\\lfloor \\frac{m}{p_i} \\rfloor )}\\mu(d) \\cdot \\lfloor \\frac{n}{d p_i} \\rfloor \\cdot \\lfloor \\frac{m}{dp_i} \\rfloor\\\n$$\n设$T_i = d p_i$，则有：\n原式\n$$\n\\sum _ {i=1}^k \\sum _ {d=1}^{\\min(\\lfloor \\frac{n}{p_i} \\rfloor,\\lfloor \\frac{m}{p_i} \\rfloor )}\\mu(d) \\cdot \\lfloor \\frac{n}{d p_i} \\rfloor \\cdot \\lfloor \\frac{m}{dp_i} \\rfloor\\\n= \\sum _ {i=1}^k \\sum _ {d=1}^{\\min(\\lfloor \\frac{n}{p_i} \\rfloor,\\lfloor \\frac{m}{p_i} \\rfloor )}\\mu(\\frac{T_i}{p_i}) \\cdot \\lfloor \\frac{n}{T_i} \\rfloor \\cdot \\lfloor \\frac{m}{T_i} \\rfloor\\\n= \\sum _ {i=1}^k \\sum _ {p_i | T}\\mu(\\frac{T}{p_i}) \\cdot \\lfloor \\frac{n}{T} \\rfloor \\cdot \\lfloor \\frac{m}{T} \\rfloor\\\n= \\sum _ {T=1}^{\\min(n,m)} \\sum _ {p_i|T} \\mu(\\frac{T}{p_i}) \\cdot \\lfloor \\frac{n}{T} \\rfloor \\cdot \\lfloor \\frac{m}{T} \\rfloor\\\n= \\sum _ {T=1}^{\\min(n,m)} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum _ {p_i|T} \\mu(\\frac{T}{p_i}) \\\n$$\n令\n$$\nh(x) = \\sum _ {p_i|x} \\mu(\\frac{x}{p_i})\n$$\n所以原式化为：\n$$\n\\sum _ {T=1}^{\\min(n,m)} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum _ {p_i|T} \\mu(\\frac{T}{p_i}) \\\n= \\sum _ {i=1}^{\\min(n,m)} \\lfloor \\frac{n}{i} \\rfloor \\lfloor \\frac{m}{i} \\rfloor h(i)\n$$\n只需要求出 $h(i)$ 的前缀和，我们就可以 $O(\\sqrt{n})$ 整除分块算出。\n观察\n$$\nh(x) = \\sum _ {p_i|x} \\mu(\\frac{x}{p_i})\n$$\n可以发现，如果我们枚举每个质数，再将所有的该质数的倍数的g[i * prime[j]] += mu[i]都加上去。\n由于枚举倍数的调和级数 $\\frac{n}{1} + \\frac{n}{2} + \\cdots + \\frac{n}{n} = O(\\ln n + r)$ ,所以这个枚举过程的复杂度是 $O(n \\ln n)$ 的。\n注意到这个 $h(x)$ 应当也是一个积性函数，所以事实上可以在线性素数筛的时候直接计算出 $h(x)$ 的值，这个过程就是 $O(n)$ 的。\n[NOI2010]能量采集 题意 给定两个整数$n,m$，对于平面上的整点 ${(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z}$ 。若 $(x,y)$ 与 $(0,0)$ 的连线上有 $k$ 个整点（不包括 $(0,0)$ , $(n,m)$），则产生的贡献为 $2k+1$ 。求所有满足条件的点的贡献总和。\n解法 一个结论：从 $(0,0)$ 到 $(n,m)$ 的线路上，有 $\\gcd(n,m)-1$ 个整点(不包括 $(0,0)$ , $(n,m)$ )。\n想一想很好明白：令 $t$ 是 $n,m$ 的公因数 $(\\frac {n}{t} , \\frac {m}{t})$ 就相当于步长， $m,n$ 一定时 $t$ 越大，步长越小，整点就越多。 $\\gcd(n,m)$ 是 $n$ ,$ m$ 的最大公因数，所以就是最多整点的个数了。\n所以问题转化为：\n求\n$$\n\\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}2\\times \\gcd(n,m)-1\n$$\n的值。\n我们进行一些微小的变换：\n$$\n\\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}2\\times \\gcd(n,m)-1\\\n= (2 \\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}\\gcd(n,m)) - n \\times m\n$$\n问题转化为求：\n$$\n\\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}\\gcd(n,m)\n$$\n$$\n\\text{ans} = \\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}\\gcd(n,m)\\\n= \\sum _ {d=1}^{\\min(n,m)} d \\times (\\sum _ {i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i,j)=1])\\\n$$\n设：\n$$\nf(d) = \\sum _ {i=1}^{x} \\sum _ {j=1}^{y} [\\gcd(i,j)=d]\n$$\n由第一题，可以发现：\n$$\nf(1) = \\sum _ {i = 1}^{ \\min(x,y) }\\mu(i) \\cdot \\lfloor \\frac{x}{i} \\rfloor \\cdot \\lfloor \\frac{y}{i} \\rfloor\n$$\n回代得：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\times (\\sum _ {i = 1}^{ \\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor) }\\mu(i) \\cdot \\lfloor \\frac{n}{id} \\rfloor \\cdot \\lfloor \\frac{m}{id} \\rfloor)\\\n$$\n设 $T = id$，可以得到：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\times (\\sum _ {i = 1}^{ \\min(\\lfloor \\frac{n}{d} \\rfloor,\\lfloor \\frac{m}{d} \\rfloor) }\\mu(i) \\cdot \\lfloor \\frac{n}{T} \\rfloor \\cdot \\lfloor \\frac{m}{T} \\rfloor)\\\n$$\n改为枚举 $T$，得到：\n$$\n\\text{ans} = \\sum _ {T=1}^{\\min(n,m)} \\lfloor \\frac{n}{T} \\rfloor \\cdot \\lfloor \\frac{m}{T} \\rfloor (\\sum _ {d|T} \\mu(\\frac{T}{d}) \\cdot d)\n$$\n如果令：\n$$\nh(T) = \\sum _ {d|T} \\mu(\\frac{T}{d}) \\cdot d\n$$\n发现 $h(T)$ 是一个积性函数，所以可以 $O(n)$ 线性筛出来， 然后就可以得到：\n$$\n\\text{ans} = \\sum _ {T=1}^{\\min(n,m)} h(T) \\cdot \\lfloor \\frac{n}{T} \\rfloor \\cdot \\lfloor \\frac{m}{T} \\rfloor\n$$\n利用整除分块可以做到 $O(\\sqrt n)$ 单次询问。\n时间复杂度： $O(n + \\sqrt n)$\n这题亦可 $O(n \\log n)$ 手动模拟容斥原理。\n[国家集训队]Crash的数字表格 题意 求：\n$$\n\\sum _ {x=1}^{n} \\sum _ {y=1}^{m} \\text{lcm}(x,y)\n$$\n数据范围： $n,m \\leq 10^7$\n解法1 $O(n)$ $$\n\\sum _ {x=1}^{n} \\sum _ {y=1}^{m} \\text{lcm}(x,y)\\\n= \\sum _ {x=1}^{n} \\sum _ {y=1}^{m} \\frac{xy}{\\gcd(x,y)}\n$$\n我们可以枚举 $\\gcd(x,y)$ 的值 $d$ ，然后就把式子化成：\n$$\n\\sum _ {x=1}^{n} \\sum _ {y=1}^{m} \\frac{xy}{\\gcd(x,y)}\\\n= \\sum _ {d=1}^{\\min(n,m)}\\sum _ {x=1}^{n} \\sum _ {y=1}^m \\frac{xy}{d} [\\gcd(x,y) = d]\\\n= \\sum _ {d=1}^{\\min(n,m)} d ; \\sum _ {i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{m}{d} \\rfloor} ij[\\gcd(i,j)=1]\\\n$$\n设：\n$$\nF(x,y) = \\sum _ {i=1}^{x} \\sum _ {j=1}^{y} ij[\\gcd(i,j)=1]\\\n$$\n则：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\cdot F(\\lfloor \\frac{n}{d}\\rfloor,\\lfloor \\frac{m}{d}\\rfloor)\n$$\n设：\n$$\nh(x,y) = \\sum _ {i=1}^x \\sum _ {j=1}^y ij\n= \\frac{x(x+1)}{2} \\cdot \\frac{y(y+1)}{2}\n$$\n$h(x,y)$ 可以 $O(1)$ 计算得到。\n我们进行莫比乌斯反演，尝试求出 $F(x,y)$ 的值：\n（以下默认上界分别为 $x,y$）\n设\n$$\nf(d) = \\sum _ {i=1}^{x} \\sum _ {j=1}^{y} ij[\\gcd(i,j)=d],g(d) = \\sum _ {d|k} f(k)\\\n$$\n我们发现， $g(d)$ 事实上可以表示为：\n$$\ng(d) = d^2 \\times \\sum _ {i=1}^{\\lfloor \\frac{x}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{y}{d} \\rfloor} ij = d^2 \\times h(\\lfloor \\frac{x}{d} \\rfloor, \\lfloor \\frac{y}{d} \\rfloor)\n$$\n经过反演：\n$$\nf(d) = \\sum _ {d|k} \\mu(\\frac{k}{d}) g(k)\\\n= \\sum _ {d|k} \\mu(\\frac{k}{d}) \\cdot k^2 \\cdot h(\\lfloor \\frac{x}{k} \\rfloor, \\lfloor \\frac{y}{k} \\rfloor)\n$$\n所以：\n$$\nf(1) = \\sum _ {k=1}^{\\min(x,y)} \\mu(k) \\cdot k^2 \\cdot h(\\lfloor \\frac{x}{k} \\rfloor, \\lfloor \\frac{y}{k} \\rfloor)\n$$\n那么，\n$$\nF(x,y) = f(1) = \\sum _ {k=1}^{\\min(x,y)} \\mu(k) \\cdot k^2 \\cdot h(\\lfloor \\frac{x}{k} \\rfloor, \\lfloor \\frac{y}{k} \\rfloor)\n$$\n这个东西可以整除分块，所以我们每计算一个 $F(x,y)$ 的复杂度是 $O(\\sqrt{n})$，根据：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\cdot F(\\lfloor \\frac{n}{d}\\rfloor,\\lfloor \\frac{m}{d}\\rfloor)\n$$\n我们发现，这里对于所有的 $d$ 来说， $\\lfloor \\frac{n}{d}\\rfloor$ 与 $\\lfloor \\frac{m}{d}\\rfloor$ 也最多分别有 $\\sqrt{n}$ 个取值，所以我们最多只需要计算 $O(\\sqrt{n})$ 次 $F(x,y)$ ，所以最后的时间复杂度是 $O(n)$。\n解法2 $O(n + T\\sqrt {n})$ 我们有\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\cdot F(\\lfloor \\frac{n}{d}\\rfloor,\\lfloor \\frac{m}{d}\\rfloor)\n$$\n又：\n$$\nF(x,y) = \\sum _ {k=1}^{\\min(x,y)} \\mu(k) \\cdot k^2 \\cdot h(\\lfloor \\frac{x}{k} \\rfloor, \\lfloor \\frac{y}{k} \\rfloor)\\\n$$\n代入得：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\cdot \\sum _ {k=1}^{\\min(\\lfloor \\frac{n}{d}\\rfloor,\\lfloor \\frac{m}{d}\\rfloor)} \\mu(k) \\cdot k^2 \\cdot h(\\lfloor \\frac{n}{dk} \\rfloor, \\lfloor \\frac{m}{dk} \\rfloor)\n$$\n设 $dk = T$，则有：\n$$\n\\text{ans} = \\sum _ {d=1}^{\\min(n,m)} d \\cdot \\sum _ {k=1}^{\\min(\\lfloor \\frac{n}{d}\\rfloor,\\lfloor \\frac{m}{d}\\rfloor)} \\mu(k) \\cdot k^2 \\cdot h(\\lfloor \\frac{n}{T} \\rfloor, \\lfloor \\frac{m}{T} \\rfloor)\n$$\n枚举 $T$ ，则有：\n$$\n\\text{ans} = \\sum _ {T=1}^{\\min(n,m)} \\sum _ {d|T} d \\cdot {\\lfloor \\frac{T}{d} \\rfloor}^2 \\mu(\\lfloor \\frac{T}{d} \\rfloor) \\cdot h(\\lfloor \\frac{n}{T} \\rfloor, \\lfloor \\frac{m}{T} \\rfloor)\n$$\n简单整理下：\n$$\n\\text{ans} = \\sum _ {T=1}^{\\min(n,m)} h(\\lfloor \\frac{n}{T} \\rfloor, \\lfloor \\frac{m}{T} \\rfloor) \\sum _ {d|T} \\lfloor \\frac{T}{d} \\rfloor \\cdot {d}^2 \\mu(d)\n$$\n拎出来后面的一坨：\n$$\nf'(T) = \\sum _ {d|T} \\lfloor \\frac{T}{d} \\rfloor \\cdot {d}^2 \\mu(d)\n$$\n发现这是一个积性函数，所以可以 $O(n)$ 线性筛出来，然后就可以配合整除分块 $O(\\sqrt n)$ 完成单词询问。\n[SDOI2015]约数个数和 题意 设 $d(x)$ 为 $x$ 的约数个数，给定 $N$ 、$M$ ，求\n$$\\sum^N _ {i=1}\\sum^M _ {j=1}d(ij)$$\n解法 我们有如下结论：\n$$\nd(ij) = \\sum _ {x|i} \\sum _ {y|j} [\\gcd(x,y) = 1]\n$$\n证明：\n我们对 $i$ 和 $j$ 两个数做唯一分解 ，得到：\n$$\ni = {p_1}^{a_1} \\times {p_2}^{a_2} \\times \\cdots \\times {p_n}^{a_n}\\\nj = {p_1}^{b_1} \\times {p_2}^{b_2} \\times \\cdots \\times {p_n}^{b_n}\\\n$$\n所以我们知道\n$$\nd(ij) = \\prod _ {x=1}^n {(a_x + b_x + 1)}\n$$\n我们需要证明，分别从 $i$ 和 $j$ 中选择两个互质的约数的方案数也等于上式。\n我们发现，在约数的构造中，不同质因子的选取是独立的。所以我们只需要考虑一个质因子的选取方案数，然后把所有质因子做一个连乘即可。\n因为不能有公共的因子，所以对 $p_1$ 这个质因子来说，我们可以正好找出 $a_1+b_1+1$ 种选取方法，分别为：\n$$\n(1,0),(2,0),\\cdots,(a_1,0)\\\n(0,1),(0,2),\\cdots,(0,b_1)\\\n(0,0)\n$$\n可以证明，这些不同的的选取可以保证我们选择的因数不会完全相同。\n所以可以证明：\n$$\nd(ij) = \\sum _ {x|i} \\sum _ {y|j} [\\gcd(x,y) = 1]\n$$\n原式：\n$$\n\\sum^N _ {i=1}\\sum^M _ {j=1}d(ij)\\\n= \\sum^N _ {i=1}\\sum^M _ {j=1}\\sum _ {x|i} \\sum _ {y|j} [\\gcd(x,y) = 1]\\\n= \\sum _ {x=1}^N\\sum _ {y=1}^M\\sum _ {x|i} \\sum _ {y|j} [\\gcd(x,y) = 1]\\\n= \\sum _ {x=1}^N\\sum _ {y=1}^M [\\gcd(x,y) = 1] \\sum _ {x|i} \\sum _ {y|j} 1\\\n= \\sum _ {x=1}^N\\sum _ {y=1}^M [\\gcd(x,y) = 1] \\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor\\\n$$\n设\n$$\nf(d) = \\sum _ {x=1}^N\\sum _ {y=1}^M [\\gcd(x,y) = d] \\lfloor \\frac{N}{x} \\rfloor \\lfloor \\frac{M}{y} \\rfloor\\\n$$\n若\n$$\ng(d) = \\sum _ {d|i} f(i)\n$$\n可以发现，此时 $x,y$ 为所有 $d$ 的倍数，所以：\n$$\ng(d) = \\sum _ {i=1}^{\\lfloor \\frac{N}{d} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{M}{d} \\rfloor} \\lfloor \\frac{N}{id} \\rfloor \\lfloor \\frac{M}{jd} \\rfloor\n$$\n进行一步反演：\n$$\nf(d) = \\sum _ {d|k} \\mu(\\frac{k}{d}) g(k)\n$$\n则：\n$$\nf(1) = \\sum _ {k=1}^{\\min(n,m)} \\mu(k) g(k)\\\n= \\sum _ {k=1}^{\\min(n,m)} \\mu(k) \\sum _ {i=1}^{\\lfloor \\frac{N}{k} \\rfloor} \\sum _ {j=1}^{\\lfloor \\frac{M}{k} \\rfloor} \\lfloor \\frac{N}{ik} \\rfloor \\lfloor \\frac{M}{jk} \\rfloor\\\n= \\sum _ {k=1}^{\\min(n,m)} \\mu(k) (\\sum _ {i=1}^{\\lfloor \\frac{N}{k} \\rfloor}\\lfloor \\frac{N}{ik} \\rfloor) (\\sum _ {j=1}^{\\lfloor \\frac{M}{k} \\rfloor} \\lfloor \\frac{M}{jk} \\rfloor)\\\n$$\n我们发现：\n$$\n\\sum _ {x=1}^nd(x) = \\sum _ {i=1}^{n}\\lfloor \\frac{n}{i} \\rfloor\n$$\n所以：\n$$\n\\text{ans} = \\sum _ {k=1}^{\\min(n,m)} \\mu(k) (\\sum _ {i=1}^{\\lfloor \\frac{N}{k} \\rfloor}\\lfloor \\frac{N}{ik} \\rfloor) (\\sum _ {j=1}^{\\lfloor \\frac{M}{k} \\rfloor} \\lfloor \\frac{M}{jk} \\rfloor)\\\n= \\sum _ {k=1}^{\\min(n,m)} \\mu(k) \\sum _ {i=1}^{\\lfloor \\frac{N}{k} \\rfloor}d(i) \\sum _ {j=1}^{\\lfloor \\frac{M}{k} \\rfloor} d(j)\\\n$$\n令：\n$$\nh(x) = \\sum _ {i=1}^x d(i)\n$$\n则：\n$$\n\\text{ans} = \\sum _ {k=1}^{\\min(n,m)} \\mu(k) \\cdot h(\\lfloor \\frac{N}{k} \\rfloor) \\cdot h(\\lfloor \\frac{M}{k} \\rfloor)\\\n$$\n我们发现 $d(i)$ 是一个积性函数，可以 $O(n)$ 线性筛，然后 $h(x)$ 可以 $O(n)$ 前缀和，然后就可以 $O(\\sqrt n)$ 整除分块单次出解。\n","description":"","id":137,"section":"posts","tags":["数学","莫比乌斯反演"],"title":"莫比乌斯反演入门题目-题解","uri":"https://blog.chenqiqian.com/posts/notes-mobius-inversion/"},{"content":"小 $\\text{G}$ 是一个出色的诗人，经常作诗自娱自乐。但是，他一直被一件事情所困扰，那就是诗的排版问题。\n一首诗包含了若干个句子，对于一些连续的短句，可以将它们用空格隔开并放在一行中，注意一行中可以放的句子数目是没有限制的。小 $\\text{G}$ 给每首诗定义了一个行标准长度（行的长度为一行中符号的总个数），他希望排版后每行的长度都和行标准长度相差不远。显然排版时，不应改变原有的句子顺序，并且小 $\\text{G}$ 不允许把一个句子分在两行或者更多的行内。在满足上面两个条件的情况下，小 $\\text{G}$ 对于排版中的每行定义了一个不协调度, 为这行的实际长度与行标准长度差值绝对值的 $P$ 次方，而一个排版的不协调度为所有行不协调度的总和。\n小 $\\text{G}$ 最近又作了几首诗，现在请你对这首诗进行排版，使得排版后的诗尽量协调（即不协调度尽量小），并把排版的结果告诉他。\n链接 Luogu P1912\n题解 没看见加粗的话\u0026hellip;因而疯狂不会做，然后回家仔细读题\u0026hellip;\n然后还是不会做。\n设 $dp[i]$ 是前 $i$ 句话的不协调度的最小值，那么我们显然有以下的状态转移方程：\n$$\ndp[i] = \\min _ {j=0}^{i-1}(dp[j] + {|sum[i]-sum[j]+(i-j-1)-L|}^p)\n$$\n打表发现决策单调性。\n用队列维护一个决策队列，用三元组 $(p,l,r)$ ，代表在 $[l,r]$ 区间中的最有决策点都是 $p$ ，类似：$11122333356 \\rightarrow (1,1,3) + (2,4,5) + (3,6,9) + (5,10,10) + (6,11,11)$ ，然后每次从后往前 $pop$ ，直到不能 $pop$ 掉整段之后再去二分看最后一块具体的分界线在哪里，然后在每次查询之前要把 $r \u0026lt; i-1$ 的区间给 $pop$ 掉。\n路径的话记录决策点即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;//#define ll long long #define ll long double using namespace std; const int MAXN = 110000; ll pow(ll x,int p){ ll ans = 1; for(int i = 1;i\u0026lt;=p;i++) ans *= x; return ans; } struct Node{ int p,l,r; }; int n,l,p; char s[MAXN][50]; ll sum[MAXN],dp[MAXN]; int last[MAXN]; ll calc(int i,int j){ return dp[j] + pow(fabs(sum[i] - sum[j] - l - 1),p); } int find(int l,int r,int now,int last){ // 找到在[l,r]区间内符合 now 决策比 last 优的最前面的位置  // last,...,last,[now],now  while(l!=r){ int mid = (l+r)\u0026gt;\u0026gt;1; if(calc(mid,last) \u0026gt; calc(mid,now)) r = mid; else l = mid+1; } return l; } void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;l,\u0026amp;p); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s[i]); sum[i] = strlen(s[i]); sum[i] += sum[i-1] + 1; } } void solve(){ static Node q[MAXN]; memset(dp,0,sizeof(dp)); memset(last,0,sizeof(last)); int fi=0,la=1;q[0] = (Node){0,1,n}; for(int i = 1;i\u0026lt;=n;i++){ if(fi != la \u0026amp;\u0026amp; q[fi].r \u0026lt;= i-1) fi++; int j = q[fi].p; dp[i] = calc(i,j);last[i] = j; if(calc(n,q[la-1].p) \u0026lt; calc(n,i)) continue;// 在n处i都不优于q[la-1].p  while(fi != la \u0026amp;\u0026amp; calc(q[la-1].l,q[la-1].p) \u0026gt; calc(q[la-1].l,i)) la--; // pop 掉整个尾段的条件：i 点在 q[la-1].l 甚至都是一个更优的决策点  if(fi==la) q[la++] = (Node){i,i+1,n}; else{ Node \u0026amp;t = q[la-1]; int x = find(t.l,n,i,t.p); t.r = x-1; q[la++] = (Node){i,x,n}; } } } void output(){ if(dp[n] \u0026gt; 1e18) printf(\u0026#34;Too hard to arrange\\n\u0026#34;); else{ static int route[MAXN]; int cnt = 0,now = n; printf(\u0026#34;%lld\\n\u0026#34;,(long long)(dp[n])); while(now != 0){ route[++cnt] = now; now = last[now]; } for(int i = 1,t=cnt;i\u0026lt;=n;i++){ printf(\u0026#34;%s\u0026#34;,s[i]); if(i!=route[t]) putchar(\u0026#39; \u0026#39;); else putchar(\u0026#39;\\n\u0026#39;),t--; } } printf(\u0026#34;--------------------\\n\u0026#34;); } int main(){ int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ init(); solve(); output(); } return 0; }   ","description":"","id":138,"section":"posts","tags":["动态规划","决策单调性","二分查找"],"title":"「NOI2009」诗人小G-动态规划+决策单调性","uri":"https://blog.chenqiqian.com/posts/noi2009-poet/"},{"content":"你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：\n 选择一个有超过一个元素的块（初始时你只有一块，即整个序列）  选择两个相邻元素把这个块从中间分开，得到两个非空的块。    每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。\n链接 Luogu P3648\n$$\na(b+c) + bc = ab+ac+bc = (a+b)c + ab \\rightarrow \\text{三个数怎么切结果都一样}\\\na(b+c+d) + (bc+cd+ad) = ab + ac + ad + bc + bd + cd = (a+b+c)d + (ab+bc+ac)\n$$\n这个式子再推广的话，就告诉我们：切割方案的分数只与切割的位置有关。\n令 $dp[i][w]$ 为前 $i$ 个数字切割w次能拿到的最小值 所以我们可以写出状态转移方程：\n$$\ndp[i][w] = \\max _ {j=1}^{i-1}(dp[j][w-1] + sum[j] \\times (sum[i]-sum[j]))\n$$\n然后如果 $k$ 比 $j$ 优秀，则有：\n$$\ndp[j][w-1] + sum[j] \\times (sum[i]-sum[j]) \u0026lt; dp[k][w-1] + sum[k] \\times (sum[i]-sum[k])\\\n\\frac{(dp[j][w-1]-{sum[j]}^2)-(dp[k][w-1]-{sum[k]}^2)}{sum[j]-sum[k]} \u0026gt; -sum[i]\\\n$$\n现在我们需要考虑 $sum[j] = sum[k]$ 的情况，我们注意到这个时候应该是 $ k$ 一定是不比 $j$ 坏的，但是我们由于要输出方案中，不能切在开头的位置，所以我们要尽量往后切，就必须令 $k$ 比 $j$ 优，就应该让这个式子返回无穷大。\n因为 $sum$ 是单调的，就可以单调队列维护凸包了。\n输出路径的话，就直接维护一个决策点，沿着决策点往回跳，然后输出就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdlib\u0026gt;#define ld long double #define ll long long using namespace std; const int MAXN = 110000; int n,k; ll num[MAXN],sum[MAXN],a[MAXN],b[MAXN]; int last[MAXN][210]; ll *dp,*now; ld calc(int i,int j){ if(sum[i] == sum[j]) return 1e18; return (ld)(dp[i]-sum[i]*sum[i]-dp[j]+sum[j]*sum[j])/(ld)(sum[i]-sum[j]); } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;sum[i]); sum[i] += sum[i-1]; } } void solve(){ static int q[MAXN]; dp = a,now = b; int fi = 0,la = 0; for(int x = 1;x\u0026lt;=k;x++){ fi = la = 0;q[0] = 0; for(int i = 1;i\u0026lt;=n;i++){ while(fi \u0026lt; la \u0026amp;\u0026amp; calc(q[fi],q[fi+1]) \u0026gt;= -sum[i]) fi++; now[i] = dp[q[fi]] + (sum[i]-sum[q[fi]])*sum[q[fi]]; last[i][x] = q[fi]; while(fi \u0026lt; la \u0026amp;\u0026amp; calc(q[la-1],q[la]) \u0026lt;= calc(q[la],i)) la--; q[++la] = i; } swap(dp,now); } printf(\u0026#34;%lld\\n\u0026#34;,dp[n]); for(int i = k,t = n;i\u0026gt;=1;--i){ printf(\u0026#34;%d \u0026#34;,last[t][i]); t = last[t][i]; } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":139,"section":"posts","tags":["动态规划","斜率优化"],"title":"「APIO2014」序列分割-动态规划-斜率优化","uri":"https://blog.chenqiqian.com/posts/apio2014-sequence/"},{"content":"将要读二年级的小 Q 买了一款新型益智玩具——魔幻棋盘，它是一个 $N$ 行 $M$ 列的网格棋盘，每个格子中均有一个正整数。棋盘守护者在棋盘的第 $X$ 行第 $Y$ 列（行与列均从 $1$ 开始编号）并且始终不会移动。棋盘守护者会进行两种操作：\n  询问：他会以自己所在位置为基础，向四周随机扩展出一块大小不定的矩形区域，向你询问这一区域内所有数的最大公约数是多少。\n  修改：他会随意挑选棋盘上的一块矩形区域，将这一区域内的所有数同时加上一个给定的整数。\n  游戏说明书上附有这样一句话“聪明的小朋友，当你连续答对 $19930324$ 次询问后会得到一个惊喜噢！”。小 Q 十分想得到这个惊喜，于是每天都在玩这个玩具。但由于他粗心大意，经常算错数，难以达到这个目标。于是他来向你寻求帮助，希望你帮他写一个程序来回答棋盘守护者的询问，并保证 $100%$ 的正确率。\n为了简化问题，你的程序只需要完成棋盘守护者的 $T$ 次操作，并且问题保证任何时刻棋盘上的数字均为不超过 $2^{62} - 1$ 的正整数。\n链接 Luogu P2086\n题解 我们发现，如果只有单点修改，这个东西是很好解决的，区间修改（加）就不太好做。\n我们有如下结论：\n$$\n\\gcd(a,b) = \\gcd(a,b-a)\n$$\n然后我们发现我们所有的查询都是包含同一个点的，这也可以给我们提供一点思路。\n我们如果对于所有点，我们对某点做一个二维的差分（也就是矩形的前缀和等于这个位置原来的值），所以这个时候我们可以直接对这个差分进行 $\\gcd$ 的查询。\n我们建立一个二维线段树，维护差分后的数组，我们需要建立两个一维线段树来辅助差分。修改矩形的时候，我们因为是以左上角差分的，所以我们需要修改四个点，就是矩形的四个角，注意 $+1$ 和 $-1$ 的问题。\n在这里，我们不必以中心点为基准差分，事实上可以以任意点差分。\n参考：SengXian\u0026rsquo;s Blog\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; #define ll long long  namespace fast_io{ //... }using namespace fast_io; const int MAXN = 510000; ll gcd(ll a,ll b){ return b==0?abs(a):gcd(b,a%b); } #define lson (nown\u0026lt;\u0026lt;1) #define rson (nown\u0026lt;\u0026lt;1|1) #define mid ((l+r)\u0026gt;\u0026gt;1) struct SegTree1D{ ll *gg; SegTree1D(int m){gg = new ll[m\u0026lt;\u0026lt;2];} void build(int nown,int l,int r,const ll *lt,const ll *rt){ if(r \u0026lt; l) return gg[nown] = 0,void(); if(l == r) gg[nown] = rt == NULL?lt[l]: gcd(lt[nown],rt[nown]); else{ build(lson,l,mid,lt,rt),build(rson,mid+1,r,lt,rt); gg[nown] = gcd(gg[lson],gg[rson]); } } ll query(int nown,int l,int r,int ql,int qr){ if(qr \u0026lt; l || r \u0026lt; ql) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return gg[nown]; else{ ll ans = 0; if(ql \u0026lt;= mid) ans = gcd(ans,query(lson,l,mid,ql,qr)); //if(ans == 1) return ans;  if(qr \u0026gt;= mid+1) ans = gcd(ans,query(rson,mid+1,r,ql,qr)); return ans; } } void modify(int nown,int l,int r,int pos,ll v){ if(pos \u0026lt; l || pos \u0026gt; r) return; if(l == r) gg[nown] += v; else{ if(pos \u0026lt;= mid) modify(lson,l,mid,pos,v); else modify(rson,mid+1,r,pos,v); gg[nown] = gcd(gg[lson],gg[rson]); } } void modify(int nown,int l,int r,int pos,const ll *ltree,const ll *rtree){ if(pos \u0026lt; l || pos \u0026gt; r) return; if(l == r) gg[nown] = gcd(ltree[nown],rtree[nown]); else{ if(pos \u0026lt;= mid) modify(lson,l,mid,pos,ltree,rtree); else modify(rson,mid+1,r,pos,ltree,rtree); gg[nown] = gcd(ltree[nown],rtree[nown]); } } }*C,*D; int n,m,xx,yy,t; ll *a[MAXN],*b[MAXN]; ll c[MAXN],d[MAXN],val;//c横d纵  struct SegTree2D{ // 每一行建1棵1D线段树  // 一共n棵，每棵大小均为m  SegTree1D *t[MAXN\u0026lt;\u0026lt;2]; int a,b,c,d;//行从 a-\u0026gt;b, 列从 c-\u0026gt;d or (a,b)  ll v; void build(int nown,int l,int r,int m,ll **num){ t[nown] = new SegTree1D(m); if(l == r) t[nown]-\u0026gt;build(1,1,m,num[l],NULL); else{ build(lson,l,mid,m,num),build(rson,mid+1,r,m,num); t[nown]-\u0026gt;build(1,1,m,t[lson]-\u0026gt;gg,t[rson]-\u0026gt;gg); } } void modify(int nown,int l,int r){//(a,b) += v  if(r \u0026lt; a || l \u0026gt; a) return; if(l == r) t[nown]-\u0026gt;modify(1,1,m,b,v); else{ if(a \u0026lt;= mid) modify(lson,l,mid); else modify(rson,mid+1,r); t[nown]-\u0026gt;modify(1,1,m,b,t[lson]-\u0026gt;gg,t[rson]-\u0026gt;gg); } } ll query(int nown,int l,int r){ if(b \u0026lt; l || r \u0026lt; a) return 0; if(a \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= b) return t[nown]-\u0026gt;query(1,1,m,c,d); else{ ll ans = 0; if(a \u0026lt;= mid) ans = gcd(ans,query(lson,l,mid)); //if(ans == 1) return ans;  if(b \u0026gt;= mid+1) ans = gcd(ans,query(rson,mid+1,r)); return ans; } } }T; void modify(int x,int y,ll v){ T.a = x,T.b = y,T.v = v; if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= n \u0026amp;\u0026amp; 1 \u0026lt;= y \u0026amp;\u0026amp; y \u0026lt;= m) T.modify(1,1,n); } ll query(int x1,int x2,int y1,int y2){ ll ans = val; x1 = xx - x1,x2 = xx + x2,y1 = yy - y1,y2 = yy + y2; ans = gcd(ans,gcd(D-\u0026gt;query(1,1,n,x1+1,x2),C-\u0026gt;query(1,1,m,y1+1,y2))); T.a = x1+1,T.b = x2,T.c = y1+1,T.d = y2; ans = gcd(ans,T.query(1,1,n)); return abs(ans); } void modify(int x1,int x2,int y1,int y2,ll v){ if(x1 \u0026lt;= xx \u0026amp;\u0026amp; xx \u0026lt;= x2 \u0026amp;\u0026amp; y1 \u0026lt;= yy \u0026amp;\u0026amp; yy \u0026lt;= y2) val += v; if(x1 \u0026lt;= xx \u0026amp;\u0026amp; xx \u0026lt;= x2) C-\u0026gt;modify(1,1,m,y1,v),C-\u0026gt;modify(1,1,m,y2+1,-v); if(y1 \u0026lt;= yy \u0026amp;\u0026amp; yy \u0026lt;= y2) D-\u0026gt;modify(1,1,n,x1,v),D-\u0026gt;modify(1,1,n,x2+1,-v); modify(x1,y1,v),modify(x1,y2+1,-v),modify(x2+1,y1,-v),modify(x2+1,y2+1,v); } void init(){ read(n),read(m),read(xx),read(yy),read(t); for(int i = 0;i\u0026lt;=n+10;i++){ ll t = m+10; a[i] = new ll[t],b[i] = new ll[t]; memset(a[i],0,sizeof(ll) * t),memset(b[i],0,sizeof(ll) * t); } for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++) read(a[i][j]); } void build(){ for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++) b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1]; for(int i = 1;i\u0026lt;=m;i++) c[i] = a[xx][i] - a[xx][i-1]; for(int i = 1;i\u0026lt;=n;i++) d[i] = a[i][yy] - a[i-1][yy]; val = a[xx][yy]; C = new SegTree1D(m),D = new SegTree1D(n); C-\u0026gt;build(1,1,m,c,NULL),D-\u0026gt;build(1,1,n,d,NULL); T.build(1,1,n,m,b); } void solve(){ static int op,x1,x2,y1,y2; static ll v; for(int i = 1;i\u0026lt;=t;i++){ read(op),read(x1),read(y1),read(x2),read(y2); if(op == 0){ print(query(x1,x2,y1,y2)),print(\u0026#39;\\n\u0026#39;); } else{ read(v); modify(x1,x2,y1,y2,v); } } } signed main(){ init(); build(); solve(); flush(); return 0; }   ","description":"","id":140,"section":"posts","tags":["线段树","树套树","数据结构","差分"],"title":"「NOI2012」魔幻棋盘-差分+树套树","uri":"https://blog.chenqiqian.com/posts/noi2012-board/"},{"content":"给定正整数 $n,m,a,c,X[0],g$ ，求按照 $X[n+1] = (a X[n] + c) \\bmod m$ 生成出的第 $n$ 项 $X[n] \\bmod g$ 的值。\n数据范围： $n,m,a,c,X[0] \\leq 10^{18}$\n链接 Luogu P2044\n题解 构造转移矩阵：\n$$\n\\left[\\begin{matrix}\na \u0026amp; c \\\n0 \u0026amp; 1\n\\end{matrix}\\right]\n\\times\n\\left[\\begin{matrix}\nx _ {n}\\\n1\n\\end{matrix} \\right] \\left[\\begin{matrix}\na x_n + c \\\n0 + 1\n\\end{matrix} \\right] \\left[\\begin{matrix}\nx _ {n+1} \\\n1\n\\end{matrix} \\right]\n$$\n快速幂即可。\n这里的乘法需要快速乘。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; #define ld long double #define ll long long  ll m,a,c,x0,n,g; ll mul(ll a,ll b){ a%=m,b%=m; return ((a*b - (ll)((ll)(((ld)a/m) * b + 1e-3) * m))%m+m)%m; } struct Matrix{ ll a[3][3]; Matrix(){ memset(a,0,sizeof(a)); } }; Matrix mul(Matrix \u0026amp;_a,Matrix \u0026amp;_b){ Matrix ans; for(int i = 1;i\u0026lt;=2;i++){ for(int j = 1;j\u0026lt;=2;j++){ for(int k = 1;k\u0026lt;=2;k++){ (ans.a[i][j] += mul(_a.a[i][k],_b.a[k][j]))%=m; } } } return ans; } Matrix pow(Matrix x,ll p){ Matrix ans; ans.a[1][1] = ans.a[2][2] = 1; for(ll i = p;i;x = mul(x,x),i\u0026gt;\u0026gt;=1) if(i \u0026amp; 1) ans = mul(ans,x); return ans; } int main(){ scanf(\u0026#34;%lld %lld %lld %lld %lld %lld\u0026#34;,\u0026amp;m,\u0026amp;a,\u0026amp;c,\u0026amp;x0,\u0026amp;n,\u0026amp;g);x0 %= m; Matrix tmp; tmp.a[1][1] = a % m, tmp.a[1][2] = c % m,tmp.a[2][2] = 1; tmp = pow(tmp,n); ll ans = ((mul(tmp.a[1][1],x0) + tmp.a[1][2])%m)%g; printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; }   ","description":"","id":141,"section":"posts","tags":["数学","矩阵快速幂","递推"],"title":"「NOI2012」随机数生成器-矩阵快速幂","uri":"https://blog.chenqiqian.com/posts/noi2012-random/"},{"content":" 题面请点击查看全文\n $\\text{YT}$ 市是一个规划良好的城市，城市被东西向和南北向的主干道划分为 $n\\times n$ 个区域。简单起见，可以将 $\\text{YT}$ 市看作一个正方形，每一个区域也可看作一个正方形。从而，$YT$ 城市中包括 $(n+1) \\times (n+1)$ 个交叉路口和 $2n \\times (n+1)$ 条双向道路（简称道路），每条双向道路连接主干道上两个相邻的交叉路口。\n小 $\\text{Z}$ 作为该市的市长，他根据统计信息得到了每天上班高峰期间 $\\text{YT}$ 市每条道路两个方向的人流量，即在高峰期间沿着该方向通过这条道路的人数。每一个交叉路口都有不同的海拔高度值， $\\text{YT}$ 市市民认为爬坡是一件非常累的事情，每向上爬 $h$ 的高度，就需要消耗 $h$ 的体力。如果 是下坡的话，则不需要耗费体力。因此如果一段道路的终点海拔减去起点海拔的值为 $h$ (注意 $h$ 可能是负数)，那么一个人经过这段路所消耗的体力是 $\\max(0, h)$ 。\n小 $\\text{Z}$ 还测量得到这个城市西北角的交叉路口海拔为 $0$ ，东南角的交叉路口海拔为 $1$ ，但其它交叉路口的海拔高度都无法得知。小 $\\text{Z}$ 想知道在最理想的情况下（即你可以任意假设其他路口的海拔高度），每天上班高峰期间所有人爬坡消耗的总体力和的最小值。\n 链接 Luogu P2046\n题解 可以发现，应该所有点的海拔都要么是 $0$ ，要么是 $1$ ，可以取到最优解。而且分界线应该是一条连续的线，让我们联想到最小割。\n但是这个数据范围太大了，直接跑最大流会超时，所以我们将这个图转化成对偶图，根据切割方向选择边的长度，然后跑最短路即可。注意不能用 $\\text{SPFA}$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#define ll long long using namespace std; const int MAXN = 300000,MAXM = 2400000; const int N = 510; struct Edge{ int from,to; ll len;int nex; }edge[MAXM]; int n,m,s,t; int fir[MAXN],ecnt = 2; int a[N][N],b[N][N],c[N][N],d[N][N]; void addedge(int a,int b,int c){s edge[ecnt] = (Edge){a,b,c,fir[a]}; fir[a] = ecnt++; } struct Point{ int x;ll d; bool operator \u0026lt;(const Point \u0026amp;a)const{ return d \u0026gt; a.d; } }; ll dis[MAXN]; bool vis[MAXN]; priority_queue\u0026lt;Point\u0026gt; q; void dij(){ for(int i = 1;i\u0026lt;=n*n+2;i++) dis[i] = 2147483647; dis[s] = 0; q.push((Point){s,0}); while(!q.empty()){ Point now = q.top();q.pop(); int nown = now.x,nowd = dis[nown]; if(vis[nown]) continue; vis[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(dis[v] \u0026gt; nowd + l){ dis[v] = nowd + l; q.push((Point){v,dis[v]}); } } } } int _hash(int i,int j){ if(i \u0026lt;= 0 || j \u0026gt; n) return s; if(j \u0026lt;= 0 || i \u0026gt; n) return t; return (i-1)*n+j; } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n);n++; for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=n-1;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); for(int i = 1;i\u0026lt;=n-1;i++) for(int j = 1;j\u0026lt;=n;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;b[i][j]); for(int i = 1;i\u0026lt;=n;i++) for(int j = 2;j\u0026lt;=n;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;c[i][j]); for(int i = 2;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=n;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;d[i][j]); n--; } void solve(){ s = n*n+1,t = n*n+2; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n;j++){ addedge(_hash(i,j),_hash(i+1,j),a[i+1][j]); addedge(_hash(i,j),_hash(i,j+1),d[i+1][j+1]); addedge(_hash(i,j),_hash(i-1,j),c[i][j+1]); addedge(_hash(i,j),_hash(i,j-1),b[i][j]); } } for(int i = 1;i\u0026lt;=n;i++){ addedge(s,_hash(1,i),a[1][i]); addedge(s,_hash(i,n),b[i][n+1]); //addedge(,s,),addedge(,s,);  } for(int i = 1;i\u0026lt;=n;i++){ addedge(_hash(i,1),t,b[i][1]); addedge(_hash(n,i),t,a[n+1][i]); //addedge(t,,),addedge(t,,);  } dij(); printf(\u0026#34;%lld\\n\u0026#34;,dis[t]); } signed main(){ init(); solve(); return 0; }   ","description":"","id":142,"section":"posts","tags":["最短路","网络流","对偶图"],"title":"「NOI2010」海拔-网络流/最短路","uri":"https://blog.chenqiqian.com/posts/noi2010-altitude/"},{"content":"给定一个 $n$ 个点，$m$ 条边的无向图，每条边有两种权值： $0$ 或者 $1$ 。\n先询问能不能找出一个生成树，使得其中恰有 $k$ 条 $0$ 边，若存在，输出任意一个方案，否则输出 no solution 。\n链接 Luogu P3623\n题解 不太会其实。首先将 $0$ 边作为大边，然后做一次最小生成树，得到必须加入的最少的 $0$ 边，此时如果这个 $0$ 边的数目大于 $k$ ，那么就无解；\n然后我们先将所有的 $0$ 边尝试加入，如果能满足不成环且最后恰好能到 $k$ 条边，就加入剩下的 $1$ 边，构成生成树即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXN = 110000; int n,m,k; struct Edge{ int from,to,len; }edge[MAXN]; bool cmp(Edge a,Edge b){ return a.len \u0026lt; b.len; } int f[MAXN]; void init(int n){ for(int i = 1;i\u0026lt;=n;i++) f[i] = i; } int find(int x){ return f[x] == x?x:f[x] = find(f[x]); } void solve(){ static Edge ans[MAXN]; int tot = 0; init(n); sort(edge+1,edge+m+1,cmp); for(int i = 1;i\u0026lt;=m;i++){ Edge \u0026amp;e = edge[i]; int fx = find(e.from),fy = find(e.to); if(fx != fy){ f[fx] = fy; if(e.len == 1){ tot++; ans[tot] = e; } } if(e.len == 1){ e.len = -1; }\t} init(n); sort(edge+1,edge+m+1,cmp); if(tot \u0026gt; k){ printf(\u0026#34;no solution\\n\u0026#34;); return; } for(int i = 1;i\u0026lt;=tot;i++){ int fx = find(ans[i].from),fy = find(ans[i].to); //printf(\u0026#34;%d %d\\n\u0026#34;,ans[i].from,ans[i].to);  f[fx] = fy; } for(int i = 1;i\u0026lt;=m;i++){ Edge \u0026amp;e = edge[i]; if(tot == n-1) break; int fx = find(e.from),fy = find(e.to); if(tot == k \u0026amp;\u0026amp; e.len == -1) continue; if(tot \u0026lt; k \u0026amp;\u0026amp; e.len != -1){ printf(\u0026#34;no solution\\n\u0026#34;); return; } if(fx != fy){ f[fx] = fy; ans[++tot] = e; } }\tif(tot!=n-1){ printf(\u0026#34;no solution\\n\u0026#34;); return; } for(int i = 1;i\u0026lt;=n-1;i++){ printf(\u0026#34;%d %d %d\\n\u0026#34;,ans[i].from,ans[i].to,1-abs(ans[i].len)); } } void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;edge[i].from,\u0026amp;edge[i].to,\u0026amp;edge[i].len); edge[i].len^=1; } } int main(){ init(); solve(); return 0; }   ","description":"","id":143,"section":"posts","tags":["图论","生成树","数据结构","并查集"],"title":"「APIO2008」免费道路-生成树+并查集","uri":"https://blog.chenqiqian.com/posts/apio2008-road/"},{"content":"你的面前有 $n$ 个数排成一行，分别为 $a_1,a_2,\u0026hellip;,a_n$ 。你打算在每相邻的两个 $a_i$c和 $a _ {i+1}$ 间都插入一个加号、减号或者乘号。那么一共有 $3^{n-1}$ 种可能的表达式。\n你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个 $a_i$ 的值。\n你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。\n链接 Luogu P4340\n题解 好题好题。可以运用人类的智慧解决。\n可以发现，所有表达式的和里面，有一些加号和减号其实是可以抵消的。\n我们重点关注所有表达式第一个不是乘号的位置。\n如果我们有这么一个表达式：\n$$\na_1 \\times a_2 \\times \u0026hellip; \\times a_i + (a _ {i+1} \u0026hellip; a _ {n})\n$$\n那么必然有一个表达式：\n$$\na_1 \\times a_2 \\times \u0026hellip; \\times a_i - (a _ {i+1} \u0026hellip; a _ {n})\n$$\n那么他们的和就是：\n$$\n2 \\times a_1 \\times a_2 \\times \u0026hellip; \\times a_i\n$$\n这样的对数一共有 $3^{n-i-1}$ 对，所以所有在第 $i$ 个数字后出现第一个非乘号的这样的表达式的和是\n$$\n2 \\times 3^{n-i-1} \\times a_1 \\times a_2 \\times \u0026hellip; \\times a_i\n$$\n所以我们可以推出所有的表达式的和就是：\n$$\n\\sum _ {i = 1}^{n-1} (2 \\times 3^{n-i-1} \\times a_1 \\times a_2 \\times \u0026hellip; \\times a_i)\n$$\n如果按照 $i$ 建立一棵线段树，那么我们发现，每次修改的都是某些连续的区间，除去原来的数，然后乘上新的数即可。因为模数是一个素数，所以除去一个数可以用乘上逆元来代替。\n建好树之后只需维护一个支持区间乘法，维护区间和的线段树即可。\n时间复杂度：$O(q (\\log{n} + \\log{\\text{mod}}))$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;cstdio\u0026gt;using namespace std; typedef long long ll; #define mod 1000000007  const int MAXN = 110000; ll pow(ll x,ll k){ ll ans = 1; for(ll i = k;i;i\u0026gt;\u0026gt;=1,x = (x*x)%mod) if(i\u0026amp;1) ans = (ans * x)%mod; return ans; } ll niyuan(ll x){ return pow(x,mod-2); } namespace SegTree{ ll sum[MAXN\u0026lt;\u0026lt;2],lazy[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1) #define rson (nown\u0026lt;\u0026lt;1|1) #define mid ((l+r)\u0026gt;\u0026gt;1) void push_up(int nown){ sum[nown] = (sum[lson] + sum[rson])%mod; } void build(int nown,int l,int r,ll *num){ lazy[nown] = 1; if(l == r) sum[nown] = num[l]; else{ build(lson,l,mid,num); build(rson,mid+1,r,num); push_up(nown); } } void addlabel(int nown,ll v){ (sum[nown] *= v)%=mod; (lazy[nown] *= v)%=mod; } void push_down(int nown){ if(lazy[nown]){ addlabel(lson,lazy[nown]),addlabel(rson,lazy[nown]); lazy[nown] = 1; } } void update(int nown,int l,int r,int ql,int qr,ll v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ addlabel(nown,v); } else{ push_down(nown); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,v); push_up(nown); } } ll query(){ return sum[1]; } } int n,m; ll a[MAXN]; ll s[MAXN]; ll tmp[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); } void build(){ s[1] = s[2] = 1; for(int i = 3;i\u0026lt;=n;i++) s[i] = (s[i-1] * 3)%mod; for(int i = 2;i\u0026lt;=n;i++) (s[i] *= 2)%=mod; tmp[n+1] = 1; for(int i = 1;i\u0026lt;=n;i++){ int ttt = n-i+1; tmp[ttt] = (tmp[ttt+1] * a[i])%mod; } for(int i = 1;i\u0026lt;=n;i++) (tmp[i] *= s[i]) %= mod; SegTree::build(1,1,n,tmp); } void solve(){ ll pos,v; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;pos,\u0026amp;v); SegTree::update(1,1,n,1,n-pos+1,(niyuan(a[pos]) * v)%mod); a[pos] = v; printf(\u0026#34;%lld\\n\u0026#34;,SegTree::query()); } } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":144,"section":"posts","tags":["线段树","数据结构"],"title":"「SHOI2016」随机序列-线段树","uri":"https://blog.chenqiqian.com/posts/shoi2016-sequence/"},{"content":"假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$ 。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。\n起飞序列还存在两类限制条件：\n  第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$ ;\n  第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a, b)$ ，表示航班 $a$ 的起飞时间必须早于航班 $b$ ，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。\n  小 $\\text{X}$ 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。\n链接 Luogu P1954\n题解 对于这些限制，我们发现可以转换成一个拓扑序的问题。但是我们发现最晚的起飞时间限制比较难达成，而两向的相对关系则是比较轻松的，所以我们考虑到可以把整个时间轴反向，那么就变成了所有飞机都有一个最早起飞的限制，那么就可以加一个虚边，按时间解锁，这个问题就可以解决了。\n对于第二问，我们就相当于把这个飞机，反向之后能压多后就压多后，将拓扑排序里面的队列变为优先队列，就可以了。\n复杂度是 $O(n^2 \\log{n})$，貌似不是正解，BZOJ可过，Luogu 需开 O2 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#define inf 0x3f3f3f3f #define pii pair\u0026lt;int,int\u0026gt; using namespace std; const int MAXN = 2100; int n,m; int k[MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; vector\u0026lt;int\u0026gt; qqq[MAXN]; int ans[MAXN]; priority_queue\u0026lt;pii\u0026gt; q; int toposort(int w = 0){ // printf(\u0026#34;w:%d\\n\u0026#34;,w);  static int in[MAXN]; memset(in,0,sizeof(in)); while(!q.empty()) q.pop(); for(int x = 1;x\u0026lt;=n;x++){ for(int i = 0;i\u0026lt;edge[x].size();i++){ in[edge[x][i]]++; } in[x]++; } for(int j = n;j\u0026gt;=1;--j){ for(int i = 0;i\u0026lt;qqq[j].size();i++){ int x = qqq[j][i]; if(--in[x] == 0){ q.push(make_pair((w==x?-inf:k[x]),x)); } } int x = q.top().second;q.pop(); if(x == w) return j; ans[j] = x; for(int i = 0;i\u0026lt;edge[x].size();i++){ int v = edge[x][i]; if(--in[v] == 0){ q.push(make_pair((w==v?-inf:k[v]),v)); } } } return 0; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;k[i]); qqq[k[i]].push_back(i); } int a,b; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); edge[b].push_back(a); } } void solve(){ toposort(); for(int i = 1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,ans[i]); printf(\u0026#34;\\n\u0026#34;); for(int i = 1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,toposort(i)); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":145,"section":"posts","tags":["图论","拓扑排序"],"title":"「NOI2010」航空管制-拓扑排序","uri":"https://blog.chenqiqian.com/posts/noi2010-airplane/"},{"content":"有 $n$ 件物品，每件物品有三个属性 $a[i], b[i], c[i]$ , $(a[i] \u0026lt; b[i])$ 。\n再给出 $q$ 个询问，每个询问由非负整数 $m$ , $k$ , $s$ 组成，问是否能够选出某些物品使得：\n  对于每个选的物品 $i$ ，满足 $a[i] \\leq m$ 且 $b[i]\u0026gt;m+s$ 。\n  所有选出物品的 $c[i]$ 的和正好是 $k$ 。\n  链接 Luogu P3537\n题解 好题好题。\n首先我们发现，如果把 $a[i]$ 这一维 $sort$ 掉，使 $a[i]$ 单增的话，这个问题就变成了给定若干个物品，问能不能取若干个物体满足 $\\sum c[i] = k$ ，且 $\\min(b[i]) \u0026gt; m + s$。\n然后这个时候，我们想要每加入一个物品都能够更新答案，可以用 $dp$ 的方法来更新，状态的第一维也就很好设置，肯定是前 $i$ 个物品如何如何。然后看到数据范围，我们需要思考如何在 $O(\\log n)$ 或者 $O(1)$ 的时间内出解。\n根据时间的限制，下面我们只能设置一维了，不可能同时表示 $\\sum c[i]$ 和 $\\min(b[i])$ 。考虑到这只是一个可行性判定，所以我们不用都存两个，只要存的这一维和$ dp$ 数组的信息能够让我们推断出来可行不可行就可以。\n所以我们令 $dp[i][j]$ 表示前i个物品，$\\sum c[i]$ 为 $j$ 的情况下，所有方案中 $\\min(b[i])$ 最大的是多少。\n这个时候，我们查 $dp[i][k]$ ，若其大于等于 $k$ ，则无解；否则有解。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 1100,MAXM = 1100000; struct Query{ int id; int x,y,c; bool operator \u0026lt;(const Query \u0026amp;_q)const{ return x \u0026lt; _q.x; } }p[MAXN],q[MAXM]; int n,m; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;p[i].c,\u0026amp;p[i].x,\u0026amp;p[i].y); } scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;q[i].x,\u0026amp;q[i].c,\u0026amp;q[i].y); q[i].y += q[i].x; q[i].id = i; } } void solve(){ sort(p+1,p+n+1),sort(q+1,q+m+1); static int dp[MAXM],ans[MAXM]; memset(dp,0,sizeof(dp)); dp[0] = 0x3f3f3f3f; int j = 1; p[n+1].x = 0x3f3f3f3f; for(int x = 1;x\u0026lt;=n+1;x++){ while(j \u0026lt;= m \u0026amp;\u0026amp; q[j].x \u0026lt; p[x].x){ ans[q[j].id] = dp[q[j].c] \u0026lt;= q[j].y ? 0: 1; j++; } if(x == n+1) break; for(int i = 100000;i\u0026gt;=p[x].c;i--) dp[i] = max(dp[i],min(dp[i-p[x].c],p[x].y)); } for(int i = 1;i\u0026lt;=m;i++){ printf(\u0026#34;%s\\n\u0026#34;,ans[i]?\u0026#34;TAK\u0026#34;:\u0026#34;NIE\u0026#34;); } } int main(){ init(); solve(); return 0; }   ","description":"","id":146,"section":"posts","tags":["动态规划","背包"],"title":"「POI2012」Cloakroom-类背包dp","uri":"https://blog.chenqiqian.com/posts/poi2012-cloakroom/"},{"content":"简单版题意：\n给定一个 $R \\times C$ 的矩形，在其中 $N$ 个位置有随机生成的资源点。现在请你求出在所有的子矩形中，至少包含一个资源点的矩形数量。\n完整版题意：\n终于到达了这次选拔赛的最后一题，想必你已经厌倦了小蓝和小白的故事，为了回馈各位比赛选手，此题的主角是贯穿这次比赛的关键人物——小蓝的好友。\n在帮小蓝确定了旅游路线后，小蓝的好友也不会浪费这个难得的暑假。与小蓝不同，小蓝的好友并不想将时间花在旅游上，而是盯上了最近发行的即时战略游戏——SangoCraft。但在前往通关之路的道路上，一个小游戏挡住了小蓝的好友的步伐。\n“国家的战争其本质是抢夺资源的战争”是整款游戏的核心理念，这个小游戏也不例外。简单来说，用户需要在给定的大小为 $R \\times C$ 长方形土地上选出一块子矩形，而系统随机生成了 $N$ 个资源点，位于用户所选的长方形土地上的资源点越多，给予用户的奖励也越多。悲剧的是，小蓝的好友虽然拥有着极其优秀的能力，但同时也有着极差的RP，小蓝的好友所选的区域总是没有一个资源点。\n终于有一天，小蓝的好友决定投诉这款游戏的制造厂商，为了搜集证据，小蓝的好友想算出至少包含一个资源点的区域的数量。作为小蓝的好友，这自然是你分内之事。\n数据范围：对于$100%$的数据，$R,C \\leq 40000$, $N \\leq 100000$，资源点的位置两两不同，且位置为 随机生成 。\n 链接 Luogu P2611\n题解 神题orz\n首先把问题转化成不包含一个资源点的子矩形数目。\n简直不可做好吗！枚举矩形都gg，简直很不可做\u0026hellip;\n所以说，我们需要用一些东西来加速这个过程。我也不知道，怎么就想到了笛卡尔树\u0026hellip;\n 笛卡尔树是一棵二叉树，树的每个节点有两个值，一个为 $\\text{key}$，一个为 $\\text{val}$。光看 $\\text{key}$ 的话，笛卡尔树是一棵二叉搜索树，每个节点的左子树的 $\\text{key}$ 都比它小，右子树都比它大；光看 $\\text{val}$ 的话，笛卡尔树有点类似堆，根节点的 $\\text{val}$ 是最小（或者最大）的，每个节点的 $\\text{val}$ 都比它的子树要大。\nFrom: SengXian\u0026rsquo;s Blog\n 我们用扫描线，从上往下扫描，然后我们的笛卡尔树维护的是每一列，中序遍历就是列从左到右的顺序，每一个节点的 $\\text{val}$ 就是这条扫描线到这一列最低的资源点的高度。\n这里的笛卡尔树，我们不维护 $\\text{key}$ ，是以序列下标来建树，类似文艺平衡树的 Splay ；堆则是小根堆。\n由于高度的随机性，我们可以发现，这棵笛卡尔树的期望高度是 $O(\\log{n})$ 的。\n所以我们可以维护一点东西，来加速我们的运算。\n我们维护一个 $sum$ ，代表下界在当前扫描线，上界在这个节点高度以下的子矩形的个数。我们可以发现，当前的节点的 $siz$ ，就是上界高度在其下的宽度（列数），然后我们可以得出满足这个条件的子矩形。然后所有的下界在扫描线上的矩形，都可以在这个笛卡尔树的所有节点处被不重不漏的包含。\n然后我们思考如何更新。扫描线往下的话就是所有的 $ht+1$，发现可以打标记 $O(1)$ 解决。出现一个点事实上就是单点修改优先值（ $\\text{val}$ ），然后往上转，也可以在 $O(\\log {n})$ 内解决。\n然后计算就好了。有不少细节\u0026hellip;怪难调的\u0026hellip;要不是数据结构基础好估计就gg了\u0026hellip;\n最后的复杂度大约是 $O(C + N \\log R)$ ？\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;#define ll long long typedef int T; using namespace std; #define calc(x) (((ll)(x)*((x)+1))/2)  namespace fast_io{ //... }using namespace fast_io; const int MAXN = 110000; namespace Treap{ //小根堆  #define ls c[x][0]  #define rs c[x][1]  ll ans[MAXN],addn[MAXN]; int ht[MAXN],siz[MAXN]; int c[MAXN][2],cnt = 0; int root; void maintain(int x){//确保合法才能maintain  siz[x] = siz[ls] + siz[rs] + 1; ans[x] = ans[ls] + ans[rs]; ans[x] += (ll)(ht[ls] - ht[x])*calc(siz[ls]); ans[x] += (ll)(ht[rs] - ht[x])*calc(siz[rs]); } int __build(int l,int r){ if(l \u0026gt; r) return 0; int x = ++cnt,mid = (l+r)\u0026gt;\u0026gt;1; siz[x] = 1; ls = __build(l,mid-1),rs = __build(mid+1,r); maintain(x); return x; } void add(int x,int v){ addn[x] += v,ht[x] += v; } void push_down(int x){ if(addn[x]){ add(ls,addn[x]),add(rs,addn[x]); addn[x] = 0; } } void rotate(int \u0026amp;x,int t){ int y = c[x][t]; c[x][t] = c[y][1-t]; c[y][1-t] = x; maintain(x),maintain(y); x = y; } void modify(int \u0026amp;x,int r){ push_down(x);int t = siz[ls] + 1; if(r == t){ ht[x] = 0;maintain(x);return; } else{ if(r \u0026lt; t){ modify(ls,r); if(ht[ls]\u0026lt;ht[x]) rotate(x,0); else maintain(x); } else{ modify(rs,r-t); if(ht[rs]\u0026lt;ht[x]) rotate(x,1); else maintain(x); } } } void add(){add(root,1);} void modify(int r){modify(root,r);} ll query(){return ans[root];} int getheight(){return ht[root];} void build(int n){root = __build(1,n);} } int n,m,k; struct Point{ int x,y; bool operator \u0026lt; (const Point \u0026amp; _a)const{ if(x != _a.x) return x \u0026lt; _a.x; else return y \u0026lt; _a.y; } }p[MAXN]; void init(){ read(n),read(m),read(k); for(int i = 1;i\u0026lt;=k;i++){ read(p[i].x),read(p[i].y); } } void build(){ sort(p+1,p+k+1); Treap::build(m); } void solve(){ static ll ans = calc(n)*calc(m); for(int i = 1,j = 1;i\u0026lt;=n;i++){ Treap::add(); //printf(\u0026#34;%d %d\\n\u0026#34;,p[j].x,p[j].y);  while(j \u0026lt;= k \u0026amp;\u0026amp; p[j].x == i){ Treap::modify(p[j].y);j++; } ans -= Treap::query() + calc(Treap::siz[Treap::root]) * Treap::getheight(); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":147,"section":"posts","tags":["数据结构","Treap"],"title":"「ZJOI2012」小蓝的好友-Treap","uri":"https://blog.chenqiqian.com/posts/zjoi2012-friend/"},{"content":"有一个长度为 $n$ 的字符串，每一位只会是 $\\text{p}$ 或 $\\text{j}$ 。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的 $\\text{p}$ 的个数不小于 $\\text{j}$ 的个数。\n链接 Luogu P3564\n题解 瞎搞题。\n把 $p$ 看做 $1$ ，$j$ 看做 $-1$ ，那么问题转化为：求最长的子串 $s[l\u0026hellip;r]$ ，使得 $sum[l-1] \\leq sum[i] \\leq sum[r]$ 对于任意 $i \\in [l,r]$ 成立。\n我们首先建一个类似图的东西，把所有 $sum$ 相同的位连到一起去，让 $nex[i]$ 表示下一个 $sum[x] = sum[i]$ 的位置，没有的话就是 $-1$ ；让 $to[i-1]$ 表示我们从第$i$位开始找到的最远的满足该性质的位置。\n然后我们发现，答案就是 $\\max(to[i-1]-i+1)$ 。\n所以我们只要推出 $to[i]$ 数组就可以了。\n剩下的我就说不明白了2333，看代码感性理解吧。\n为啥它是最长的我也不知道，反正能过。\n复杂度 $O(n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXN = 1100000; int n; char str[MAXN]; int a[MAXN],sum[MAXN]; int minsum = 0; int fir[MAXN],nex[MAXN],to[MAXN]; // fir仅做建图方便用，nex表示下一个sum相同的位置 // to表示区间最远能够延伸的距离  void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); scanf(\u0026#34;%s\u0026#34;,str + 1); memset(fir,-1,sizeof(fir)); for(int i = 1;i\u0026lt;=n;i++){ a[i] = str[i] == \u0026#39;p\u0026#39; ? 1 : -1; sum[i] = sum[i-1] + a[i]; minsum = min(sum[i],minsum); } for(int i = n;~i;--i){ int x = sum[i] - minsum; nex[i] = fir[x],to[i] = i,fir[x] = i; } } void solve(){ static int ans = 0; int r = n; for(int l = n;l\u0026gt;=1;--l){ if(a[l] == -1){ r = l-1; } else{ int t = nex[l-1]; if(~t \u0026amp;\u0026amp; sum[to[t]] \u0026gt;= sum[r]) r = to[t]; to[l-1] = r; ans = max(ans,r-l+1); } } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":148,"section":"posts","tags":["瞎搞"],"title":"「POI2014」Salad Bar-瞎搞","uri":"https://blog.chenqiqian.com/posts/poi2014-salad-bar/"},{"content":"给定两个数字串 $A$ 和 $B$ ，通过将 $A$ 和 $B$ 进行二路归并得到一个新的数字串 $T$ ，请找到字典序最小的 $T$ 。\n链接 BZOJ\n（离线题面）\ndata（数据）\n题解 如果前面两个字符不同，显然选取小的一个。\n分情况讨论，我们可以发现，如果相同，那么就应该取目前后缀字典序较小的一个。\n所以事实上就是取后缀字典序比较小的。\n此题亦可 hash 二分。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 410000; namespace SA{ int s[MAXN],sa[MAXN],ht[MAXN],rk[MAXN],x[MAXN],y[MAXN]; int cnt[MAXN]; void get_sa(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] != s[sa[i-1]]?++m:m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k = j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i] - j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]] != y[sa[i-1]] || y[sa[i]+j] != y[sa[i-1]+j])?++m:m; } } void build(int n,int* str){ int m = 1002;str[n++] = 0; for(int i = 0;i\u0026lt;n;i++) s[i] = str[i]; get_sa(n,m); } bool cmp(int i,int j){ return rk[i+1] \u0026lt; rk[j+1]; } } int n; int u,v; int a[MAXN],b[MAXN],t[MAXN],ans[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;u); for(int i = 0;i\u0026lt;u;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;v); for(int i = 0;i\u0026lt;v;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;b[i]); for(int i = 0;i\u0026lt;u;i++) t[n++] = a[i]; t[n++] = 0; for(int i = 0;i\u0026lt;v;i++) t[n++] = b[i]; SA::build(n,t); } void solve(){ int l = 0,r = 0,t = 0; while(t \u0026lt;= u+v){ // printf(\u0026#34;l:%d,%d r:%d,%d\\n\u0026#34;,l,a[l],r,b[r]);  if(l == u) ans[t++] = b[r++]; else if(r == v) ans[t++] = a[l++]; else{ if(a[l]==b[r]) ans[t++] = SA::cmp(l,u+1+r)?a[l++]:b[r++]; else ans[t++] = a[l] \u0026lt; b[r]?a[l++]:b[r++]; } } for(int i = 0;i\u0026lt;u+v;i++) printf(\u0026#34;%d \u0026#34;,ans[i]); printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":149,"section":"posts","tags":["后缀数组","字符串"],"title":"「BZOJ4278」[ONTAK2015]Tasowanie-后缀数组","uri":"https://blog.chenqiqian.com/posts/bzoj4278-tasowanie/"},{"content":"给定一个 $n$ 个点，$m$ 条边的无向联通图，每条边的权值均为 $a$。\n在原图所有满足 $u$ 节点和 $v$ 节点间最短路为 $2 \\times a$ 的点对 $(u,v)$ 间建立一条无向边，边的权值均为 $b$。\n给定一个起始节点$k$，求在上述操作后，$k$到所有节点的最短路径。\n链接 Luogu P3547\n题解 第一遍写觉得是sb题，第二遍觉得是神题oooorz\n可以发现，一共有三种从k点到达其他点的方式：\n 全走 $a$ 边 走 $0/1$ 条边的 $a$ ，剩下沿最短路走 $b$ 全走 $b$ 边（可能绕远）  第一种和第二种情况可以一遍 $bfs$ 解决，这也就是我所想到的了。\n然后交上去， $WA$ 。\n第三种情况如果直接两次往外扩展建边，那么复杂度是 $O(m^2)$ 。\n这个时候我们有一个微小的优化，就是建两份的图，分别用作从一个点第一次和第二次扩展的用的边。\n每次我们两次扩展，都把所有合法的第二次扩展的边删掉，理由是非常显然的，因为我们已经访问到了这个节点，根据bfs的性质，所有这个节点在第二张图的入边都不需要了，所以就可以删掉。\n然后复杂度是 $O(m \\sqrt{m})$ 。\n具体证明如下：\n首先，时间复杂度约等于遍历的边的数量，所以我们只需要考虑那些遍历了却没被删掉的边的数量。\n对于每一个节点 $x$ ，由他开始只会进行一次遍历再二次遍历中，没被删掉的边只有一种，就是在二次遍历中遍历到了一个仍然与 $x$ 距离为 $1$ 的点，也就是一个三元环。\n所以对于这个节点 $x$ ，假设和他距离为 $1$ 的点有 $k$ 个（也就是这个节点的度数），那么对于每一次二次遍历，那么最多有 $k^2$ 条边遍历过但没有被删掉，只有这些边有可能在接下来的遍历中被再次遍历，又因为第一次遍历的边总共是 $m$ 条，所以总时间复杂度就是它们的相乘。\n$$\n\\sum _ {v \\in V} \\min(deg(v)^2,m) \\leq \\sum _ {v \\in V} \\sqrt{deg(v)^2 \\cdot m} = \\sqrt {m} \\sum _ {v \\in V} deg(v) = O(m \\sqrt{m})\n$$\n参考：\nCSDN\n这个题告诉我们：适当删边可能降低一些复杂度。\norz出题人\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 210000,MAXM = 210000; struct Graph{ int to[MAXM],nex[MAXM],pre[MAXM]; int fir[MAXN];int ecnt; Graph(){ ecnt = 1; } void addedge(int u,int v){ int e = ecnt; pre[fir[u]] = e; to[e] = v,nex[e] = fir[u],pre[e] = 0; fir[u] = e; ecnt++; } void deledge(int x,int e){ int n = nex[e],p = pre[e]; if(!p) fir[x] = n; nex[p] = n,pre[n] = p; } }A,B; int n,m,k,a,b; long long ans[MAXN]; long long dis[MAXN]; queue\u0026lt;int\u0026gt; q; void init(){ scanf(\u0026#34;%d %d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k,\u0026amp;a,\u0026amp;b); int u,v; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); A.addedge(u,v),A.addedge(v,u); B.addedge(u,v),B.addedge(v,u); } } void bfs1(){ while(!q.empty()) q.pop(); for(int i = 1;i\u0026lt;=n;i++) dis[i] = 1000000; dis[k] = 0;q.push(k); while(!q.empty()){ int nown = q.front();q.pop(); for(int nowe = A.fir[nown];nowe;nowe = A.nex[nowe]){ int v = A.to[nowe]; if(dis[v] \u0026gt; dis[nown] + 1){ dis[v] = dis[nown] + 1; q.push(v); } } } for(int i = 1;i\u0026lt;=n;i++) ans[i] = min(dis[i] * a,(dis[i]/2) * b + (dis[i]%2) * a); } void bfs2(){ static bool vis[MAXN]; while(!q.empty()) q.pop(); for(int i = 1;i\u0026lt;=n;i++) dis[i] = 1000000; dis[k] = 0;q.push(k); while(!q.empty()){ int nown = q.front();q.pop(); vis[nown] = 1; for(int e1 = A.fir[nown];e1;e1 = A.nex[e1]){ int v1 = A.to[e1]; vis[v1] = 1; } for(int e1 = A.fir[nown];e1;e1 = A.nex[e1]){ int v1 = A.to[e1]; for(int e2 = B.fir[v1];e2;e2 = B.nex[e2]){ int v2 = B.to[e2]; if(!vis[v2]){ // printf(\u0026#34;\tv2:%d\\n\u0026#34;,v2);  if(dis[v2] \u0026gt; dis[nown] + 1){ dis[v2] = dis[nown] + 1; q.push(v2); } B.deledge(v1,e2); } } } for(int e1 = A.fir[nown];e1;e1 = A.nex[e1]){ int v1 = A.to[e1]; vis[v1] = 0; } vis[nown] = 0; } for(int i = 1;i\u0026lt;=n;i++) ans[i] = min(ans[i],dis[i] * b); } void solve(){ memset(ans,0x3f,sizeof(ans)); bfs1(); bfs2(); for(int i = 1;i\u0026lt;=n;i++){ printf(\u0026#34;%lld\\n\u0026#34;,ans[i]); } } int main(){ init(); solve(); return 0; }   ","description":"","id":150,"section":"posts","tags":["图论","最短路"],"title":"「POI2013」Price List-图论","uri":"https://blog.chenqiqian.com/posts/poi2013-price-list/"},{"content":"一个串是有限个小写字符的序列,特别的,一个空序列也可以是一个串. 一个串 $P$ 是串 $A$ 的前缀, 当且仅当存在串 $B$ , 使得 $A = PB$. 如果 $P \\neq A$ 并且 $P$ 不是一个空串,那么我们说 $P$ 是 $A$ 的一个 $proper$ 前缀. 定义 $Q$ 是 $A$ 的周期, 当且仅当 $Q$ 是 $A$ 的一个 $proper$ 前缀并且 $A$ 是 $QQ$ 的前缀(不一定要是 $proper$ 前缀).\n比如串 $abab$ 和 $ababab$ 都是串 $abababa$ 的周期. 串 $A$ 的最大周期就是它最长的一个周期或者是一个空串(当 $A$ 没有周期的时候), 比如说, $ababab$ 的最大周期是 $abab$ . 串 $abc$ 的最大周期是空串. 给出一个串,求出它所有前缀的最大周期长度之和.\n链接 Luogu P3435\n题解 分析一下，可以发现我们要求的是所有前缀的最短的相同的前后缀，且还有长度的限制，不能超过字符串的一半。\n这个可以联想到 $KMP$ ，所以我们思考如何在 $KMP$ 的基础上维护这个事情。因为 $KMP$ 在往回跳的话，是可以找到所有的相同的前后缀的。所以给定一个前缀，它沿 $nex$ 数组的转移是确定的，我们也就可以维护一个 $near[i]$ ，就是最近能够跳到的长度，也就是相同的前后缀最短值，所以我们就可以 $O(1)$ 的根据 $nex$ 数组计算这个 $near$ 数组，然后得到最后的答案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 1100000; char s[MAXN]; int n,nex[MAXN],near[MAXN]; void solve(){ int j;j = nex[0] = 0; for(int i = 1;i\u0026lt;n;i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = nex[j-1]; if(s[i]==s[j]) j++; nex[i] = j; } j = 0; long long ans = 0; near[0] = 0; for(int i = 1;i\u0026lt;n;i++){ int w = nex[i] - 1; if(w \u0026gt;= 0) near[i] = near[w] == -1?w:near[w]; else near[i] = -1; j = near[i]+1; if(j \u0026gt; 0 \u0026amp;\u0026amp; j \u0026lt;= (i+1)/2) ans += (i+1)-j; // printf(\u0026#34;i:%d j:%d\\n\u0026#34;,i,j);  } printf(\u0026#34;%lld\\n\u0026#34;,ans); } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); scanf(\u0026#34;%s\u0026#34;,s); } int main(){ init(); solve(); return 0; }   ","description":"","id":151,"section":"posts","tags":["字符串","KMP"],"title":"「POI2006」Periods of Words-KMP","uri":"https://blog.chenqiqian.com/posts/poi2006-okr/"},{"content":"可读版题意：\n给定 $n$ 个仅包含大写字母的模板串，求所有的长度为 $M$ 且仅包含大写字母的不同字符串中，有多少个包含至少一个模板串。答案对 $10007$ 取模。\n原题意：\n$JSOI$ 交给队员 ZYX 一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是$GW$文本生成器 $v6$ 版。\n该软件可以随机生成一些文章――总是生成一篇长度固定且完全随机的文章，也就是说，生成的文章中每个字节都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $a$ 包含单词 $b$ ，当且仅当单词 $b$ 是文章 $a$ 的子串）。但是，即使按照这样的标准，使用者现在使用的 $GW$ 文本生成器 $v6$ 版所生成的文章也是几乎完全不可读的。 $ZYX$ 需要指出 $GW$ 文本生成器 $v6$ 生成的所有文本中可读文本的数量，以便能够成功获得 $v7$ 更新版。你能帮助吗？\n链接 Luogu P4052\n题解 正难则反。不如我们考虑所有长度为 $M$ 的字符串，一个模版串都不出现的情况数。\n神似 GT考试 啊，只不过模版从一个变成了多个，那么我们就用AC自动机代替KMP。\n状态：$dp[i][j]$ 表示在 $AC$ 自动机的第 $i$ 个节点上，还有$j$位的符合条件的子串数量。\n先建立 $AC$ 自动机，补全 $Trie$ 图。\n然后将所有不是 $end$ 节点且 $fail$ 指针一路指向的没有$end$节点的点的 $dp[i][0]$ 设为 $1$ 。\n然后将26种情况转移即可。注意这里也不要转移上面的 $dp[i][0] = 0$ 的节点，来方便我们的处理，不用特判。\n最后答案是 $dp[root][M]$ 。\n这里比较有趣，我想了想能不能用矩阵快速幂。但是，这个地方的转移\u0008矩阵最大有可能\u0008到 $10000\\times 10000$ ，会凉凉233。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;#define ll long long #define mod 10007 #define sigma_size 26 using namespace std; const int MAXN = 7000,MAXM = 110; struct AC_automaton{ int c[MAXN][sigma_size],f[MAXN],end[MAXN]; int root,cnt; AC_automaton(){ root = cnt = 0; } void insert(char *str){ int n = strlen(str),nown = root; for(int i = 0;i\u0026lt;n;i++){ if(!c[nown][str[i]-\u0026#39;A\u0026#39;]) c[nown][str[i]-\u0026#39;A\u0026#39;] = ++cnt; nown = c[nown][str[i]-\u0026#39;A\u0026#39;];; } end[nown] |= 1; } void get_fail(){ queue\u0026lt;int\u0026gt; q; while(!q.empty()) q.pop(); for(int i = 0;i\u0026lt;sigma_size;i++){ if(c[root][i]){ f[c[root][i]] = root; q.push(c[root][i]); } } while(!q.empty()){ int nown = q.front();q.pop(); for(int i = 0;i\u0026lt;sigma_size;i++){ if(c[nown][i]){ f[c[nown][i]] = c[f[nown]][i]; end[c[nown][i]] |= end[f[c[nown][i]]]; q.push(c[nown][i]); } else c[nown][i] = c[f[nown]][i]; } } } }; AC_automaton AC; int n,m; char ch[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,ch); AC.insert(ch); } AC.get_fail(); } void solve(){ static ll dp[MAXN][MAXM]; for(int i = 0;i\u0026lt;=AC.cnt;i++) if(!AC.end[i]) dp[i][0] = 1; for(int j = 1;j\u0026lt;=m;j++){ for(int i = 0;i\u0026lt;=AC.cnt;i++){ if(!AC.end[i]){ for(int k = 0;k\u0026lt;sigma_size;k++) dp[i][j] += dp[AC.c[i][k]][j-1]; dp[i][j] %= mod; } } } int ans = 1; for(int i = 1;i\u0026lt;=m;i++){ ans *= sigma_size; ans %= mod; } printf(\u0026#34;%lld\\n\u0026#34;,(ans-dp[0][m]+mod)%mod); } int main(){ init(); solve(); return 0; }   ","description":"","id":152,"section":"posts","tags":["字符串","AC自动机","动态规划"],"title":"「JSOI2007」文本生成器-AC自动机+dp","uri":"https://blog.chenqiqian.com/posts/jsoi2007-generator/"},{"content":"对于一个 $0/1$ 字符串，如果将这个字符串 $0$ 和 $1$ 取反后，再将整个串反过来和原串一样，就称作“反对称”字符串。比如 $00001111$ 和 $010101$ 就是反对称的， $1001$ 就不是。\n现在给出一个长度为 $n$ 的 $0/1$ 字符串，求它有多少个子串是反对称的。\n链接 LOJ 2452\nLuogu P3501\n题解 本题是胡搞过去的\u0026hellip;正解好像是回文自动机\u0026hellip;后缀数组复杂度多一个 $\\log$ \u0026hellip;然后就被卡的死死的emmm最后 LOJ 1000ms 极限操作233\n注意到\u0026hellip;一个串如果想是反对称的，首先要是偶数长度。而且从中间劈开往两边看每个对应位置都相反。\n所以我们可以把 这个串+分隔符+这个串的反向\u0026amp;取反 搞一个后缀数组出来，然后枚举中间点，在前后串对应位置取 LCP 就是可能的大小，然后求和即可。\n如果后缀数组和ST表的初始化复杂度是 $O(n \\log n)$ ，最后 $n$ 次查询每次复杂度都是 $O(n)$ 。\n时间复杂度是 $O(n \\log {n})$ ，比正解多一个 $\\log$ 勉强卡过233\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  // Code By Chen Qiqian on 2018.08.10 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; inline int min(int a,int b){return a\u0026gt;b?b:a;} int n,m; const int MAXN = 1000100,logn = 20; namespace SA{ int s[MAXN],sa[MAXN],rk[MAXN],x[MAXN],y[MAXN],ht[MAXN]; int cnt[MAXN]; void get_SA(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (s[sa[i]]!=s[sa[i-1]])?++m:m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k = j;i\u0026lt;n;i++) if(sa[i]\u0026gt;=j) y[k++] = sa[i]-j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]]!=y[sa[i-1]] || y[sa[i]+j]!=y[sa[i-1]+j])?++m:m; } } void getheight(int n){ for(int i = 0, h = ht[0] = 0;i\u0026lt;n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n\u0026amp;\u0026amp;j+h\u0026lt;n\u0026amp;\u0026amp;s[i+h]==s[j+h]) h++; if(ht[rk[i]] = h) --h; } } void build(int n){ ++n; get_SA(n,4); getheight(n); } } int _log[MAXN]; namespace ST{ int minn[MAXN][logn]; void build(int n,int *num){ for(int i = 1;i\u0026lt;=n;i++) _log[i] = _log[i-1] + ((i==(1\u0026lt;\u0026lt;(_log[i-1]+1)))?1:0); int l = _log[n]; for(int i = 0;i\u0026lt;=n;i++) minn[i][0] = num[i]; for(int j = 1;j\u0026lt;=l;j++){ for(int i = 0;i+(1\u0026lt;\u0026lt;(j-1))\u0026lt;=n;i++){ minn[i][j] = min(minn[i][j-1],minn[i+(1\u0026lt;\u0026lt;(j-1))][j-1]); } } } int query(int l,int r){ int t = _log[r-l+1]; return min(minn[l][t],minn[r-(1\u0026lt;\u0026lt;t)+1][t]); } } int lcp(int x,int y){ if(x == y) return n-x+1; x = SA::rk[x],y = SA::rk[y]; if(x \u0026gt; y) swap(x,y); return ST::query(x+1,y); } char s[MAXN]; void init(){ scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;m); fread(s,MAXN,1,stdin); for(int i = 0;i\u0026lt;m;i++) SA::s[n++] = s[i] - (\u0026#39;0\u0026#39;-1); reverse(s,s+n); SA::s[n++] = 3; for(int i = 0;i\u0026lt;m;i++) SA::s[n++] = (s[i]^1) - (\u0026#39;0\u0026#39;-1); SA::s[n] = 0; SA::build(n); ST::build(n+1,SA::ht); } void solve(){ long long ans = 0; for(int i = 0;i\u0026lt;m;i++){ ans += lcp(i+1,n-i-1); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":153,"section":"posts","tags":["字符串","后缀数组"],"title":"「POI2010」Antisymmetry-后缀数组","uri":"https://blog.chenqiqian.com/posts/poi2010-antisymmetry/"},{"content":"可读版题意：\n给定 $n$ 个字符串，第 $i$ 个字符串的长度为 $M_i$ ，求每个字符串在所有字符串中出现的次数。\n数据范围：$n \\leq 100,\\ M = \\sum M_i \\leq 10^6$.\n原题面：\n小张最近在忙毕设,所以一直在读论文。一篇论文是由许多单词组成但小张发现一个单词会在论文中出现很多次,他想知道每个单词分别在论文中出现了多少次。\n链接 Luogu P3966\n题解 首先我们加不同的分隔符，将所有字符串拼成一个整串。\n注意到这个问题，其实可以转化为\u0008\u0008若干个子串在母串中的出现次数。\n\u0008套路题吧\u0026hellip;找到这个子串出现位置的后缀在 $ht$ 数组里面的位置，往两侧延伸（这个地方二分答案），看最多的 $ht \\geq len$ 的范围，这个区间里面的所有串都是出现的位置。然后计算一下长度\u0008就可以得到答案。\n时间复杂度 $O(M \\log {M} + n \\log{M})$ 。\n\u0008开始写了一个 $O(NM)$ 的暴力\u0008死活过不去，还以为自己常数\u0008大\u0026hellip;233\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 1001000,logn = 21,MAXM = 300; namespace SA{ int s[MAXN],sa[MAXN],rk[MAXN],x[MAXN],y[MAXN],ht[MAXN]; int cnt[MAXN]; void get_SA(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] != s[sa[i-1]]?++m:m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k = j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i]-j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = (y[sa[i]]!=y[sa[i-1]] || y[sa[i]+j]!=y[sa[i-1]+j])?++m:m; } } void getheight(int n){ for(int i = 0,h = ht[0] = 0;i\u0026lt;n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n\u0026amp;\u0026amp;j+h\u0026lt;n\u0026amp;\u0026amp;s[i+h]==s[j+h]) ++h; if(ht[rk[i]] = h) --h; } } template \u0026lt;typename T\u0026gt; void build(int n,const T *str){ int m = 128+200;++n; for(int i = 0;i\u0026lt;n;i++) s[i] = str[i]; get_SA(n,m); getheight(n); } } namespace ST{ int minn[MAXN][logn]; void build(int n,int *num){ int l = log2(n); for(int i = 0;i\u0026lt;=n;i++) minn[i][0] = num[i]; for(int j = 1;j\u0026lt;=l;j++){ for(int i = 0;i+(1\u0026lt;\u0026lt;(j-1))\u0026lt;=n;i++){ minn[i][j] = min(minn[i+(1\u0026lt;\u0026lt;(j-1))][j-1],minn[i][j-1]); } } } int query(int l,int r){ int t = log2(r-l+1); return min(minn[l][t],minn[r-(1\u0026lt;\u0026lt;t)+1][t]); } } int n,m; int query(int p,int len){ p = SA::rk[p]; int l,r,b = 0,e = p; while(b!=e){ int mid = (b+e)\u0026gt;\u0026gt;1; if(ST::query(mid+1,p)\u0026lt;len) b = mid+1; else e = mid; } l = b; b = p+1,e = n; while(b!=e){ int mid = (b+e)\u0026gt;\u0026gt;1; if(ST::query(p+1,mid)\u0026gt;=len) b = mid+1; else e = mid; } r = b; return r-l; } int ans[MAXM]; int b[MAXM],len[MAXM]; int s[MAXN];char t[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%s\u0026#34;,t); len[i] = strlen(t),b[i] = n; for(int j = 0;j\u0026lt;len[i];j++) s[n++] = t[j]; s[n++] = 127+i; } s[n] = \u0026#39;a\u0026#39; - 1; SA::build(n,s); ST::build(n+1,SA::ht); } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ printf(\u0026#34;%d\\n\u0026#34;,query(b[i],len[i])); } } int main(){ init(); solve(); return 0; }   ","description":"","id":154,"section":"posts","tags":["字符串","后缀数组"],"title":"「TJOI2013」单词-后缀数组+二分","uri":"https://blog.chenqiqian.com/posts/tjoi2013-word/"},{"content":"阿申准备报名参加 $GT$ 考试，准考证号为 $n$ 位数 $X_1X_2\\cdots X_n(0\\le X_i\\le 9)$，他不希望准考证号上出现不吉利的数字。\n他的不吉利数字 $A_1A_2\\cdots A_m(0\\le A_i\\le 9)$ 有 $m$ 位，不出现是指 $X_1X_2\\cdots X_n$ 中没有恰好一段等于 $A_1A_2\\cdots A_m$，$A_1$​ 和 $X_1$ 可以为 $0$。\n阿申想知道不出现不吉利数字的号码有多少种，输出模 $K$ 取余的结果。\n链接 Luogu P3193\n题解 显然dp\u0026hellip;\n令 $dp[i][j]$ 为准考证已经匹配了 $i$ 位，不吉利数字（模版）最长可以匹配了 $j$ 位的方案数。\n下一位有 $10$ 种情况，在 $nex$ 数组上分别转移即可。\n注意到 $n$ 的大小比较大， $m$ 的大小比较小，可以用矩阵快速幂化掉第一维。\n时间复杂度: $O(m^3 \\times \\log{n})$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXM = 30; int n,m,k; char s[MAXM]; int nex[MAXM]; struct Matrix{ int a[MAXM][MAXM]; Matrix(){memset(a,0,sizeof(a));} }; Matrix mul(Matrix \u0026amp;_a,Matrix \u0026amp;_b){ Matrix ans; for(int i = 0;i\u0026lt;=m;i++){ for(int j = 0;j\u0026lt;=m;j++){ for(int k = 0;k\u0026lt;=m;k++){ ans.a[i][j] += _a.a[i][k] * _b.a[k][j]; } if(ans.a[i][j] \u0026gt;= k) ans.a[i][j] %= k; } } return ans; } Matrix pow(Matrix x,int k){ Matrix ans; for(int i = 0;i\u0026lt;=m;i++) ans.a[i][i] = 1; for(int i = k;i;i\u0026gt;\u0026gt;=1,x = mul(x,x)) if(i \u0026amp; 1) ans = mul(ans,x); return ans; } void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k); scanf(\u0026#34;%s\u0026#34;,s); } //dp[i][j]表示已经匹配了i位，模版已经匹配了j位  void get_next(){ nex[0] = 0; int j = 0; for(int i = 1;i\u0026lt;m;i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = nex[j-1]; if(s[i] == s[j]) j++; nex[i] = j; } } void solve(){ get_next(); Matrix tmp; for(int i = 0;i\u0026lt;m;i++){ int t = i; for(int w = \u0026#39;0\u0026#39;;w\u0026lt;=\u0026#39;9\u0026#39;;w++){ t = i; while(t \u0026gt; 0 \u0026amp;\u0026amp; s[t] != w) t = nex[t-1]; if(s[t] == w) t++; tmp.a[t][i]++; } } tmp = pow(tmp,n); int ans = 0; for(int i = 0;i\u0026lt;m;i++){ ans += tmp.a[i][0]; } ans %= k; printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":155,"section":"posts","tags":["动态规划","KMP","矩阵快速幂"],"title":"「HNOI2008」GT考试-KMP+dp+矩阵快速幂","uri":"https://blog.chenqiqian.com/posts/hnoi2008-gtexams/"},{"content":"二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。\n链接 Luogu P2444\n题解 对所有的模版串建立 AC 自动机，补全 Trie 图，在 Trie 图上找环。\n注意这里不能到达单词结束的节点，也不能到达所有 fail 节点是单词结束的点。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int MAXN = 1001000; template \u0026lt;int sigma_size\u0026gt; struct AC_automaton{ bool vis[MAXN],flag; bool instack[MAXN]; int f[MAXN],c[MAXN][sigma_size],end[MAXN]; int root,cnt; AC_automaton(){root=cnt=0;} void clear(){} //qwq  void insert(char *str){ int n = strlen(str),nown = root; for(int i = 0;i\u0026lt;n;i++){ if(!c[nown][str[i]-\u0026#39;0\u0026#39;]) c[nown][str[i]-\u0026#39;0\u0026#39;] = ++cnt; nown = c[nown][str[i]-\u0026#39;0\u0026#39;]; } end[nown] |= 1; } void get_fail(){ queue\u0026lt;int\u0026gt; q; while(!q.empty()) q.pop(); for(int i = 0;i\u0026lt;sigma_size;i++){ if(c[root][i]){ f[c[root][i]] = root; q.push(c[root][i]); } } while(!q.empty()){ int nown = q.front();q.pop(); for(int i = 0;i\u0026lt;sigma_size;i++){ if(c[nown][i]){ f[c[nown][i]] = c[f[nown]][i]; end[c[nown][i]] |= end[f[c[nown][i]]]; q.push(c[nown][i]); } else c[nown][i] = c[f[nown]][i]; } } } bool judge(){ memset(vis,0,sizeof(vis)); memset(instack,0,sizeof(instack)); flag = 0; for(int i = 0;i\u0026lt;=cnt;i++){ if(!vis[i] \u0026amp;\u0026amp; !end[i]) flag |= dfs(i); if(flag) return true; } return false; } bool dfs(int x){ instack[x] = vis[x] = 1; for(int i = 0;i\u0026lt;sigma_size;i++){ int v = c[x][i]; if(end[v]) continue; if(instack[v] || (!vis[v] \u0026amp;\u0026amp; dfs(v))) return true; } instack[x] = 0; return false; } }; AC_automaton\u0026lt;2\u0026gt; AC; int n; char s[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s); AC.insert(s); } } void solve(){ AC.get_fail(); if(AC.judge()){ printf(\u0026#34;TAK\\n\u0026#34;); } else{ printf(\u0026#34;NIE\\n\u0026#34;); } } int main(){ init(); solve(); return 0; }   ","description":"","id":156,"section":"posts","tags":["AC自动机","字符串","图论"],"title":"「POI2000」病毒-AC自动机","uri":"https://blog.chenqiqian.com/posts/poi2000-virus/"},{"content":"HH 是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为 HH 是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。\n现在给你学校的地图（假设每条路的长度都是一样的都是 $1$ ），问长度为 $t$ ，从给定地点 $A$ 走到给定地点 $B$ 共有多少条符合上述条件的路径。\n链接 Luogu P2151\n题解 可以发现这是一道dp。\n如果令状态为 $dp[i][t]$ ，在第 $i$ 个点，再走 $t$ 步到达 $B$ 点的方案数。但是我们注意到这个就很难满足：\n 他不会立刻沿着刚刚走来的路走回\n 的限制条件。\n所以我们为了体现出刚走过的边，同时还能体现出刚走过的点，就重新设计一下状态：\n令 $dp[e][t]$ 为刚刚走过第 $e$ 条边，再走 $t$ 步到达 $B$ 点的方案数。\n具体实现的时候要建两条单向边，然后状态转移方程大概是：\n$$\ndp[e][t] = \\sum dp[e'][t-1]\n$$\n其中 $e'$ 为所有从 $e.to$ 出发的边，除了 $e$ 的反向边。\n注意到这里 $t$ 的范围比较大，对于任意时候的 $t$ 和某个 $e$ ，转移的路径，也就是 $e'$ 都不会变，所以我们用矩阵快速幂优化这一过程。\n这里的模数要用 define 样式的比较好，对于常数比较有利。\n时间复杂度：$O((2m)^3 \\times \\log{t})$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; const int MAXN = 200; typedef long long ll; #define mod 45989  int n,m,t,A,B; struct Edge{ int to,nex; }edge[MAXN]; int fir[MAXN],ecnt = 2; inline void addedge(int u,int v){ edge[ecnt] = (Edge){v,fir[u]}; fir[u] = ecnt++; } struct Matrix{ ll a[MAXN][MAXN]; Matrix(){ memset(a,0,sizeof(a)); } }; inline Matrix mul(const Matrix \u0026amp;_a,const Matrix \u0026amp;_b){ Matrix tmp; for(int i = 1;i\u0026lt;=2*m;i++){ for(int j = 1;j\u0026lt;=2*m;j++){ for(int k = 1;k\u0026lt;=2*m;k++){ tmp.a[i][j] += _a.a[i][k] * _b.a[k][j]; } if(tmp.a[i][j] \u0026gt;= mod) tmp.a[i][j] %= mod; } } return tmp; } inline Matrix pow(Matrix x,int k){ Matrix ans; for(int i = 1;i\u0026lt;=2*m;i++) ans.a[i][i] = 1; for(int i = k;i;i\u0026gt;\u0026gt;=1,x = mul(x,x)){ if(i\u0026amp;1) ans = mul(ans,x); } return ans; } inline void init(){ scanf(\u0026#34;%d %d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;t,\u0026amp;A,\u0026amp;B); A++,B++; int u,v; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); u++,v++; addedge(u,v); addedge(v,u); } m++; edge[2*m] = (Edge){A,fir[0]}; fir[0] = 1; } void solve(){ Matrix M,I; for(int e = 2;e\u0026lt;=2*m;e++){ int x = edge[e].to; if(x == B) I.a[e][1] = 1; for(int nowe = fir[x];nowe;nowe = edge[nowe].nex){ if((e^1)==nowe) continue; M.a[e][nowe] = 1; } } M = pow(M,t); static ll ans[MAXN]; for(int i = 1;i\u0026lt;=2*m;i++){ for(int j = 1;j\u0026lt;=2*m;j++){ ans[i] += M.a[i][j] * I.a[j][1]; } } printf(\u0026#34;%lld\\n\u0026#34;,ans[2*m] % mod); } int main(){ init(); solve(); return 0; }   ","description":"","id":157,"section":"posts","tags":["矩阵快速幂","动态规划","图论"],"title":"「SDOI2009」HH去散步-矩阵快速幂+dp","uri":"https://blog.chenqiqian.com/posts/sdoi2009-walk/"},{"content":"有一个无向图 $G$ ，每个点有个权值，每条边有一个颜色。这个无向图满足以下两个条件：\n 对于任意节点连出去的边中，相同颜色的边不超过两条。 图中不存在同色的环，同色的环指相同颜色的边构成的环。  在这个图上，你要支持以下三种操作：\n 修改一个节点的权值。 修改一条边的颜色。 查询由颜色 $c$ 的边构成的图中， $u$ 到节点 $v$ 之间的简单路径上的节点的权值的最大值。  对于 100% 的数据，保证颜色不多于 $10$ 种。\n链接 Luogu P2173\n题解 对于每一种颜色维护一颗维护最大值的LCT，点权对于所有的树都要改，改边的颜色的话相当于删边再加边，最大值查询就好。\n错误判断的话就是LCT的正常操作，再维护一个度数就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; inline char read(){ const int SIZE = 1024*1024; static char *s,*t,ibuf[SIZE]; if(s == t) t = (s = ibuf) + fread(ibuf,1,SIZE,stdin); return s == t ? -1: (*s++); } inline void read(int \u0026amp;x){ static bool iosig = 0;char ch; for(ch = read(),iosig = 0;!isdigit(ch);ch= read()){ if(ch == \u0026#39;-\u0026#39;) iosig = 1; if(ch == -1) return; } for(x = 0;isdigit(ch);ch = read()) x = (((x\u0026lt;\u0026lt;2)+x)\u0026lt;\u0026lt;1) + (ch^48); if(iosig) x = -x; } const int MAXN = 13000; struct Link_Cat_Tree{ int v[MAXN],maxn[MAXN]; int f[MAXN],c[MAXN][2]; bool rev[MAXN]; void push_up(int x){ maxn[x] = max(max(maxn[c[x][0]],maxn[c[x][1]]),v[x]); } void reverse(int x){ swap(c[x][0],c[x][1]); rev[x] ^= 1; } void push_down(int x){ if(rev[x]){ reverse(c[x][0]),reverse(c[x][1]); rev[x] = 0; } } bool noroot(int x){ return c[f[x]][0] == x || c[f[x]][1] == x; } void push_all(int x){ if(noroot(x)) push_all(f[x]); push_down(x); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[y][t] = w,c[x][1-t] = y; if(w) f[w] = y; f[x] = z,f[y] = x; push_up(y),push_up(x); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ if((c[y][1]==x)^(c[z][1]==y)) rotate(x); else rotate(y); }rotate(x); } } void access(int x){ for(int y = 0;x;x = f[y = x]){ splay(x);c[x][1] = y; push_up(x); } } void makeroot(int x){ access(x),splay(x),reverse(x); } void split(int x,int y){//split后y位于树根（代表整条链  makeroot(x),access(y),splay(y); } int find(int x){ access(x),splay(x); push_down(x); while(c[x][0]){ x = c[x][0],push_down(x); } return x; } bool link(int x,int y){ makeroot(x); if(find(y) != x){ f[x] = y; return 1; }else return 0; } bool judge(int x,int y){ makeroot(x); return find(y) == x \u0026amp;\u0026amp; f[x] == y \u0026amp;\u0026amp; !c[x][1]; } bool cat(int x,int y){ makeroot(x);//find 之后 y 位于 树根  if(find(y) == x \u0026amp;\u0026amp; f[x] == y \u0026amp;\u0026amp; !c[x][1]){ f[x] = c[y][0] = 0;push_up(y); return 1; }else return 0; } void update(int x,int val){ makeroot(x); v[x] = val,push_up(x); } int query(int x,int y){ makeroot(x); if(find(y)!=x) return -1; else{ access(y),splay(y); return maxn[y]; } } }T[10];// Tree 0 -\u0026gt; 9 int d[MAXN][10];// degree  int n,m,c,k; void update(int x,int v){ for(int i = 0;i\u0026lt;c;i++) T[i].update(x,v); } int change(int u,int v,int w){ if(T[w].judge(u,v)) return 0; for(int i = 0;i\u0026lt;c;i++){ if(T[i].judge(u,v)){ if(d[u][w] \u0026gt;= 2 || d[v][w] \u0026gt;= 2) return 1; else{ if(!T[w].link(u,v)) return 2; else{ d[u][i]--,d[v][i]--; T[i].cat(u,v); d[u][w]++,d[v][w]++; return 0; } } } } return -1; } void init(){ read(n),read(m),read(c),read(k); int u,v,w; for(int i = 1;i\u0026lt;=n;i++){ read(v); update(i,v); } for(int i = 1;i\u0026lt;=m;i++){ read(u),read(v),read(w); T[w].link(u,v); d[u][w]++,d[v][w]++; } } int query(int u,int v,int w){ return T[w].query(u,v); } void solve(){ int op,u,v,w; for(int i = 1;i\u0026lt;=k;i++){ read(op); if(op == 0){ read(u),read(v); update(u,v); } else if(op == 1){ read(u),read(v),read(w); int t = change(u,v,w); if(t\u0026gt;0) printf(\u0026#34;Error %d.\\n\u0026#34;,t); else if(t==-1) printf(\u0026#34;No such edge.\\n\u0026#34;); else printf(\u0026#34;Success.\\n\u0026#34;); } else if(op == 2){ read(w),read(u),read(v); printf(\u0026#34;%d\\n\u0026#34;,query(u,v,w)); } } } int main(){ init(); solve(); return 0; }   ","description":"","id":158,"section":"posts","tags":["数据结构","树形结构","LCT"],"title":"「ZJOI2012」网络-LCT","uri":"https://blog.chenqiqian.com/posts/zjoi2012-network/"},{"content":"简单版题意：\n给定一个长度为 $n$ 的字符串，和一个长度为 $n$ 的数列 ${a_n}$ ，求对于 $r$ 从 $0$ 到 $n-1$ ，所有满足 $1 \\leq p \u0026lt; q \\leq n$ 且 $lcp(p,q) \\geq r$ 的数对个数以及满足上述条件的数对中 $a_p \\times a_q$ 的最大值。（ $a_i$ 可以为负数）\n完整版题意：\n一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战 两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。\n在大会的晚餐上，调酒师 $Rainbow$ 调制了 $n$ 杯鸡尾酒。这 $n$ 杯鸡尾酒排成一行，其中第 $n$ 杯酒 $(1 \\leq i \\leq n)$ 被贴上了一个标签$s_i$，每个标签都是 $26$ 个小写 英文字母之一。设 $str(l, r)$表示第 $l$ 杯酒到第 $r$ 杯酒的 $r - l + 1$个标签顺次连接构成的字符串。若 $str(p, po) = str(q, qo)$，其中 $1 \\leq p \\leq po \\leq n$, $1 \\leq q \\leq qo \\leq n$, $p ≠ q$, $po - p + 1 = qo - q + 1 = r$ ，则称第 $p$ 杯酒与第 $q$ 杯酒是“ $r$ 相似” 的。当然两杯“ $r$ 相似”$(r \u0026gt; 1)$的酒同时也是“ $1$ 相似”、“ $2$ 相似”、……、“ $(r - 1)$ 相似”的。特别地，对于任意的 $1 ≤ p$ , $q ≤ n$ ， $p ≠ q$ ，第 $p$ 杯酒和第 $q$ 杯酒都 是“ $0$ 相似”的。\n在品尝环节上，品酒师 $Freda$ 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第 $i$ 杯酒 ($1 ≤ i ≤ n$) 的 美味度为 $a_i$ 。现在 $Rainbow$ 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 $p$ 杯酒与第 $q$ 杯酒调兑在一起，将得到一杯美味度为 $a_p \\times a_q$ 的酒。现在请各位品酒师分别对于 $r = 0,1,2, ⋯ , n - 1$ ，统计出有多少种方法可以 选出 $2$ 杯“ $r$ 相似”的酒，并回答选择 $2$ 杯“ $r$ 相似”的酒调兑可以得到的美味度的最大值。\n链接 Luogu P2178\n题解 注意到这个东西有 LCP ，所以我们可以上后缀数组乱怼。\n$O(n^2)$ 的做法是显而易见的，只需要枚举 $p,q$ ，更新LCP位置的值，从大往小再扫一遍就可以了。\n事实上问题所求的东西可以转化成：恰好为 $r$ 的最大值，恰好为 $r$ 的数目。\n构造出 height 数组，我们可以发现，所有 lcp 恰好为 $r$ 的数对，必然经过至少一个 height 为 $r$ 的位置，而且它们经过的区域的 height 应该全都大于等于 $r$ ，随着 $r$ 的减小这个区域是在不断扩大的，事实上就是大于 $r$ 的联通块在不断减少。\n用一个并查集维护一下就好。每次连接两个集合 $x,y$ ，都会产生 $siz[x] \\times siz[y]$ 对这样的数对。\n因为有负数，所以为了获得最大值，这里我们要同时维护最大、最小值。\n这道题细节挺多的，有一个地方不能合并，要特殊处理 $0$ 相似，令人窒息。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; #define inf 0x3f3f3f3f #define ll long long  const int MAXN = 310000; namespace fast_io{ //... }using namespace fast_io; namespace SA{ int s[MAXN],sa[MAXN],ht[MAXN],rk[MAXN],x[MAXN],y[MAXN],cnt[MAXN]; void get_sa(int n,int m){ for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[s[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[s[i]]] = i; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] = s[sa[i]] != s[sa[i-1]]?++m:m; for(int j = 1;;j\u0026lt;\u0026lt;=1){ if(++m == n) break; for(int i = 0;i\u0026lt;j;i++) y[i] = n-j+i; for(int i = 0,k=j;i\u0026lt;n;i++) if(sa[i] \u0026gt;= j) y[k++] = sa[i]-j; for(int i = 0;i\u0026lt;n;i++) x[i] = rk[y[i]]; for(int i = 0;i\u0026lt;m;i++) cnt[i] = 0; for(int i = 0;i\u0026lt;n;i++) cnt[x[i]]++; for(int i = 1;i\u0026lt;m;i++) cnt[i] += cnt[i-1]; for(int i = n-1;~i;--i) sa[--cnt[x[i]]] = y[i],y[i] = rk[i]; m = rk[sa[0]] = 0; for(int i = 1;i\u0026lt;n;i++) rk[sa[i]] =(y[sa[i]]!=y[sa[i-1]]||y[sa[i]+j]!=y[sa[i-1]+j])?++m:m; } } template\u0026lt;typename T\u0026gt; int mapCharToInt(int n,const T *str){ int m = *max_element(str,str+n); for(int i = 0;i\u0026lt;=m;i++) rk[i] = 0; for(int i = 0;i\u0026lt;n;i++) rk[(int)(str[i])] = 1; for(int i = 1;i\u0026lt;=m;i++) rk[i] += rk[i-1]; for(int i = 0;i\u0026lt;n;i++) s[i] = rk[(int)(str[i])]-1; return rk[m]; } void getheight(int n){ for(int i = 0,h = ht[0] = 0;i\u0026lt;n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n\u0026amp;\u0026amp;j+h\u0026lt;n\u0026amp;\u0026amp;s[i+h]==s[j+h]) h++; if(ht[rk[i]] = h) h--; } } void build(int n,char *str){ int m = mapCharToInt(++n,str); get_sa(n,m); getheight(n); } } namespace BCJ{ int f[MAXN],siz[MAXN]; ll maxn[MAXN],minn[MAXN]; void init(int n,ll * val){ for(int i = 0;i\u0026lt;=n;i++){ f[i] = i,siz[i] = 1; maxn[i] = minn[i] = val[i]; } } int find(int x){ return f[x] == x?x:f[x] = find(f[x]); } bool same(int x,int y){ return find(x) == find(y); } ll unite(int x,int y,ll \u0026amp;ans){ int fx = find(x),fy = find(y); if(fx == fy) return 0; ans = max(ans,maxn[fx]*maxn[fy]); ans = max(ans,minn[fx]*minn[fy]); f[fy] = fx; minn[fx] = min(minn[fx],minn[fy]); maxn[fx] = max(maxn[fx],maxn[fy]); ll res = 1LL*siz[fx] * siz[fy]; siz[fx] += siz[fy]; return res; } } bool cmp(int a,int b){ return SA::ht[a] \u0026gt; SA::ht[b]; } char str[MAXN]; int n,m; ll a[MAXN],ans[MAXN],cnt[MAXN]; void init(){ static ll min1 = inf,min2 = inf,max1 = -inf,max2 = -inf; read(n); read(str); str[n] = \u0026#39;a\u0026#39;-1; for(int i = 1;i\u0026lt;=n;i++){ read(a[i]); if(a[i] \u0026lt; min1) min1=a[i]; else if(a[i] \u0026lt; min2) min2=a[i]; if(a[i] \u0026gt; max1) max1=a[i]; else if(a[i] \u0026gt; max2) max2=a[i]; ans[i] = -1LL*inf*inf; } ans[0] = max(max1*max2,min1*min2); } void solve(){ static int h[MAXN]; SA::build(n,str); BCJ::init(n,a); for(int i = 1;i\u0026lt;=n;i++) h[i] = i; sort(h+1,h+n+1,cmp); for(int i = 1;i\u0026lt;=n;i++){ int x = h[i],ht = SA::ht[x]; if(x!=1) cnt[ht] += BCJ::unite(SA::sa[x]+1,SA::sa[x-1]+1,ans[ht]); } for(int i = n-2;i\u0026gt;=0;i--){ cnt[i] += cnt[i+1]; ans[i] = max(ans[i],ans[i+1]); } cnt[0] = 1LL*n*(n-1)/2; for(int i = 0;i\u0026lt;n;i++){ if(!cnt[i]) ans[i] = 0; print(cnt[i]),print(\u0026#39; \u0026#39;),print(ans[i]),print(\u0026#39;\\n\u0026#39;); } } signed main(){ init(); solve(); flush(); return 0; }   ","description":"","id":159,"section":"posts","tags":["字符串","后缀数组","并查集"],"title":"「NOI2015」品酒大会-后缀数组","uri":"https://blog.chenqiqian.com/posts/noi2015-savour/"},{"content":"系统将依次随机抛出 $k$ 次宝物，每次你都可以选择吃或者不吃。宝物一共有 $n$ 种，系统每次抛出这 $n$ 种宝物的概率都相同且相互独立。\n吃一次第 $i$ 种宝物将得到 $P_i$ 分，但并不是每种宝物都是可以随意获取的。第 $i$ 种宝物有一个前提宝物集合 $S_i$ 。只有当 $S_i$ 中所有宝物都至少吃过一次，才能吃第 $i$ 种宝物。注意，$P_i$ 可以是负数。\n假设你采取最优策略，平均情况你一共能在奖励关得到多少分值？\n链接 Luogu P2473\n题解 为了方便最后答案的计算，我们设 $dp[i][S]$ 为当前已经吃了 $i$ 次，并且已经吃到的宝物的集合为 $S$ ，到最后（吃完 $k$ 次）能够获得。\n然后状态转移（ $W_i$ 为单独取 $i$ 的集合）：\n$$\ndp[i][S] = \\frac{1}{n}\\sum _ {i = 1}^{n}\n\\begin{cases}\nmin(dp[i+1][S],dp[i+1][S \\cup W_i] + P_i),S_i \\subset S\\\ndp[i+1][S],S_i \\not\\subset S\n\\end{cases}\n$$\n状压，转移即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 110; int k,n; int q[MAXN],p[MAXN],t; double dp[MAXN][1\u0026lt;\u0026lt;16];//1\u0026lt;\u0026lt;type代表第i种  void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;k,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;p[i],\u0026amp;t); while(t!=0) q[i] |= (1\u0026lt;\u0026lt;(t-1)),scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); } } void solve(){ for(int i = k-1;i\u0026gt;=0;i--){ for(int j = 0;j\u0026lt;=(1\u0026lt;\u0026lt;n)-1;j++){ for(int w = 1;w\u0026lt;=n;w++) dp[i][j] += max(dp[i+1][j],(q[w]\u0026amp;j)==q[w]?dp[i+1][j|(1\u0026lt;\u0026lt;w-1)]+p[w]:-1e9); dp[i][j]/=n; } } printf(\u0026#34;%.6lf\\n\u0026#34;,dp[0][0]); } int main(){ init(); solve(); return 0; }   ","description":"","id":160,"section":"posts","tags":["动态规划","期望dp"],"title":"「SCOI2008」奖励关-期望dp","uri":"https://blog.chenqiqian.com/posts/scoi2008-award/"},{"content":"现在有一棵二叉树，所有非叶子节点都有两个孩子。在每个叶子节点上有一个权值(有 $n$ 个叶子节点，满足这些权值为 $1\u0026hellip;n$ 的一个排列)。可以任意交换每个非叶子节点的左右孩子。\n要求进行一系列交换，使得最终所有叶子节点的权值按照前序遍历序写出来，逆序对个数最少。\n输入方式：\n第一行一个整数n；\n下面每行，一个数x；\n 如果 $x==0$ ，表示这个节点非叶子节点，递归地向下读入其左孩子和右孩子的信息； 如果 $x!=0$ ，表示这个节点是叶子节点，权值为$x$。  链接 Luogu P3521// 数据太弱\nLOJ 2163 // 单点时限0.2s 十分适合卡常\n题解 线段树合并 这里的线段树合并讨论的都是动态开点的线段树的合并。\n我们注意到，如果给定元素个数（值域区间），那么这个线段树的每个节点对应的区间是唯一确定的，这也是我们可以在一个较低的复杂度里面将若干棵动态开点的线段树合到一起去的一个基础。\n我们在这里假设我们可以在 $O(1)$ 的时间里面合并两个树的叶子的信息，并从线段树的两个子树 $O(1)$ 的得到更大的区间的信息（区间合并），其实这也是线段树的基础。\n我们其实可以暴力的写出合并的伪代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13  node merge(node u,node v): if u,v 中存在一个节点为空节点: return 另一个节点 // O(1)  if u,v 均为叶节点: return 合并u,v 两个叶节点 // O(1)  u.leftchild = merge(u.leftchild,v.leftchild) u.rightchild = merge(u.rightchild,v.rightchild) 合并 u.leftchild 和 u.rightchild 的信息为 u // O(1)  return u   线段树合并的过程也可以很容易的可持久化，只需要把上面的代码中后面的几个 $u$ 修改成一个新创建的 $w$ 即可。\n关于复杂度，可以显而易见的注意到， merge 两个动态开点线段树的时候，其复杂度与公共节点的数量成正比，也就是减少的节点数目。\n动态开点线段树每次插入一个节点，其空间会增加 $\\log n$ 。这样如果我们有了 $n$ 颗只有一个节点的动态开点线段树，总共的点有 $O(n \\log n)$ 个。\n如果将这样 $n$ 个动态开点的线段树合并到一棵线段树，最后剩下的节点数是在 $O(n)$ 量级的，减少的节点数目是在 $O(n \\log n)$ 量级的，所以这样合并的时间复杂度是 $O(n \\log n)$ 。\n题目解法 这道题主要就是权值线段树合并的一个过程。我们对每个叶子结点开一个权值线段树，然后逐步合并。\n考虑到一件事情：如果在原树有一个根节点x，和其左儿子 $ls$ ，右儿子 $rs$ 。我们要合并的是 $ls$ 的权值线段树和 $rs$ 的权值线段树。\n发现交换 $ls$ 和 $rs$ 并不会对更上层之间的逆序对产生影响，于是我们只需要每次合并都让逆序对最少。\n于是我们的问题转化为了给定两个权值线段树，问把它们哪个放在左边可以使逆序对个数最小，为多少。\n考虑我们合并到一个节点，其权值范围为 $[l,r]$ ，中点为 $mid$ 。这个时候我们有两棵树，我们要分别计算出某棵树在左边的时候和某棵树在右边的时候的逆序对个数。事实上我们只需要处理权值跨过中点 $mid$ 的逆序对，那么所有的逆序对都会在递归过程中被处理仅一次（类似一个分治的过程）。而我们这个时候可以轻易的算出两种情况的逆序对个数，不交换的话是左边那棵树的右半边乘上左边那棵树的的右半边的大小；交换的话则是左边那棵树的左半边乘上左边那棵树的的左半边的大小。\n然后每次合并由于都可以交换左右子树，我们就把这次合并中交换和不交换的情况计算一下，取最小值累积就可以了。\n空间复杂度：$O(n \\log n)$ ，时间复杂度 $O(n \\log n)$ 。\n另，洛谷上这题数据极弱，LOJ上的数据就很强，线段树合并卡过去略微费劲，可以体验一下不断 $TLE$ 的感觉qwq。\n另另，这道题的读入很迷，附上一点人话：\n 第一行一个数 $n$ ，表示该二叉树的叶节点的个数；\n下面若干行，每行一个数 $x$ ：\n如果 $x = 0$ ，表示这个节点不是叶节点，递归地向下读入其左孩子和右孩子的信息；\n如果 $x \\neq 0$ ，表示这个节点是叶节点，权值为 $x$ 。\n 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; #define mid ((l+r)\u0026gt;\u0026gt;1) typedef long long ll; inline char read(){ static const int SIZE = 1024*1024; static char *s,*t,ibuf[SIZE]; if(s == t) t = (s=ibuf) + fread(ibuf,1,SIZE,stdin); return s == t ? -1:(*s++); } template\u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x){ static bool iosig = 0;static char ch; for(ch = read(),iosig = 0;!isdigit(ch);ch = read()){ if(ch == -1) return; if(ch ==\u0026#39;-\u0026#39;) iosig = 1; } for(x = 0;isdigit(ch);ch =read()) x = (((x\u0026lt;\u0026lt;2)+x)\u0026lt;\u0026lt;1) + (ch^48); if(iosig) x = -x; } inline ll min(ll a,ll b){ return a \u0026gt; b?b : a; } const int MAXN = 210000; ll ANS = 0,ans1 = 0,ans2 = 0; int n,pos; struct node{ int sumn,ls,rs; }aa[MAXN*30]; int cnt = 0; void update(int \u0026amp;nown,int l,int r){ if(!nown) nown = ++cnt; aa[nown].sumn++; if(l == r) return; if(pos \u0026lt;= mid) update(aa[nown].ls,l,mid); else update(aa[nown].rs,mid+1,r); } void merge(int \u0026amp;lx,int rx){ if(!lx || !rx){lx=lx+rx;return;} aa[lx].sumn += aa[rx].sumn; ans1 += (ll)aa[aa[lx].rs].sumn*aa[aa[rx].ls].sumn; ans2 += (ll)aa[aa[lx].ls].sumn*aa[aa[rx].rs].sumn; merge(aa[lx].ls,aa[rx].ls); merge(aa[lx].rs,aa[rx].rs); } void solve(int \u0026amp;x){ int t,ls,rs;x = 0; read(t); if(!t){ solve(ls),solve(rs); ans1 = ans2 = 0; x = ls;merge(x,rs); ANS += min(ans1,ans2); } else pos = t,update(x,1,n); } signed main(){ read(n); int t = 0; solve(t); printf(\u0026#34;%lld\\n\u0026#34;,ANS); return 0; }   ","description":"","id":161,"section":"posts","tags":["数据结构","线段树","树形结构","线段树合并"],"title":"「POI2011」Tree Rotations-线段树合并","uri":"https://blog.chenqiqian.com/posts/poi2011-tree-rotations/"},{"content":"有 $m$ 个骑士攻占 $n$ 个城池。除 $1$ 号城池外，城池 $i$ 会受到另一座城池 $f_i$ 的管辖，其中 $f_i \u0026lt; i$。也就是说，所有城池构成了一棵有根树。第 $i$ 个骑士的初始战斗力为 $s_i$，第一个攻击的城池为 $c_i$。\n每个城池有一个防御值 $h_i$，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 $1$ 号城池，或牺牲为止。\n除 $1$ 号城池外，每个城池 $i$ 会给出一个战斗力变化参数 $a_i$;$v_i$。若 $a_i = 0$，攻占城池 $i$ 以后骑士战斗力会增加 $v_i$；若 $a_i = 1$，攻占城池 $i$ 以后，战斗力会乘以 $v_i$。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。\n对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。\n链接 Luogu P3261\n题解 这个问题是可以离线的，我们不需要在线的回答每一个骑士的问题。\n所以我们思考如何对于这个问题进行处理。\n考虑所有到达某个节点的人。在这些人中，都会有一些攻击力最小的人在这个节点死掉。这个时候剩下的人的攻击力的大小关系并不会改变。\n所以我们有两个选择：平衡树、堆。\n这个时候我们思考一下对于所有下面活着的人如何再攻击上面的城池。这个时候其实就是所有某个节点所有的子节点的活着的人合并到一起。用启发式合并的话，复杂度是$O(n \\log^2 n)$，如果用左偏树的话，复杂度就是$O(n \\log n)$。\n在最上面添加一个虚拟的节点把所有人都牺牲了就好。\n这里的加法和乘法类似线段树，维护lazy标记下传即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;typedef long long ll; using namespace std; namespace fast_io{ //... }using namespace fast_io; const int MAXN = 310000; namespace MH{ int l[MAXN],r[MAXN],d[MAXN]; ll v[MAXN],addn[MAXN],muln[MAXN]; inline void add(int x,ll val){ if(!x) return; v[x]+=val,addn[x]+=val; } inline void mul(int x,ll val){ if(!x) return; v[x]*=val,addn[x]*=val,muln[x] *= val; } inline void push_down(int x){ if(!x) return; if(muln[x]!=1){ mul(l[x],muln[x]),mul(r[x],muln[x]); muln[x] = 1; } if(addn[x]){ add(l[x],addn[x]),add(r[x],addn[x]); addn[x] = 0; } } inline int merge(int x,int y){ if(x == y) return x; if(!x || !y) return x+y; if(v[x] \u0026gt; v[y]) swap(x,y); push_down(x); r[x] = merge(r[x],y); if(d[l[x]] \u0026lt; d[r[x]]) swap(l[x],r[x]); d[x] = d[r[x]] + 1; return x; } inline ll top(int x){ return v[x]; } inline int del(int x){ push_down(x); int t = merge(l[x],r[x]); l[x] = r[x] = d[x] = 0; return t; } inline void init(int n,ll *num){ for(int i = 1;i\u0026lt;=n;i++) v[i] = num[i],l[i] = r[i] = d[i] = addn[i] = 0,muln[i] = 1; } } int n,m,root; ll h[MAXN]; int f[MAXN],a[MAXN];ll v[MAXN]; ll s[MAXN];int c[MAXN],dep[MAXN]; int ans1[MAXN],ans2[MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; vector\u0026lt;int\u0026gt; st[MAXN]; void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(h[i]); for(int i = 2;i\u0026lt;=n;i++){ read(f[i]),read(a[i]),read(v[i]); edge[f[i]].push_back(i); } for(int i = 1;i\u0026lt;=m;i++){ read(s[i]),read(c[i]); st[c[i]].push_back(i); } root = m+1; edge[root].push_back(1); h[root] = (long long)(1e18); MH::init(m,s); } int dfs(int nown){ int ans = 0,tmp = 0; for(int i = 0;i \u0026lt; edge[nown].size();i++){ int v = edge[nown][i]; dep[v] = dep[nown] + 1; tmp = dfs(v); ans = MH::merge(ans,tmp); } for(int i = 0;i\u0026lt;st[nown].size();i++) ans = MH::merge(st[nown][i],ans); while(MH::top(ans) \u0026lt; h[nown] \u0026amp;\u0026amp; ans!=0){ ans1[nown]++; tmp = ans; ans2[tmp] = dep[c[tmp]] - dep[nown]; ans = MH::del(ans); } if(a[nown] == 0) MH::add(ans,v[nown]); else if(a[nown] == 1) MH::mul(ans,v[nown]); return ans; } void output(){ for(int i = 1;i\u0026lt;=n;i++) print(ans1[i]),print(\u0026#39;\\n\u0026#39;); for(int i = 1;i\u0026lt;=m;i++) print(ans2[i]),print(\u0026#39;\\n\u0026#39;); } signed main(){ init(); dfs(root); output(); flush(); return 0; }   ","description":"","id":162,"section":"posts","tags":["左偏树","数据结构"],"title":"「JLOI2015」城池攻占-左偏树","uri":"https://blog.chenqiqian.com/posts/jloi2015-fail/"},{"content":"给定一棵有根树，每个点有一个代价 $C_i$ ，权值 $L_i$ ，要求从这个树某个节点 $k$ 的子树（包含该节点）选取若干个节点，使得选取节点的个数乘上节点 $k$ 的权值最大，且这若干个节点的代价和不超过给定的限制 $M$ 。\n链接 Luogu P1552\n题解 可以用一定的贪心的思想。\n如果确定了一个根结点 $k$ ，那么我们的问题就转化成在 $M$ 的限制内，取最多的节点。\n对于每个节点，如果我们知道它的子节点的最优的满足 $M$ 的限制的若干节点，那么可以证明合并之后的所有最优节点肯定都只会来自于子节点的最优节点。这是非常显然的。\n所以我们用左偏树（大根堆）合并，对于每个节点 pop 掉最大的若干个节点使其符合限制，然后尝试更新答案。\n然后子树合并得到根结点的情况，dfs处理即可。\n最后时间复杂度大概是 $O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; typedef long long ll; const int MAXN = 200000; namespace MH{ ll v[MAXN],sum[MAXN],siz[MAXN]; int l[MAXN],r[MAXN],d[MAXN]; void push_up(int x){ if(!x) return; sum[x] = sum[l[x]] + v[x] + sum[r[x]]; siz[x] = siz[l[x]] + 1 + siz[r[x]]; } int merge(int x,int y){ if(x == y) return x; if(!x || !y) return x+y; if(v[x] \u0026lt; v[y]) swap(x,y); r[x] = merge(r[x],y); if(d[l[x]] \u0026lt; d[r[x]]) swap(l[x],r[x]); d[x] = d[r[x]] + 1; push_up(x); return x; } int del(int x){ int t = merge(l[x],r[x]); sum[x] = v[x],l[x] = r[x] = d[x] = 0; return t; } ll top(int x){ return v[x]; } void init(int n,ll *num){ for(int i = 1;i\u0026lt;=n;i++){ v[i] = sum[i] = num[i],siz[i] = 1,l[i] = r[i] = d[i] = 0; } } void print(int n){ printf(\u0026#34;----------------------\\n\u0026#34;); for(int i = 1;i\u0026lt;=n;i++){ printf(\u0026#34;%d: v:%lld sum:%lld siz:%lld son:%d %d d:%d\\n\u0026#34;,i,v[i],sum[i],siz[i],l[i],r[i],d[i]); } printf(\u0026#34;----------------------\\n\u0026#34;); } } int n,m,root; ll fans; vector\u0026lt;int\u0026gt; edge[MAXN]; int f[MAXN];ll s[MAXN], l[MAXN]; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); root = n + 1; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %lld %lld\u0026#34;,\u0026amp;f[i],\u0026amp;s[i],\u0026amp;l[i]); if(f[i] == 0) f[i] = root; } for(int i = 1;i\u0026lt;=n;i++) edge[f[i]].push_back(i); fans = -1; MH::init(n,s); } int dfs(int x){ int ans = x,tmp; for(int i = 0;i\u0026lt;edge[x].size();i++){ int v = edge[x][i]; tmp = dfs(v); ans = MH::merge(ans,tmp); } while(MH::sum[ans] \u0026gt; m \u0026amp;\u0026amp; ans!=0) ans = MH::del(ans); fans = max(fans,l[x] * MH::siz[ans]); return ans; } int main(){ init(); dfs(root); printf(\u0026#34;%lld\\n\u0026#34;,fans); return 0; }   ","description":"","id":163,"section":"posts","tags":["左偏树","数据结构"],"title":"「APIO2012」派遣-左偏树","uri":"https://blog.chenqiqian.com/posts/apio2012-dispatching/"},{"content":"左偏树是一种以二叉树为基础的数据结构，可以用来实现可以在$O(\\log n)$时间内合并的堆。\n定义 左偏树是一颗二叉树, 每个节点具有四个属性: 左儿子 ($lc$), 右儿子($rc$), 键值 ($key$), 距离 ($dis$)。\n左偏树要求满足左右儿子的键值不小于该节点的键值 (小根堆时)。 节点 $i$ 的距离指的是从节点 $i$ 往下走, 最短的能走到外节点的路径长度。\n这里的外节点指的是两个儿子不是均存在的节点。\n性质 性质1 可以发现一个节点 $i$ 的距离等于以节点 $i$ 为根的子树的最右路径的\n长度。\n证明：递归证明即可。\n性质2 如果一颗左偏树有 $n$ 个节点, 则该左偏树的距离不会超过\n$⌊log(n + 1)⌋ − 1$。\n证明：因为上面的$dis$层都需要填满，所以距离必须要小于$\\log n$。\n实现 合并 这个操作是左偏树的核心。\n我们用$u$和$v$代表我们需要合并的两颗左偏树的根节点。\n令$u.key \u0026lt; v.key$，那么我们先合并$u.rc$和$v$，将其作为$u$的右节点，然后检查$u.lc.dis$和$u.rc.dis$的大小关系并检查是否满足左偏树性质，然后再更新根结点的$u.dis = u.rc.dis + 1$。\n复杂度的话，每次合并的时候至少有一棵子树的$dis$消减$1$，总共的$dis$是在$\\log n$级别的，所以复杂度也就是$O(\\log n)$。\n插入 合并一个节点和一颗左偏树即可。\n最值 直接取根节点的值即可。\n删除最值 合并根节点的左右子树即可。\n复杂度 一些复杂度：\n 建堆：$O(n)$ 插入一个节点：$O(\\log n)$ 查询最值：$O(1)$ 删除最值：$O(\\log n)$ 删除任意节点：最坏$O(n)$，一般$O(\\log n)$(存疑) 合并两个堆：$O(\\log n)$  一些事情：\n左偏树的深度是可以到$O(n)$的，所以我们查询一个点所属的堆应该要再用一个并查集维护每个节点对应的最值点（根节点），复杂度才是正确的。（下面的还没有改）\n代码 以Luogu P3377【模板】左偏树（可并堆）为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  // luogu-judger-enable-o2 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { // ... }using namespace fast_io; const int MAXN = 500000; namespace Merge_Heap{ int v[MAXN],l[MAXN],r[MAXN],d[MAXN],f[MAXN]; bool vis[MAXN]; int __merge(int x,int y){ if(x == y) return x; if(!x || !y) return x+y; if(v[x] \u0026gt; v[y] || (v[x] == v[y] \u0026amp;\u0026amp; x \u0026gt; y)) swap(x,y); r[x] = __merge(r[x],y); f[r[x]] = x;// 维护父亲  if(d[l[x]] \u0026lt; d[r[x]]) swap(l[x],r[x]); d[x] = d[r[x]] + 1; return x; } int __pop(int x){ f[l[x]] = f[r[x]] = 0; int t = __merge(l[x],r[x]); l[x] = r[x] = 0; return t; } int __find(int x){ while(f[x]) x = f[x]; return x; } void init(int n,int *num){ for(int i = 1;i\u0026lt;=n;i++) v[i] = num[i]; } void merge(int x,int y){ if(vis[x]||vis[y]) return; __merge(__find(x),__find(y)); } int pop(int x){ if(vis[x]) return -1; int w = __find(x); vis[w] = 1; __pop(w); return v[w]; } } int n,m,num[MAXN]; void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(num[i]); Merge_Heap::init(n,num); } void solve(){ int op,x,y; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(x); if(op == 1) read(y),Merge_Heap::merge(x,y); else if(op == 2) print(Merge_Heap::pop(x)),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   应用 主要就是可并堆嘛。\n「JLOI2015」城池攻占-左偏树\n「APIO2012」派遣-左偏树\n","description":"","id":164,"section":"posts","tags":["左偏树","数据结构","模板"],"title":"左偏树学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-leftist-tree/"},{"content":"一个无向连通图，顶点从 $1$ 编号到 $N$ ，边从 $1$ 编号到 $M$ 。 小 Z 在该图上进行随机游走，初始时小 Z 在 $1$ 号顶点，每一步小 Z 以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小 Z 到达 N 号顶点时游走结束，总分为所有获得的分数之和。 现在，请你对这 $M$ 条边进行编号，使得小 Z 获得的总分的期望值最小。\n链接 Luogu P3232\n题解 注意到因为图是给定的，所以我们可以通过算出每个点期望经过的次数再推出每个边经过的期望次数。\n因为在每个点选定每条边的概率是相同的，所以我们有以下期望方程，设第 $i$ 个点期望经过次数为 $e1_i$ ，度数为 $d_i$ ，第 $i$ 条边期望经过次数为 $e2_i$ ：\n$$\ne1_i = \\sum _ {j} \\frac{e1_j}{d_j},\\text{(i,j) has a edge}\n$$\n那么第 $i$ 条边 $(u,v)$ 的经过次数的期望就是：\n$$\ne2_i = \\frac{e1_u}{d_u} + \\frac{e1_v}{d_v}\n$$\n其中有一些特殊处理，因为开始一定会经过一次 1 节点，可以理解成起点到 1 号节点只有一条边，所以：\n$$\ne1_1 = 1+\\sum _ {j} \\frac{e1_j}{d_j},\\text{(1,j) has a edge}\n$$\n而且这个人走到 $n$ 节点后不会再走回来，所以：$e1_n = 0$。\n高斯消元即可。\n然后排序贪心就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 600; const double eps = 1e-8; int n,m,in[MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; struct Edge{ int from,to; double c; bool operator \u0026lt; (const Edge \u0026amp;a)const{ return c \u0026gt; a.c; } }edgea[MAXN*MAXN]; bool gauss(double a[MAXN][MAXN],int n){ for(int i = 1;i\u0026lt;=n;i++){ int r = i; for(int j = i+1;j\u0026lt;=n;j++) if(fabs(a[j][i]) \u0026gt; fabs(a[r][i])) r = j; if(r!=i) for(int j = 1;j\u0026lt;=n+1;j++) swap(a[r][j],a[i][j]); if(fabs(a[i][i]) \u0026lt; eps) return false; for(int j = 1;j\u0026lt;=n;j++)if(j!=i){ double t = a[j][i]/a[i][i]; for(int k = 1;k\u0026lt;=n+1;k++) a[j][k] -= a[i][k] * t; } } for(int i = 1;i\u0026lt;=n;i++) a[i][n+1]/=a[i][i]; return true; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); int a,b; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b);\tedge[a].push_back(b); edge[b].push_back(a); in[a]++,in[b]++; edgea[i] = (Edge){a,b,double(0)}; } } void solve(){ //a_u -\u0026gt; 点u期望次数  static double a[MAXN][MAXN]; for(int u = 1;u\u0026lt;n;u++){ a[u][u] = 1; for(int i = 0;i\u0026lt;edge[u].size();i++){ int v = edge[u][i]; if(v == n) continue; a[u][v] = -1 / double(in[v]); } } a[1][n] = 1;//很重要！对1的特殊处理  static double c[MAXN]; gauss(a,n-1); for(int i = 1;i\u0026lt;=n-1;i++) c[i] = a[i][n]; for(int i = 1;i\u0026lt;=m;i++){ int u = edgea[i].from,v = edgea[i].to; edgea[i].c = c[u]/in[u]+c[v]/in[v]; }//计算边的期望经过次数  sort(edgea+1,edgea+m+1); double ans = 0; for(int i = 1;i\u0026lt;=m;i++) ans += edgea[i].c * i; printf(\u0026#34;%.3lf\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":165,"section":"posts","tags":["数学","期望","高斯消元"],"title":"「HNOI2013」游走-期望方程","uri":"https://blog.chenqiqian.com/posts/hnoi2013-walk/"},{"content":" 题面以图片显示，请点击“阅读全文”查看。\n 链接 Luogu P3830\n题解 这题有两问。\n第一问 如果令 $dp[x]$ 为有 $x$ 个叶节点的时候叶节点的平均深度，那么有如下方程：\n$$\n\\begin{aligned}{}\ndp[x] \u0026amp;= \\frac{(x-1)dp[x-1] - dp[x-1] + 2 \\times (dp[x-1]+1)}{x}\\\n\u0026amp;=dp[x-1] + \\frac{2}{x}\n\\end{aligned}\n$$\n初始 $dp[1] = 0$ ， $O(n)$ 递推或者搞一搞通项即可qwq。\n第二问 树的深度不太好搞。\n定理：\n$$\nE(x) = \\sum _ {i=1}^{+\\infty} P(i \\leq x)\n$$\n感性理解：大小为 $x$ 的可能性就会被从 $i = 1$ 到 $i = x$ 一直累积，累积正好就是 $x$ 次，就是这种可能性的值，所以这个式子的值就是期望。\n所以我们只要求出在树的叶节点有 $x$ 个的时候，求出树的深度 $i$ 大于 $1$ ，大于 $2$ ，\u0026hellip;，一直到大于 $n-1$ 的概率，然后求和之后就是树的期望深度了。\n令 $dp[x][j]$ 为有 $x$ 个叶节点时树的深度大于 $j$ 的概率，因为展开在两侧时完全等概率的，所以我们有如下方程：\n$$\ndp[x][j] = \\frac{1}{x-1}(\\sum _ {i=1}^{x-1} dp[i][j-1] + dp[x-i][j-1] - dp[i][j-1] \\times dp[x-i][j-1])\n$$\n很简单的容斥。转移即可。注意一下边界，和根结点深度为0即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  #include \u0026lt;cstdio\u0026gt;using namespace std; const int MAXN = 200; double cal(int n,int op){ double ans = 0; if(op == 1) for(int i = 2;i\u0026lt;=n;i++) ans += (2/double(i)); else { static double d[MAXN][MAXN]; for(int i = 1;i\u0026lt;=n;i++) d[i][0] = 1; for(int i = 2;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;i;j++){ for(int k = 1;k\u0026lt;=i-1;k++) d[i][j] += d[k][j-1] + d[i-k][j-1]- d[k][j-1] * d[i-k][j-1]; d[i][j] /= (i-1); } } for(int i = 1;i\u0026lt;=n-1;i++)//从1开始枚举  ans += d[n][i]; } return ans; } int main(){ int q,n; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;q,\u0026amp;n); printf(\u0026#34;%lf\\n\u0026#34;,cal(n,q)); return 0; }   ","description":"","id":166,"section":"posts","tags":["数学","期望","树形结构"],"title":"「SHOI2012」随机树-期望dp","uri":"https://blog.chenqiqian.com/posts/shoi2012-tree/"},{"content":"Y901 高速公路是一条由 $N-1$ 段路以及 $N$ 个收费站组成的东西向的链，我们按照由西向东的顺序将收费站依次编号为 $1 \\sim N$ ，从收费站 $i$ 行驶到 $i+1$ (或从 $i+1$ 行驶到 $i$ )需要收取 $V_i$ 的费用。高速路刚建成时所有的路段都是免费的。\n政府部门根据实际情况，会不定期地对连续路段的收费标准进行调整，根据政策涨价或降价。\n求对于给定的 $l,r(l \u0026lt; r)$ ，在第 $l$ 个到第 $r$ 个收费站里等概率随机取出两个不同的收费站 $a$ 和 $b$ ，那么从 $a$ 行驶到 $b$ 将期望花费多少费用呢?\n链接 Luogu P2221\n题解 位于某个位置的边只会被两个端点分居两边的路径经过，所以我们就可以暴力推式子qwq：\n$$\n\\begin{aligned}{}\nE(l,r) \u0026amp;= \\frac{1}{(r-l-1)(r-l)}\\sum _ {i = l}^{r-1}(i-l+1)(r-i)V_i\\\n\u0026amp;= \\frac{1}{(r-l-1)(r-l)}\\sum _ {i = l}^{r-1}[-i^2 V_i-(l+r-1)i V_i - r(l-1)V_i]\n\\end{aligned}\n$$\n所以需要记录的只有三个东西：$\\sum V_i , \\sum i V_i , \\sum i^2 V_i$。\n这三个东西都是可以用线段树维护的（就是 O(1) 完成打标记和标记下放）。\n具体方法看代码吧。\n 披着期望外衣的线段树题。\n 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;bits/stdc++.h\u0026gt;#define gcd __gcd #define ll long long using namespace std; const int MAXN = 110000; namespace SegTree{ //0-\u0026gt;sigma(V_i),1-\u0026gt;sigma(i*V_i),2-\u0026gt;sigma(i^2*V_i)  struct node{ ll sum[3]; node(ll _a = 0,ll _b = 0,ll _c = 0){ sum[0] = _a,sum[1] = _b,sum[2] = _c; } node operator + (const node \u0026amp;a)const{ node newnode; newnode.sum[0] = sum[0] + a.sum[0]; newnode.sum[1] = sum[1] + a.sum[1]; newnode.sum[2] = sum[2] + a.sum[2]; return newnode; } }sumn[MAXN\u0026lt;\u0026lt;2]; ll tag[MAXN\u0026lt;\u0026lt;2]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson (nown\u0026lt;\u0026lt;1|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  inline ll cal(int n){ return 1LL*n*(n+1)*(2*n+1)/6; } inline void addtag(int nown,int l,int r,ll v){ tag[nown] += v; static node tmp; tmp = node(v*(r-l+1),v*(l+r)*(r-l+1)/2,v*(cal(r)-cal(l-1))); sumn[nown] = sumn[nown] + tmp; } inline void push_down(int nown,int l,int r){ if(tag[nown]){ addtag(lson,l,mid,tag[nown]),addtag(rson,mid+1,r,tag[nown]); tag[nown] = 0; } } inline void push_up(int nown){ sumn[nown] = sumn[lson] + sumn[rson]; } inline void update(int nown,int l,int r,int ql,int qr,int v){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) addtag(nown,l,r,v); else{ push_down(nown,l,r); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,v); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,v); push_up(nown); } } inline node query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sumn[nown]; else{ push_down(nown,l,r); node ans; if(ql \u0026lt;= mid) ans = ans + query(lson,l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans = ans + query(rson,mid+1,r,ql,qr); return ans; } } } int n,m; void update(int l,int r,int v){ SegTree::update(1,1,n,l,r-1,v); } void query(int l,int r,ll \u0026amp;x,ll \u0026amp;y){ SegTree::node tmp = SegTree::query(1,1,n,l,r-1); x = -1LL*r*(l-1)*tmp.sum[0] + 1LL * (r+l-1)*(tmp.sum[1]) - tmp.sum[2]; y = 1LL*(r-l+1)*(r-l)/2; ll d = gcd(x,y); x/=d,y/=d; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); } void solve(){ ll x, y; for(int i = 1;i\u0026lt;=m;i++){ char op[10];int l,r,c; scanf(\u0026#34;%s %d %d\u0026#34;,op,\u0026amp;l,\u0026amp;r); if(op[0] == \u0026#39;C\u0026#39;) scanf(\u0026#34;%d\u0026#34;,\u0026amp;c),update(l,r,c); else query(l,r,x,y),printf(\u0026#34;%lld/%lld\\n\u0026#34;,x,y); } } int main(){ init(); solve(); return 0; }   ","description":"","id":167,"section":"posts","tags":["线段树","数学","期望"],"title":"「HAOI2012」高速公路-期望+线段树","uri":"https://blog.chenqiqian.com/posts/haoi2012-highway/"},{"content":"给出 $n$ 个数 $q_i$ ，给出 $F_j$ 定义为：\n$$\nF_j = \\sum _ {i \u0026lt; j}\\frac{q_i q_j}{(i-j)^2} - \\sum _ {i \u0026gt; j}\\frac{q_i q_j}{(i-j)^2}\n$$\n令 $E_i = \\frac{F_i}{q_i}$ ，求 $E_i$ 的值。\n链接 Luogu P3338\n题解 先化简：\n$$\nE_j = \\sum _ {i \u0026lt; j}\\frac{q_i}{(i-j)^2} - \\sum _ {i \u0026gt; j}\\frac{q_i}{(i-j)^2}\n$$\n注意到我们只需要求：\n$$\nE_j' = \\sum _ {i = 1}^{j-1}\\frac{q_i}{(i-j)^2}\n$$\n注意到卷积的形式：\n$$\n(f * g)[i] = \\sum _ {j = 0}^{i} f[j],g[i-j]\n$$\n在上式中，令 $f[i] = q_i,g[i] = i^{-2}$ ，由卷积的定义可以发现：\n$$\nE_i' = (f * g)[i]\n$$\n这个过程可以用快速傅立叶变换优化，达到 $O(n \\log n)$ 的复杂度。\n然后把序列反转，再做一遍，组合一下就是最后的答案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 500000; typedef complex\u0026lt;double\u0026gt; complex_t; namespace FFT{ const double PI = acos(-1.0); // n = 2^k void fft(complex_t *P,int n,int op){ static int r[MAXN]; int len = log2(n); for(int i = 0;i\u0026lt;n;i++) r[i] = (r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(len-1)); for(int i = 0;i\u0026lt;n;i++) if(i \u0026lt; r[i]) swap(P[i],P[r[i]]); for(int i = 1;i\u0026lt;n;i\u0026lt;\u0026lt;=1){ complex_t x(cos(PI/i),sin(PI/i)*op); for(int j = 0;j\u0026lt;n;j+=(i\u0026lt;\u0026lt;1)){ complex_t y(1,0); for(int k = 0;k\u0026lt;i;k++,y*=x){ complex_t p = P[j+k],q = y*P[i+j+k]; P[j+k] = p+q,P[i+j+k] = p-q; } } } } void mul(double *a,double *b,double *res,int n){ static complex_t c[MAXN],d[MAXN]; for(int i = 0;i\u0026lt;n;i++) c[i] = d[i] = 0; for(int i = 0;i\u0026lt;n;i++) c[i] = a[i],d[i] = b[i]; fft(c,n,1),fft(d,n,1); for(int i = 0;i\u0026lt;n;i++) c[i] *= d[i]; fft(c,n,-1); for(int i = 0;i\u0026lt;n;i++) res[i] = double(c[i].real())/double(n); } } int n; double q[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%lf\u0026#34;,\u0026amp;q[i]); } void solve(){ static double ans[MAXN],tmp[MAXN],a[MAXN],b[MAXN]; int m = 1; for(;m\u0026lt;=2*n;m\u0026lt;\u0026lt;=1); // 注意这里的b[i]一定只能到n！  for(int i = 1;i\u0026lt;=n;i++) a[i] = q[i],b[i] = (1.0/double(i))/double(i);// 这里可能会爆一点什么东西  FFT::mul(a,b,tmp,m); for(int i = 1;i\u0026lt;=n;i++) ans[i] += tmp[i]; reverse(a+1,a+n+1); FFT::mul(a,b,tmp,m); for(int i = 1;i\u0026lt;=n;i++) ans[i] -= tmp[n-i+1]; for(int i = 1;i\u0026lt;=n;i++) printf(\u0026#34;%lf\\n\u0026#34;, ans[i]); } int main(){ init(); solve(); return 0; }   ","description":"","id":168,"section":"posts","tags":["快速傅立叶变换","数学"],"title":"「ZJOI2014」力-快速傅立叶变换","uri":"https://blog.chenqiqian.com/posts/zjoi2014-force/"},{"content":"给定一个长度为 $n$ 且初始值全为 $0$ 的序列。你需要支持以下两种操作：\n $Add, L, R, h$ ：将序列 $[L, R]$ 内所有值小于 $h$ 的元素都赋为 $h$，此时不改变高度大于 $h$ 的元素值 $Remove, L, R, h$：将序列 $[L, R]$ 内所有值大于 $h$ 的元素都赋为 $h$ ，此时不改变高度小于 $h$ 的元素值  你需要输出进行 $k$ 次上述操作之后的序列。\n链接 Luogu P4560\n题解 维护两个标记，近乎于线段树裸题。不过这种写法很有趣，可以积累一下。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 2100000,INF = 0x3f3f3f3f; namespace SegTree{ #define ls (o\u0026lt;\u0026lt;1) #define rs (o\u0026lt;\u0026lt;1|1) #define mid ((l+r)\u0026gt;\u0026gt;1) int high[MAXN\u0026lt;\u0026lt;2],low[MAXN\u0026lt;\u0026lt;2]; // op == 1 修改向上 op == 2 修改向下 void turn(int o,int v,int op){ if(op == 1){ low[o] = max(low[o],v); high[o] = max(high[o],v); } if(op == 2){ low[o] = min(low[o],v); high[o] = min(high[o],v); } } void push_down(int o){ if(high[o]!=INF){turn(ls,high[o],2),turn(rs,high[o],2),high[o]=INF;} if(low[o]!=0){turn(ls,low[o],1),turn(rs,low[o],1),low[o]=0;} } void update(int o,int l,int r,int ql,int qr,int v,int op){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) turn(o,v,op); else{ push_down(o); if(ql \u0026lt;= mid) update(ls,l,mid,ql,qr,v,op); if(qr \u0026gt;= mid+1) update(rs,mid+1,r,ql,qr,v,op); } } void output(int o,int l,int r,int *num){ if(l == r) num[l] = high[o]; else{ push_down(o); output(ls,l,mid,num); output(rs,mid+1,r,num); } } } int n,m; void init(){ read(n),read(m); } void solve(){ int op,l,r,c; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(l),read(r),read(c); SegTree::update(1,1,n,l+1,r+1,c,op); } static int ans[MAXN]; SegTree::output(1,1,n,ans); for(int i = 1;i\u0026lt;=n;i++){ print(ans[i]),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":169,"section":"posts","tags":["数据结构","线段树"],"title":"「IOI2014」Wall-线段树","uri":"https://blog.chenqiqian.com/posts/ioi2014-wall/"},{"content":"给定一个 $n$ 个节点的树，每个点有一个正整数权值 $a_i$ 。我们定义 $g(x,y)$ 为 $x,y$ 之间简单路径上所有点（包括端点）的权值的最大公约数。\n现在请求出对于所有的 $i \\in [1,2×10^5]$ ，满足 $1 \\le x \\le y \\le n$ 且 $g(x,y) = i$ 的点对 $(x,y)$ 的数目。\n链接 Codeforces 990G\n题解 一个结论：一个数的约数个数不会很多。\n在 $100000000$ 之内，约数最多的数是 $73513440$ ，有 $768$ 个因子。这大约不是 $log$ 级别的？令它是一个 $O(d(n))$ 级别的吧。\nSolution A: 容斥原理：\n所有以 $q$ 为最大公约数的点对的数目等于所有以 $q$ 为公约数的点对数目减去以 $2q,3q,\u0026hellip;,kq$ 为最大公约数的点对数目。\n所以我们采用逆序计算以 $q$ 为公约数的点对数目，就可以推出以 $q$ 为最大公约数的点对数目。\n考虑怎么计算这个问题。如果两个点对的公约数是 $q$ ，那么他们路径上的所有边两端连的点的 $gcd$ 都是 $q$ 或者 $q$ 的倍数，经过的点的权值也一定是 $q$ 或者 $q$ 的倍数。因为权值不大，我们用权值记录点，用 $gcd$ 记录边。考虑到如果把所有的 $gcd$ 为 $q$ 或者 $q$ 的倍数的边全都连起来，这样图里所有联通的点都是满足条件的。所以我们只需要连边，然后维护点对数目。\n我们维护一个并查集。记录集合大小。每次先将上述的点初始化，然后把边连上。用一个cnt维护所有联通点对数目，注意一个点也算点对。然后联通集合的时候加上从这端到那端的所有点对就可以了。\n来分析一下复杂度。这里的复杂度主要集中在：并查集的初始化（满足条件的点）和并查集的合并（满足条件的边），每个操作都是 $O(1)$ 的，我们考虑一下它会被执行多少次。发现每个点都会被权值的因数初始化一次，所以这个是 $O(nd(n))$ 的。对于边的话也是一样，所以复杂度大约是 $O(n d(n))$ 的。\n如果 $d(n)$ 不是很大，那么这个东西过掉问题不大。\nSolution B: 树上点对的问题让我们想到了点分治。\n考虑点分治的过程，我们要计算过当前根点的所有点对的gcd及其数量。根节点的约数个数是O(d)的，那么我们所有数与根节点的 $gcd$ 最多也只能是 $O(d)$ 种。\n先枚举根节点的所有约数，复杂度是 $O(d)$ 。\n对于每个子树我们可以用 $O(n)$ 的时间完成dfs、去重。然后我们有 $O(d^2)$ 的时间完成对所有前面的和现在这个子树的 $gcd$ 的一一枚举，然后在将这个子树添加到前面去。\n然后这个点分治的过程应该是 $O(d n \\log n)$ 的?复杂度比较迷。\n不过能过，跑的很快。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int MAXN = 300000; int gcd(int x,int y){ return y == 0?x:gcd(y,x%y); } namespace BCJ{ int f[MAXN],siz[MAXN]; int find(int x){ return f[x] == x?x:f[x] = find(f[x]); } void un(int x,int y,ll \u0026amp;cur){ int fx = find(x),fy = find(y); if(fx == fy) return; cur -= 1LL*siz[fx]*(siz[fx]+1)/2; cur -= 1LL*siz[fy]*(siz[fy]+1)/2; f[fy] = fx,siz[fx] += siz[fy]; cur += 1LL*siz[fx]*(siz[fx]+1)/2; } } struct Edge{ int u,v; }edge[MAXN]; vector\u0026lt;int\u0026gt; V[MAXN]; vector\u0026lt;int\u0026gt; E[MAXN]; int n,a[MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); V[a[i]].push_back(i); } for(int i = 1;i\u0026lt;=n-1;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;edge[i].u,\u0026amp;edge[i].v); E[gcd(a[edge[i].u],a[edge[i].v])].push_back(i); } } void solve(){ int maxn = 200000; static ll res[MAXN],cur = 0; for(int i = maxn;i\u0026gt;=1;--i){ cur = 0; for(int j = i;j\u0026lt;=maxn;j+=i){ for(int k = 0;k\u0026lt;V[j].size();k++){ int t = V[j][k]; BCJ::siz[t] = 1,BCJ::f[t] = t; cur++; } if(j \u0026gt; i) res[i] -= res[j]; } for(int j = i;j\u0026lt;=maxn;j+=i) for(int k = 0;k\u0026lt;E[j].size();k++) BCJ::un(edge[E[j][k]].u,edge[E[j][k]].v,cur); res[i] += cur; } for(int i = 1;i\u0026lt;=maxn;i++){ if(res[i]) printf(\u0026#34;%d %lld\\n\u0026#34;,i,res[i]); } } int main(){ init(); solve(); return 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 非本人创作 #include\u0026lt;bits/stdc++.h\u0026gt;#define gcd(a,b) __gcd(a,b) using namespace std;const int N=2e5+7;typedef long long ll; struct data{int to,next;}e[N\u0026lt;\u0026lt;1];int n,m,i,j,cnt,a[N],d[N],vis[N],head[N],f[N],q[N],qq[N],u,v,root,sum,num[N],Tnum[N],size[N],fr[N],T,tt,tot;ll ans[N]; void ins(int u,int v){e[++cnt].to=v;e[cnt].next=head[u];head[u]=cnt;} void insert(int u,int v){ins(u,v);ins(v,u);} void getroot(int x,int fa){ size[x]=1;f[x]=0; for(int i=head[x];i;i=e[i].next)if(e[i].to!=fa\u0026amp;\u0026amp;!vis[e[i].to]) getroot(e[i].to,x),size[x]+=size[e[i].to],f[x]=max(f[x],size[e[i].to]); f[x]=max(f[x],sum-size[x]); if(f[x]\u0026lt;f[root])root=x; } void getdis(int x,int fa){ q[++tt]=d[x]; for(int i=head[x];i;i=e[i].next)if(!vis[e[i].to]\u0026amp;\u0026amp;e[i].to!=fa)d[e[i].to]=gcd(d[x],a[e[i].to]),getdis(e[i].to,x); } void work(int x){ vis[x]=1;T=0; for(int i=head[x],j,k;i;i=e[i].next)if(!vis[e[i].to]){ tot=tt=0;d[e[i].to]=gcd(a[x],a[e[i].to]);getdis(e[i].to,0); for(sort(q+1,q+tt+1),j=1;j\u0026lt;=tt;++j)if(q[j]==q[j-1])num[tot]++;else q[++tot]=q[j],num[tot]=1; for(j=1;j\u0026lt;=tot;++j)for(k=1;k\u0026lt;=T;++k)ans[gcd(q[j],qq[k])]+=1ll*num[j]*Tnum[k]; for(j=1;j\u0026lt;=tot;++j)ans[q[j]]+=num[j]; for(j=1;j\u0026lt;=tot;++j)if(!fr[q[j]])qq[++T]=q[j],Tnum[T]=num[j],fr[q[j]]=T; else Tnum[fr[q[j]]]+=num[j]; }ans[a[x]]++;for(int i=1;i\u0026lt;=T;++i)fr[qq[i]]=0; for(int i=head[x];i;i=e[i].next)if(!vis[e[i].to]) root=0,sum=size[e[i].to],getroot(e[i].to,x),work(root); } int main(){ for(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),i=1;i\u0026lt;=n;++i)scanf(\u0026#34;%d\u0026#34;,a+i);for(i=1;i\u0026lt;n;++i)scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;u,\u0026amp;v),insert(u,v); f[0]=N;sum=n;root=0;getroot(1,0);work(root); for(i=1;i\u0026lt;N;++i)if(ans[i])printf(\u0026#34;%d %lld\\n\u0026#34;,i,ans[i]); }   ","description":"","id":170,"section":"posts","tags":["并查集","点分治"],"title":"「CF990G」GCD Counting-并查集/点分治","uri":"https://blog.chenqiqian.com/posts/cf990g/"},{"content":" 你以为你见证了整个故事，其实你只知道他们的名字，甚至你连他们的名字都不一定知道。\n 错过 老人坐在床上，翻着大箱子里那些珍藏的往事。\n老人曾经是一名军人，而这也让他屋子里面的东西整洁的就像无人居住似的。而他的这个箱子，自然也就整整齐齐的放置着对他最为重要的那些东西。\n他轻轻拿布擦掉箱子上面覆盖的灰尘，用手抚了下红绿色的军徽。箱子慢慢吱吱呀呀的打开了。\n最上面的是一张很老的照片。他看着照片上的父子，细细回想了半天。那是他14岁的时候。学校组织他们到附近的军用机场参观，而这张照片，就是以那一架他永远铭记的飞机为背景拍成的。他是那么兴奋，看着飞机的起降，飞行员的帅气，让他小小的内心充满了憧憬，他甚至还偷偷的摸了一下那架金属的飞机，而至今他仍然记得金属铆钉突出的质感和他心里的激动。那个时候，他经常喜欢到机场边的地方去看着，只是看着，如果能有飞机的起降，这能让他激动整整一天。他在心里就想着：我有一天，也要去开飞机！甚至，飞到比飞机更高的地方！\n厨房里老伴做饭的声音把他一下子拉回现实。他笑笑。他已经不是少年了，那个时候的年少轻狂恐怕也早就丢掉了吧。\n他把那张照片小心翼翼地放到床上，再看向箱子里面的下一样东西。这是一张证书，他虽然已经认不全上面的俄文，但是记忆仍然十分鲜活。那是他30岁的时候。他高中毕业之后，去了航校，成为了飞行员。他喜欢开着飞机，看着下面的大地和无比渺小的农田、城镇。他有的时候也会向远方望，看着那天地相接处深邃的蓝色，想要看到天空上面，然而他就算极尽目力，也很难再看出些什么。当他听说要招航天员的时候，他毫不犹豫的答应了。这是他一直以来的梦想啊。\n一年以后，他来到了俄罗斯的加加林太空中心。贫弱的中国没有办法自己培养航天员，只能将航天员送到已经有三十多年航天经验的俄罗斯去接受培训。培训是艰苦的，他们不仅要与时间作战，更要不断挑战自己的身体和精神的极限。他到现在都忘不了在零下五十度的冰天雪地里的野外求生训练，也永远忘不了在接近一百度高温下对生理的折磨。最令人绝望的是什么来着？他皱了皱眉，那个时代的记忆不断涌入心里。那个小屋子，至今他还能清楚的记得里面的每一个陈设，其实也不难，因为里面就像一个坟墓似的简洁。而他就在那个坟墓里，不眠不休的呆了三天三夜，二十四小时不间断地完成指令的操作。他至今也不能忘却那个屋子的哪怕一个纹理。\n最终，他拿到了联盟号飞船的指令长证书。他又一次激动的像个孩子，就像他14岁的时候，第一次见到飞机似的那种激动。他还清楚的记得，他拿到这个证书之后说的第一句话就是对加加林基地的训练长官说的：“我现在拿的是‘联盟’号飞船指令长的证书，回去以后再拿中国自己的证书，然后驾驶着我们中国的宇宙飞船飞向太空，与你们的和平号空间站对接，行吗？”\n都过去了啊。那份证书上的金光灿灿的字母如今已经不再那么光鲜亮丽，知道这份证书的人也越来越少了。他把证书轻轻的塞回那镶嵌着金丝的精致的布袋里。\n又是一张照片。这张照片大约是很近的时候了。对，神舟五号。他就在这幅照片的左侧，而照片中央就是中国第一个进入太空的人——杨利伟。那是他35岁的时候。他回国了，带着一张金光灿灿的证书，和满满的重负。中国的载人航天条件正在快速具备，而航天员的培养则是重中之重。为了国家，他必须投入所有的精力，去训练新的航天员。\n “团结，自律，勤奋，奉献。”\n 灰白的墙上砖红色的八个大字，一直提醒着他他的职责所在。他现在是一名航天员训练师，兼预备航天员。而他现在的任务，就是为国家训练出尽量多的合格的航天员，让他们每一个都能够上天。一天天的日子过去了。神舟飞船一艘一艘的上天，而那最后进入太空的日子也越来越近了。航天员从选拔到最后上天淘汰的数量大约是50%。然而在中国，这一数字是0%。\n这意味着这十二名航天员，加上两位教员，每个人都能够进入太空。但，并不是每个人都有机会进入太空的。\n神舟五号，他落选了。他安慰自己：还有很多飞船，自己还不算老，还有机会的。神舟五号返回的时候，他作为教员，在现场目睹着飞船的着陆。他是为数不多第一个看到那名之后被誉为“民族英雄”的航天员出舱的人。他作为教员，当然是首先与航天员合影的一员。他拍着肩膀对杨利伟说：“好样的。”他和杨利伟，即是师生，又是朋友，还是邻居，甚至还是竞争对手。那是一个足以标榜史册的时候。中国这个国家，第一次拥有了载人进入太空的能力，甚至连总理都亲自到场迎接航天员的归来。\n全部十四名第一批航天员\n转眼几年又过去了又是神舟七号发射，他仍然在只能在北京的航天城，看着飞船成功发射，看着出舱行走，看着中国国旗的挥动，看着发射大厅里面人们的欢呼。他已经五十岁了。在这几年，他落选了神舟六号，只成为了备份航天员，他培养的学生载着火箭升空，而他只能在酒泉，第一次如此近的观看火箭的发射。当长征二号F火箭缓缓升空时，他感觉自己的心似乎也有一部分，变空了一点点。\n 「遥看神六巡天走，梦想神七伴我行」\n 神舟六号任务出征仪式，后排左二\n发射完成之后，时间已近午夜。他拖起疲惫的身躯，一步一步的走回他的家。这意味一个航天员很难再有希望进入太空了。他听着风吹过他的耳畔，缓缓前行。年轻时候所有的记忆，壮志、惊喜、兴奋、痛苦、失落，所有这些都一股脑的在他的脑海间盘桓。他抬头望向星空。星空仍然是那么的无垠，那么的微茫。那里是他的梦啊，是他唯一的梦啊。他再也忍不住眼眶中的泪水，只能蹲在路边，凝视星空璀璨，久久无言。\n神八，神九，神十，神十一。飞船一艘艘的上天，而他，再也找不到上天的机会了。\n 2016年，他从航天员大队退休。截至2018年，第一批航天员中14人共有8人已进入太空；第二批航天员中7人共3人已进入太空。他们大部分都受到过他的指导。\n 饭香从隔壁传了过来。饭菜已经端上了桌。他从回忆里面抽出思绪，慢慢地将手里的照片、书信、证书再次按照时间顺序整齐的放回那个军绿色的箱子。他走出房间，和儿子一起吃饭，和老伴侃侃最近的大事。\n虽然别人都说老人错过了不少机会，但在老人心里，他从来就没有错过过什么。\nFrom:Wikimedia\n根据真实故事改编。该题目为鄙校期末语文作文题目之一。\n","description":"","id":171,"section":"posts","tags":null,"title":"「错过」","uri":"https://blog.chenqiqian.com/posts/essay-miss/"},{"content":"lxhgww预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$ ，第 $i$ 天的股票卖出价为每股 $BP_i$ （数据保证对于每个 $i$ ，都有$AP_i \\ge BP_i$ ），第$i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天；在任何时间一个人的手里的股票数不能超过 $MaxP$ 。\n在第 $1$ 天之前，lxhgww手里有数目无限的钱，但是没有任何股票，在 $T$ 天以后， lxhgww 能赚到的钱最多是多少？\n链接 Luogu P2569\n题解 显然要 dp 嘛，要不然它放在 dp 模块里搞笑么。\n如果用 $dp[i][j]$ 表示在第 $i$ 天的时候拥有 $j$ 股股票的时候的最大收益。\n那么状态转移：\n$$\ndp[i][j] = max\n\\begin{cases}{}\ndp[i-1][j]\\\n-ap[i]\\times j,; \u0026amp;j\\leq as[i]\\\ndp[i-w][j+t] + t \\times bp[i],;\u0026amp;0 \u0026lt; t \u0026lt; bs[i],j+t \\leq maxp\\\ndp[i-w][j-t] - t \\times ap[i],;\u0026amp;0 \u0026lt; t \u0026lt; as[i],j-t \u0026gt; 0\n\\end{cases}\n$$\n注意到前两个转移是 $O(1)$ 的 ，后两个是如果直接做是 $O(n)$ 的，然而这个东西就是在一个区间里面找最大值，后面加减的 $t$ 随位置同步改变，不会改变状态的相对大小，所以用单调队列优化后面两个转移即可。\n最后扫一下所有的 $dp[n][i]$ 最大值即为答案。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 2100; int n,m,w; int ap[MAXN],bp[MAXN],as[MAXN],bs[MAXN]; int dp[MAXN][MAXN]; void init(){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;w); w++; for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;ap[i],\u0026amp;bp[i],\u0026amp;as[i],\u0026amp;bs[i]); } deque\u0026lt;int\u0026gt; q; void solve(){ for(int i = 0;i\u0026lt;=n;i++) for(int j = 0;j\u0026lt;=m;j++) dp[i][j] = -0x3f3f3f3f; dp[0][0] = 0; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 0;j\u0026lt;=as[i];j++) dp[i][j]=-ap[i]*j; for(int j = 0;j\u0026lt;=m;j++) dp[i][j] = max(dp[i][j],dp[i-1][j]); if(i-w \u0026lt; 0) continue;//!!!  while(!q.empty()) q.pop_back(); for(int j = 0;j\u0026lt;=m;j++){ while(!q.empty() \u0026amp;\u0026amp; q.front() \u0026lt; j-as[i]) q.pop_front(); while(!q.empty() \u0026amp;\u0026amp; dp[i-w][q.back()]-(j-q.back())*ap[i] \u0026lt;= dp[i-w][j]) q.pop_back(); q.push_back(j); dp[i][j] = max(dp[i][j],dp[i-w][q.front()]-(j-q.front())*ap[i]); } while(!q.empty()) q.pop_back(); for(int j = m;j\u0026gt;=0;--j){ while(!q.empty() \u0026amp;\u0026amp; q.front() \u0026gt; j+bs[i]) q.pop_front(); while(!q.empty() \u0026amp;\u0026amp; dp[i-w][q.back()]+(q.back()-j)*bp[i] \u0026lt;= dp[i-w][j]) q.pop_back(); q.push_back(j); dp[i][j] = max(dp[i][j],dp[i-w][q.front()] + (q.front() - j)*bp[i]); } } int ans = 0; for(int i = 0;i\u0026lt;=m;i++) ans = max(ans,dp[n][i]); printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   在写下这个题解的时候，这的确是第100篇博文了。祝贺一下自己。\n","description":"","id":172,"section":"posts","tags":["动态规划","单调队列"],"title":"「SCOI2010」股票交易-dp+单调队列","uri":"https://blog.chenqiqian.com/posts/scoi2010-stock/"},{"content":"给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。当这两个子串中只要有一个取得位置不同时，两个方案不同。\n链接 Luogu P3181\n题解 解法一：$O(n^4)$ 暴力枚举两个起始位置，然后枚举每个起始长度， $O(n)$ 的判断子串是否相同，这个算法是 $O(n^4)$ 的。\n解法二：$O(n^3)$ 暴力枚举两个起始位置，然后从 $1$ 到 $n$ ，每次判断新增的一个字符是否相同，从而判断子串是否相同。这样对于每一个起始位置的判断就是 $O(n)$ ，最后的复杂度就是 $O(n^3)$ 。\n解法三：$O(n^2)$ 我们学会了后缀数组，我们知道了我们事实上可以在 $O(n\\log n)$ 预处理的情况下 $O(1)$ 的得到解法二的 $O(n)$ 的过程，也就是求一下 $LCP$ 。这样的话，复杂度是 $O(n^2)$ 。\n解法四：$O(n \\log n)$ 我们先转化一下问题。这道题要求的是两个串的每一个位置两两之间的 $LCP$ 的和。但是如果我们枚举的话，时间复杂度至少是 $O(n^2)$ 。那么我们肯定要用一些数据结构之类来批量求和，最后才能够降低复杂度。\n其次，我们发现这个问题可以拆解。我们只需要找出一个解法，解得在一个字符串里面任取两个位置不同的子串，取得子串相同的方案数。\n令 s_3 = s_1 + \u0026quot;?\u0026quot; + s_2 ，那么答案就是 cal(s3)-cal(s1)-cal(s2) ，其中 ? 是一个没有在字符串里面出现的字符。\n那么我们发现，对于每一个位置来说，我们可以将其视作以这个位置开始的后缀，那么其顺序对于每一个位置两两之间 LCP 的和是无关紧要的。\n所以我们按 $sa[i]$ ，也就是后缀字典序的顺序来遍历。每次我们都要求这个位置和前面所有位置的 LCP 的和。那么这个时候，我们就可以把前面的所有后缀到按字典序前一个后缀的LCP长度扔到一个 Splay 或者什么权值线段树里面去。\n然后这个时候我们新加入了一个后缀，需要更新这个数据结构。我们需要把这个数据结构里面所有的大于 $ht[i]$ 的数都拎出来，改成 $ht[i]$ ，然后再塞回去就可以了。然后每次给 $ans$ 加上这个数据结构里面所有数的总和就可以了。\n这个算法的时间复杂度应当是 $O(n \\log n)$ 。\n解法五：$O(n)$ 什么？？？这种东西还能 $O(n)$ ？？？\n反正我很震惊。\n于是我就在合格考的考场上苦思冥想，最后自己脑补出了一个数据结构。用摊还证了下复杂度，竟然发现是 $O(n)$ 的\u0026hellip;仔细一想，这个东西叫单调栈2333\u0026hellip;\u0026hellip;\n其他都同上，我们现在解决的是这里：\n我们需要把这个数据结构里面所有的大于 $ht[i]$ 的数都拎出来，改成 $ht[i]$ ，然后再塞回去就可以了。然后每次给 $ans$ 加上这个数据结构里面所有数的总和就可以了。\n怎么办呢？我们想能不能暴力解决这个问题。注意到我们每次用 $ht[i]$ 更新之后，所有的这些数我们都可以只用一个数(数对)来表示，也就是 $(ht[i],cnt)$ 。我们维护一个有序表。然后每次从大端把所有大于等于 $ht[i]$ 的数给拿出来，更新 $cnt$ ，最后在插回去一个新的节点。\n然后数据结构里面的数的和的更新就比较简单了\u0026hellip;记一下出来的数的和，再记一下进去的数的和，然后加一下减一下即可。\n可以用摊还证明，这个东西是 $O(n)$ 的。\n我用的后缀数组是 $SA-IS$ 算法，也是 $O(n)$ 的。\n语言很混乱，哪看不懂可以问我23333\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111  #include \u0026lt;bits/stdc++.h\u0026gt;#define ll long long #define pp pair\u0026lt;int,int\u0026gt; using namespace std; const int MAXN = 233333; template\u0026lt;size_t siz\u0026gt; struct SA{ int s[siz\u0026lt;\u0026lt;1],p[siz],t[siz\u0026lt;\u0026lt;1]; int sa[siz],rk[siz],ht[siz]; int b[siz],cur[siz]; #define pushL(x) sa[cur[s[x]]++] = x #define pushS(x) sa[cur[s[x]]--] = x #define inducedSort(v)\\ fill_n(b,m,0),fill_n(sa,n,-1);\\ for(int i = 0;i\u0026lt;n;i++) b[s[i]]++;\\ for(int i = 1;i\u0026lt;m;i++) b[i] += b[i-1];\\ for(int i = 0;i\u0026lt;m;i++) cur[i] = b[i]-1;\\ for(int i=n1-1;~i;--i) pushS(v[i]);\\ for(int i = 1;i\u0026lt;m;i++) cur[i] = b[i-1];\\ for(int i = 0;i\u0026lt;n;i++) if(sa[i]\u0026gt;0\u0026amp;\u0026amp;t[sa[i]-1]) pushL(sa[i]-1);\\ for(int i = 0;i\u0026lt;m;i++) cur[i] = b[i]-1;\\ for(int i =n-1;~i;--i) if(sa[i]\u0026gt;0\u0026amp;\u0026amp;!t[sa[i]-1]) pushS(sa[i]-1); void sais(int n,int m,int *s,int *t,int *p){ int ch = rk[0] = -1,n1 = t[n-1] = 0,*s1 = s+n; for(int i = n-2;~i;--i) t[i] = s[i]==s[i+1]?t[i+1]:s[i]\u0026gt;s[i+1]; for(int i = 1;i\u0026lt;n;i++) rk[i] = (!t[i]\u0026amp;\u0026amp;t[i-1])?(p[n1]=i,n1++):-1; inducedSort(p); for(int i = 0,x,y;i\u0026lt;n;i++)if(~(x=rk[sa[i]])){ if(ch\u0026lt;1||p[x+1]-p[x] != p[y+1]-p[y]) ch++; else for(int j=p[x],k=p[y];j\u0026lt;=p[x+1];j++,k++) if((s[j]\u0026lt;\u0026lt;1|t[j])!=(s[k]\u0026lt;\u0026lt;1|t[k])){ch++;break;} s1[y=x] = ch; } if(ch+1 \u0026lt; n1) sais(n1,ch+1,s1,t+n,p+n1); else for(int i = 0;i\u0026lt;n1;i++) sa[s1[i]] = i; for(int i = 0;i\u0026lt;n1;i++) s1[i] = p[sa[i]]; inducedSort(s1); } template\u0026lt;typename T\u0026gt; int mapp(const T *str,int n){ int m = *max_element(str,str+n); fill_n(rk,m+1,0); for(int i = 0;i\u0026lt;n;i++) rk[str[i]] = 1; for(int i = 0;i\u0026lt;m;i++) rk[i+1] += rk[i]; for(int i = 0;i\u0026lt;n;i++) s[i] = rk[str[i]]-1; return rk[m]; } // 这个时候传正确的字符串大小，++n对str[n]做处理 template\u0026lt;typename T\u0026gt; void SuffixArray(const T *str,int n){ int m = mapp(str,++n); sais(n,m,s,t,p); } void getheight(int n){ for(int i = 0;i\u0026lt;=n;i++) rk[sa[i]] = i; for(int i = 0,h=ht[0]=0;i\u0026lt;=n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n\u0026amp;\u0026amp;j+h\u0026lt;n\u0026amp;\u0026amp;s[i+h]==s[j+h]) ++h; if(ht[rk[i]] = h) --h; } } template\u0026lt;typename T\u0026gt; void build(const T *str,int n){ SuffixArray(str,n); getheight(n); } }; char s1[MAXN],s2[MAXN],s3[MAXN\u0026lt;\u0026lt;1]; void init(){ scanf(\u0026#34;%s\u0026#34;,s1); scanf(\u0026#34;%s\u0026#34;,s2); } ll cal(char *a){ int n = strlen(a); a[n] = \u0026#39;A\u0026#39;-1; static SA\u0026lt;401000\u0026gt; T; T.build(a,n); ll ans = 0,tmp = 0; stack\u0026lt;pp\u0026gt; S; for(int i = 1;i\u0026lt;=n;i++){ ll cnt = 1,tot = 0; while(!S.empty() \u0026amp;\u0026amp; S.top().first \u0026gt;= T.ht[i]){ cnt += S.top().second; tot += 1LL * S.top().first * S.top().second; S.pop(); } S.push(make_pair(T.ht[i],int(cnt))); tmp += T.ht[i]*cnt - tot; ans += tmp; } return ans; } void solve(){ int n = strlen(s1),m = strlen(s2); memcpy(s3,s1,n),memcpy(s3+n+1,s2,m);s3[n] = \u0026#39;A\u0026#39;; printf(\u0026#34;%lld\\n\u0026#34;,cal(s3)-cal(s1)-cal(s2)); } signed main(){ init(); solve(); return 0; }   ","description":"","id":173,"section":"posts","tags":["字符串","单调栈","后缀数组"],"title":"「HAOI2016」找相同字符-后缀数组+单调栈","uri":"https://blog.chenqiqian.com/posts/haoi2016-same/"},{"content":"如果一个字符串可以被拆分为 $AABB$ 的形式，其中 $A$ 和 $B$ 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。\n现在给出一个长度为 $n$ 的字符串 $S$ ，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。\n以下事项需要注意：\n 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。 在一个拆分中，允许出现 $A = B$。例如 $cccc$ 存在拆分 $A = B = c$。 字符串本身也是它的一个子串。  链接 Luogu P1117\nBZOJ 4650\n题解 下文字符串下标均为 $[0,n)$ 。\n我们如果令 $l[i]$ 为在 $i$ 处开始的 AA 串的个数，$r[i]$ 为在 $i$ 处结束的 AA 串的个数，那么\n$$\nans = \\sum _ {i = 1}^{n-1} r[i-1] \\times l[i]\n$$\n这个过程是 $O(n)$ 的，所以我们需要思考怎么求出 $l[i]$ 和 $r[i]$ 。\n我们对每一个 AA 子串的循环节长度 $L$ 从 $1$ 到 $\\frac{n}{2}$ 进行枚举考虑。如果在 $0,L,2L,\u0026hellip;,nL$ 的地方设为关键点，那么 AA 的左半边的循环节因为长度为 $L$ ，一定过且仅过一个关键点，这也是我们下面考虑的基础。\n我们正序、逆序建立两个后缀数组，来求得原字符串某两个后缀的LCP（最长公共前缀）或者某两个前缀的 LCS （最长公共后缀）。\n如果这个 AA 子串的左半边过 $kL$ 这个关键点，那么这个时候的 AA 子串在 $kL$ 和 $(k+1)L$ 的位置必须相同，而且他们的$LCP+LCS$的长度必须能够接上这样一个 $L$ 的间隔，我们才能找到一段 $2L$ 的区间，满足 AA 串的条件。\n这个时候，我们用差分的方法标记修改 $l$ 和 $r$ 即可。\n注意要保证 AA 串(也就是我们枚举的串)左边的串的左端点、右端点都不触碰到其他的关键点，不然会重复计数。\n具体看代码吧。solve 函数就是最终的这一过程。\n时间复杂度 $O(n \\log{n})$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 210000; struct SA{ int sa[MAXN],rk[MAXN],ht[MAXN],s[MAXN\u0026lt;\u0026lt;1],t[MAXN\u0026lt;\u0026lt;1]; int b[MAXN],cur[MAXN],p[MAXN]; #define pushS(x) sa[cur[s[x]]--] = x #define pushL(x) sa[cur[s[x]]++] = x #define inducedSort(v) \\ fill_n(b,m,0),fill_n(sa,n,-1);\\ for(int i = 0;i\u0026lt;n;i++) b[s[i]]++;\\ for(int j = 1;j\u0026lt;m;j++) b[j]+=b[j-1];\\ for(int j = 0;j\u0026lt;m;j++) cur[j] = b[j]-1;\\ for(int i=n1-1;~i;--i) pushS(v[i]);\\ for(int j = 1;j\u0026lt;m;j++) cur[j] = b[j-1];\\ for(int i = 0;i\u0026lt;n;i++) if(sa[i]\u0026gt;0 \u0026amp;\u0026amp; t[sa[i]-1]) pushL(sa[i]-1);\\ for(int j = 0;j\u0026lt;m;j++) cur[j] = b[j]-1;\\ for(int i=n-1;~i;--i) if(sa[i]\u0026gt;0 \u0026amp;\u0026amp; !t[sa[i]-1]) pushS(sa[i]-1); void sais(int n,int m,int *s,int *t,int *p){ int n1 = t[n-1] = 0,ch = rk[0] = -1,*s1 = s+n; for(int i = n-2;~i;--i) t[i] = (s[i]!=s[i+1])?s[i]\u0026gt;s[i+1]:t[i+1]; for(int i = 1;i\u0026lt;n;i++) rk[i] = (!t[i]\u0026amp;\u0026amp;t[i-1])?(p[n1]=i,n1++):-1; inducedSort(p); for(int i=0,x,y;i\u0026lt;n;i++)if(~(x=rk[sa[i]])){ if(ch \u0026lt; 1 || p[x+1]-p[x]!=p[y+1]-p[y]) ch++; else for(int j=p[x],k=p[y];j\u0026lt;=p[x+1];j++,k++) if((s[j]\u0026lt;\u0026lt;1|t[j])!=(s[k]\u0026lt;\u0026lt;1|t[k])){ch++;break;} s1[y=x]=ch; } if(ch+1 \u0026lt; n1) sais(n1,ch+1,s1,t+n,p+n1); else for(int i = 0;i\u0026lt;n1;i++) sa[s1[i]] = i; for(int i = 0;i\u0026lt;n1;i++) s1[i] = p[sa[i]]; inducedSort(s1); } template\u0026lt;typename T\u0026gt; int mapp(const T *str,int n){ int m = *max_element(str,str+n); fill_n(rk,m+1,0); for(int i = 0;i\u0026lt;n;i++) rk[str[i]] = 1; for(int j = 0;j\u0026lt;m;j++) rk[j+1] += rk[j]; for(int i = 0;i\u0026lt;n;i++) s[i] = rk[str[i]] - 1; return rk[m]; } template\u0026lt;typename T\u0026gt; void SuffixArray(const T *str,int n){ int m = mapp(str,++n); sais(n,m,s,t,p); } void getheight(int n){ for(int i = 0;i\u0026lt;=n;i++) rk[sa[i]] = i; for(int i = 0,h = ht[0] = 0;i\u0026lt;=n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n\u0026amp;\u0026amp;j+h\u0026lt;n\u0026amp;\u0026amp;s[i+h]==s[j+h]) h++; if(ht[rk[i]] = h) --h; } } struct ST{ int maxn[20][MAXN]; void build(int *num,int n){ for(int i = 1;i\u0026lt;=n;i++) maxn[0][i] = num[i]; for(int j = 1,t=2;t\u0026lt;=n;j++,t\u0026lt;\u0026lt;=1)// st表取min！  for(int i = 1;i+(t\u0026gt;\u0026gt;1)\u0026lt;=n;i++) maxn[j][i] = min(maxn[j-1][i],maxn[j-1][i+(t\u0026gt;\u0026gt;1)]); } int query(int l,int r){ if(l \u0026gt; r) return -1; int t = log2(r-l+1); return min(maxn[t][l],maxn[t][r-(1\u0026lt;\u0026lt;t)+1]);// 取min！！！！  } }S; int lcp(int x,int y,int n){ x = rk[x],y = rk[y]; if(x \u0026gt; y) swap(x,y); if(x == y) return n-x+1; return S.query(x+1,y); } template\u0026lt;typename T\u0026gt; void solve(const T *str,int n){ SuffixArray(str,n); getheight(n); S.build(ht,n); } }A,B; int n; char s[MAXN],tmp[MAXN]; void init(){ scanf(\u0026#34;%s\u0026#34;,s); n = strlen(s); s[n] = \u0026#39;a\u0026#39;-1; A.solve(s,n); for(int i = 0;i\u0026lt;n;i++) tmp[i] = s[n-i-1]; tmp[n] = \u0026#39;a\u0026#39;-1; B.solve(tmp,n); } // Longest Common Prefix int lcp(int x,int y){ return A.lcp(x,y,n); } // Longest Common Suffix int lcs(int x,int y){ return B.lcp(n-x-1,n-y-1,n); } long long solve(){ static long long l[MAXN],r[MAXN]; long long ans = 0; memset(l,0,sizeof(l)),memset(r,0,sizeof(r)); for(int L = 1;L\u0026lt;=n/2;L++){ for(int j = 0;j+L\u0026lt;n;j+=L){ int ll = j,rr = j+L; if(s[ll] != s[rr]) continue; int x = ll-lcs(ll,rr)+1,y = ll + lcp(ll,rr) - 1; x = max(max(x,0),ll-L+1),y = min(ll+L-1,min(n-L-1,y)); if(y-x+1 \u0026gt;= L){ int cnt = (y-x+1)-L+1; l[x]++,l[x+cnt]--; r[x+2*L-1]++,r[x+2*L+cnt-1]--; } } } for(int i = 1;i\u0026lt;n;i++) l[i] += l[i-1],r[i] += r[i-1]; for(int i = 0;i\u0026lt;n-1;i++) ans += r[i]*l[i+1]; return ans; } int main(){ int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ init(); printf(\u0026#34;%lld\\n\u0026#34;,solve()); } return 0; }   ","description":"","id":174,"section":"posts","tags":["字符串","后缀数组"],"title":"「NOI2016」优秀的拆分-后缀数组","uri":"https://blog.chenqiqian.com/posts/noi2016-split/"},{"content":"给定 $n$ 个点的高度，规定从 $1$ 点出发，跳到比高度小于当前点的点不消耗体力，否则消耗一点体力，最后到达 $n$ 点。\n$q$ 次询问，每次询问有一个步伐限制 $k$ ，求最少耗费的体力。\n链接 Luogu P3752\n题解 很明显的一个dp。\n状态转移方程：\n$$\n\\begin{equation}\ndp[i] = \\min _ {j \\geq i-k}\n\\begin{cases}\ndp[j] + 1 \u0026amp; ht[i] \\geq ht[j]\\\ndp[j], \u0026amp; ht[i] \u0026lt; ht[j]\n\\end{cases}\n\\end{equation}\n$$\n注意到$j$随$i$的变化而单调递增，所以这个东西可以用单调队列来完成$O(n)$的复杂度。\n不过有一点小问题，在于这个加一的问题。我们注意到，如果我们把dp的值当作第一关键字，高度当作第二关键字，如果最优解的高度较矮，加一之后也不会比次优解要差（单调队列里的最优和次优至少差$1$），所以我们可以如此优化。\n时间复杂度$O(nq)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 1100000; int n,m; int num[MAXN], dp[MAXN]; deque\u0026lt;int\u0026gt; q;// 其中的int为pos  void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); num[0] = 0x3f3f3f3f; for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); } bool cmp(int x,int y){ // 1 -\u0026gt; x 的优先级大于y;0 -\u0026gt; y的优先级大于x  if(dp[x]!=dp[y]) return dp[x] \u0026lt; dp[y]; return num[x] \u0026gt; num[y]; } int getans(int k){ dp[1] = 0; while(!q.empty()) q.pop_back(); q.push_back(1); for(int i = 2;i\u0026lt;=n;i++){ while(!q.empty() \u0026amp;\u0026amp; q.front() \u0026lt; i-k) q.pop_front(); dp[i] = dp[q.front()] + ((num[q.front()] \u0026gt; num[i])? 0: 1); while(!q.empty() \u0026amp;\u0026amp; cmp(i,q.back())) q.pop_back(); q.push_back(i); } return dp[n]; } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); int t; for(int i = 1;i\u0026lt;=m;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); printf(\u0026#34;%d\\n\u0026#34;,getans(t)); } } int main(){ init(); solve(); return 0; }   ","description":"","id":175,"section":"posts","tags":["动态规划","单调队列"],"title":"「POI2014」PTA-单调队列","uri":"https://blog.chenqiqian.com/posts/poi2014-pta/"},{"content":"高斯消元法是线性代数中的一个算法，可用来为线性方程组求解，求出矩阵的秩，以及求出可逆方阵的逆矩阵。当用于一个矩阵时，高斯消元法会产生出一个行梯阵式。\n怎么消？ 一个小小的例子 回想一下你的小学生活吧。\n老师给了你一个方程组。\n$$\n\\left\\{\n\\begin{array}{rc}\n2x+3y = 7 \\\\\n4x-5y = 3\n\\end{array}\n\\right.\n$$\n聪慧如你当然能一眼看出来这个东西的答案是：$x = 2,y = 1$，可是你是怎么看出来的呢？老师告诉过你解二元一次方程组的标准做法：加减消元法。\n具体来说，就是用一式乘以某比例之后去减二式，把方程组变成如下的样子：\n$$\n\\left\\{\n\\begin{array}{rc}\n2x+3y = 7 \\\\\n0x-11y = -11\n\\end{array}\n\\right.\n$$\n然后再把 $y$ 带回一式就可以得到 $x$ ：\n$$\n\\left\\{\n\\begin{array}{rc}\n2x+0y = 4 \\\\\n0x-11y = -11\n\\end{array}\n\\right.\n$$\n从而你知道，$x = 2,y = 1$。\n恭喜你，你已经完成了高斯消元。\n再看上面的例子 如果我们把上面方程组的系数抽出来变成一个行列式，就会如下所示:\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}\n2 \u0026amp; 3 \\\\\n5 \u0026amp; -4\n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}\n7 \\\\\n3\n\\end{array}\\right|\n\\end{array}\n$$\n那么我们消元的过程就会如下所示：\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}\n2 \u0026amp; 3 \\\\\n0 \u0026amp; -11\n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}\n7 \\\\\n-11\n\\end{array}\\right|\n\\end{array}\n$$\n然后是\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}\n2 \u0026amp; 0 \\\\\n0 \u0026amp; -11\n\\end{array}\\right|\n\\quad\n\\left|\\begin{array}{cccc}\n4 \\\\\n-11\n\\end{array}\\right|\n\\end{array}\n$$\n注意到，最后我们达成了一个目标：**使整个行列式只有对角线上的部分不为 $0$ ，其他部分均为 $0$ 。**这个条件的达成，让我们可以方便的计算出来这个方程组的解。\n这也是我们在接下来设计的算法中需要达到的。\n高斯-约旦消元法 运用上面提到的思想去解多元一次方程组的算法，叫做高斯-约旦消元法（Gauss-Jordan Elimination）。\n它有着以下的优点：\n 方便理解 不用回代 精度较高  它有着以下的缺点：\n 运行较慢  实现 简单来说，它的运行过程是这个样子的：每次对于第 $i$ 行，让第 $i$ 列除了第 $i$ 行之外均成为 $0$ ，且不破坏前 $i-1$ 列的该性质。\n具体来说，每次在处理第 $i$ 行时，将第 $i$ 行整行，乘以恰当比例后与除了第 $i$ 行之外的共 $n-1$ 行相减，使得除了第 $i$ 行之外的 $n-1$ 行的第 $i$ 列均为$0$。\n（如果你对于第 $i$ 行第 $i$ 列的数万一是 $0$ 的情况感到困惑，请你先往下看，并假设这个位置上永远不会是 $0$ ）\n正确性的说明：\n我们需要证明的，就是我们在循环中处理完第 $i$ 行时，不会破坏前 $i-1$ 行的该性质。注意到我们前 $i-1$ 次操作已经使得第 $i$ 行以后的前 $i-1$ 列均成为了 $0$ ，即为如下所示：(将要处理第4行)\n$$\n\\begin{array}{}\n\\left|\\begin{array}{cccc}\na \u0026amp; 0 \u0026amp; 0 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; b \u0026amp; 0 \u0026amp; 5 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; c \u0026amp; 3 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; d \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 7 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 5 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 8 \u0026amp; 2 \u0026amp; 3 \u0026amp; 2 \u0026amp; 3\\\\ \\end{array}\\right|\n\\end{array}\n$$\n这个时候我们拿第 $i$ 行无论如何与其他 $n-1$ 行相减，都不会使前 $i-1$ 列的数发生任何改变。这是因为第 $i$ 行的前 $i-1$ 列都是 $0$ 。\n微小的优化 这个算法主要有两个微小的优化：一个是精度上的优化，一个是时间上的优化。\n精度优化 注意到我们在处理第 $i$ 行的时候，在第 $i+1 \\rightarrow n$ 行之间的这些行与第 $i$ 行完全是可以互换的。而这个时候我们用第 $i$ 行与其他行相减的时候，我们为了能获得更优秀的精度，往往会选择在第 $i$ 行到第 $n$ 行中，第 $i$ 列的数的绝对值最大的那一行，与第 $i$ 行交换，然后再进行后面的操作。\n大家都知道，浮点数储存时有不可避免的误差，比如 $2.0000001$ 之类。这个时候如果我们需要对这行乘很多倍，就会导致误差的放大，而除法则不会。\n时间优化 注意到事实上我们再处理第 $i$ 行的时候只需要处理第 $i+1$ 列之后的列，所以我们在行之间相减的时候，运用这个技巧大约可以减少一半的复杂度。\n无解的判定 如果我们发现在处理第 $i$ 行的数的时候，所有能选的第 $i$ 列的数都是 $0$ ，那么这个时候，这个方程就是无解或者没有唯一解的。\n代码 以Luogu P3389 【模板】高斯消元法为例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 110; const double eps = 1e-7; bool gauss(double a[MAXN][MAXN],int n){ for(int i = 1;i\u0026lt;=n;i++){ int r = i; for(int j = i+1;j\u0026lt;=n;j++) if(fabs(a[r][i]) \u0026lt; fabs(a[j][i])) r = j; // 寻找a[r][i]使其绝对值最大  if(r!=i) for(int j = 1;j\u0026lt;=n+1;j++) swap(a[r][j],a[i][j]); // 交换两列  if(fabs(a[i][i]) \u0026lt; eps) return false; // 如果全部都是0，则无解  for(int j = 1;j\u0026lt;=n;j++)if(j!=i){ double t = a[j][i]/a[i][i]; for(int k = i+1;k\u0026lt;=n+1;k++) a[j][k] -= a[i][k] * t; } //使第i个位置的所有其他数都为0  } for(int i = 1;i\u0026lt;=n;i++) a[i][n+1]/=a[i][i]; return true; } int n; double num[MAXN][MAXN]; void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n+1;j++){ scanf(\u0026#34;%lf\u0026#34;,\u0026amp;num[i][j]); } } } void solve(){ if(gauss(num,n)) for(int i = 1;i\u0026lt;=n;i++) printf(\u0026#34;%.2lf\\n\u0026#34;,num[i][n+1]); else printf(\u0026#34;No Solution\\n\u0026#34;); } int main(){ init(); solve(); return 0; }   ","description":"","id":176,"section":"posts","tags":["数学","高斯消元","模板"],"title":"高斯消元法学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-gaussian-elimination/"},{"content":"加里敦大学的生物研究所发现了决定人喜不喜欢吃藕的基因序列 $S$ ,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$ ,任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S0$ 上，有多少个连续子串可能是该基因，即有多少个 $S0$ 的连续子串修改小于等于三个字母能够变成 $S$ 。\n链接 Luogu P3763\n题解 先把两个串拼到一起，然后处理出后缀数组，建立出RMQ的ST表。然后对于每一位都判断是否满足条件即可，即往后取三个LCP，然后判断长度关系即可。\n时间复杂度 $O(n)$。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; const int MAXN = 210000; namespace SA{ int sa[MAXN],rk[MAXN],ht[MAXN],s[MAXN\u0026lt;\u0026lt;1],t[MAXN\u0026lt;\u0026lt;1]; int p[MAXN],b[MAXN],cur[MAXN]; #define pushS(x) sa[cur[s[x]]--] = x #define pushL(x) sa[cur[s[x]]++] = x #define inducedSort(v)\\ fill_n(b,m,0),fill_n(sa,n,-1);\\ for(int i=0;i\u0026lt;n;i++) b[s[i]]++;\\ for(int j=1;j\u0026lt;m;j++) b[j]+=b[j-1];\\ for(int j=0;j\u0026lt;m;j++) cur[j] = b[j]-1;\\ for(int i=n1-1;~i;--i) pushS(v[i]);\\ for(int j=1;j\u0026lt;m;j++) cur[j] = b[j-1];\\ for(int i=0;i\u0026lt;n;i++) if(sa[i]\u0026gt;0 \u0026amp;\u0026amp; t[sa[i]-1]) pushL(sa[i]-1);\\ for(int j=0;j\u0026lt;m;j++) cur[j] = b[j]-1;\\ for(int i=n-1;~i;--i) if(sa[i]\u0026gt;0 \u0026amp;\u0026amp; !t[sa[i]-1]) pushS(sa[i]-1); void sais(int n,int m,int *s,int *t,int *p){ int n1 = t[n-1] = 0,ch = rk[0] = -1,*s1 = s+n; for(int i=n-2;~i;--i) t[i] = s[i]==s[i+1]?t[i+1]:s[i]\u0026gt;s[i+1]; for(int i=1;i\u0026lt;n;i++) rk[i] = (t[i-1]\u0026amp;\u0026amp;!t[i])?(p[n1] = i,n1++):-1; inducedSort(p); for(int i=0,x,y;i\u0026lt;n;i++)if(~(x=rk[sa[i]])){ if(ch\u0026lt;1||p[x+1]-p[x]!=p[y+1]-p[y]) ch++; else for(int j=p[x],k=p[y];j\u0026lt;=p[x+1];j++,k++) if((s[j]\u0026lt;\u0026lt;1|t[j]) != (s[k]\u0026lt;\u0026lt;1|t[k])){ch++;break;} s1[y=x] = ch; } if(ch+1 \u0026lt; n1) sais(n1,ch+1,s1,t+n,p+n1); else for(int i = 0;i\u0026lt;n1;i++) sa[s1[i]] = i; for(int i = 0;i\u0026lt;n1;i++) s1[i] = p[sa[i]]; inducedSort(s1); } template \u0026lt;typename T\u0026gt; int mapChartoInt(int n,const T *str){ int m = *max_element(str,str+n); fill_n(rk,m+1,0);//+1!!!  for(int i = 0;i\u0026lt;n;i++) rk[str[i]] = 1;//=1!  for(int j = 0;j\u0026lt;m;j++) rk[j+1] += rk[j]; for(int i = 0;i\u0026lt;n;i++) s[i] = rk[str[i]]-1; return rk[m]; } // str[n] yange zidianxu zuixiao template \u0026lt;typename T\u0026gt; void suffixArray(int n,const T *str){ int m = mapChartoInt(++n,str); sais(n,m,s,t,p); } void getHeight(int n){ // 这里的循环一定要到a！  for(int i = 0;i\u0026lt;=n;i++) rk[sa[i]] = i; for(int i = 0,h = ht[0] = 0;i\u0026lt;=n;i++){ int j = sa[rk[i]-1]; while(i+h\u0026lt;n \u0026amp;\u0026amp; j+h\u0026lt;n \u0026amp;\u0026amp; s[i+h] == s[j+h]) h++; if(ht[rk[i]] = h) --h; } } } int n,x,y; char s[MAXN]; namespace ST{ int st[20][MAXN]; void build(int n,int *num){ for(int i = 1;i\u0026lt;=n;i++) st[0][i] = num[i]; for(int j = 1,t = 2;t\u0026lt;=n;j++,t\u0026lt;\u0026lt;=1) for(int i = 1;i+(t\u0026gt;\u0026gt;1)\u0026lt;=n;i++) st[j][i] = min(st[j-1][i],st[j-1][i+(t\u0026gt;\u0026gt;1)]); } int query(int l,int r){ int t = log2(r-l+1); return min(st[t][l],st[t][r-(1\u0026lt;\u0026lt;t)+1]); } } void init(){ scanf(\u0026#34;%s\u0026#34;,s); x = strlen(s); scanf(\u0026#34;%s\u0026#34;,s+x); n = strlen(s); y = n-x; s[n] = \u0026#39;A\u0026#39;-1; SA::suffixArray(n,s); SA::getHeight(n); ST::build(n,SA::ht); } int lcp(int a,int b){ if(a == b) return n - a + 1; a = SA::rk[a],b = SA::rk[b]; if(a \u0026gt; b) swap(a,b); return ST::query(a+1,b); } bool judge(int p){ int cnt = 0,len = 0; while(len \u0026lt; y){ len += lcp(p+len,x+len); if(cnt \u0026gt;= 3 \u0026amp;\u0026amp; len \u0026lt; y) return false; len++,cnt++; } return true; } void solve(){ int ans = 0; for(int i = 0;i\u0026lt;=x-y;i++) if(judge(i)) ans++; printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ int T;scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++) init(),solve(); return 0; }   ","description":"","id":177,"section":"posts","tags":["字符串","后缀数组"],"title":"「TJOI2017」DNA-后缀数组","uri":"https://blog.chenqiqian.com/posts/tjoi2017-dna/"},{"content":"手机号码是一个有 $11$ 位且不含前导 $0$ 的数。满足条件手机号码的必须同时满足：号码中出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$ 。\n给定两个数 $L$ 和 $R$ ，统计出 $[L,R]$区间内所有满足条件的手机号码的个数。 $L$ 和 $R$ 都是符合定义的手机号码。\n链接 Luogu P4124\n题解 这个题用数位dp其实也可以递推。\n定义一个状态 $dp[i][j][num][is8][is4]$ ，其中 $i$ 代表需要考虑的是后 $i$ 位； $j$ 表示倒数第 $i+1$ 位是数码 $j$； $num$ 表示目前的连号是几个（ $num = 1,2$ ），若这个为 $3$ 则代表已经出现了连着三位相同的数字；最后两维分别表示有没有出现$8$和有没有出现 $4$ 。状态储存的值就是符合条件的数的个数。\n边界情况就是在 $i == 0$ 的时候。只有 num == 3 且 is8 \u0026amp;\u0026amp; is4 == 0 时，边界才能得 $1$ ；否则就得 $0$ 。\n其次转移就好了。枚举下一个数位从 $0$ 到 $9$ ，然后根据新的数位计算出 $num$ ， $is8$ ， $is4$ 等信息，转移就可以了。这里的 $num$ 如果已经为 $3$ ，就算与上一位相同，我们也不再往上加了；如果不是3的话才往上加。\n注意在计算状态的时候，要把所有 is8 \u0026amp;\u0026amp; is4 == 1 的情况全都置作 $0$ 。\n计算答案的话，就按照普通数位 dp 的统计方式去统计就可以了：把每一位都拆下来，在每一位都取到所有比这一位小的数，最后再加上最后一个数的情况。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;cstdio\u0026gt;using namespace std; #define ll long long  const int MAXN = 12; ll x,y; ll dp[MAXN][MAXN][4][2][2]; //dp[i][j][num][is8][is4]; //后i位，上一个数字是j，连续出现了num个数，有没有出现8，有没有出现4  void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;x,\u0026amp;y); } void solve(){ for(int i = 0;i\u0026lt;=11;i++) for(int j = 0;j\u0026lt;=9;j++) for(int num = 1;num\u0026lt;=3;num++) for(int is8 = 0;is8\u0026lt;=1;is8++) for(int is4 = 0;is4\u0026lt;=1;is4++){ ll \u0026amp;t = dp[i][j][num][is8][is4]; if(i == 0) t = (num==3?1:0);// 边界的判定  else for(int w = 0;w\u0026lt;=9;w++){ t += dp[i-1][w][num==3?3:w==j?num+1:1][is8||(w==8)][is4||(w==4)]; if(is8 \u0026amp;\u0026amp; is4) t = 0; } } } ll cal(ll x){ if (x \u0026lt; 1e10) return 0; int d[20],cnt = 0; while(t) d[++cnt] = x%10,x/=10; d[cnt+1] = 0; ll ans = 0;int num = 0,is8 = 0,is4 = 0; for(int i = cnt;i\u0026gt;=1;--i){ for(int j = 0;j\u0026lt;d[i];j++) ans += dp[i-1][j][num==3?3:d[i+1]==j?num+1:1][(j==8)||is8][(j==4)||is4]; // 该位小于限定数 \tnum = (num == 3?3:d[i]==d[i+1]?num+1:1); is8 |= d[i] == 8; is4 |= d[i] == 4; } ans -= dp[10][0][1][0][0];//减去存在前缀0的情况  ans += dp[0][d[1]][num][is8][is4]; return ans; } void getans(){ ll ans = cal(y)-cal(x-1); printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); getans(); return 0; }   ","description":"","id":178,"section":"posts","tags":["数位dp","动态规划"],"title":"「CQOI2016」手机号码-数位dp","uri":"https://blog.chenqiqian.com/posts/cqoi2016-phone/"},{"content":"给定两个正整数 $a$ 和 $b$ ，求在 $[a,b]$ 中的所有整数中，每个数码(digit)各出现了多少次。\n链接 Luogu P2602\n题解 比较入门的数位dp\u0026hellip;很适合我这种蒟蒻。\n令 $dp[i][j]$ 为当倒数第 $i$ 位为 $j$ 时，后 $i$ 位的数码总计（一个储存着十个整数的结构体，加减即为对位加减）。若 $j=10$ ，则代表这位是前导 $0$ 。(感觉这个搞法有点笨拙\u0026hellip;巨佬能不能教教我\u0026hellip;)\n令 $sum(i,j)$ 为有 $i$ 数码有 $j$ 个，其他均为 $0$ 的状态。\n则状态转移方程为：\n$$dp[1][j] = sum(j,1)$$\n$$dp[i][j] = sum(j,10^{i-1}) + \\sum _ {w = 0}^{9} dp[i-1][w]; ,0\\leq j \\leq 9$$\n$$dp[i][10] = \\sum _ {w = 1}^{10} dp[i-1][w]$$\n计算答案时，这个实在不太好说\u0026hellip;看代码的注释会更好理解\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  #include \u0026lt;cstdio\u0026gt;using namespace std; #define ll long long  ll a,b; const int MAXN = 20; struct sum{ ll num[10]; sum(int pos = -1,ll d = 1){ for(int i = 0;i\u0026lt;10;i++) num[i] = 0; if(~pos) num[pos] = d; } sum operator +(const sum a)const{ sum ans = sum(); for(int i = 0;i\u0026lt;=9;i++) ans.num[i] = this-\u0026gt;num[i] + a.num[i]; return ans; } sum operator *(const int a)const{ sum ans = sum(); for(int i = 0;i\u0026lt;=9;i++) ans.num[i] = this-\u0026gt;num[i] * a; return ans; } sum operator -(const sum a)const{ sum ans = sum(); for(int i = 0;i\u0026lt;=9;i++) ans.num[i] = this-\u0026gt;num[i] - a.num[i]; return ans; } }; sum dp[MAXN][MAXN]; ll t[MAXN]; //dp[i][j] -\u0026gt; 后i位，倒数第i位为j,j == 10 代表为先导0  void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;a,\u0026amp;b); t[0] = 1; for(int i = 1;i\u0026lt;=15;i++) t[i] = 10*t[i-1]; } void build(){ for(int j = 0;j\u0026lt;=9;j++) dp[1][j] = sum(j,1); for(int i = 2;i\u0026lt;=15;i++){ for(int j = 0;j\u0026lt;=9;j++){ dp[i][j] = sum(j,t[i-1]); for(int w = 0;w\u0026lt;=9;w++) dp[i][j] = dp[i][j] + dp[i-1][w]; } dp[i][10] = sum(); for(int w = 1;w\u0026lt;=10;w++) dp[i][10] = dp[i][10] + dp[i-1][w]; } } sum getnum(ll a){ ll tmp = a; sum ans = sum(0,1); if(a == 0) return sum(0,1); int num[15],cnt = 0; while(a){ num[++cnt] = a % 10; a/=10; } ans = ans + dp[cnt][10] - dp[cnt][0]; //加上在这一位有前导0，再除去在这一位是0的  for(int i = cnt;i\u0026gt;=1;--i){ for(int j = 0;j\u0026lt;num[i];++j) ans = ans + dp[i][j]; //加上所有比当前位置小的数的数码  ans = ans + sum(num[i],tmp%t[i-1]+1); //补上后面的数中不再计算的这一位的数码  } return ans; } void solve(){ sum ans = getnum(b)-getnum(a-1); for(int i = 0;i\u0026lt;=9;i++){ printf(\u0026#34;%lld \u0026#34;,ans.num[i]); } printf(\u0026#34;\\n\u0026#34;); } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":179,"section":"posts","tags":["数位dp","动态规划"],"title":"「ZJOI2010」数字计数-数位dp","uri":"https://blog.chenqiqian.com/posts/zjoi2010-count/"},{"content":"JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 JYY 自己看上的。\n为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$ 也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。\n链接 Luogu P4322\n代码 这题看着很高端\u0026hellip;事实上就是一个0/1分数规划+树形dp\u0026hellip;\n0/1分数规划的过程，就是二分选择一个答案 $ans$ ，然后去验证能不能取到若干个 $P_i - ans \\times S_i$ 大于0。\n能不能取到这个大于 $0$ 的东西，用 $O(n^2)$ 的树形dp验证一下就好了。\n我这个代码好像有点锅，不开O2就RE\u0026hellip;懒得找了\u0026hellip;就这样吧\u0026hellip;\n这里的初始化也要注意一下，还有就是循环的边界，因为这里父节点必须取，第一层循环就不能到 $0$ \u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int MAXN = 3000; const double eps = 1e-4; int n,m; double s[MAXN],p[MAXN]; int siz[MAXN]; double dp[MAXN][MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; double k; double tmp[MAXN]; void dfs(int x){ for(int j = 0;j \u0026lt; MAXN;j++) dp[x][j] = -1e9; siz[x] = 1;dp[x][0] = 0;dp[x][1] = p[x] - k*s[x]; for(int i = 0;i\u0026lt;edge[x].size();i++){ int v = edge[x][i]; dfs(v); for(int j = 0;j\u0026lt;=siz[x] + siz[v];j++) tmp[j] = -1e9; for(int j = 0;j\u0026lt;=siz[x];j++) tmp[j] = dp[x][j]; for(int j = siz[x];j \u0026gt;= 1;--j) for(int w = siz[v];w \u0026gt;= 0;--w) if(j+w \u0026lt;= m) tmp[j+w] = max(tmp[j+w],dp[x][j] + dp[v][w]); memcpy(dp[x],tmp,sizeof(double)*(siz[x] + siz[v]+1)); siz[x] += siz[v]; } } bool check(double num){ k = num; dfs(0); return dp[0][m] \u0026gt; -eps; } int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n);m++; int f; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%lf %lf %d\u0026#34;,\u0026amp;s[i],\u0026amp;p[i],\u0026amp;f); edge[f].push_back(i); } double l = 0,r = 10000; while(r - l \u0026gt; eps){ double mid = (l+r)/2; if(check(mid)) l = mid; else r = mid; } printf(\u0026#34;%.3lf\\n\u0026#34;,l); return 0; }   ","description":"","id":180,"section":"posts","tags":["0/1分数规划","树形结构","树形dp"],"title":"「JSOI2016」最佳团体-树上背包+0/1分数规划","uri":"https://blog.chenqiqian.com/posts/jsoi2016-team/"},{"content":"给定两个整数 $n,m$ ，对于平面上的整点 ${(x,y)|x \\in [1,n],y \\in [1,m],x,y \\in \\mathbb Z}$ 。若 $(x,y)$ 与 $(0,0)$ 的连线上有 $k$ 个整点（不包括 $(0,0),(n,m)$ ），则产生的贡献为 $2k+1$ 。求所有满足条件的点的贡献总和。\n链接 Luogu P1447\n题解 给出一个结论：从 $(0,0)$ 到 $(n,m)$ 的\u0008线段上，有 $gcd(n,m)-1$ 个整点(不包括端点)。想一想很好明白：令 $t$ 是 $n,m$ 的公因数， $(\\frac {n}{t},\\frac {m}{t})$ 就相当于步长， $m,n$ 一定时 $t$ 越大，步长越小，整点就越多。 $gcd(n,m)$ 是 $n,m$ 的最大公因数，所以就是最多整点的个数了。\n所以问题转化为：\n求\n$$\\sum _ {i = 1}^{n} \\sum _ {j = 1}^{m}2\\times gcd(n,m)-1$$\n的值。\n显然高端的数学方法我肯定是不会的。那怎么办呢。\n数据范围不允许我们求出对于每一个 $n,m$ 的 $gcd$ ，但是我们可以想办法求出对于每一个 $w$ ， $gcd(i,j) = w$ 的 $(i,j)$ 对数，然后就可以 $O(n)$ 的加出结果了。\n这个东西的话也不太好求\u0026hellip;但是我们可以求出以 $w$ 为约数的树的个数！对于一个 $w$ ，均以 $w$ 为约数的 $(i,j)$ 的个数就是 $\\lfloor \\frac{n}{w} \\rfloor \\times \\lfloor \\frac{m}{w} \\rfloor$ 。\n还有一件事情，就是以 $w$ 为最大公因数的数的个数就是以 $w$ 为约数的数的个数减去以 $kw(k = 2,3,4\u0026hellip;)$ 为最大公因数的个数。\n然后我们就可以开始从上往下的递推了，计算的时候每次往上跳 $w$ ，直到超界，然后都减去就可以了。\n根据一些调和级数的东西， $1+\\frac{1}{2}+\\frac{1}{3}\u0026hellip;+\\frac{1}{n} \\approx \\ln n$ ，所以最后的复杂度大约是 $O(n \\ln n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#define int long long using namespace std; const int MAXN = 110000; int n,m,w,f[MAXN]; void init(){ scanf(\u0026#34;%lld %lld\u0026#34;,\u0026amp;n,\u0026amp;m); w = min(n,m); } void solve(){ int ans = 0; for(int i = w;i\u0026gt;=1;--i){ f[i] = (n/i) * (m/i); for(int j = 2*i;j\u0026lt;=w;j+=i) f[i] -= f[j]; ans += f[i]*(2*i-1); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } signed main(){ init(); solve(); return 0; }   ","description":"","id":181,"section":"posts","tags":["数学","最大公约数"],"title":"「NOI2010」能量采集-简单数学","uri":"https://blog.chenqiqian.com/posts/noi2010-energy/"},{"content":"给定一个 $n$ 个点 $m$ 条边的无向图，每条边有两个权值 $a_i,b_i$ 。请你找到一条从 $1 \\rightarrow n$ 的道路，令道路上所有边的集合为 $S$ ，使 $ans = \\max(a_i)+\\max(b_j),i,j \\in S$ 最小，求出这个最小值 $ans$ 。\n链接 Luogu P2387\nBZOJ 3669\n题解 这题告诉我们了一个 LCT (连猫树)的新用法：动态维护最小生成树。\n思考一下：如果我们有一颗生成树，现在再添加进一条边，图里必然会出现一个环。而新的最小生成树就是在这个环里面砍掉最大的那一条边而得到的。\n这是非常显然的。\n可以发现一个结论，就是给定一个无向图，那么 $1 \\rightarrow n$ 路径上边权最大值最小的这些边一定在其最小生成树里面。这个只要考虑一下 $Kruskal$ 算法的过程就很容易明白。\n那么再回来看这个问题。如果这个地方只有一维的限制，那么我们就可以用并查集做。这是一个离线的做法，也就是我们把所有边一股脑的扔进去，拿到一个最小生成树，然后答案就是这两点之间的边权最大值。（其实是并查集直到两个东西联通为止）\n但是现在有了 $a$ 这一维的限制，该怎么办呢？考虑一下贪心的做法，我们可以利用 LCT 动态维护最小生成树的特点。\n考虑对于 $a$ 排序之后，就可以排除掉 $a$ 对这个东西的干扰。然后我们按照 $a$ 从小到大往树里面加边，每次维护最小生成树，答案就可以用 $a _ {now} + b _ {max}$ 来求得，动态更新即可。\n为什么这个东西是正确的呢？如果路径上的 $a _ {max} \u0026lt; a _ {now}$ ，会不会对答案造成影响？\n不会。因为如果 $a _ {max} \u0026lt; a _ {now}$ ，那么在我们加到 $a _ {max}$ 这条边的时候，其所有路径上的边应该已经出现，就可以囊括 $a _ {max} + b _ {max}$ 这种情况了。而如果后面换用了其他 $b$ 更小的边，显然 $a _ {max}$ 会扩大为 $a _ {now}$ ，算法的正确性就可以保证了。\nLCT 只能维护点权，所以我们把边换成点，每次 $link$ 或者 $cat$ 的时候连或者猫两下就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 151000; struct Link_Cat_Tree{ int val[MAXN],maxn[MAXN]; int c[MAXN][2],f[MAXN]; bool rev[MAXN]; int getmax(int u,int x,int y){ if(val[u] \u0026gt;= val[maxn[x]] \u0026amp;\u0026amp; val[u] \u0026gt;= val[maxn[y]]) return u; else if(val[maxn[x]] \u0026gt;= val[maxn[y]]) return maxn[x]; else return maxn[y]; } bool noroot(int x){ return (c[f[x]][1] == x) || (c[f[x]][0] == x); } void push_up(int x){ if(!x) return; maxn[x] = getmax(x,c[x][0],c[x][1]); } void reverse(int x){ if(!x) return; swap(c[x][0],c[x][1]); rev[x]^=1; } void push_down(int x){ if(!x) return; if(rev[x]){ reverse(c[x][0]),reverse(c[x][1]); rev[x] = 0; } } void push_all(int x){ if(!x) return; if(noroot(x)) push_all(f[x]); push_down(x); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y;c[y][t] = w; if(w) f[w] = y; f[y] = x;f[x] = z; push_up(y),push_up(x); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)) (c[z][1] == y) ^ (c[y][1] == x) ? rotate(x):rotate(y); rotate(x); } } void access(int x){ for(int y = 0;x;x=f[y=x]){ splay(x); c[x][1] = y,push_up(x); } } void makeroot(int x){ access(x);splay(x);reverse(x); } int findroot(int x){ access(x);splay(x); push_down(x); while(c[x][0]) x = c[x][0],push_down(x); return x; } void link(int x,int y){ makeroot(x); if(findroot(y) != x) f[x] = y; } void cat(int x,int y){ makeroot(x); if(findroot(y) == x \u0026amp;\u0026amp; f[x] == y \u0026amp;\u0026amp; !c[x][1]) f[x] = c[y][0] = 0,push_up(y); } void split(int x,int y){ makeroot(x),access(y),splay(y); } int querymax(int x,int y){ return split(x,y),maxn[y]; } }T; //点1-\u0026gt;n 边n+1-\u0026gt;n+m int n,m; struct Edge{ int from,to,a,b; }edge[MAXN]; bool cmp(Edge x,Edge y){ return x.a \u0026lt; y.a; } void init(){ read(n),read(m); int a,b,f,t; for(int i = 1;i\u0026lt;=m;i++){ read(f),read(t),read(a),read(b); edge[i] = (Edge){f,t,a,b}; } } void solve(){ int ans = 0x3f3f3f3f; sort(edge + 1,edge+m+1,cmp); for(int i = 1;i\u0026lt;=m;i++) T.val[n+i] = edge[i].b; for(int i = 1;i\u0026lt;=n+m;i++) T.maxn[i] = i; int x = 0,y = 0,a = 0,b = 0; for(int i = 1;i\u0026lt;=m;i++){ x = edge[i].from,y = edge[i].to; a = edge[i].a,b = edge[i].b; if(x == y) continue; if(T.findroot(x)!=T.findroot(y)) T.link(n+i,x),T.link(n+i,y); else{ int t = T.querymax(x,y) - n; if(edge[t].b \u0026lt; b) continue; T.cat(n+t,edge[t].from),T.cat(n+t,edge[t].to); T.link(n+i,x),T.link(n+i,y); } if(T.findroot(1) == T.findroot(n)) ans = min(ans,a+edge[T.querymax(1,n)-n].b); } if(ans \u0026gt; 1000000000) print(-1); else print(ans); print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":182,"section":"posts","tags":["数据结构","LCT"],"title":"「NOI2014」魔法森林-LCT","uri":"https://blog.chenqiqian.com/posts/noi2014-forest/"},{"content":"什么是梦想呢\u0026hellip;\n序 有的时候，总会有人问我：“你有梦想吗？”我向来是最烦这种问题的，所以往往搪塞一句回去：“没有。我就是条没有梦想的咸鱼。”\n最近写完作文，再去细细回想，或许我也曾有过梦，只不过大约是忘记了吧。\n梦·想 一 我不怎么做梦。我自认为我是一个非常现实的人，现实到不会幻想，现实到总会否定自己，现实到不会做梦。\n某人就不一样。如果说我是个现实主义的人，那么我觉得这位的生活里，更多的是些许浪漫主义的情怀和洒脱。某人的梦，就比我的有趣的多了。\n但我也有平衡现实主义的特点。对于我来说，只要不是特别大的事情，所有的上一天的不快在睡一觉之后，大多都是会忘掉的，长此以往，显得我的性格也就比较随和，不易生气了吧。\n但我忘掉的恐怕也包括梦吧。\n二 感觉不论什么时候，如果你问我：“你以后想干什么啊？”我恐怕都会稍稍思考一会，然后遗憾的说道：“我不知道啊。”\n的确，我从来都不知道我想要去做什么，我人生的意义是什么。或许我在小时候小小的高床上也曾经思考过，但一切都好像已经远去了。\n最近我似乎又思考出了一个冠冕堂皇的借口，来抵御这些询问：“生而为生。”这个借口一出，终于摆脱了无尽的询问：懂得的人知道这是一个无关紧要的借口，不懂得人觉得这是一个无关紧要的玩笑。\n于是，所有人似乎都觉得这件事情无关紧要了。\n三 渐渐的，也没有时间让我去思考了。\n生活越来越烦躁了。越来越多的事情，让我简直腾不出手来。明天要考试了，今天得赶快复习；明天要上课了，今天要稍微预习一下；明天要讲新算法了，现在还不会。\n总有那么多的事，在每一个方面堵住你的丝丝缕缕的梦，让你不得不回到沉重的桌前。无时无刻，身边萦绕着的都是嘈杂与烦乱的声音，督促着你上进，督促着你在一条无尽的独木桥上越走，越走，越远。\n有什么可以去想的呢\u0026hellip;只不过勉强能让自己不在这木桥上摔下去，摔得遍体鳞伤，摔得无处可归。\n你问我什么是「梦」，什么是「想」？\n我不知道。\n四 小时候的梦想总是易碎的。我梦想着考年级第一，享受无边的夸耀；我梦想着什么东西一学就会，却无数次倍遭打击；我梦想着有一天能够买下家门口的一大片空地，可十多年过去，覆盖其上的仍然是一片荒芜。\n我也不断的问自己：什么才是我真正想要的梦想？我究竟能做到什么？\n或许，我们大部分人，都是这苍茫世界中的一粒草芥吧。世界不会以你的意志为转移，你也很难去改变或者世界，甚至是你家门口的一片空地。我们所能做的，恐怕也只是活好自己，让自己活好，让你所有希望能够好好活着的人活好。除此之外，我们，不过是漫天大雪中被风无力裹挟着的一片雪花，只能打着转，被风吹着，到一个不知道什么的地方吧。\n然而活着，这恐怕也不容易呢。\n所以啊，我就在想我应该为什么而活着。但或许我心里早已有了答案吧。我不知道我从哪里得来的这个结论，也不知道任何有关的过程。\n趁现在能开心的活着，做人多天真一点，去追寻自己内心想要的吧。\n已经逝去的梦，就让它成为美好的回忆；还在手心的梦，就将它捧好，祈愿它永不离去。\n一点更多的话 最近我终于明白，哪有那么多梦想。\n你的阶级，你的身份，你的人生在此刻之前的每一秒，都让你的某些梦想，或大或小，无声的坠地。\n有的人，他们或出身显赫，或一世豪门。他们生来，就已经跨过了温饱、小康，这种在中国社会里还没有完全普及的生活。他们可以有梦想。他们如果今天想要干些什么，自会有人在明天，把所有他想要的，搬上桌去。\n但其实，人们中的大部分，和他们，追求的所谓「梦想」，恐怕都不是一样的东西，甚至不在一个层次上。他们中有的人可以想着去改变世界，因为就算改变不了这个世界，他也能一辈子活在父辈的荫护之下。而对于大多数人，如果世界没有被你改变，那么，你就会被这个世界毁灭。\n你应该去市井逛逛。看看那些在建筑工地上的工人，看看他们黝黑的肌肤，看看那些住在不到十平米的地下室里面的人。他们的奋斗，很多恐怕也都是为了晚上的一顿饭，为了能够在这个世界上拥有一些最基本的权利吧。\n 時間永是流駛，街市依舊太平。\n 百年前的工人就在社会的底层，而如今，仍然如此。那是什么人代替了土豪、地主、资本家和官僚阶级呢？\n不管是谁，我相信，他们肯定是有梦想的。\n最后 我还很天真，这是毫无疑问的。就像我现在看三年前的作文一样，三年后再来看这里，恐怕也会认为这不过是无病的牢骚，令人恶心。\n但不论如何吧，这也是一点点微小的思想。虽然肯定十分的幼稚，但我想，以后再看到的时候，多少也会有那么一点点的启示吧。\n Stay simple. Stay naïve.\n 应某人要求，写成这样一篇小文，以聊寄微情。\n你的「梦想」？  某人的一篇「梦想」\n 我从未想过在这里遇到她。她身上的文字，是应该让人经历了风沙的洗礼，怀着朝圣的心匍匐着翻过沙丘才能细细拜读，绝不是在这冰冷的玻璃柜里，与耶稣的画像和法老的木乃伊为邻，赤裸着暴露在游人迷茫的眼睛下，企盼着故人匆匆走过时的一瞥。我心里涌起一阵不平，一个强烈的愿望如热风一样席卷而来，把我带回一百年前的中国。\n沙丘上浮出三个人影，一个骑在马上，另两个一前一后地跟着。走在前的牵着马，身材瘦高。后面的垂着手小步跟着，扮成道士模样。正是他们了。\n马背上的外国人首先看到了我，他的面露戒备，稍稍拉紧了缰绳。“斯坦因！”三人应声而停，牵马的买办向我微微欠腰，眼神里却满是厌恶。“你我在这不毛之地相见定是有缘了。您既知道我们老板斯坦因先生的大名，相必对我们老板此行的高尚目的也有所耳闻。这马上所载皆是贵重之物，我等归京心切不便耽搁，见谅。”“等等。”我上前一步。“蒋孝琬，斯坦因不懂中文你大可不必对我说这冠冕堂皇之话。”他的脸突然拉下来：“不知您有何贵干。”“你我二人，还有王道士。”我看向他时他怕得只不断作揖念着“无量观”“我们三个都是中国人，这马上载的都是中国的宝物。你只告诉斯坦因我是在此等他来保他过沙漠的向导，机会一到我们就把斯坦因身上的枪拿过来，逼他和我们回去，把这些经书全放回藏经洞。他孤身在外不得不信任你，这事一定能成。”“您这是要置我于不义之地啊。”“不义？我是让您免做历史的罪人，被子孙万世唾弃！”“我只区区一个平民，流传千古倒是我的运气呢。只是拿了人的钱就得帮人做事，买卖定了就再无反悔的余地。”\n“他给了你多少钱。”我转向王道士。“大人念佛心虔，给了小道30英镑。”30英镑\u0026hellip;千百年来大师们的智慧结晶只值30英镑！“你为什么不把这发现告诉朝廷，大清的国库里绝不止有30英磅啊！”“哼”蒋孝琬冷笑一声“朝廷的钱都去给老佛爷办寿了。上交了朝廷，沿途押韵的官员谁不从中抽利？先就把好东西挑光了。况且这朝廷也不稳固了，一路上到处都是军阀。这书要是落到他们手里，哼，肯定是撕了擦屁股\u0026hellip;要我说，只有洋人靠的住…”\n他的声音渐渐远了，烟霭下只剩落寞的我。神游归来，梦想破灭，面对着这一屋子的展品，我突然感到很自卑。历史的厚重压的我喘不过气。我不知道一个人的错误，需要多少后人来弥补。或者是否因为史书上只留下这一两个犯错的人的名字，我们就让他们来顶替一个民族的罪过。不愿再想了，只希望以后的人们不再在异国的博物馆里经受这梦想破灭的悲哀。\n 太强啦！\n","description":"","id":183,"section":"posts","tags":null,"title":"「梦想」","uri":"https://blog.chenqiqian.com/posts/essay-dream/"},{"content":"小凸和小方相约玩密室逃脱，这个密室是一棵有 $n$ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。\n每个灯泡有个权值 $a_i$ ，每条边也有个权值 $b_i$ 。点亮第 $1$ 个灯泡不需要花费，之后每点亮 $1$ 个新的灯泡 $v$ 的花费，等于上一个被点亮的灯泡 $u$ 到这个点 $v$ 的距离 $D _ {u,v}$ ，乘以这个点的权值 $a_v$ 。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。\n请告诉他们，逃出密室的最少花费是多少。\n链接 BZOJ 4446\nLuogu 4253\n题解 这个树形dp真是可以说神了orz\u0026hellip;最近做到的神题真多\u0026hellip;（萌萌哒，LCA，再加上这个\u0026hellip;\n思考一下怎么表示状态。如果我们已经第一个点亮了一个点（假设其他点都未被点亮），那么我们必须先点亮这两个子树。由于必须联通而且必须只能点子树，下一步只能点亮两个儿子之一。而点亮的那个儿子的子树肯定要先被全部点亮，然后才能点亮另一个一个子树。\n如果我们忽略上一个点点在哪里的话，那么我们事实上发现上述的过程是一个无后效性的子结构，这个东西就可以设置成状态了。但这个事情的最关键的问题在于我们忽略了上一个点点在哪里，那我们怎样去表示这个 $D _ {u,v} \\times a_v$ 的过程呢？\n这个时候我们发现我们不知道上一个点点在哪里，但是我们可以知道下一个点点在哪里。如果我们发现我们点完了一个子树，我们现在只有两种情况：\n  我们所有目前点完的点构成了一颗更大的完整的子树，这个时候我们就只能去点这个更大的完整的子树的\n根节点的父节点。\n  我们现在所有点完的点不能构成一棵更大的完整的子树，这个时候我们就必须点完最近的没有点的一个子树。\n  事实上只有两种情况，也就是到某个祖先，或者某个祖先的兄弟。\n所以我们用 $dp[i][j][0]$ 表示点完以第 $i$ 个点为根节点的子树之后，再去点其第 $j$ 个祖先的过程需要的最小花费， $dp[i][j][1]$ 表示点完以第 $i$ 个点为根节点的子树之后，再去点其第 $j$ 个祖先的另一个儿子的过程需要的最小花费。注意到这是一个完全二叉树，所以保证了我们的状态的数目是 $O(n \\log{n})$ 的。\n转移方程太长，不写了，简单说一说如何转移。\n简单来说，需要分成三类讨论：没有儿子；只有一个儿子；有两个儿子。\n没有儿子的没啥好说的。有一个儿子的就相当于不变结束节点进入这个子树。有两个儿子的就有两种情况：先进左子树和先进右子树，分开讨论即可。状态转移是 $O(1)$ 的。\n具体来说的话看代码注释。\n以上只是我们计算答案的一个辅助。\n我们发现，如果选定一个点作为固定的起点，那么这个东西它点的顺序就是确定的。所以我们按照点灯规则确定子树的顺序，再加上子树之间转移的代价，就可以推出答案。这里需要对有没有兄弟节点进行分类讨论。由于树的高度是严格 $O(\\log n)$ 的，所以我们的每个点的递推也是 $O(\\log n)$ 的。\n时间复杂度与空间复杂度都是 $O(n \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; #define ll long long  const int SIZE = 1024*1024;char ibuf[SIZE],*s,*t; inline char read(){ if(s==t) t=(s=ibuf)+fread(ibuf,1,SIZE,stdin); return s==t?-1:*s++; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x){ static char c;bool iosig; for(c=read(),iosig=0;!isdigit(c);c=read()){ if(c==-1) return; iosig |= (c==\u0026#39;-\u0026#39;); } for(x=0;isdigit(c);c=read()) x = (((x\u0026lt;\u0026lt;2)+x)\u0026lt;\u0026lt;1) + (c^48); if(iosig) x = -x; } const int MAXN = 210000,logn = 20; int n; ll num[MAXN]; ll dp[MAXN][logn][2]; //点亮了i这个节点和子树的所有节点，下一个点亮到？级祖先的？儿子的最小代价 ll dis[MAXN][logn]; //从i节点向上j个节点的长度  #define p(i,j) (((1\u0026lt;\u0026lt;(j-1))\u0026lt;=i)?(i\u0026gt;\u0026gt;j):-1) //i的j祖先，上设虚拟0节点，其他均为-1 //num[0] = 0,dis[1][1] = 0 #define b(i,j) ((i\u0026gt;\u0026gt;(j-1))^1) //i的j祖先的另一个儿子 #define lson (i\u0026lt;\u0026lt;1) #define rson ((i\u0026lt;\u0026lt;1)|1)  void init(){ read(n); for(int i = 1;i\u0026lt;=n;i++) read(num[i]); dis[1][1] = 0; for(int i = 2;i\u0026lt;=n;i++){ read(dis[i][1]); for(int j = 2;~p(i,j);j++) dis[i][j] = dis[p(i,1)][j-1] + dis[i][1]; } } void solve(){ //0 祖先 1 兄弟  for(int i = n;i \u0026gt;= 1;--i){ for(int j = 1;~p(i,j);j++){ dp[i][j][0] = dp[i][j][1] = 0x3f3f3f3f3f3f3f3f; if((i\u0026lt;\u0026lt;1) \u0026gt; n){//一个儿子都没有  dp[i][j][0] = dis[i][j] * num[p(i,j)]; dp[i][j][1] = (dis[i][j] + dis[b(i,j)][1]) * num[b(i,j)]; } else if(((i\u0026lt;\u0026lt;1)|1) \u0026gt; n){//只有左儿子  //注意要加上从根节点到儿子的代价  dp[i][j][0] = dp[lson][j+1][0] + dis[lson][1] * num[lson]; dp[i][j][1] = dp[lson][j+1][1] + dis[lson][1] * num[lson]; } else{//有两个儿子  //两种转移方式，左-\u0026gt;右 or 右-\u0026gt;左 ，注意要加上从根节点到儿子的代价  dp[i][j][0] = min(dp[i][j][0],dp[lson][1][1]+dp[rson][j+1][0] + dis[lson][1] * num[lson]); dp[i][j][0] = min(dp[i][j][0],dp[rson][1][1]+dp[lson][j+1][0] + dis[rson][1] * num[rson]); dp[i][j][1] = min(dp[i][j][1],dp[lson][1][1]+dp[rson][j+1][1] + dis[lson][1] * num[lson]); dp[i][j][1] = min(dp[i][j][1],dp[rson][1][1]+dp[lson][j+1][1] + dis[rson][1] * num[rson]); } } } //计算答案  ll ans = 0x3f3f3f3f3f3f3f3f; for(int s = 1;s\u0026lt;=n;s++){ //从s点开始，先点亮所有s子树的节点和s的父亲  ll tmp = dp[s][1][0]; for(int i = p(s,1),last = s;~i;i = p(i,1),last = p(last,1)){ //last节点的子树即i节点已经被点亮，现在要点亮i的父亲节点  //有兄弟，就需要去先点亮兄弟，再点亮i的父亲（last兄弟的祖父）节点  if(b(last,1) \u0026lt;= n) tmp += dis[b(last,1)][1] * num[b(last,1)] + dp[b(last,1)][2][0]; else tmp += dis[i][1] * num[p(i,1)]; //加上从i到i的父亲节点的代价  } ans = min(ans,tmp); } printf(\u0026#34;%lld\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":184,"section":"posts","tags":["动态规划","树形结构"],"title":"「SCOI2015」小凸玩密室-树形dp","uri":"https://blog.chenqiqian.com/posts/scoi2015-room/"},{"content":"对于序列 $A$ ，它的逆序对数定义为满足 $i\u0026lt;j$ ，且 $A_i\u0026gt;A_j$ 的数对 $(i,j)$ 的个数。\n给出一个 $1$ 到 $n$ 的排列，按照某种顺序依次删除 $m$ 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n链接 Luogu P3157\n题解 CDQ分治强啊。\n这道题可以用树状数组\u0026amp;主席树做，不过很难写。\nCDQ分治的话，实现难度上比较低一些吧。\n首先，我们转化问题为每次在某个位置添加一个数，并查询能贡献出来的逆序对个数。这个问题和题目是等价的。\n然后我们令这个删除的反着的顺序为 $id$ ，其插入的位置为 $b$ ，插入的值为 $c$ ，我们要求的就是在 $id \\in [1,id - 1]$ 的数中，满足 $b_j \u0026lt; b_i,c_j \u0026gt; c_i$ 或者 $b_j \u0026gt; b_i,c_j \u0026lt; c_i$ 的 $j$ 有多少个。\n这个问题我们用 CDQ 归并解决。先按照 $id$ 排序，然后对 $b$ 进行归并，完成后正序和倒序各扫一遍，统计贡献，最后作前缀和即可。\n实现有一点点不好写。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;#define ll long long using namespace std; const int MAXN = 110000; namespace fast_io{ //... }using namespace fast_io; struct Q{ bool w; int id,b,c; // id -\u0026gt; 加入时间 b -\u0026gt; 加入的位置 c -\u0026gt; 这个数的大小  Q(int x,int y,int z):id(x),b(y),c(z){} Q(){} bool operator \u0026lt; (Q w)const{//用于排序  if(id!=w.id) return id \u0026lt; w.id; if(b!=w.b) return b \u0026lt; w.b; return c \u0026lt; w.c; } }q[MAXN]; int n,m; int num[MAXN],pos[MAXN],del[MAXN]; ll ans[MAXN]; // num -\u0026gt; 原数组 // pos -\u0026gt; 值对应的位置 // del -\u0026gt; 删除第 pos 个数的序顺  namespace BIT{ ll sumn[MAXN]; int lowbit(int x){ return x \u0026amp; (-x); } void add(int x,int d){ while(x \u0026lt;= n) sumn[x] += d,x += lowbit(x); } ll query(int x){ ll ans = 0; while(x \u0026gt;= 1) ans += sumn[x],x -= lowbit(x); return ans; } } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++){ read(num[i]); pos[num[i]] = i; } int tmp; for(int i = 1;i\u0026lt;=m;i++){ read(tmp); del[pos[tmp]] = i; } } int l,r,tot,tmp[MAXN]; inline bool judge(int x,int y){ //判断归并顺序函数 这里因为不重复，可以不写其他维判定  return q[x].b \u0026lt; q[y].b; } void CDQ(int *t,int num){ if(num == 1) return; int mid = num/2; CDQ(t,mid),CDQ(t+mid,num-mid);//分治解决问题  //进行归并  for(l=0,r=mid,tot=0;tot \u0026lt; num;tot++){ if((r==num)||(l\u0026lt;mid \u0026amp;\u0026amp; judge(t[l],t[r])))//这一行的条件易错  q[t[l]].w = 0,tmp[tot] = t[l++]; else q[t[r]].w = 1,tmp[tot] = t[r++]; } for(int i = 0;i\u0026lt;num;i++) t[i] = tmp[i]; //统计id(time)比其小 b(pos)比其小 c(val)比其大的数的个数  for(int i = 0;i\u0026lt;num;i++) if(!q[t[i]].w) BIT::add(q[t[i]].c,1); else ans[q[t[i]].id] += BIT::query(n)-BIT::query(q[t[i]].c); for(int i = 0;i\u0026lt;num;i++) if(!q[t[i]].w) BIT::add(q[t[i]].c,-1); //统计id(time)比其小 b(pos)比其大 c(val)比其小的数的个数  for(int i = num-1;i\u0026gt;=0;--i) if(!q[t[i]].w) BIT::add(q[t[i]].c,1); else ans[q[t[i]].id] += BIT::query(q[t[i]].c-1); for(int i = num-1;i\u0026gt;=0;--i) if(!q[t[i]].w) BIT::add(q[t[i]].c,-1); } void solve(){ int nowcnt = 0; static int tt[MAXN]; for(int i = 1;i\u0026lt;=n;i++){ //遍历每个pos  if(del[i] == 0) q[i] = Q(1,i,num[i]); else q[i] = Q(m-del[i]+2,i,num[i]); } sort(q+1,q+1+n); for(int i = 1;i\u0026lt;=n;i++) tt[i] = i; CDQ(tt+1,n); // 前缀和统计答案  for(int i = 1;i\u0026lt;=m+1;i++) ans[i] += ans[i-1]; for(int i = m+1;i\u0026gt;1;--i) print(ans[i]),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":185,"section":"posts","tags":["CDQ分治","数据结构"],"title":"「CQOI2011」动态逆序对-CDQ分治","uri":"https://blog.chenqiqian.com/posts/cqoi2011-inverse/"},{"content":"有 $N$ 个位置， $M$ 个操作。\n操作有两种：\n 如果是 1 a b c 的形式表示在第 $a$ 个位置到第 $b$ 个位置，每个位置加入一个数 $c$ ； 如果是 2 a b c 形式，表示询问从第 $a$ 个位置到第 $b$ 个位置，第 $c$ 大的数是多少。  链接 Luogu P3332\n题解 可以树套树。然后基本上就会死在树上。\n正解整体二分。\n比较模板，就不讲思路了，主要说一说实现。这个地方的区间加数其实和单点加数是一样的，只不过把原来单点修改的树状数组改成区间修改的线段树。\n注意，整体二分是按答案二分，每次二分我们的在原区间上处理范围仍然是整个区间，不要搞错成啥的\u0026hellip;\n还有注意，这里每一层递归的复杂度一定只能与你的正在处理的询问的个数有关！不能带有其他项，所以我们这里归零线段树的时候是一个个减回去，复杂度就是 $O(n \\log {n})$ 。\n递归的每层都要处理 $n$ 个操作，一共有 $\\log n$ 层，处理每个询问的时间是 $O(\\log n)$ ，最后的复杂度就是 $O(n \\log ^{2} {n})$ 。\n莫名跑的就特别慢\u0026hellip;明明我写了zkw线段树啊\u0026hellip;BZOJ莫名RE\u0026hellip;明明我luogu和codevs上全AC了啊\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; #define ll long long #define mid ((l+r)\u0026gt;\u0026gt;1) const int MAXN = 51000; namespace fast_io{ //... }using namespace fast_io; struct ZKW{ //区间修改、求和zkw线段树  ll sumn[MAXN\u0026lt;\u0026lt;2],addn[MAXN\u0026lt;\u0026lt;2]; int M; void init(int n){ for(M = 1;M\u0026lt;=n+2;M\u0026lt;\u0026lt;=1); } void update(int l,int r,ll d){ int i=1,L=0,R=0; for(l=l+M-1,r=r+M+1;l^r^1;l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1,i\u0026lt;\u0026lt;=1){ sumn[l]+=L*d,sumn[r]+=R*d; if(~l\u0026amp;1) addn[l^1]+=d,sumn[l^1]+=d*i,L+=i; if(r\u0026amp;1) addn[r^1]+=d,sumn[r^1]+=d*i,R+=i; } sumn[l]+=L*d,sumn[r]+=R*d; while(l\u0026gt;\u0026gt;=1) sumn[l]+=(L+R)*d; } ll query(int l,int r){ ll ans = 0;int i=1,L=0,R=0; for(l=l+M-1,r=r+M+1;l^r^1;l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1,i\u0026lt;\u0026lt;=1){ ans+=addn[l]*L,ans+=addn[r]*R; if(~l\u0026amp;1) ans+=sumn[l^1],L+=i; if(r\u0026amp;1) ans+=sumn[r^1],R+=i; } ans+=addn[l]*L,ans+=addn[r]*R; while(l\u0026gt;\u0026gt;=1) ans+=addn[l]*(L+R); return ans; } }tree; struct Q{ int o,ql,qr; ll k; // o == 0 -\u0026gt; update l r val; o == 1 -\u0026gt; query l r k  Q(){} Q(int a,int b,int c,ll d):o(a),ql(b),qr(c),k(d){} }query[MAXN]; int tl[MAXN],tr[MAXN],ans[MAXN]; void solve(int *a,int n,int l,int r){ //表示要处理的询问在q[0]-\u0026gt;q[n-1]，二分答案范围为[l,r]  if(n == 0) return;//一个微小的剪枝  if(l == r){ //递归边界  for(int i = 0;i\u0026lt;n;i++) ans[a[i]] = l; return; } int n1 = 0,n2 = 0;ll sum; for(int i = 0;i\u0026lt;n;i++){ Q \u0026amp;q = query[a[i]]; if(q.o == 1){ //修改如果值大于mid，就应用修改；否则不管  if(q.k \u0026gt; mid) tree.update(q.ql,q.qr,1),tr[n2++] = a[i]; else tl[n1++] = a[i]; } else if(q.o == 2){ //查询的结果sum大于k，二分到右边；否则左边  sum = tree.query(q.ql,q.qr); if(q.k \u0026lt;= sum) tr[n2++] = a[i]; else q.k -= sum,tl[n1++] = a[i]; } } //原样减回去  for(int i = 0;i\u0026lt;n;i++){ Q \u0026amp;q = query[a[i]]; if(q.o == 1 \u0026amp;\u0026amp; q.k \u0026gt; mid) tree.update(q.ql,q.qr,-1); } memcpy(a,tl,sizeof(int) * n1),memcpy(a+n1,tr,sizeof(int) * n2); //递归二分  solve(a,n1,l,mid),solve(a+n1,n2,mid+1,r); } int n,m,t[MAXN]; void init(){ read(n),read(m); tree.init(n); int op,l,r;ll c; for(int i = 0;i\u0026lt;m;i++){ read(op),read(l),read(r),read(c); query[i] = Q(op,l,r,c); t[i] = i; } } void solve(){ solve(t,m,-n,n); for(int i = 0;i\u0026lt;m;i++){ if(query[i].o == 2) print(ans[i]),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":186,"section":"posts","tags":["整体二分","数据结构"],"title":"「ZJOI2013」K大数查询-整体二分","uri":"https://blog.chenqiqian.com/posts/zjoi2013-kth/"},{"content":"有 $n$ 朵花,每朵花有三个属性：花形( $s$ )、颜色( $c$ )、气味( $m$ )，用三个整数表示。显然，两朵花可能有同样的属性。\n定义一朵花 $A$ 比另一朵花 $B$ 要美丽，当且仅当 $S_a\\geq S_b$ , $C_a\\geq C_b$ , $M_a \\geq M_b$ 。定义一朵花的等级是它拥有的美丽能超过的花的数量。\n求出每个等级的花的数量。\n 陌上花开，可缓缓归矣。\n 链接 Luogu P3810\n题解 这道题还有一个名字叫「三维偏序」，题面如下：\n 有 $n$ 个元素，第 $i$ 个元素有 $a_i$ 、$b_i$ 、$c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \\leq a_i$ 且 $b_j \\leq b_i$ 且 $c_j \\leq c_i$ 的 $j$ 的数量。\n对于$d \\in [0, n)$，求$f(i) = d$的数量\n 我在这里使用上面的题面。（虽然是一样的。\n这是一道三维偏序的模版题。很多一些二维的问题经过转化也可以变成三维偏序的类似问题，套用排序+CDQ分治+BIT来解决。\n假设所有的 $(a,b,c)$ 互不相同。\n第一维：排序\n按照 $a$ 的大小排序从新编号 $1 -\u0026gt; n$ ，排序完成后就可以发现对于第 $i$ 个元素，满足条件的元素只存在于 $[1,i-1]$ 中。问题转化为：在 $[1,i-1]$ 中有多少个满足 $b_i \\geq b_j$ 且 $c_i \\geq c_j$ 的元素。\n这个问题其实就是二维数点。因为 $b$ 乱序添加，所以不能离线解决，可以用树套树在线解决。\n但是呢，我们用 $CDQ$ 分治，就可以化动态为静态。\n第二维：$CDQ$ 分治\n什么是 $CDQ$ 分治呢？在这里就是一个类似归并排序的东西，因为我们要统计的是小于一个数的个数。\n事实上在这里，我们对于每一个元素 $i$ ，都将其看成同样内容的一次询问和一次修改。\n我们在解决一个询问的区间 $[L,R]$ 时，我们只需要累计这个区间里左半部分的修改对右半部分的查询的贡献就可以了。正确性不太显然，跟树状数组类似，查询时能够涵盖 $[1,i-1]$区间。\n第三维也可以接着用 $CDQ$ 分治，那就真的是归并排序了。就像归并统计逆序对似的，我们在第三维按 $c$ 进行归并排序。只需要多维护一个标记，标记在上一维里面其属于左区间还是右区间，来决定在归并时是否累及答案。\n第三维：树状数组\n第三维有更方便的做法，也就是用树状数组。\n第二维中，我们只需要将左侧的 $c$ 按照 $b$ 在归并中的顺序加入树状数组，然后归并加入右侧元素的时候查询比 $c$ 小的数累积答案，最后得到的就是在左半区间所有 $b$ 比它小，而且 $c$ 也比它小的数的个数。\n相同元素怎么处理？\n在改之前强行累积一下就可以了，把后面的数对于前面的贡献给预先加上去就可以了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int n,k; const int MAXN = 210000; namespace fast_io{ //... }using namespace fast_io; namespace BIT{ int sumn[MAXN]; int lowbit(int x){return x \u0026amp; (-x);} void add(int x,int d){ for(;x \u0026lt;= k;x += lowbit(x)) sumn[x] += d; } int query(int x){ int ans = 0; for(;x \u0026gt;= 1;x -= lowbit(x)) ans += sumn[x]; return ans; } } struct Q{ int a,b,c; Q(){} Q(int x,int y,int z):a(x),b(y),c(z){} bool operator \u0026lt; (Q w)const{ if(a != w.a) return a \u0026lt; w.a; if(b != w.b) return b \u0026lt; w.b; else return c \u0026lt; w.c; } bool operator == (Q w)const{ return a == w.a \u0026amp;\u0026amp; b == w.b \u0026amp;\u0026amp; c == w.c; } }q[MAXN]; bool judge(int x,int y){ // 用于第二维的归并判断  if(q[x].b!=q[y].b) return q[x].b \u0026lt; q[y].b;//比较两数的c  if(q[x].c!=q[y].c) return q[x].c \u0026lt; q[y].c;//比较两数的c  else return x \u0026lt; y;//最后比较两数的id } int d[MAXN],ans[MAXN],tt[MAXN]; int tmp[MAXN]; int tot,l,r; void CDQ(int *t,int num,int depth = 0){ //t[0] -\u0026gt; t[num-1] (num个元素）  if(num == 1) return; int mid = num/2; CDQ(t,mid,depth+1),CDQ(t+mid,num-mid,depth+1); // 递归分治问题  for(tot = 0,l = 0,r = mid;l \u0026lt; mid \u0026amp;\u0026amp; r \u0026lt; num;tot++){ //归并过程，统计左半区间对右半区间的贡献  //如果在左区间，就把其当作修改，更新树状数组  //如果在右区间，就把其当作查询，查询树状数组，更新答案  if(judge(t[l],t[r])) BIT::add(q[t[l]].c,1),tmp[tot] = t[l++]; else ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot] = t[r++]; } //剩余的归并  while(l \u0026lt; mid) BIT::add(q[t[l]].c,1),tmp[tot++] = t[l++]; while(r \u0026lt; num) ans[t[r]] += BIT::query(q[t[r]].c),tmp[tot++] = t[r++]; for(int i = 0;i\u0026lt;mid;i++) BIT::add(q[t[i]].c,-1);//清空树状数组  memcpy(t,tmp,sizeof(int) * num);//拷贝数组 } void init(){ read(n),read(k); int a,b,c; for(int i = 1;i\u0026lt;=n;i++){ read(a),read(b),read(c); q[i] = Q(a,b,c); } } void solve(){ sort(q+1,q+n+1); for(int i = n;i\u0026gt;=1;--i){ // 累计相同元素的贡献  if(q[i] == q[i+1]) ans[i] = ans[i+1] + 1; tt[i] = i; } CDQ(tt+1,n); for(int i = 1;i\u0026lt;=n;i++) ++d[ans[i]]; for(int i = 0;i\u0026lt;n;i++) print(d[i]),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":187,"section":"posts","tags":["CDQ分治","树状数组","模板"],"title":"「模板」陌上花开-CDQ分治+树状数组","uri":"https://blog.chenqiqian.com/posts/luogu-3810/"},{"content":"对于一棵树，我们可以将某条链和与该链相连的边抽出来，称其为一个“毛毛虫”。求在这个树中点数最多的毛毛虫的点数。\n$n \u0026lt; 300000$\n链接 Luogu P3174\n题解 很简单的一道 $dp$ 题（感觉这个东西像一个 $faKe$ 的 $dp$ ）\u0026hellip;\n随便找一个根，记录 $in[x]$ 为 $x$ 节点的度，令 $d[x]$ 为从 $x$ 节点向下最长的毛毛虫的边数（含 $x$ 连向其他儿子及其连向父节点的边）。\n状态转移方程：\n$d[x] = \\max(d[v]) + in[x]$\n统计答案的时候，在 $dfs$ 过程中，我们记录其子树里面的最大的两个 $d$ ，最后更新 $ans = max(ans,d + d' + in[x])$ 。\n最后给 ans +1 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io{ //... }using namespace fast_io; const int MAXN = 310000; vector\u0026lt;int\u0026gt; edge[MAXN]; int n,m,d[MAXN],in[MAXN],ans = 0; void dfs(int nown,int fa){ //d[nown] -\u0026gt; 从nown往下走的最大毛毛虫  int maxa = 0,maxb = -0x3f3f3f3f; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(v == fa) continue; dfs(v,nown); d[nown] = max(d[nown],d[v]); if(d[v] \u0026gt;= maxa) maxb = maxa,maxa = d[v]; else if(d[v] \u0026gt;= maxb) maxb = d[v]; } ans = max(ans,maxa+maxb+in[nown]); d[nown] += in[nown]-1; } void init(){ read(n),read(m); int a,b; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b); edge[a].push_back(b); edge[b].push_back(a); in[a]++;in[b]++; } } void solve(){ dfs(1,0); printf(\u0026#34;%d\\n\u0026#34;,ans+1); } int main(){ init(); solve(); return 0; }   ","description":"","id":188,"section":"posts","tags":["树形dp","动态规划"],"title":"「HAOI2009」毛毛虫-树形dp","uri":"https://blog.chenqiqian.com/posts/haoi2009-worm/"},{"content":"青春真的是一个非常空泛而又令人迷茫的词汇。\n青春设计师  文章来自我校年级范文。\n 我是一名新晋的青春设计师，为人们设计平行宇宙中另一个自己的青春。等他们到了那里，就能过上自己想要的生活。\n网站提示音一响。第一单！我激动的打开信息单：要求栏只写着两个字：完美。\n完美的青春是什么样子？我开始构想。\n他要生活在温馨的家庭，父亲要严格而不失幽默，为他树立生活中的权威和条框。母亲要慈善贤惠，让他感到世界的温度与和善。他要和父母保持良好的关系。他要在亲子的对话中了解这个世界真实的样子，并学会为人处事的方法，从而形成健全的心理和独立的人格\u0026hellip;\u0026hellip;当我看着自己的设定十分满意时，心中却出现了别的声音：用自己的血肉触碰世界的条框，用自己的方式理解世界，不正是青春的意义吗？我陷入了迷茫，点击了“暂存”。\n他要擅长一项体育运动，并从中结交一群朋友，都说“无运动，不青春”，球场上矫健的身影才是青春该有的样子。这是他在青春岁月里竭尽全力的方式。他为了目标——进球得分，挥汗如雨，拼尽全力。结束的哨声即将响起，他第一次体会何谓放手一搏。肌肉的力量，意志的坚定，再加上一点运气，球进！场外女孩子的尖叫划破天空，如赞歌般充斥着他的双耳。他双眼模糊，倒在兄弟的手臂上。那是他第一次站上世界之巅。他尝到了自信和成功的味道\u0026hellip;我一遍遍为这美妙的体验鼓掌，而多疑的神经又占据了脑海：在青春年华，我们也会经常犯错啊！但正是在青春时期的不断跌倒和再次爬起，铸就了我们心智的成熟和未来成功的基石。谬赞的浪潮使人膨胀，而膨胀和自负恰是成熟的杀手。他的青春该如何描绘？接连不断的成功，还是令人沮丧的失败？我再次按下“暂存”。\n他要在青春年华初尝爱情的甜蜜。从见到那个女孩的第一面起，他的目光就再没离开过她。他对她并无半点杂念，单纯的注视就已经能让他感到幸福。她的一颦一笑，一举一动是那么纯真，澄澈。她就是天使。那个炎热的下午，他用了一节课的时间，终于在桌子下面牵到了她的手。他呆呆地盯着桌上树叶交错斑驳的影子，半个身子都涌上热流。之后的日子里，他们的甜蜜一如初见。二人心有灵犀，琴瑟和鸣，无不羡煞旁人。\n我审视这纯粹而完美的爱情，恍惚间像看到一场青春的大梦。激烈的争吵和内心的大雨滂沱何不是青春花园的一部分？争端和误解正是启蒙，带我们走进异性的世界。在人生的雨季，我们修炼爱情，不断成长，不正是青春的幸福吗？两个青春的爱情怎样才算是完美，我有些茫然。\n呆坐在电脑前，浏览着刚刚写下的文字，无论怎么修改，我总觉得距离“完美”还差了一点。我盯着要求栏里的“完美”两字，从午后盯到黄昏，甚至拿出放大镜，想通过透镜看出什么来。良久，我终于看出了两个字：\n “遗憾”。\n 我明白了。\n成长即破碎，青春终有遗憾。\n我快速的找到“个人履历”一栏，复制，粘贴，发送。\n之后，我关掉了网站，再不设计青春。\n 文章来自我校年级范文。如果作者同学对于我擅自的发表有任何意见，我会将文章立刻撤下。\n 青春  以下是我随便乱写的\n 或许青春永远都不存在所谓“完美”。\n我曾经思考过我的过去、现在和未来。\n我的过去，何时回忆起来也不免欢欣。\n我的家长，对于我的管教应该说还算是比较严格，小学每天八点半都要上床睡觉，即使到了中考前夕，九点半点之前也必须要在床上躺着。这的确对我有极大的帮助。如果说到学校，其实我对于小学的记忆已经渐渐模糊了，甚至连在哪里上的课都不太记得。但我恐怕一辈子也不能忘记，在那里懵懵懂懂的成长的时光。在那个最纯真的时候，我收获的不止几段最为美丽的友情，更有许多的成长。小的时候每天都坐班车，虽然没有什么人愿意跟我说话，但我也因此在车上读了许多许多的书。或许我现在对人生的许多看法，也是在那几年的班车上获得的。初中，在我当时看来，可以说是侥幸混到了本区最好的初中吧。同学都是很棒的一些人。有的人擅长学习，在学习上给了我许多的帮助；有的人思想深邃，教会我去如何更好的理解这个世界。相对于小学，我倒是更认为初中的老师让我成长更多。无论如何，我的初中生活很快也就结束了。一个懵懂的孩童终于长成一个少年，当然要归功于我亲爱的老师和同学们，还有我的家长。\n我的现在，是一个近乎完美的现在。\n不负众望的，我考进了本校的高中。一个三年，接下来的又是一个三年。小学的六年，并没有给我留下什么印象；而中学的六年，则会是人生中不可磨灭的一部分。同学自然十分优秀，老师也是非常有才华，我现在所拥有的一切恐怕是以前连梦都不敢梦的所有。一切一切，都让我一直认为，我的现在，已经是最好的现在了。\n我的未来，大约也会是令人向往的远方。\n我所拥有的一切，都在激励着我继续前行。我有负责的家人，给我的奋斗最大的支持；我有热爱的事业，并且我在这上面也获得了无可比拟的成就感；我有深深爱着的人，无论何时都会给我我安慰与鼓励；我有负责任的老师，会给我在学业上一切可能的帮助；我有一群可爱的同学，始终让我在每天放学都能带着微笑回家，不论生活的繁忙与否；而我现在所取得的一切，也告诉我：未来充满着希望。人生中最美好的事情或许也就莫过于，每一天都是怀揣着希望而前行吧。\n当时看到这篇范文，突然就想到了自己。感谢我生命里遇到的所有人，不论是到现在已经相忘，还是依旧相随而行；不论我们之间是至今不渝的友情，还是无法弥补的伤痕，感谢你们让我完全地成长，让我拥有这么一个完美的青春。\n鲁迅也说过：“使精神的丝缕还牵着已逝的寂寞的时光，又有什么意义呢。”\n虽说青春终有遗憾，但如果这一切都是你爱的人和爱你的人一起为你写就，那么是否遗憾，或许也不那么重要。\n这篇文章写的匆忙，来不及细细打磨，如果有文意疏漏之处，在所难免，请观者原谅。\n","description":"","id":189,"section":"posts","tags":null,"title":"「摘录」青春设计师-年级范文","uri":"https://blog.chenqiqian.com/posts/essay-youth-designer/"},{"content":"给出一个 $n$ 个节点的有根树。有 $q$ 次询问，每次询问给出 $l,r,z$ ，求 $\\sum _ {l \\leq i \\leq r}dep[LCA(i,z)]$ 。\n链接 Luogu P4211\n题解 神仙题\u0026hellip;真是不知道考场上有没有人能够想到。\n给出这样一个结论：\n 节点 $x$ 和 $y$ 的 $lca$ 到根节点的距离等于在 $x$ 到根节点的路径上且 $y$ 到根节点的路径上的节点个数。\n 所以如果我们将 $[l,r]$ 中的点到根节点的路径上所有的节点的值分别加 $1$ ，这个时候 $z$ 到根节点的路径上的权值和就是查询 $(l,r,z)$ 的答案。\n而且我们注意到这个问题满足区间可减性：\n即设 $sum(l,r) = \\sum _ {l\\leq i\\leq r}{dep[LCA(i,z)]}$ ，有 $sum(l,r) = sum(1,r)-sum(1,l-1)$ 。\n因此，我们将询问 $(l,r,z)$ 分离成 $(l-1,z)$ 和 $(r,z)$ 。\n我们用 $(t_i,pos_i)$ 代表询问。按照 $t_i$ 为第一关键字进行排序离线之后查询。每次查询的时候，使得 $1~t_i$ 的所有节点都已经把往根节点的路径上都做了修改，那么我们只需要查询一个 $(1,pos_i)$ 的路径上的节点的权值和即可。\n这个东西如果用树链剖分+线段树，复杂度是 $O(n \\log^{2}{n})$ ，如果用 LCT，复杂度是 $O(n\\log n)$ 。\n其实我感觉这道题完全可以出到 $200000$ ，然后给 $O(n \\log^{2}{n})$ 五六十分部分分。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 210000,mod = 201314; int n,m; vector\u0026lt;int\u0026gt; edge[MAXN]; int dep[MAXN],son[MAXN],top[MAXN],siz[MAXN],fa[MAXN],id[MAXN],cnt = 0; void dfs1(int nown,int f,int depth){ siz[nown] = 1;dep[nown] = depth; fa[nown] = f; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(v == f) continue; dfs1(v,nown,depth+1); siz[nown] += siz[v]; if(siz[v] \u0026gt; siz[son[nown]]) son[nown] = v; } } void dfs2(int nown,int topf){ top[nown] = topf; id[nown] = ++cnt; if(!son[nown]) return; dfs2(son[nown],topf); for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(v == fa[nown] || v == son[nown]) continue; dfs2(v,v); } } namespace SegTree{ int sumn[MAXN],addn[MAXN]; #define lson (nown\u0026lt;\u0026lt;1)  #define rson ((nown\u0026lt;\u0026lt;1)|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  void push_up(int nown){ sumn[nown] = sumn[lson] + sumn[rson]; sumn[nown] %= mod; } void add(int nown,int l,int r,int d){ sumn[nown] += d*(r-l+1); addn[nown] += d; sumn[nown] %= mod,addn[nown] %= mod; } void push_down(int nown,int l,int r){ if(addn[nown]){ add(lson,l,mid,addn[nown]); add(rson,mid+1,r,addn[nown]); addn[nown] = 0; } } void add(int nown,int l,int r,int ql,int qr,int d){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr){ add(nown,l,r,d); } else{ push_down(nown,l,r); if(ql \u0026lt;= mid) add(lson,l,mid,ql,qr,d); if(mid+1 \u0026lt;= qr) add(rson,mid+1,r,ql,qr,d); push_up(nown); } } int query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sumn[nown]; else{ push_down(nown,l,r); int ans = 0; if(ql \u0026lt;= mid) ans += query(lson,l,mid,ql,qr); if(mid + 1 \u0026lt;= qr) ans += query(rson,mid+1,r,ql,qr); ans %= mod; return ans; } } void build(int nown,int l,int r){ ; } } struct Q{ int ti,pos,id; Q(int t,int p,int i):ti(t),pos(p),id(i){;} bool operator\u0026lt;(Q a) const{ return ti \u0026lt; a.ti; } }; vector\u0026lt;Q\u0026gt; q; int ans[MAXN\u0026lt;\u0026lt;2],qa[MAXN][2]; void init(){ read(n),read(m); int a,b,c; for(int i = 2;i\u0026lt;=n;i++){ read(a); edge[i].push_back(a+1); edge[a+1].push_back(i); } int tot; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b),read(c); q.push_back(Q(a,c+1,++tot)); qa[i][0] = tot; q.push_back(Q(b+1,c+1,++tot)); qa[i][1] = tot; } } void w_add(int u,int v,int d = 1){ while(top[u]!=top[v]){ if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); SegTree::add(1,1,n,id[top[u]],id[u],d); u = fa[top[u]]; } if(dep[u] \u0026gt; dep[v]) swap(u,v); SegTree::add(1,1,n,id[u],id[v],d); } int w_query(int u,int v){ int ans = 0; while(top[u] != top[v]){ if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); ans += SegTree::query(1,1,n,id[top[u]],id[u]); u = fa[top[u]]; ans %= mod; } if(dep[u] \u0026gt; dep[v]) swap(u,v); ans += SegTree::query(1,1,n,id[u],id[v]); ans %= mod; return ans; } void solve(){ sort(q.begin(),q.end()); dfs1(1,0,1); dfs2(1,1); int nowt = 0; for(int i = 0;i \u0026lt; q.size();i++){ while(q[i].ti \u0026gt; nowt) w_add(1,++nowt); ans[q[i].id] = w_query(1,q[i].pos); } for(int i = 1;i\u0026lt;=m;i++) print((ans[qa[i][1]]-ans[qa[i][0]]+mod+mod+mod)%mod),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":190,"section":"posts","tags":["数据结构","树链剖分","差分"],"title":"「LNOI2014」LCA-树链剖分-差分","uri":"https://blog.chenqiqian.com/posts/lnoi2014-lca/"},{"content":"维护一个动态的关于 $x$的无穷多项式 ，这个多项式初始时对于所有 $i$ 有 $a_i = 0$\n$$\nf(x)=a_0x^0+a_1x^1+a_2x^2\u0026hellip;\n$$\n操作者可以进行四种操作：\n  mul L R V 表示将 $x^L$ 到 $x^R$ 这些项的系数乘上某个定值 $v$ ；\n  add L R V 表示将 $x^L$ 到 $x^R$ 这些项的系数加上某个定值 $v$ ；\n  mulx L R 表示将 $x^L$ 到 $x^R$ 这些项乘上x变量；\n  query V 求 $f(v)$ 的值。\n  操作集中在前三种，第四种操作不会出现超过 $10$ 次。\n链接 Luogu P3278\n题解 Splay大毒瘤题。\n前两个操作让我们想到线段树的模板，第三个操作如果从序列的角度来看就像是把一个序列向右移动，在把被冲掉的那一个位置加到原来的位数上去。\n显然啊！同志们，这是送分题啊！Splay套套套\u0026hellip;\n  add操作：提取区间，打标记，维护信息。\n  mul操作：提取区间，打标记，维护信息。\n  mulx操作：呃\u0026hellip;先找到rank为l-1,l,r,r+1,r+2的节点。删除掉r+1号节点，把其值加到r上去，然后在l-1和l之间插入一个值为0的节点，维护信息。\n  注意：push_down操作先传muln，再传addn。\n打标记几乎同线段树模板，就不说了。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;cctype\u0026gt;#define ll long long using namespace std; const int MAXN = 210000; const ll p = 20130426LL; namespace fast_io { //... }using namespace fast_io; inline void mod(ll \u0026amp;x){x %= p;} struct Splay{ ll val[MAXN],addn[MAXN],muln[MAXN]; int f[MAXN],c[MAXN][2],siz[MAXN],tot,root; int newnode(int v = 0){ val[++tot] = v; siz[tot] = 1; addn[tot] = 0,muln[tot] = 1; return tot; } void add(int x,int num){ if(!x) return; addn[x] += num,val[x] += num; mod(val[x]),mod(addn[x]); } void mul(int x,int num){ if(!x) return; muln[x] *= num,addn[x] *= num,val[x] *= num; mod(addn[x]),mod(muln[x]),mod(val[x]); } void push_down(int x){ if(!x) return; if(muln[x]!=1){ mul(c[x][0],muln[x]); mul(c[x][1],muln[x]); muln[x] = 1; } if(addn[x] != 0){ add(c[x][0],addn[x]); add(c[x][1],addn[x]); addn[x] = 0; } } void push_up(int x){ if(!x) return; siz[x] = siz[c[x][0]] + siz[c[x][1]] + 1; } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1]==x),w = c[x][1-t]; push_down(y),push_down(x); f[x] = z;f[y] = x; if(w) f[w] = y; c[x][1-t] = y,c[y][t] = w; if(z) c[z][c[z][1]==y] = x; push_up(y),push_up(x); if(!f[x]) root = x; } void splay(int x,int target = 0){ while(f[x]!=target){ int y = f[x],z = f[y]; if(z!=target) (c[z][1]==y) ^ (c[y][1]==x)?rotate(x):rotate(y); rotate(x); } } int qrank(int r){ int x = root; while(2333){ if(r \u0026lt;= siz[c[x][0]]) x = c[x][0]; else if(r == siz[c[x][0]] + 1) break; else r -= siz[c[x][0]] + 1,x = c[x][1]; } return x; } int __build(int l,int r,int fa){ if(l \u0026gt; r) return 0; int mid = (l+r)\u0026gt;\u0026gt;1; int x = newnode(); f[x] = fa; c[x][0] = __build(l,mid-1,x); c[x][1] = __build(mid+1,r,x); push_up(x); return x; } void build(int num){ root = __build(1,num,0); } void __output(int x,ll *a){ if(!x) return; push_down(x); __output(c[x][0],a); a += siz[c[x][0]],*a = val[x]; __output(c[x][1],a+1); } void output(ll *a){ __output(root,a); } void add(int l,int r,int num){ int lb = qrank(l),rb = qrank(r+2); splay(lb),splay(rb,lb); add(c[rb][0],num); push_up(rb),push_up(lb); } void mul(int l,int r,int num){ int lb = qrank(l),rb = qrank(r+2); splay(lb),splay(rb,lb); mul(c[rb][0],num); push_up(rb),push_up(lb); } void mulx(int l,int r){ int x = qrank(l),y = qrank(l+1),z = qrank(r+1),a = qrank(r+2),b = qrank(r+3); splay(z),splay(b,z); c[b][0] = 0;push_up(b),push_up(z); val[z] += val[a]; splay(x),splay(y,x); c[y][0] = newnode(),f[c[y][0]] = y; push_up(y),push_up(x); } }T; int n,m = 110000; ll query(ll v){ static ll o[MAXN]; T.output(o); ll ans = 0; for(int i = m;i\u0026gt;=1;i--){ ans = ans * v + o[i]; mod(ans); } return ans; } void init(){ read(n); T.build(m+3); } void solve(){ char op[10];int l,r,v; for(int i = 1;i\u0026lt;=n;i++){ read(op); if(op[0] == \u0026#39;q\u0026#39;){ read(v); print(int(query(v))),print(\u0026#39;\\n\u0026#39;); } else{ read(l),read(r); if(op[3] == \u0026#39;x\u0026#39;) T.mulx(l+1,r+1); else{ read(v); if(op[0] == \u0026#39;m\u0026#39;) T.mul(l+1,r+1,v); else if(op[0] == \u0026#39;a\u0026#39;) T.add(l+1,r+1,v); } } } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":191,"section":"posts","tags":["Splay","数据结构","平衡树"],"title":"「SCOI2013」多项式的运算-Splay","uri":"https://blog.chenqiqian.com/posts/scoi2013-function/"},{"content":"给定一棵 $n$ 个节点的树，对于每个点都有两个权值 $w_i,c_i$ 。\n存在 $m$ 个操作，分为4类。\n  “CC x c”：将 $c_x$ 更改为 $c$ ；\n  “CW x w”：将 $w_x$ 更改为 $w$ ；\n  “QS x y”：对所有满足在 $x$ 到 $y$ 路径上且 $c_i = c_x = c_y$ 的节点 $i$，求 $\\sum w_i$ ；\n  “QM x y”：对所有满足在 $x$ 到 $y$ 路径上且 $c_i = c_x = c_y$ 的节点 $i$ ，求 $\\max(w_i)$ ；\n  对于后两个操作，保证 $c_x = c_y$ 。\n对于所有数据， $n,m \\leq 10^5$ ，在任意时刻均满足 $w_i \\leq 10^4,c_i \\leq 10^5,; w_i,c_i \\in \\mathbb{N}^+$ 。\n链接 Luogu P3313\n题解 没什么太多好说的。几乎是裸题了。\n对于每一种 $c$ ，建立一颗动态开点的线段树，每个节点维护当前区间的最大值和区间和。\n对于树进行树链剖分，查询的时候直接按照树链剖分查询就好了。\n时间复杂度 $O(m \\log^{2}{n})$ ，空间复杂度 $O(m \\log n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 110000,logn = 30; int n,m,cnt; int son[MAXN],dep[MAXN],fa[MAXN],siz[MAXN],top[MAXN],id[MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; void dfs1(int nown,int f,int depth){ siz[nown] = 1,fa[nown] = f; dep[nown] = depth,son[nown] = 0; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i]; if(v == f) continue; dfs1(v,nown,depth+1); siz[nown] += siz[v]; if(siz[v] \u0026gt; siz[son[nown]]) son[nown] = v; } } void dfs2(int nown,int topf){ top[nown] = topf;id[nown] = ++cnt; if(!son[nown]) return; dfs2(son[nown],topf); for(int i = 0;i \u0026lt; edge[nown].size();i++){ int v = edge[nown][i]; if(v == fa[nown] || v == son[nown]) continue; dfs2(v,v); } } namespace SegTree{ int sumn[MAXN*logn],maxn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 0; #define mid ((l+r)\u0026gt;\u0026gt;1)  void maintain(int nown){ maxn[nown] = max(maxn[ls[nown]],maxn[rs[nown]]); sumn[nown] = sumn[ls[nown]] + sumn[rs[nown]]; } int query_sum(int nown,int l,int r,int ql,int qr){ if(nown == 0 || (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) ) return sumn[nown]; else{ int ans = 0; if(ql \u0026lt;= mid) ans += query_sum(ls[nown],l,mid,ql,qr); if(mid+1 \u0026lt;= qr) ans += query_sum(rs[nown],mid+1,r,ql,qr); return ans; } } int query_max(int nown,int l,int r,int ql,int qr){ if(nown == 0 || (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr)) return maxn[nown]; else{ int ans = 0; if(ql \u0026lt;= mid) ans = max(ans,query_max(ls[nown],l,mid,ql,qr)); if(mid+1 \u0026lt;= qr) ans = max(ans,query_max(rs[nown],mid+1,r,ql,qr)); return ans; } } void update(int \u0026amp;nown,int l,int r,int pos,int d){ if(!nown) nown = ++cnt,ls[nown] = 0,rs[nown] = 0; if(l == r) sumn[nown] = maxn[nown] = d; else{ if(pos \u0026lt;= mid) update(ls[nown],l,mid,pos,d); if(mid+1 \u0026lt;= pos) update(rs[nown],mid+1,r,pos,d); maintain(nown); } } } int rt[MAXN],r[MAXN],b[MAXN]; int query_max(int u,int v,int k){ int ans = 0; while(top[u]!=top[v]){ if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); ans = max(ans,SegTree::query_max(rt[k],1,n,id[top[u]],id[u])); u = fa[top[u]]; } if(dep[u] \u0026gt; dep[v]) swap(u,v); ans = max(ans,SegTree::query_max(rt[k],1,n,id[u],id[v])); return ans; } int query_sum(int u,int v,int k){ int ans = 0; while(top[u]!=top[v]){ if(dep[top[u]] \u0026lt; dep[top[v]]) swap(u,v); ans += SegTree::query_sum(rt[k],1,n,id[top[u]],id[u]); u = fa[top[u]]; } if(dep[u] \u0026gt; dep[v]) swap(u,v); ans += SegTree::query_sum(rt[k],1,n,id[u],id[v]); return ans; } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(r[i]),read(b[i]); int a,b; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b); edge[a].push_back(b); edge[b].push_back(a); } } void build(){ dfs1(1,0,1),dfs2(1,1); for(int i = 1;i\u0026lt;=n;i++) SegTree::update(rt[b[i]],1,n,id[i],r[i]); } void solve(){ char op[10];int x,y; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(x),read(y); if(op[0] == \u0026#39;C\u0026#39;){ if(op[1] == \u0026#39;W\u0026#39;){ SegTree::update(rt[b[x]],1,n,id[x],y); r[x] = y; } else if(op[1] == \u0026#39;C\u0026#39;){ SegTree::update(rt[b[x]],1,n,id[x],0); SegTree::update(rt[y],1,n,id[x],r[x]); b[x] = y; } } else if(op[0] == \u0026#39;Q\u0026#39;){ if(op[1] == \u0026#39;S\u0026#39;) print(query_sum(x,y,b[x])),print(\u0026#39;\\n\u0026#39;); else if(op[1] == \u0026#39;M\u0026#39;) print(query_max(x,y,b[x])),print(\u0026#39;\\n\u0026#39;); } } } int main(){ init(); build(); solve(); flush(); return 0; }   ","description":"","id":192,"section":"posts","tags":["数据结构","线段树","树链剖分"],"title":"「SDOI2014」旅行-树链剖分+动态开点线段树","uri":"https://blog.chenqiqian.com/posts/sdoi2014-journey/"},{"content":"可持久化线段树，是一种可以进行可持久化操作的线段树，具有优越的时间复杂度。\n线段树 相信看这篇文章的人很熟悉什么是线段树了，就不在这里胡扯了。\n如上就是线段树的基本结构。\n可持久化？ 简单来说，可持久化就是能够在修改的时候，保留下原来的数据结构的样子的一种数据结构。比如说，对于上图，如果线段树维护的是区间和，这个时候我们要修改某个数的大小，就会使一条链上的信息全部改变，并且我们失去了这次修改之前的线段树的信息。\n那么对于线段树来说，怎么样才能做到可持久化呢？\n可持久化的思路 假设这个线段树维护的是区间和。\n一种非常简单的思路：为了维护修改之前的信息，每次修改我重新建一棵线段树不就好了？？？但是如果仔细想一想，建一棵线段树的时间复杂度是O(n)，空间复杂度O(n)，如果有n次修改，最后的时间复杂度O(n^2)，空间复杂度也是O(n^2)，GG。\n观察上图，显然可以发现单点修改会改变的只会有这一条链上的节点的值，所以我们就会自然想到，能不能只维护这一条链呢？\n但是单独维护一条链很傻，而且很多线段树上的操作进行起来也很复杂。所以可以把这条链嵌到线段树上，比如我们修改位置4，那么修改出来的链就是红色节点，而我们也需要把它其他的地方连到原来的线段树上。\n这个时候，我们就发现只要我们掌握着根结点，我们就可以当所有其他线段树都是不存在的一样，做普通线段树的查询操作。\n主要的可持久化操作的思想大概如上。总结来说的话，就是只更改需要更改的部分，其他的不管它，保持树形结构完整性就可以了。其他的可持久化数据结构如可持久化Trie树和平衡树，思想都是类似的。\n分析一下的话，上例子里总共有m次修改的话，每次修改创建出的新节点都是一条完整的长度为O(\\log n)的链，每次修改或者查询，时间复杂度都是O(\\log{n})。最后空间复杂度是O(n \\log{n})，时间复杂度也是O(n \\log{n})。\n具体实现 具体来说，可持久化数据结构一般推荐用数组模拟指针来实现。首先是因为数组的代码写起来很短很快，其次还有就是指针的大小目前一般是8字节，比一个整数大了一倍，在一些题目中可能被卡内存。\n对于可持久化线段树来说，实现跟普通线段树有微小的一点不同。（废话\n首先，在节点的数目上，我们需要开n\\log n数目的节点，这个很容易忘记。我们还需要显性的记录每个节点的左儿子和右儿子，和一些其他你要维护的信息。\n在修改操作上，有一些不同。\n具体来说如下：\n 复制原来节点，成为一个新的当前节点 往需要更改的位置（左／右儿子）更新  这里的修改中的原来节点就是原来同一个位置的节点，而需要新建一个节点，所以这个地方当前节点需要传一个引用，具体到后面可以看一看代码，理解的会更好。\n查询操作就一模一样啦。\n应用 非常强大。\n可持久化数组、并查集 可持久化数组可以说是最简单的应用了。就是一个模板，套上就好。\n主席树 静态第k大问题 动态第k大问题 树上第k大、维护值域 其他奇怪应用 例题 TBD。\n","description":"","id":193,"section":"posts","tags":["可持久化线段树","主席树","数据结构","模板"],"title":"可持久化线段树学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-prsegtree/"},{"content":"某个国家有 $n$ 个城市，这 $n$ 个点之间的边构成一棵树。\n现求一条边长度和不超过 $S$ 的路径（两端都是城市，可以只为一个城市），使得所有城市到这条路径的距离的最大值最小，并输出这个最小值。\n链接 Luogu P2491\n题解 很有趣的题。\n很明显，这条路径必须全部位于直径上。具体证明不会，大概可以感性理解一下。\n那么我们就要考虑，在直径上选出一段长度不大于 $S$ 的路径，如何维护这颗树上的所有点到这条路径的长度的最大值。\n考虑到只有两种情况：\n 在树的直径上叉出来的一支 路径上的两个端点到同侧直径端点的距离  第一个先 $O(n)$ 预处理出来，第二个记录直径的一个端点到直径上所有点的距离，然后可以 $O(1)$ 的计算。\n我们枚举路径的右端点 $r$ ，然后把左端点 $l$ 推到最左侧可以满足 $d \\leq S$ 的点，这个过程是 $O(n)$ 的，注意到 $l,r$ 都是单调递增的，我们可以用一个单调队列维护 $[l,r]$ 的最大值，然后再与第二个情况取一个 $max$ 。然后最小值就是我们的 $ans$ 。\n总时间复杂度 $O(n)$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cctype\u0026gt;#define pp pair\u0026lt;int,int\u0026gt; using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 310000; struct Edge{ int from,to; int len; }; int n,k; vector\u0026lt;Edge\u0026gt; edge[MAXN]; void init(){ read(n),read(k); int a,b,c; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b),read(c); edge[a].push_back((Edge){a,b,c}); edge[b].push_back((Edge){b,a,c}); } } int dis[MAXN],f[MAXN]; void dfs(int nown,int fa){ f[nown] = fa; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i].to,l = edge[nown][i].len; if(v == f[nown]) continue; dis[v] = dis[nown] + l; dfs(v,nown); } } int getmax(int nown){ int ans = dis[nown]; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int v = edge[nown][i].to; if(v == f[nown]) continue; ans = max(ans,getmax(v)); } return ans; } int num[MAXN],d[MAXN],maxn[MAXN],tot = 0; void build(){ int u = 0,v = 0; dis[1] = 0; dfs(1,0); for(int i = 1;i\u0026lt;=n;i++) if(dis[u] \u0026lt; dis[i]) u = i; dis[u] = 0; dfs(u,0); for(int i = 1;i\u0026lt;=n;i++) if(dis[v] \u0026lt; dis[i]) v = i; for(int i = v;i;i = f[i]) num[++tot] = i; reverse(num+1,num+tot+1); for(int i = 1;i\u0026lt;=tot;i++) d[i] = dis[num[i]]; for(int i = 1;i\u0026lt;=tot;i++){ int nown = num[i]; for(int j = 0;j\u0026lt;edge[nown].size();j++){ int v = edge[nown][j].to; if(v == num[i+1] || v == num[i-1]) continue; maxn[i] = max(maxn[i],getmax(v)); } if(maxn[i]) maxn[i] -= d[i]; } } void solve(){ deque\u0026lt;pp\u0026gt; q; int l = 1,ans = 0x3f3f3f3f; for(int i = 1;i\u0026lt;=tot;i++){ while(!q.empty() \u0026amp;\u0026amp; q.back().second \u0026lt; maxn[i]) q.pop_back(); q.push_back(make_pair(i,maxn[i])); while(d[i] - d[l] \u0026gt; k) l++; while(!q.empty() \u0026amp;\u0026amp; q.front().first \u0026lt; l) q.pop_front(); ans = min(ans,max(max(d[l],d[tot] - d[i]),q.front().second)); } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); build(); solve(); flush(); return 0; }   ","description":"","id":194,"section":"posts","tags":["单调队列","树的直径","树形结构"],"title":"「SDOI2011」消防-树的直径+单调队列","uri":"https://blog.chenqiqian.com/posts/sdoi2011-fireman/"},{"content":"小Z有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。\n小Z希望执行 $T$ 个操作，操作有两类：\n  Q x y k 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。\n  L x y 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。\n  强制在线。\n对于所有的数据 $n,m,T \\leq 8 \\times 10^4$ 。\n链接 Luogu P3302\n题解 恶心的大数据结构。\n对于合并操作，我们会想到 LCT ，而对于查询路径上的第 $k$ 大，又让我们想到主席树。\n只能牺牲一种操作。注意到这里没有 cut ，所以我们可以通过启发式合并的方式，减少一个 $\\log$ 。\n用并查集维护森林的大小，每次合并的时候强势暴力dfs修改树上路径主席树，以及求 lca的倍增数组即可。\n然后就是常规操作了。\n需要用离散化，这里用了 map。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 81000,maxb = 20,logn = 500; namespace prSegTree{ int sumn[MAXN*logn],ls[MAXN*logn],rs[MAXN*logn],cnt = 1; #define mid ((l+r)\u0026gt;\u0026gt;1)  void insert(int \u0026amp;nown,int pre,int l,int r,int pos,int d){ nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre]; sumn[nown] = sumn[pre] + d; if(l == r) return; else{ if(pos \u0026lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,d); if(mid+1 \u0026lt;= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d); } } int query(int x1,int x2,int y1,int y2,int l,int r,int k){ if(l == r) return l; else{ int sum = sumn[ls[x1]] + sumn[ls[x2]] - sumn[ls[y1]] - sumn[ls[y2]]; if(k \u0026lt;= sum) return query(ls[x1],ls[x2],ls[y1],ls[y2],l,mid,k); if(sum+1 \u0026lt;= k) return query(rs[x1],rs[x2],rs[y1],rs[y2],mid+1,r,k-sum); } } void build(int \u0026amp;nown,int l,int r){ nown = ++cnt; if(l == r) return; else{ build(ls[nown],l,mid); build(rs[nown],mid+1,r); } } } int fir[MAXN]; int to[MAXN*2],nex[MAXN*2],ecnt = 1; int n,m,q,num[MAXN],last[MAXN],tot = 0; int rt[MAXN]; int f[MAXN][maxb],dep[MAXN]; map\u0026lt;int,int\u0026gt; S; void addedge(int u,int v){ to[ecnt] = v,nex[ecnt] = fir[u],fir[u] = ecnt++; to[ecnt] = u,nex[ecnt] = fir[v],fir[v] = ecnt++; } namespace BCJ{ int f[MAXN],siz[MAXN]; int find(int x){ return f[x]==x?x:find(f[x]); } int query(int x){ return siz[find(x)]; } void un(int x,int y){ //y-\u0026gt;x  int xx = find(x),yy = find(y); f[yy] = xx;siz[xx] += siz[yy]; } void init(){ for(int i = 1;i\u0026lt;=n;i++) f[i] = i,siz[i] = 1; } } void pre_dfs(int nown,int fa,int depth){ prSegTree::insert(rt[nown],rt[fa],1,tot,S[num[nown]],1); dep[nown] = depth; f[nown][0] = fa; for(int j = 1;j\u0026lt;maxb;j++) f[nown][j] = f[ f[nown][j-1] ][j-1]; for(int i = fir[nown];i;i=nex[i]){ int v = to[i]; if(v == fa) continue; pre_dfs(v,nown,depth+1); } } int lca(int u,int v){ if(dep[u] \u0026lt; dep[v]) swap(u,v); for(int j = maxb-1;j\u0026gt;=0;j--) if(dep[f[u][j]] \u0026gt;= dep[v]) u = f[u][j]; if(u == v) return u; for(int j = maxb-1;j\u0026gt;=0;j--) if(f[u][j] != f[v][j]) u = f[u][j],v = f[v][j]; return f[u][0]; } void init(){ int T; read(T); read(n),read(m),read(q); BCJ::init(); for(int i = 1;i\u0026lt;=n;i++){ read(num[i]); S[num[i]] = 0; } for(map\u0026lt;int,int\u0026gt;::iterator it = S.begin();it!=S.end();it++){ it-\u0026gt;second = ++tot;last[tot] = it-\u0026gt;first; } int a,b; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b); addedge(a,b); BCJ::un(a,b); } } void build(){ for(int i = 1;i\u0026lt;=n;i++){ if(BCJ::find(i)==i) pre_dfs(i,0,1); } } void link(int u,int v){ addedge(u,v); if(BCJ::query(u) \u0026lt; BCJ::query(v)) swap(u,v); pre_dfs(v,u,dep[u]+1); BCJ::un(u,v); } int query(int u,int v,int k){ int l = lca(u,v),fl = f[l][0]; int ans = prSegTree::query(rt[u],rt[v],rt[l],rt[fl],1,tot,k); //printf(\u0026#34;query: u:%d v:%d l:%d fl:%d k:%d ANS:%d\\n\u0026#34;,u,v,l,fl,k,ans);  return last[ans]; } void solve(){ char op[10];int a,b,k,last = 0; for(int i = 1;i\u0026lt;=q;i++){ read(op);read(a),read(b); a^=last,b^=last; if(op[0] == \u0026#39;L\u0026#39;) link(a,b); else if(op[0] == \u0026#39;Q\u0026#39;) read(k),k^=last,print(last = query(a,b,k)),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); build(); solve(); flush(); return 0; }   ","description":"","id":195,"section":"posts","tags":["可持久化线段树","最近公共祖先","启发式合并"],"title":"「SDOI2013」森林-主席树+LCA+启发式合并","uri":"https://blog.chenqiqian.com/posts/sdoi2013-forest/"},{"content":"$n$ 个布丁摆成一行，每个布丁最开始都有一个颜色 $c_i$ ，进行 $m$ 次操作。\n操作格式：\n  1 c d ：将所有的 $c$ 颜色替换为$d$\n  2 ：查询当前布丁序列一共有多少段颜色。例如颜色分别为 $1,2,2,1$ 的四个布丁一共有3段颜色。\n  链接 Luogu P3201\n题解 这题非常有趣。开始想倒是像以前做过的 [SDOI2011]染色 ，不过仔细想想这个东西很难用线段树进行维护。\n由于这道题放在平衡树的专题里，我们思考一下这个东西能不能用平衡树维护。\n重点需要解决的问题是如何合并两种颜色（因为颜色段肯定是单调递减的）。我们可以想到使用平衡树的启发式合并。合并的时候更新答案的情况只有当前这个位置的 $pos-1$ 或者 $pos+1$ 的位置有相同颜色的位置的时候，我们都需要对答案减去 1 。\n启发式合并可以让复杂度降低一个 $log$ ，最后时间复杂度就是 $O(n \\log^2{n})$ 。最坏情况就是每次合并的区间大小都相等的情况，合并起来的次数 $O(n \\log {n})$ 。\n有 $O(n \\log{n})$ 的奇怪做法，具体我也就不会了。\n具体实现上，可以维护一个数组记录当前某个数对应的 set 位置，就可以减去一些不必要消耗。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; const int MAXN = 1100000; namespace fast_io { //... }using namespace fast_io; int n,m,ans = 0; int num[MAXN],re[MAXN]; set\u0026lt;int\u0026gt; S[MAXN]; void update(int last,int now){ for(set\u0026lt;int\u0026gt;::iterator it = S[last].begin();it!=S[last].end();it++){ if(num[(*it)-1] == (now)) ans--; if(num[(*it)+1] == (now)) ans--; S[now].insert(*it); } for(set\u0026lt;int\u0026gt;::iterator it = S[last].begin();it!=S[last].end();it++) num[*it] = now; S[last].clear(); } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++){ read(num[i]); if(num[i]!=num[i-1]) ans++; S[num[i]].insert(i); re[num[i]] = num[i]; } } void solve(){ int op,a,b; for(int i = 1;i\u0026lt;=m;i++){ read(op); if(op == 1){ read(a),read(b); if(a == b) continue;//很重要！  if(S[re[a]].size() \u0026gt; S[re[b]].size()) swap(re[a],re[b]); update(re[a],re[b]); } else if(op == 2){ print(ans),print(\u0026#39;\\n\u0026#39;); } } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":196,"section":"posts","tags":["启发式合并","set","平衡树"],"title":"「HNOI2009」梦幻布丁-set-启发式合并","uri":"https://blog.chenqiqian.com/posts/hnoi2009-pudding/"},{"content":"游戏一开始，Lostmonkey 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $K_i$ ，当绵羊达到第 $i$ 个装置时，它会往后弹 $K_i$ 步，达到第 $i+K_i$ 个装置，若不存在第 $i+K_i$ 个装置，则绵羊被弹飞。\n存在两种操作：\n  查询在第 $i$ 个装置起步时，再经多少次会被弹飞。\n  修改第 $i$ 个装置的弹力系数为 $K'$ 。\n  保证任何时候，任何装置弹力系数均为正整数。\n链接 Luogu P3203\nBZOJ 2002\n题解 Link_Cut_Tree比较好想的一道题。\n我们注意到，这 $n$ 个装置的弹力系数可以抽象成一颗树，即连接第$i$和第 $i+K_i$ 个节点的边，并且弹力系数的正整数的性质使其不存在环。\n对于弹出去的装置，我们都用一个 $n+1$ 号点来代替。每次在Link_Cut_Tree上查询 $i$ 到 $i+K_i$ 的距离，即为答案。修改的时候，我们先断掉与原来的 $i+K_i$ 的边，再连上到 $i+K'$ 的边，更新弹力系数数组即可。\n注意这里的装置编号是 $0\\to n-1$ 的，所以可以统一进行 $+1$ 处理。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; const int MAXN = 510000; namespace fast_io { //... }using namespace fast_io; struct Link_Cat_Tree{ int sum[MAXN]; int f[MAXN],c[MAXN][2]; bool rev[MAXN]; void push_up(int x){ sum[x] = sum[c[x][0]] + sum[c[x][1]] + 1; } void reverse(int x){ if(!x) return; swap(c[x][0],c[x][1]); rev[x] ^= 1; } void push_down(int x){ if(!x) return; if(rev[x]){ reverse(c[x][0]); reverse(c[x][1]); rev[x] = 0; } } bool noroot(int x){ return (c[f[x]][0] == x) || (c[f[x]][1] == x); } void push_all(int x){ if(!x) return; if(noroot(x)) push_all(f[x]); push_down(x); } void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1]==y] = x; c[x][1-t] = y,c[y][t] = w; if(w) f[w] = y; f[y] = x;f[x] = z; push_up(y),push_up(x); } void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ if((c[y][1]==x)^(c[z][1]==y)) rotate(x); else rotate(y); }rotate(x); } } void access(int x){ for(int y = 0;x;x = f[y=x]){ splay(x);c[x][1] = y; push_up(x); } } void makeroot(int x){ access(x),splay(x),reverse(x); } int find(int x){ access(x),splay(x); push_down(x); while(c[x][0]) x = c[x][0],push_down(x); return x; } void link(int x,int y){ makeroot(x); if(find(y)!=x) f[x] = y; } void cat(int x,int y){ makeroot(x);//find == splay  if(find(y) == x \u0026amp;\u0026amp; f[x] == y \u0026amp;\u0026amp; !c[x][1]) f[x] = c[y][0] = 0,push_up(y); } int query(int u,int v){ makeroot(v); //if(find(v)!=find(u)) return -1;  access(u);splay(u); return sum[u]; } void print(int n){ for(int i = 1;i\u0026lt;=n;i++){ printf(\u0026#34;%d: sum:%d f:%d c:%d %d r:%d\\n\u0026#34;,i,sum[i],f[i],c[i][0],c[i][1],int(rev[i])); } } }; int n,m,num[MAXN]; Link_Cat_Tree T; void init(){ read(n); for(int i = 1;i\u0026lt;=n;i++) read(num[i]); for(int i = 1;i\u0026lt;=n;i++) T.link(i,min(i+num[i],n+1)); } void solve(){ read(m); int op,a,b; for(int i = 1;i\u0026lt;=m;i++){ read(op);read(a);++a; if(op == 1) print(T.query(a,n+1)-1),print(\u0026#39;\\n\u0026#39;); else if(op == 2){ read(b); T.cat(a,min(a+num[a],n+1)); T.link(a,min(a+b,n+1)); num[a] = b; } } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":197,"section":"posts","tags":["LCT","数据结构","树形结构"],"title":"「HNOI2010」弹飞绵羊-动态树","uri":"https://blog.chenqiqian.com/posts/hnoi2010-bounce/"},{"content":"有一个 $a \\times b$ 的整数组成的矩阵，现请你从中找出一个 $n\\times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小，输出这个最小的差值。\n链接 Luogu P2216\n题解 单调队列的一道有趣的题。\n事实上我们可以发现，需要找出的区域是正方形，而且大小固定，所以我们可以想到用单调队列来解决这个问题。\n但这个问题是二维的，怎么把单调队列转化成二维的呢？\n可以这么考虑。用 $a$ 个单调队列维护 每一行在 $[j-n+1,j]$ 的位置中的最大值和最小值。\n每次我们计算正方形的最大值或最小值的时候，对于这 $a$ 个单调队列中的最大值或者最小值，我们新开一个单调队列，其中维护在 $a$ 个单调队列中 $[i-n+1,i]$ 这个范围里的最大值或者最小值。然后就可以用最大值减去最小值，并尝试更新答案。\n可以证明，复杂度是 $O(n^2)$ 的。\n实在偷懒，单调队列用了 $deque$ ，不开O2极慢。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;#define pp pair\u0026lt;int,int\u0026gt; using namespace std; const int MAXN = 1100; namespace fast_io { //... }using namespace fast_io; int n,m,k; int num[MAXN][MAXN]; deque\u0026lt;pp\u0026gt; max1[MAXN],min1[MAXN]; deque\u0026lt;pp\u0026gt; max2,min2; void init(){ read(n),read(m),read(k); for(int i = 1;i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++) read(num[i][j]); } void solve(){ int ans = 0x3f3f3f3f; static int minn[MAXN],maxn[MAXN]; int tmin,tmax; for(int i = 1;i\u0026lt;=n;i++){ //printf(\u0026#34;i %d:\\n\u0026#34;,i);  for(int j = 1;j\u0026lt;=m;j++){ //max  while(!max1[j].empty()\u0026amp;\u0026amp;max1[j].begin()-\u0026gt;second \u0026lt; num[i][j]) max1[j].pop_front(); max1[j].emplace_front(i,num[i][j]); while(!max1[j].empty()\u0026amp;\u0026amp;max1[j].rbegin()-\u0026gt;first \u0026lt;= i-k) max1[j].pop_back(); tmax = max1[j].rbegin()-\u0026gt;second; maxn[j] = tmax; //min  while(!min1[j].empty()\u0026amp;\u0026amp;min1[j].begin()-\u0026gt;second \u0026gt; num[i][j]) min1[j].pop_front(); min1[j].emplace_front(i,num[i][j]); while(!min1[j].empty()\u0026amp;\u0026amp;min1[j].rbegin()-\u0026gt;first \u0026lt;= i-k) min1[j].pop_back(); tmin = min1[j].rbegin()-\u0026gt;second; minn[j] = tmin; } max2.clear(),min2.clear(); for(int j = 1;j\u0026lt;=m;j++){ //max  while(!max2.empty()\u0026amp;\u0026amp;max2.begin()-\u0026gt;second \u0026lt; maxn[j]) max2.pop_front(); max2.emplace_front(j,maxn[j]); while(!max2.empty()\u0026amp;\u0026amp;max2.rbegin()-\u0026gt;first \u0026lt;= j-k) max2.pop_back(); tmax = max2.rbegin()-\u0026gt;second; //min  while(!min2.empty()\u0026amp;\u0026amp;min2.begin()-\u0026gt;second \u0026gt; minn[j]) min2.pop_front(); min2.emplace_front(j,minn[j]); while(!min2.empty()\u0026amp;\u0026amp;min2.rbegin()-\u0026gt;first \u0026lt;= j-k) min2.pop_back(); tmin = min2.rbegin()-\u0026gt;second; if(i\u0026gt;=k \u0026amp;\u0026amp; j\u0026gt;=k)//保证解合法  ans = min(tmax-tmin,ans); } } printf(\u0026#34;%d\\n\u0026#34;,ans); } int main(){ init(); solve(); return 0; }   ","description":"","id":198,"section":"posts","tags":["单调队列","数据结构"],"title":"「HAOI2007」理想的正方形-单调队列","uri":"https://blog.chenqiqian.com/posts/haoi2007-square/"},{"content":"超级计算机中的任务用三元组 $(S_i,E_i,P_i)$ 描述， $(S_i,E_i,P_i)$ 表示任务运行区间为 $[S_i,E_i]$ ,其优先级为 $P_i$ 。\n给出 $n$ 个任务。随后给出 $m$ 个询问，第 $X_i$ 秒正在运行的任务中，优先级最小的 $K_i$ 个任务的优先级之和是多少。特别的，如果 $K_i$ 大于第 $X_i$ 秒正在运行的任务总数，则直接回答第 $X_i$ 秒正在运行的任务优先级之和。\n强制在线。\n链接 Luogu P3128\n题解 注意到这个问题主要就是区间的权值修改，以及单点的求和（求值），我们可以采用差分的办法。\n\u0008首先对任务离线后分成 $(S_i,P_i,1)$ ， $(E_i+1,P_i,-1)$ 两个修改，排序后\u0008扫一遍进行修改。\n查询第 $X_i$ 秒的时候，我们注意到我们\u0008每个时间所对应的线段树\u0008其实就是\u0008差分的前缀和，所以我们直接在第 $X_i$ 个线段树上求前 $K_i$ 个数的和就好了。注意在叶子结点需要分类讨论，看\u0008叶子结点有没有取全。\n数据范围很大（？），需要离散化，这里用了map。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;vector\u0026gt;#define ll long long using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 200000; map\u0026lt;int,int\u0026gt; S;int last[MAXN]; namespace prSegTree{ int val[MAXN*50],ls[MAXN*50],rs[MAXN*50]; ll sum[MAXN*50];int cnt = 0; #define mid ((l+r)\u0026gt;\u0026gt;1)  void maintain(int nown,int l,int r){ val[nown] = val[ls[nown]] + val[rs[nown]]; sum[nown] = sum[ls[nown]] + sum[rs[nown]]; } void insert(int \u0026amp;nown,int pre,int l,int r,int pos,int d){ nown = ++cnt;ls[nown] = ls[pre],rs[nown] = rs[pre]; val[nown]=val[pre]+d,sum[nown]=sum[pre]+1ll * d * last[pos]; if(l == r) return; else{ if(pos \u0026lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,d); if(mid+1 \u0026lt;= pos) insert(rs[nown],rs[pre],mid+1,r,pos,d); } } ll query(int nown,int l,int r,int k){ if(l == r){ if(k\u0026gt;=val[nown]) return sum[nown]; else return k * last[l]; } else{ int sumn = val[ls[nown]]; if(k \u0026lt;= sumn) return query(ls[nown],l,mid,k); else if(sumn + 1 \u0026lt;= k) return sum[ls[nown]] + query(rs[nown],mid+1,r,k-sumn); } } } int n,m,totn,maxt,rt[MAXN]; vector\u0026lt;int\u0026gt; qq[MAXN]; void init(){ read(n),read(m); int a,b,c; maxt = n; for(int i = 1;i\u0026lt;=n;i++){ read(a),read(b),read(c); qq[a].push_back(c); qq[b+1].push_back(-c); maxt = max(maxt,b+1); S[c] = 0; } for(auto it = S.begin();it!=S.end();it++){ it-\u0026gt;second = ++totn; last[totn] = it-\u0026gt;first; } for(int i = 1;i\u0026lt;=maxt;i++){ rt[i] = rt[i-1]; for(int j = 0;j\u0026lt;qq[i].size();j++){ prSegTree::insert(rt[i],rt[i],1,totn,(S[abs(qq[i][j])]),qq[i][j] \u0026gt; 0? 1 : -1); } } } void solve(){ ll last = 1,ans; int x,k,a,b,c; for(int i = 1;i\u0026lt;=m;i++){ read(x),read(a),read(b),read(c); k = 1+(a*last+b)%c; ans = prSegTree::query(rt[x],1,totn,k); printf(\u0026#34;%lld\\n\u0026#34;,ans); last = ans; } } int main(){ init(); solve(); return 0; }   ","description":"","id":199,"section":"posts","tags":["可持久化线段树","差分","数据结构"],"title":"「CQOI2015」任务查询系统-可持久化线段树","uri":"https://blog.chenqiqian.com/posts/cqoi2015-mission/"},{"content":"辉辉热衷于洞穴勘测。\n辉辉有一台监测仪器可以实时将通道的每一次改变状况，并在辉辉手边的终端机上显示：\nConnect u v代表监测到洞穴u和洞穴v之间出现了一条通道，Destroy u v代表监测到洞穴u和洞穴v之间的通道被毁。Query u v，代表向监测仪询问此时洞穴u和洞穴v是否连通。\n保证无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。\n已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n链接 Luogu P2147\nBZOJ2049\n题解 利用动态树维护森林的连通性。\n每次寻找在对应原树中的根，一样就联通，否则不连通。不加更多解释。\n注意判断一下加边和切边的合法性判断。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 20000; struct Link_Cat_Tree{ int f[MAXN],c[MAXN][2]; bool rev[MAXN]; inline bool noroot(int x){ return (c[f[x]][0] == x) || (c[f[x]][1] == x); } inline void reverse(int x){ if(!x) return; swap(c[x][0],c[x][1]); rev[x] ^= 1; } inline void push_down(int x){ if(!x) return; if(rev[x]){ reverse(c[x][0]),reverse(c[x][1]); rev[x] = 0; } } void push_all(int x){ if(!x) return; if(noroot(x)) push_all(f[x]); push_down(x); } inline void rotate(int x){ int y = f[x],z = f[y],t = (c[y][1] == x),w = c[x][1-t]; if(noroot(y)) c[z][c[z][1] == y] = x; c[y][t] = w,c[x][1-t] = y; if(w) f[w] = y; f[y] = x,f[x] = z; } inline void splay(int x){ push_all(x); while(noroot(x)){ int y = f[x],z = f[y]; if(noroot(y)){ if((c[z][1] == y) ^ (c[y][1] == x)) rotate(x); else rotate(y); }rotate(x); } } inline void access(int x){ for(int y = 0;x;x = f[y=x]) splay(x),c[x][1] = y; } inline void makeroot(int x){ access(x);splay(x);reverse(x); } inline int find(int x){ access(x),splay(x); push_down(x); while(c[x][0]) x = c[x][0],push_down(x); return x; } inline void link(int x,int y){ makeroot(x); if(find(y)!=x) f[x] = y; } inline void cat(int x,int y){ makeroot(x); if(find(y) == x \u0026amp;\u0026amp; f[x] == y \u0026amp;\u0026amp; !c[x][1]) f[x] = c[y][0] = 0; } inline int query(int x,int y){ return int(find(x) == find(y)); } }; Link_Cat_Tree S; int n,m; char yes[6] = \u0026#34;Yes\\n\u0026#34;,no[5] = \u0026#34;No\\n\u0026#34;; void solve(){ read(n),read(m); char op[20];int a,b; for(int i = 1;i\u0026lt;=m;i++){ read(op);read(a),read(b); if(op[0] == \u0026#39;C\u0026#39;) S.link(a,b); if(op[0] == \u0026#39;D\u0026#39;) S.cat(a,b); else if(op[0] == \u0026#39;Q\u0026#39;) print(S.query(a,b) ? yes:no); } } int main(){ solve(); flush(); return 0; }   ","description":"","id":200,"section":"posts","tags":["数据结构","LCT"],"title":"「SDOI2008」洞穴勘测-LCT","uri":"https://blog.chenqiqian.com/posts/sdoi2008-cave/"},{"content":"给定一个含有 $n$ 个数的序列 ${a_n}$ ，回答询问或执行操作：\n  Q i j k （$1\\leq i\\leq j\\leq n, 1\\leq k\\leq j-i+1$）表示询问$a[i],a[i+1]\u0026hellip;\u0026hellip;a[j]$中第 $k$ 小的数。\n  C i t ($1 \\leq i \\leq n,0\\leq t \\leq 10^{9}$)表示把 $a[i]$ 改变成为 $t$ 。\n  链接 Luogu P2617\n先在这里粗略的讲一讲。\n与普通主席树不同，令第 $i$ 个位置的线段树维护 $(i-lowbit(i),; i,]$ 这个区间的权值线段树，而不是 $[1,;i,]$ 。\n这个时候，我们注意到，对于每一个修改，只会影响到 $O(\\log{n})$ 个线段树。我们直接按树状数组的规则去修改，直接在原节点上建立一颗新树进行更改即可。\n而每次查询，也只会需要到 $O(\\log{n})$ 个线段树，也就是两个树状数组前缀和相减，就可以得到指定区间的权值线段树。我们可以按照树状数组的方式先将权值线段树中要加上的节点和要减去的节点全部存到一个数组里，然后就可以按照不带修改区间 $k$ 大差不多的样子去查询了。\n这里时空复杂度应该都是 $O(n \\log^{2}{n})$ 。\n需要离散化。这里用了 map 。这里有一个地方易错。离散化出来的数可能比 $n$ 要大，所以需要另记一个 totn 在树状数组查询修改和各种地方作为值域使用。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;map\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 50000; int n,m,totn = 0; int rt[MAXN],num[MAXN]; int lowbit(int x){return x \u0026amp; (-x);} namespace prSegTree{ int val[MAXN*50],ls[MAXN*50],rs[MAXN*50]; int cnt = 0;int ll[MAXN],rr[MAXN],totx,toty; #define mid ((l+r) \u0026gt;\u0026gt; 1)  void insert(int \u0026amp;nown,int pre,int l,int r,int pos,int d){ nown = ++cnt;val[nown] = val[pre] + d; ls[nown] = ls[pre],rs[nown] = rs[pre]; if(l == r) return; else{ if(pos \u0026lt;= mid) insert(ls[nown],ls[pre],l,mid,pos,d); else if(pos \u0026gt;= mid+1) insert(rs[nown],rs[pre],mid+1,r,pos,d); } } void update(int pos,int v,int d){ for(int i = pos;i\u0026lt;=totn;i += lowbit(i)) insert(rt[i],rt[i],1,totn,v,d); } void add(int l,int r){ totx = toty = 0; for(int i = l-1;i;i-=lowbit(i)) ll[++totx] = rt[i]; for(int i = r;i;i-=lowbit(i)) rr[++toty] = rt[i]; } int find_kth(int l,int r,int k){ int sum = 0; if(l == r){ return l; } else{ for(int i = 1;i\u0026lt;=totx;i++) sum -= val[ls[ll[i]]]; for(int i = 1;i\u0026lt;=toty;i++) sum += val[ls[rr[i]]]; if(k \u0026lt;= sum){ for(int i = 1;i\u0026lt;=totx;i++) ll[i] = ls[ll[i]]; for(int i = 1;i\u0026lt;=toty;i++) rr[i] = ls[rr[i]]; return find_kth(l,mid,k); } else{ for(int i = 1;i\u0026lt;=totx;i++) ll[i] = rs[ll[i]]; for(int i = 1;i\u0026lt;=toty;i++) rr[i] = rs[rr[i]]; return find_kth(mid+1,r,k-sum); } } } int query(int l,int r,int k){ add(l,r); return find_kth(1,totn,k); } } map\u0026lt;int,int\u0026gt; S;int last[MAXN]; int op[MAXN],ql[MAXN],qr[MAXN],v[MAXN]; void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(num[i]),S[num[i]] = 0; char t[23]; for(int i = 1;i\u0026lt;=m;i++){ read(t);read(ql[i]),read(qr[i]); if(t[0] == \u0026#39;Q\u0026#39;) op[i] = 1,read(v[i]); else S[qr[i]] = 0; } for(auto it = S.begin();it != S.end();it++) it-\u0026gt;second = ++totn,last[totn] = it-\u0026gt;first; for(int i = 1;i\u0026lt;=n;i++) prSegTree::update(i,S[num[i]],1); } void solve(){ for(int i = 1;i\u0026lt;=m;i++){ if(op[i] == 0) prSegTree::update(ql[i],S[num[ql[i]]],-1), prSegTree::update(ql[i],S[qr[i]],1),num[ql[i]] = qr[i]; else print(last[prSegTree::query(ql[i],qr[i],v[i])]),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":201,"section":"posts","tags":["数据结构","可持久化线段树"],"title":"「Luogu2617」Dynamic Rankings-树状数组-可持久化线段树","uri":"https://blog.chenqiqian.com/posts/luogu-2617/"},{"content":"定义一棵树上最长的路径为树的直径。树的直径可能不唯一。\n给定的一棵 $n$ 个结点的树，求其直径的长度，以及有多少条边满足所有的直径都经过该边。\n链接 Luogu P3304\nBZOJ 3124\n题解 很有趣的一道题\n首先找直径。先从任取点 $t$ 出发，到达最远的一个点 $u$ 。再从 $u$ 出发，到达最远的点$v$，$u$，$v$之间的路径即为树的直径。\n这比较显然。\n令 $\\delta (u,v)$ 为 $u,v$ 两点间路径，其数值即为路径长度。\n引理：在一棵树中， $x$ 、 $y$ 和 $z$ 是三个不同的结点。当 $x$ 到 $y$ 的最短路与 $y$ 到 $z$ 的最短路不重合时，$x$ 到 $z$ 的最短路就是这两条最短路的拼接。\n定理1：在一棵树中，以任意结点出发所能到达的最远结点，一定是该树直径的端点之一。\n证明：假设这条直径是 $\\delta (u,v)$ 。分两种情况：\n当出发结点 $y$ 在 $\\delta(u,v)$ 上时，假设到达的最远结点 $z$ 不是 $u,v$ 中的任一个。这时将 $\\delta(y,z)$ 与不与之重合的 $\\delta(y,u)$ 拼接（也可以假设不与之重合的是直径的另一个方向），可以得到一条更长的路径，矛盾。\n当出发结点 $y$ 不在 $\\delta(u,v)$ 上时，分两种情况：\n  当 $y$ 到达的最远结点 $z$ 横穿 $\\delta(u,v)$ 时，记与之相交的结点为 $x$。此时有 $\\delta(y,z)=\\delta(y,x)+\\delta(x,z)$ 。而此时 $\\delta(y,z)\u0026gt;\\delta(y,v)$ ，故可得 $\\delta(x,z)\u0026gt;\\delta(x,v)$ 。由 $1$ 的结论可知该假设不成立。\n  当 $y$ 到达的最远结点 $z$ 与$\\delta(u,v)$不相交时，记 $y$ 到 $v$ 的最短路首先与 $\\delta(u,v)$ 相交的结点是 $x$。由假设 $\\delta(y,z)\u0026gt;\\delta(y,x)+\\delta(x,v)$ 。而 $\\delta(y,z)+\\delta(y,x)+\\delta(x,u)$ 又可以形成 $\\delta(z,u)$ ，而 $\\delta(z,u)\u0026gt;\\delta(x,u)+\\delta(x,v)+2\\delta(y,x)=\\delta(u,v)+2\\delta(y,x)$ 矛盾。\n  先求出了直径，我们就发现一件好玩的事情。\n定理2：对于一个边权为正数的树，其所有的直径必然两两有交点。\n证明：设树的一条直径为 $\\delta (u,v)$ ，任取另一直径为 $\\delta (u',v')$ 。其长度设为 $d$ 。\n若两直径有公共部分，显然有公共点。\n若没有公共部分，则必有一条路径 $\\delta (x,y)$ 连接两条直径， $x$ 在 $\\delta (u,v)$ 上， $y$ 在 $\\delta (u',v')$ 上。\n在 $\\delta(u,x)$ 和 $\\delta(x,v)$ 中，不妨设 $\\delta(u,x) \\geq \\frac{1}{2} \\times d$ 。同理设 $\\delta(u',y) \\geq \\frac{1}{2} \\times d$ ，又因为 $\\delta (x,y) \u0026gt; 0$ ，所以 $\\delta (u,u') = \\delta(u,x) + \\delta(x,y) + \\delta(y,u') \u0026gt; d = \\delta(u,v)$ ，矛盾。\n我们要求的是有多少个边在在所有的直径上。我们已经求得了一条直径 $\\delta(u,v)$ 。\n令 $x$ 为在 $\\delta(u,v)$ 上离 $u$ 点最远的点，满足存在点 $u'$ ，使得 $\\delta(x,u') = \\delta(x,u)$ ，且 $u \\neq u'$ ，则可得 $\\delta(u',v)$ 也是一条直径。\n同理 $y$ 为在 $\\delta(u,v)$ 上离 $v$ 点最远的点，满足存在点 $v'$ ，使得 $\\delta(x,v') = \\delta(x,v)$ ，且 $v \\neq v'$ ，则可得 $\\delta(u,v')$ 也是一条直径。\n这两个东西都可以在找出直径之后一边扫直径一边 dfs出来。这个时候我们注意到， $x$ 应当在 $y$ 左侧，且 $x$ 在直径左半部， $y$ 在直径右半部，排列顺序大概是这个样子 $u\\leftrightarrow x \\leftrightarrow y \\leftrightarrow v$ 。很容易看出， $x$ 与 $y$ 之间的部分，就是所有直径的公共边。答案即为 $\\delta(x,y)$ 。\n时间复杂度大约是一个常数比较大的 $O(n)$ 。\n代码 懒得写 bfs ，于是就比较的慢\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; namespace fast_io {//快速输入模板  inline char read(){ static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t; return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++; } inline void read(int \u0026amp;x){ static bool iosig;static char c; for (iosig=false,c=read();!isdigit(c);c=read()){ if(c==\u0026#39;-\u0026#39;)iosig=true;if(c==-1)return; } for(x=0;isdigit(c);c=read()) x=((x+(x\u0026lt;\u0026lt;2))\u0026lt;\u0026lt;1)+(c^\u0026#39;0\u0026#39;); if(iosig)x=-x; } }using namespace fast_io; const int MAXN = 300000; struct Edge{ int from,to,len; }; int n,u=0,v=0,fa[MAXN]; ll dis[MAXN],ans1,ans2; vector\u0026lt;Edge\u0026gt; edge[MAXN]; void addedge(int a,int b,int c){ edge[a].push_back((Edge){a,b,c}); edge[b].push_back((Edge){b,a,c}); } void init(){ read(n); int a,b,c; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b),read(c); addedge(a,b,c); } } void dfs(int nown,int f){//寻找从nown节点出发的最长路  fa[nown] = f; for(int i = 0;i\u0026lt;edge[nown].size();i++){ Edge e = edge[nown][i]; if(e.to == f) continue; dis[e.to] = dis[nown] + e.len; dfs(e.to,nown); } } void find(){ memset(dis,0,sizeof(dis)); dfs(1,0); for(int i = 1;i\u0026lt;=n;i++)//第一次搜到的节点记作直径的一个端点u  if(dis[i] \u0026gt; dis[u]) u = i; memset(dis,0,sizeof(dis)); dfs(u,0); for(int i = 1;i\u0026lt;=n;i++)//第二次搜到的节点记作直径的另一个端点v  if(dis[i] \u0026gt; dis[v]) v = i; } bool dfs2(int nown,ll len){//dfs寻找是否从某个节点存在长度为len的路径  if(len == 0) return true; for(int i = 0;i \u0026lt; edge[nown].size();i++){ Edge e = edge[nown][i]; if(e.to == fa[nown]) continue; if(dfs2(e.to,len - e.len)) return true; } return false; } void solve(){ static int nex[MAXN]; int t = v,tmp = 0;//tmp为直径长度  while(t!=u){//记录从u到v的路径  nex[fa[t]] = t; t = fa[t]; tmp++; } //l代表到右节点最近的满足上文性质的点，r代表到左节点最近的满足上文性质的点  int l = 0,r = tmp,nowt = 0; //循环中dis[t] = d(u,t)  for(t = u;t!=v;t = nex[t]){ for(int i = 0;i\u0026lt;edge[t].size();i++){ Edge e = edge[t][i]; if(e.to == fa[t] || e.to == nex[t]) continue; if(dfs2(e.to,dis[t] - e.len)) l = max(nowt,l);//寻找离u最远的t,满足d(u\u0026#39;,t) = d(u,t),得到即为x,名字叫做l  else if(dfs2(e.to,(dis[v] - dis[t])- e.len)) r = min(r,nowt);//寻找离v最远的t,满足d(t,v\u0026#39;) = d(t,v),得到即为y,名字叫做r  } nowt++; } ans1 = dis[v];//直径长度  ans2 = r - l;//在这里事实上是求了r和l的位置并求出ans2 } int main(){ init(); find(); solve(); printf(\u0026#34;%lld\\n%lld\\n\u0026#34;,ans1,ans2); return 0; }   ","description":"","id":202,"section":"posts","tags":["图论","树形结构","树的直径"],"title":"「SDOI2013」直径-树的直径","uri":"https://blog.chenqiqian.com/posts/sdoi2013-diameter/"},{"content":"给一个数列 ${a_n}$ ，每次询问区间 $[l,r]$ 内有没有一个数出现次数超过一半。如果有，输出这个数，如果没有，输出 $0$ 。\n链接 Luogu P3567\n题解 主席树的模版\u0026hellip;然而蒟蒻如我居然并看不出来怎么做\u0026hellip;不过现在对权值线段树也更了解了呢。\n普通的建立一颗主席树。每个节点维护该区间内权值总和。\n在查询的时候，还是两个前缀相减，往大于 $\\lceil \\frac{r-l+1}{2} \\rceil$ （原始的 $[l,r]$ ）的方向去走，如果没有，就返回0，边界就是 $l == r$ 的时候返回。\n其实就是总统选举那道题的弱化版。\n很简单。然而我更菜。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#define mid ((l+r)\u0026gt;\u0026gt;1) #define pp pair\u0026lt;int,int\u0026gt; using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 600000; namespace prSegTree{ int val[MAXN*20];int ls[MAXN*20],rs[MAXN*20]; int cnt = 1; void build(int \u0026amp;nown,int l,int r){ nown = cnt++; if(l == r) val[nown] = 0; else{ build(ls[nown],l,mid); build(rs[nown],mid+1,r); } } void update(int \u0026amp;nown,int pre,int l,int r,int pos,int d){ nown = cnt++;val[nown] = val[pre]+d; ls[nown] = ls[pre];rs[nown] = rs[pre]; if(l == r) return; else{ if(pos \u0026lt;= mid) update(ls[nown],ls[pre],l,mid,pos,d); if(mid+1 \u0026lt;= pos) update(rs[nown],rs[pre],mid+1,r,pos,d); } } int query(int nowl,int nowr,int l,int r,int limit){ if(l == r) return l; else{ if(val[ls[nowr]] - val[ls[nowl]]\u0026gt;=limit) return query(ls[nowl],ls[nowr],l,mid,limit); if(val[rs[nowr]] - val[rs[nowl]]\u0026gt;=limit) return query(rs[nowl],rs[nowr],mid+1,r,limit); return 0; } } } int n,m; int root[MAXN]; void init(){ read(n),read(m); prSegTree::build(root[0],1,n); int tmp; for(int i = 1;i\u0026lt;=n;i++){ read(tmp); root[i] = root[i-1]; prSegTree::update(root[i],root[i-1],1,n,tmp,1); } } void solve(){ int l,r; for(int i = 1;i\u0026lt;=m;i++){ read(l),read(r); print(prSegTree::query(root[l-1],root[r],1,n,(r-l+1)/2+1)),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":203,"section":"posts","tags":["数据结构","主席树","线段树","可持久化线段树"],"title":"「POI2014」KUR-Couriers-主席树","uri":"https://blog.chenqiqian.com/posts/poi2014-kur/"},{"content":"美食节共有 $n$ 种不同的菜品，每个同学都点了一份在这 $n$ 个菜品中的菜。总共有 $m$ 个厨师来制作这些菜品。厨师们会按照要求的顺序进行制作，并且每次只能制作一人份。第 $j$ 个厨师制作第 $i$ 种菜品的时间记为 $t _ {i,j}$ 。每个同学的等待时间为所有厨师开始做菜起，到自己那份菜品完成为止的时间总长度。总等待时间为所有同学的等待时间之和。\n已知共有 $n$ 种菜品，第 $i$ 种菜品需要做 $p_i$ 份，共有 $m$ 个厨师。请计算出最小的总等待时间是多少。\n链接 Luogu P2050\n题解 \u0008很有趣的题。\u0008\n看起来跟「SCOI2007」修车 很像，然而这道题的数据大大加强了。\n这道题主要的方法如下：\n对于每一个厨师，构建 $\\sum p$ 个点，分别代表其倒数第一个，\u0026hellip;\u0008，倒数第 $p$ \u0008个制作的\u0008菜品。对于第 $i$ 个菜品，由菜品节点向第 $j$ 个厨师倒数第 $k$ 个做的菜，连一条\u0008容量为 $1$ ，\u0008费用为 $t _ {i,j} \\times k$ 的边。可以发现，这条边就代表了\u0008所有在倒数第 $k$ 个后面以及倒数第 $k$ \u0008个\u0008制作菜品中由倒数第k个菜品的制作而产生的等待时间。\u0008\n其他还有从各个\u0008节点连向汇点，以及源点\u0008连向各菜品节点，\u0008\u0008容量为 $p_i$ 的边。\n但是，这个过不了。经过计算，我们发现最多的时候会有近 $6000000$ 条边，\u0008显然很惨。干写这个算法大概是50-60分的样子吧。\n所以我们需要作出一些\u0008改进，来让这个算法变成 O(能过) 。考虑到最主要的问题是边数太多，\u0008所以我们应该想办法减少边的数目。\n\u0008这个时候就可以玄学操作了。\n考虑到以下的一件事：如果一个厨师倒数第 $k$ 个需要做的菜还没有做，那么不可能先做倒数第 $k+1$ 个菜，因为无论做什么菜，倒数第 $k$ 个做的菜价格总是更低。\n所以我们先把每个厨师最后一个制作的菜品加入图中，然后进行一次 spfa 的增广。然后每次增广出来的菜和厨师，我们就加一条同一个厨师后面一个需要做的菜，这样既能保证复杂度比较低，也可以正确增广。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 100000,MAXM = 2000000; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM]; int n,m,s,t,sum = 0; int ff = 0,cc = 0,p[MAXN],ti[1000][1000]; int fir[MAXN],ecnt = 2; void addedge(int a,int b,int c,int d){ edge[ecnt] = (Edge){a,b,c,0,d,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]}; fir[b] = ecnt++; } int dis[MAXN],instack[MAXN],pree[MAXN]; queue\u0026lt;int\u0026gt; q; bool spfa(){ while(!q.empty()) q.pop(); memset(dis,0x3f,sizeof(dis)); memset(instack,0,sizeof(instack)); q.push(s);dis[s] = 0; while(!q.empty()){ int nown = q.front();q.pop(); instack[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ Edge e = edge[nowe]; if(dis[e.to] \u0026gt; dis[nown] + e.cost \u0026amp;\u0026amp; e.cap \u0026gt; e.flow){ dis[e.to] = dis[nown] + e.cost; pree[e.to] = nowe; if(instack[e.to] == 0){ q.push(e.to); instack[e.to] = 1; } } } } return dis[t] \u0026lt; 0x3f3f3f3f; } void argument(){ int nown = t,nowe = 0,limit = 0x3f3f3f3f; while(nown != s){ nowe = pree[nown]; limit = min(limit,edge[nowe].cap - edge[nowe].flow); nown = edge[nowe].from; } nown = t; while(nown != s){ nowe = pree[nown]; edge[nowe].flow += limit; edge[nowe^1].flow -= limit; nown = edge[nowe].from; } ff += limit,cc += limit * dis[t]; } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++){ read(p[i]); sum += p[i]; } for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m;j++){ read(ti[i][j]); } } } void solve(){ s = m*sum + n + 1,t = m*sum + n + 2; for(int i = 1;i\u0026lt;=n;i++) addedge(s,m*sum + i,p[i],0); for(int j = 1;j\u0026lt;=m;j++){ addedge(j,t,1,0); for(int i = 1;i\u0026lt;=n;i++){\taddedge(m*sum + i,j,1,ti[i][j]); } } while(spfa()){ argument(); int x = edge[pree[t]].from; addedge(x+m,t,1,0); for(int i = 1;i\u0026lt;=n;i++){ addedge(m*sum + i,x+m,1,ti[i][(x-1)%m+1]*((x+m-1)/m+1)); } } print(cc),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":204,"section":"posts","tags":["费用流","图论"],"title":"「NOI2012」美食节-费用流","uri":"https://blog.chenqiqian.com/posts/noi2012-festival/"},{"content":" 衡水市，2017年常住人口446.0万人，GDP1550.1亿元，人均GDP3.47万元，衡水市教育局预算支出68644.4万元。\n  北京市海淀区，2017年常住人口348.0万人，GDP5915.3亿元，人均GDP17.00万元，海淀区教育委员会预算支出1038648.0万元。\n X大附中，高中在校生约3000人，一本率近100%，清北录取人数119人。\n河北衡水中学，在校生约10000人，一本率超过85%，清北录取人数175人。\n写在前面 \u0008\u0008\u00082018年4月29日，我去衡水参观了衡水中学的开放日。参观的时间和内容都不是很充分，\u0008我作为一个知名“素质教育”学校的学生，\u0008某些事情上的观点有可能并不准确和正确。如有这些情况，可以留言告知，我会酌情删改。\n引子 2018年4月29日，河北省衡水市。晴，18-31摄氏度。\n驱车五个小时，终于从北京到达了衡水。\n总是说要出北京去见见世面，去观察那些不是那么熟悉的地方，所以一看到衡中开放日，就暗暗下定决心，要去这所只在新闻里听闻过的学校。以至于后面几天听说清华的校庆可以去观礼，也仍然去了衡水。甚至就在去之前的一天，还跟同学开玩笑说：“您去清华签约，我只能去衡水复读了。”\n早上的路程说不上顺利。六点钟就从北京出发，一路目睹了许多追尾车祸，最后竟11点才到了衡中门口。\n下了车，就拿好东西，向衡中的大门缓缓走去。那时正是中午，天气很热，天空上也没有一点的浮云，穿上短袖也感到少许闷热。突然间，衡中的大门就出现了在眼前。\n衡水中学正校门：酷似首都师范大学\n从停车处走到校门的路上，一路的景象也让我不禁唏嘘。一条笔直的大道，路旁的店铺则大多与教育有关，甚至还有在地上摆了一地高中教材和五三的小贩。脚下的道路虽然已经硬化，但是仍然不甚平整。在大门口，停满了各种各样的电动车和三轮车，车上撑着遮阳伞的小摊贩也举目可见。如果你不说这里是衡水中学，那么我一定会把这个一个省最强，乃至全国最强的中学之一的学校当作一个普通十八线小县城的一所普通的高中。\n然而这是衡水中学。\n\u0008图：证明确实去过\n校园 \u0008衡中的校园，其实并不和X大附中的\u0008校园\u0008\u0008的格局有什么多大的区别。但相比于\u0008X大附中，衡中的校园显得更大一些。\n0x01 进门的左手边就是一门大炮和一个小湖。\n\u0008图：神奇的加农炮\n不止左手边是一门大炮，右手边就是一台62坦克。果然是又红又专啊！到处都是关于十九大和\u0008今年的人大换届的展板\u0008，政治觉悟实在是高！\n图：62式坦克 初教6\u0008教练机\n一直羡慕校园里有水的学校，比如101。如果一个学校\u0008里面有活水，那么这所学校的气氛，就一定不会死气沉沉，在其中\u0008学习一定会是充满愉快的。遇到什么困难，去看看\u0008\u0008澄澈的水面，总是会让人觉得人生是充满希望的。但我想人大的一勺之池大约是不算在其中的。\n图：衡中湖\n0x02 \u0008\u0008走到最里面，就是\u0008衡中的操场了。\n图：操场及标语\n全世界的操场都是差不多的\u0008样子。不过我还是要说\u0026hellip;你X大附中每年几个亿的经费能不能修个草皮？？？\u0008全世界的草皮都不知道比破校好到哪里去了。\n有点特色的就是标语。开始还没什么。站在操场的中央，越读越觉得有趣。没有看到跑操的示范，也不好再说些\u0008什么，这个章节就简短一些了。\n\u0008图：衡水中学的学生正在打篮球\n这张图也让我印象很深刻。衡中的\u0008学生，再怎么样，也还可以是学生的嘛。\n0x03 往外走的路上，在树梢的枝头瞟见\u0008高三\u0008(or高二？)的教学楼上有着一面几乎分毫不差的大钟。\n图：教学楼上的钟\n或许这也是衡中的几乎变态的时间规划的体现吧。刚看到觉得有些意外，但渐渐地也觉得\u0008这些东西，也不是什么坏的东西啊。\n趁着\u0008家长会偷偷溜进了高一的教室。接下来这一段大概是全文我感觉最有意思的\u0008地方了。\n\u0008我现在也正是高一，所以大约对下高一的学习\u0008进度大约是件非常有趣的事情。\n图：公开贴在楼道的\u0008周测\u0008（或者期中考试）排名\n毋庸置疑，衡中，尤其其实验班的确是一个学习\u0008氛围非常浓厚的地方。也许并不是所有人都想去学习，\u0008不停的学习，但这样学习的环境的确是很难在县城高中里获得的。\n就算在我的同学里面，\u0008\u0008\u0008\u0008我恐怕也是少数几个还对初三\u0008的月考抱有好感的人。这种学习的氛围，对自己学习方面实力的提升，我还是很喜欢的。\n还有就是教室。它的教室较我们现在使用的楼来看，还是稍大一些。但是，就是这些稍大一些的\u0008教室，竟然\u0008盛下了几乎两倍于\u0008我们一个\u0008\u0008教室的人。\n图：高一的教室，可以\u0008看到\u0008三个，乃至四个人同桌\u0008情况\n不敢想象啊。我们的教室，\u0008坐下40\u0008个人就已经很拥挤。70个人真的是难以令人想象。\u0008每个人的座位下，都有一个箱子，盛着或许是书，或许是卷子。\n这就是\u0008中国最厉害的高中的教室。\n图：每个班门口都配有的\u0008电子触摸屏幕\n即使教室比较破旧，可是\u0008电教什么的却不差什么。像这样的\u0008\u0008屏幕，每个班都有一块。在楼道里还有自动售货机，真是不知道比我们高到哪里去了。\u0008\n\u0008在教学楼里，人来人往，学生拿着自己的东西，家长和学生一起。我去的仅仅是高一的教室。这里的高一\u0008，感觉\u0008比我校的高三还要累上许多。\n看看我拥有的条件，很惭愧，但我也\u0008无能为力。\u0008我妄想着以笔为刃，然而\u0008我确实也只是一个普通的高中生。我比他们所拥有的一切好的多\u0008，不是靠我，而是靠我的\u0008父母。这不应是他们可悲之处，是国家之可悲啊。\u0008\n0x04 从教室里面走出来，家长会已近结束，上午还在学校的学生们也要回家度过两天半（或者一天半？）的五一假期了。\n开放日结束，我也只好走出校门。突然就看到\u0008右手边，有一个学生，\u0008坐在那种拉货的三轮车上，\u0008整个三轮车的其他位置全都被行李占满。这一切突然撞入\u0008眼帘，不经意间也撞入心坎。\n\u0008商量好去哪里吃中午饭，一家人就开着车前往目的地。\u0008天气很热，车的\u0008座椅经过半个\u0008上午的炙烤都有点发烫。进车关门，\u0008空调的声音一时\u0008喧闹起来。我坐在后排，百无聊赖的看着\u0008\u0008窗外\u0008有些枯黄的天空。\n\u0008街上\u0008满都是刚放学的衡中的学生，以及骑着各种\u0008电动车\u0008接他们回去的家长们。车内的温度渐渐降下来了。看着窗外，想着上午\u0008所见的一切，刚要有些感慨，\u0008突然就看到\u0008那个坐在电动车上的女生再次出现在了我的视野里。我坐在凉爽的\u0008私家车的车座座上，而她却只能坐在三轮车那或许滚烫的金属板子上。\u0008\u0008\u0008\u0008\u0008我可以去餐馆\u0008吹着空调舒舒服服\u0008的吃上一顿然后写一篇游记，\u0008她或许只能吃完简朴的饭食接着去写作业。\n当这些差距真真的摆在面前——用语文的话说“形成鲜明对比”，或许才是真正能体会到百味辛酸的时候。\n感慨万千。我看着那位同学背后的四个字 “追求卓越” ，\u0008一时凝神，不知道该说些什么好。\n诚然，以\u0008\u0008衡水中学为代表的一系列超级中学的跑操、近乎\u0008军训的日常时间表，还有严苛的\u0008各种纪律，的确是\u0008一种对于人的特性的磨灭。\n但请你放下身位，真的放下你所拥有的一切去思考：\n 你是一个四线城市的\u0008\u0008普通人家的孩子。你的爸妈并不具有很高的文化素养，家庭的物质条件也不算富裕。你渴望更大的世界，渴望走出小小的\u0008县城。你能怎么做呢？\n 衡水中学不可能像X大附中一样。 \u0008整个衡水市，给\u0008总共十几所的小学，\u0008中学，\u0008\u0008专科学校的教育资金只有6个亿。而光X大附中一所学校，每年从X大能拿到的资金就有3个多亿。怎么比？X大附中的学生，\u0008绝大多数的父母都是\u0008高级知识分子，\u0008家境怎么着也能算得上殷实。怎么比？\n衡中所能\u0008做的，是给那些想走出去的学生，一个公平的舞台，\u0008一个\u0008完整的机会。一个普通的学生，如果他本身有强烈的愿望想要学习，\u0008想要提升自己，想要\u0008到达更高的\u0008\u0008平台；那么除了衡中，\u0008在一个小小的地级市，还有什么学校能提供给他想要的平台和机遇？既然如此，那\u0008外人所诋毁的衡中的一切，\u0008对于\u0008他，又算得了什么呢？\n其实衡水中学更像是一个\u0008中国\u0008教育的矛盾的集中体。人人都知道素质教育好，人人都在媒体上抨击应试教育。可是就算以素质教育闻名的X大附中，一位老师也这么说：“这节课我教你的不是\u0008素质教育。我们该应试的\u0008时候\u0008就得应试。”只要你还处在平民的层次，应试仍然是阶级可能的上升途径中不能避开的一件事。\u0008国情在此，如果连衡水中学这样，能给贫苦孩子提供上升机会的平台都要去推翻，那\u0008这些人的\u0008嘴脸简直是卑鄙。\n虽然衡水中学这样的模式的确是一种当前国情下的最优解，但是\u0008不能否认，衡水中学还是需要去批判的。诸如衡水中学、毛坦厂中学的出现，根本还是因为教育资源的极为不均，这终究不是我们想看到的，我们这一代人\u0008也需要去拼搏奋斗的\u0008去改变。\n还有最后一点。那位同学，我衷心的祝你好运。\u0008愿你能够考上\u0008心仪的大学，过上满意的生活。愿阶级不再能成为你的枷锁，你的\u0008人生能摆脱\u0008这层\u0008近乎无解的\u0008桎梏。\n愿你\u0008安好。\n来源：Dear Earth\n写在最后 如果我有机会，其实我愿意在这所学校里生活上一个月，体验一下北京以外的生活。老是呆在\u0008北京，恐怕总会把人生看的\u0008过于简单。\u0008在那里，恐怕才是中国意义上比较普遍的人生的样子。\n但恐怕并我不会去\u0008衡中，有机会能去的\u0008时候也并不想去\u0008如此去为自己拼搏了。\n写于2018年4月30日。\n","description":"","id":205,"section":"posts","tags":null,"title":"衡水中学游记","uri":"https://blog.chenqiqian.com/posts/trip-hs-middle-school/"},{"content":"给定 $n$ 个结点的数据值 $V_i$ ，权值 $P_i$ ，访问频度 $T_i(T_i \\geq 0)$ 。对于 $\\forall i,j \\in V$ 且 $i \\neq j$ ，有 $V_i \\neq V_j, P_i \\neq P_j$ 。\n现令这 $n$ 个点组成一颗二叉树，且满足 $\\forall , i \\in V$ ，若 $p$ 为 $i$ 的左子节点， $q$ 为 $i$ 的右子节点，则 $V_p \u0026lt; V_i \u0026lt; V_q$ 且 $P_i \u0026lt; P_p,; P_i \u0026lt; P_q$ 。可以证明，这样的二叉树是唯一的。点\u001c$i$ 在树中的深度 $D_i$ 定义为它到根的距离加 $1$ 。定义结点 $i$ 的访问代价 $E_i = T_i \\times D_i$ 。可以修改每个点的权值为任意实数，其代价均为给定的正整数 $K$ ，但需保证任两点权值仍互不相同。\n现求上文所述二叉树中，其 $\\sum^n _ {i = 1}{E_i} + \\sum K$ 的最小值。\n原文描述：\n已知一棵特殊的二叉查找树。根据定义，该二叉查找树中每个结点的数据值都比它左儿子结点的数据值大，而比它右儿子结点的数据值小。\n另一方面，这棵查找树中每个结点都有一个权值，每个结点的权值都比它的儿子结点的权值要小。\n已知树中所有结点的数据值各不相同；所有结点的权值也各不相同。这时可得出这样一个有趣的结论：如果能够确定树中每个结点的数据值和权值，那么树的形态便可以唯一确定。因为这样的一棵树可以看成是按照权值从小到大顺序插入结点所得到的、按照数据值排序的二叉查找树。\n一个结点在树中的深度定义为它到树根的距离加1。因此树的根结点的深度为1。\n每个结点除了数据值和权值以外，还有一个访问频度。我们定义一个结点在树中的访问代价为它的访问频度乘以它在树中的深度。整棵树的访问代价定义为所有结点在树中的访问代价之和。\n现在给定每个结点的数据值、权值和访问频度，你可以根据需要修改某些结点的权值，但每次修改你会付出K的额外修改代价。你可以把结点的权值改为任何实数，但是修改后所有结点的权值必须仍保持互不相同。现在你要解决的问题是，整棵树的访问代价与额外修改代价的和最小是多少？\n链接 Luogu P1864\n题解 比较简单的区间dp。\n首先对点的权值离散化，然后按照点的数据值排序。注意到点的顺序是确定的，所以如果给定区间 $[l,r]$ 以及其根节点能取到的最大的权值 $p$ ，就可以确定这个最小值。这个问题还满足局部最优解，所以搞一搞 $dp$ 就可以了。定义 $w(i,j)= \\sum _ {k = i}^j {T_i}$ 。转移方程如下：\n$$\nm(l,r,p) = 0; (l \\geq r),\n$$\n$$\n\\min _ {k = l}^r{(, m(l,k-1,p)+m(k+1,r,p)+ K), ;\nm(l,k-1,P_k)+m(k+1,r,P_k))+w(i,j) ; ;(l \u0026lt; r)}\n$$\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#define pp node using namespace std; const int MAXN = 80; int n,K; int sum[MAXN],num[MAXN]; int dp[MAXN][MAXN][MAXN]; struct node{ int fr,sc,tr; bool operator \u0026lt; (const node a)const{ return fr \u0026lt; a.fr; } }; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;K); pp tmp[MAXN];int t[MAXN]; for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp[i].fr); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp[i].sc); t[i] = tmp[i].sc; } for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp[i].tr); sort(tmp+1,tmp+n+1),sort(t+1,t+n+1); for(int i = 1;i\u0026lt;=n;i++){ num[i] = lower_bound(t+1,t+n+1,tmp[i].sc)-t; sum[i] = sum[i-1]+tmp[i].tr; } } void solve(){ int tmp; for(int w = 1;w\u0026lt;=n;w++){ for(int l = 1,r = w;r\u0026lt;=n;l++,r++){ for(int p = 0;p\u0026lt;=n;p++){ dp[l][r][p] = 0x3f3f3f3f; for(int k = l;k\u0026lt;=r;k++){ tmp = min(dp[l][k-1][p] + dp[k+1][r][p] + K, num[k] \u0026gt; p? dp[l][k-1][num[k]] + dp[k+1][r][num[k]]: 0x3f3f3f3f); dp[l][r][p] = min(dp[l][r][p],tmp); } dp[l][r][p] += sum[r] - sum[l-1]; } } } printf(\u0026#34;%d\\n\u0026#34;,dp[1][n][0]); } int main(){ init(); solve(); return 0; }   ","description":"","id":206,"section":"posts","tags":["动态规划","平衡树"],"title":"「NOI2009」二叉查找树-区间dp","uri":"https://blog.chenqiqian.com/posts/noi2009-binary/"},{"content":"lxhgww 最近迷上了一款游戏，在游戏里，他拥有 $n$ 个装备（ $n \\le 1000000$ ），每种装备都有 $2$ 个属性，这些属性的值用 $[1,10000]$ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。\n游戏进行到最后， lxhgww 遇到了终极 boss ，这个终极 boss 很奇怪，攻击他的装备所使用的属性值必须从 $1$ 开始连续递增地攻击，才能对 boss 产生伤害。现在lxhgww想知道他最多能连续攻击 boss 多少次？\n链接 Luogu P1640\n题解 upd on 2019.4.5 这是个假做法。\n可以看出，这个东西可以转换成二分图的模版。左边的 $10000$ 个点代表属性值，右边的 $n$ 个点代表装备。\n从属性值 $1$ 开始跑匈牙利的 $dfs$ ，如果能增广，就接着往下。不能的话，输出答案返回。复杂度不太会算\u0026hellip;不过可以过的。\n值得一提的是，网络流虽然我每次直接在残量网络上增广\u0026hellip;但仍然慢的要死\u0026hellip;$40$分TLE再也优化不了了\u0026hellip;\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; const int MAXN = 2000000,MAXM = 5000000; namespace fast_io { //... }using namespace fast_io; struct Edge{ int from,to; int nex; }edge[MAXM]; int fir[MAXN],ecnt = 1; void addedge(int a,int b){ edge[ecnt] = (Edge){a,b,fir[a]}; fir[a] = ecnt++; } int n,a,b; int pre[1100000],vis[11000]; void init(){ read(n); for(int i = 1;i\u0026lt;=n;i++){ read(a),read(b); addedge(a,100000+i),addedge(b,100000+i);\t} } bool dfs(int nown){ if(vis[nown]) return 0; vis[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(!pre[v] || dfs(pre[v])){ pre[v] = nown; return 1; } } return 0; } void solve(){ int ans = 0; for(int i = 1;i\u0026lt;=10000;i++){ memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; else break; } print(ans); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":207,"section":"posts","tags":["图论","二分图匹配"],"title":"「SCOI2010」连续攻击游戏-二分图匹配","uri":"https://blog.chenqiqian.com/posts/scoi2010-game/"},{"content":"秋之国共有 $n$ 个人，分别编号为 $1,2,\u0026hellip;,n$ ，一开始每个人都投了一票，范围 $[1,n]$ ，表示支持对应编号的人当总统。共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜，如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。全部预选结束后，公布最后成为总统的候选人，没有候选人的话输出 $-1$ 。\n链接 Luogu P3765\n题解 非常有趣的一道题。\nBZOJ的2456可以启发到这道题。\n那道题是：\n 给你一个 $n$ 个数的数列，其中某个数出现了超过 $\\frac {n}{2}$ 次即为绝对众数，请你找出那个数。\n 做法则是:\n 如果众数出现了超过 $\\frac {n}{2}$ 次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。(摘自Menci\u0026rsquo;s Blog)\n 这件事是可以用线段树维护的。\n所以可以用线段树维护这个信息，就可以在 $O(\\log {n})$ 的时间里查询到某个区间可能的区间绝对众数。可以证明，如果区间有绝对众数，那么这个数一定就是。但是也可以发现，这个数不一定就是绝对众数，所以我们需要检验。\n这个时候我们建立 $n$ 棵平衡树，共用一个 $pool$ 。我们可以直接用数组中的节点编号来代表它的 $val$ 。检验的时候，找到待查询数字的根节点，然后查询在 $[l,r]$ 区间内有多少个数，也就是 $getrank(r+1) - getrank(l)$ 。然后就可以检验出给定的数是不是给定的区间的绝对众数了。\n修改投票也很简单，线段树直接修改然后一路维护就好，平衡树的话就在旧树里删掉，新树里加上就可以了。\n时间复杂度大概是\n$$O((n+\\sum _ {i = 1}^{n} {k_i}) \\log {n})$$\n可以过掉本题。\n 妙啊！\n 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAXN = 550000; int n,m,num[MAXN]; //平衡树 namespace Treap{ int nowcnt = 0; int p[MAXN],son[MAXN][2]; int siz[MAXN]; int root[MAXN]; void update(int x){ siz[x] = siz[son[x][0]] + siz[son[x][1]] + 1; } void rotate(int \u0026amp;x,int t){ int y = son[x][t]; son[x][t] = son[y][1-t]; son[y][1-t] = x; update(x),update(y); x = y; } void insert(int \u0026amp;x,int v){ if(!x){ x = v,p[x] = rand(); } else{ int t = v \u0026gt; x; insert(son[x][t],v); if(p[son[x][t]] \u0026lt; p[x]) rotate(x,t); } update(x); } void erase(int \u0026amp;x,int v){ if(x == v){ if(!son[x][0] \u0026amp;\u0026amp; !son[x][1]){ x = 0;return; } int t = p[son[x][0]] \u0026gt; p[son[x][1]]; rotate(x,t); erase(x,v); } else{ erase(son[x][v \u0026gt; x],v); } update(x); } int grank(int r,int v){ int x = r,ans = 0; while(x){ if(v \u0026lt; x) x = son[x][0]; else if(v == x) ans += siz[son[x][0]],x = 0; else ans += siz[son[x][0]]+1,x = son[x][1]; } return ans; } void __print(int x,int dep){ if(dep == 0) printf(\u0026#34;%d:-------------------\\n\u0026#34;,x); if(x == 0) return; __print(son[x][0],dep+1); for(int i = 0;i\u0026lt;dep;i++) putchar(\u0026#39; \u0026#39;); printf(\u0026#34;v:%d p:%d siz:%d son:%d %d\\n\u0026#34;,x,p[x],siz[x],son[x][0],son[x][1]); __print(son[x][1],dep+1); if(dep == 0) printf(\u0026#34;---------------------\\n\u0026#34;); } bool check(int num,int l,int r){ return 2*(grank(root[num],r+1)-grank(root[num],l)) \u0026gt; r-l+1; } void update(int pos,int last,int now){ erase(root[last],pos); insert(root[now],pos); } void init(int *a){ p[0] = 2147483647; for(int i = 1;i\u0026lt;=n;i++) insert(root[a[i]],i); } } //线段树 namespace seg_tree{ #define lson (nown\u0026lt;\u0026lt;1) #define rson ((nown\u0026lt;\u0026lt;1)|1) #define mid ((l+r)\u0026gt;\u0026gt;1) #define pp pair\u0026lt;int,int\u0026gt; #define fr first #define sc second pp tree[MAXN\u0026lt;\u0026lt;2]; pp merge(pp a,pp b){ pp ans; if(a.fr == b.fr) ans.fr = a.fr,ans.sc = a.sc + b.sc; else{ ans.fr = a.sc \u0026gt; b.sc?a.fr:b.fr; ans.sc = a.sc - b.sc; if(ans.sc \u0026lt; 0) ans.sc *= -1; } return ans; } void update(int nown){ tree[nown] = merge(tree[lson],tree[rson]); } void build(int nown,int l,int r,int *a){ if(l == r){ tree[nown] = make_pair(a[l],1); return; } build(lson,l,mid,a); build(rson,mid+1,r,a); update(nown); } pp query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return tree[nown]; else{ pp ans; if(ql \u0026lt;= mid \u0026amp;\u0026amp; mid+1 \u0026lt;= qr) ans = merge(query(lson,l,mid,ql,qr),query(rson,mid+1,r,ql,qr)); else if(ql \u0026lt;= mid) ans = query(lson,l,mid,ql,qr); else if(mid+1 \u0026lt;= qr) ans = query(rson,mid+1,r,ql,qr); return ans; } } void update(int nown,int l,int r,int pos,int val){ if(l == r) tree[nown] = make_pair(val,1); else{ if(pos\u0026lt;=mid) update(lson,l,mid,pos,val); if(pos\u0026gt;=mid+1) update(rson,mid+1,r,pos,val); update(nown); } } } void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(num[i]); seg_tree::build(1,1,n,num); Treap::init(num); } void solve(){ int l,r,s,k,t,win; for(int i = 1;i\u0026lt;=m;i++){ read(l),read(r),read(s),read(k); win = seg_tree::query(1,1,n,l,r).first; win = Treap::check(win,l,r)? win:s; for(int i = 1;i\u0026lt;=k;i++){ read(t); Treap::update(t,num[t],win); seg_tree::update(1,1,n,t,win); num[t] = win; } print(win),print(\u0026#39;\\n\u0026#39;); } win = seg_tree::query(1,1,n,1,n).first; win = Treap::check(win,1,n)?win:-1; print(win),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":208,"section":"posts","tags":["数据结构","平衡树","线段树"],"title":"「Luogu3765」总统选举-平衡树-线段树","uri":"https://blog.chenqiqian.com/posts/luogu-3765/"},{"content":"有一个 $n$ 行 $m$ 列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第 $i$ 行第 $j$ 列的格子只能参与 $m _ {i,j}$ 次交换。\n输出仅一行，为最小交换总次数。如果无解，输出 $-1$ 。\n链接 Luogu P3159\n题解 比较难以实现的是对交换次数的限制。注意到如果一个点是起点或者终点，那么它的交换次数应当是奇数，其余的都是偶数，而且是经过这个点的棋子数目的两倍。所以我们可以按照如下方法建图：\n对于棋盘上的每个点，我们把它拆成三个点：$A _ {i,j},B _ {i,j},C _ {i,j}$ 。\n对于一个既是起点也是终点的点或者既不是起点也不是终点的点，我们从 $A _ {i,j}$ 向 $C _ {i,j}$ 和 $C _ {i,j}$ 向 $B _ {i,j}$ 连一条容量是 $\\lfloor \\frac {m _ {i,j}}{2} \\rfloor$ ，费用为 $0$ 的边。\n对于一个只是起点的点，我们从起点 $S$ 向 $C _ {i,j}$ 连一条容量为 $1$ ，费用为 $0$ 的边。从 $A _ {i,j}$ 向 $C _ {i,j}$ 连一条容量是 $\\lfloor \\frac {m _ {i,j} , -1}{2} \\rfloor$ ，费用为 $0$ 的边。从 $C _ {i,j}$ 向 $B _ {i,j}$ 连一条容量是 $\\lfloor \\frac {m _ {i,j} , -1}{2} +1 \\rfloor$ ，费用为 $0$ 的边。\n对于一个只是终点的点，我们反过来就可以了。\n还需要从 $C _ {i,j}$ 向 $B _ {i,j-1},B _ {i-1,j+1}\u0026hellip;$ ，也就是周围的八个点连一条容量是 $+\\infty$ ,费用是 $1$ 的边。\n显然这样可以保证个点的交换次数不超过 $m _ {i,j}$ 。然后我们求出起点 $S$ 到终点 $T$ 最小费用最大流，如果满流有解，不满流就无解。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; const int MAXN = 5000,MAXM = 500000; struct Edge{ int from,to; int cap,flow; int cost,nex; }edge[MAXM]; int n,m,s,t; int fir[MAXN],ecnt = 2,maxf = 0; int dis[MAXN],instack[MAXN],pree[MAXN]; int b[25][25],e[25][25],num[25][25]; queue\u0026lt;int\u0026gt; q; int tr(int a,int b){ if(a == 0 || b == 0 || a\u0026gt;n||b\u0026gt;m) return -1; return (a-1)*m+b; } void addedge(int a,int b,int c,int d){ if(a \u0026lt;= 0 || b \u0026lt;= 0 || c == 0) return; edge[ecnt] = (Edge){a,b,c,0,d,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,0,0,-d,fir[b]}; fir[b] = ecnt++; } bool spfa(){ memset(dis,0x3f,sizeof(dis)); memset(instack,0,sizeof(instack)); while(!q.empty()) q.pop(); dis[s] = 0;q.push(s); while(!q.empty()){ int nown = q.front();q.pop(); instack[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ Edge e = edge[nowe]; if(dis[e.to] \u0026gt; dis[nown] + e.cost \u0026amp;\u0026amp; e.cap \u0026gt; e.flow){ dis[e.to] = dis[nown] + e.cost; pree[e.to] = nowe; if(instack[e.to] == 0){ q.push(e.to); instack[e.to] = 1; } } } } return dis[t] \u0026lt; 0x3f3f3f3f; } void argument(int \u0026amp;sumf,int \u0026amp;sumc){ int nown = t,limit = 0x3f3f3f3f,nowe; while(nown!=s){ nowe = pree[nown]; limit = min(limit,edge[nowe].cap - edge[nowe].flow); nown = edge[nowe].from; } nown = t; while(nown!=s){ nowe = pree[nown]; edge[nowe].flow += limit,edge[nowe^1].flow -= limit; nown = edge[nowe].from; } sumf += limit,sumc += limit * dis[t]; } void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m);s = 1,t = 2; char tmp[50]; for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,tmp); for(int j = 1;j\u0026lt;=m;j++) b[i][j] = tmp[j-1]^48; } for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,tmp); for(int j = 1;j\u0026lt;=m;j++) e[i][j] = tmp[j-1]^48; } for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,tmp); for(int j = 1;j\u0026lt;=m;j++) num[i][j] = tmp[j-1]^48; } } void build(){ int bb = 0,ee = 0; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=m;j++){ int tmp = tr(i,j); if(b[i][j] \u0026amp;\u0026amp; !e[i][j]){ num[i][j]-=1; addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0); addedge(3*tmp+3,3*tmp+2,num[i][j]/2+1,0); addedge(s,3*tmp+3,1,0); maxf = max(maxf,++bb); } else if(e[i][j] \u0026amp;\u0026amp; !b[i][j]){ num[i][j]-=1; addedge(3*tmp+1,3*tmp+3,num[i][j]/2+1,0); addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0); addedge(3*tmp+3,t,1,0); maxf = max(maxf,++ee); } else{ addedge(3*tmp+1,3*tmp+3,num[i][j]/2,0); addedge(3*tmp+3,3*tmp+2,num[i][j]/2,0); } addedge(3*tmp+2,3*tr(i-1,j-1)+1,100000,1); addedge(3*tmp+2,3*tr(i+1,j+1)+1,100000,1); addedge(3*tmp+2,3*tr(i+1,j-1)+1,100000,1); addedge(3*tmp+2,3*tr(i-1,j+1)+1,100000,1); addedge(3*tmp+2,3*tr(i,j-1)+1,100000,1); addedge(3*tmp+2,3*tr(i,j+1)+1,100000,1); addedge(3*tmp+2,3*tr(i+1,j)+1,100000,1); addedge(3*tmp+2,3*tr(i-1,j)+1,100000,1); } } } void solve(){ int f = 0,c = 0; while(spfa()) argument(f,c); if(f!=maxf) printf(\u0026#34;-1\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,c); } int main(){ init(); build(); solve(); return 0; }   ","description":"","id":209,"section":"posts","tags":["图论","费用流"],"title":"「CQOI2012」交换棋子-费用流","uri":"https://blog.chenqiqian.com/posts/cqoi2012-chess/"},{"content":"有一颗 $n$（$n\u0026lt;20000$）个节点的树，每条边都有边权。接下来由聪聪和可可分别随即选一个点，如果两点之间简单路径上的边权和是 $3$ 的倍数，则判聪聪赢，否则可可赢。\n聪聪非常爱思考问题，希望知道对于这张图自己的获胜概率是多少。\n链接 Luogu P2634\n题解 点分治比较模版的一道题吧。\n树上的路径问题，也可以提示我们点分治。\n所以问题转化为：怎么在 $O(n)$ 或者 $O(n \\log{n})$ 的时间内求出过一个点的所有，起点终点不在同一子树中，边权和为$3$的倍数的路径个数。\n事实上，我们发现，这个问题不难解决。如果只有经过一个点这个条件，那么就很简单： dfs 一遍求出这个点到所有点的距离除 $3$ 余数，然后 $num[0] \\times num[0] + num[1] \\times num[2] + num[2] \\times num[1]$ 即为所求。\n比较难搞的是第二个条件，也就是我们要求这个路径的起点和终点不在一个子树内。我们可以考虑采用容斥原理。即对每一颗子树分别 dfs 求出 $3$ 个 $num'$ ，然后减去这个子树内过上面根节点的路径个数。这个个数我们上面好像已经求过了，事实上就是 $num'[0] \\times num'[0] + num'[1] \\times num'[2] + num'[2] \\times num'[1]$ 。\n所以我们就可以 $O(n)$ 的时间处理完这件事情了。再加上点分治，我们最终的复杂度就是 $O(n \\log {n})$ 。\n有一些比较容易错的地方，比如要注意开始的时候 $num[0]$ 要置做 $1$ ，而 $num'[0]$就不用。这是比较显然的，然而我还是错了好久\u0026hellip;还有就是在加边的时候可以对 $3$ 取模\u0026hellip;后面也要不断对 $3$ 取模\u0026hellip;要不然会炸。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; ll gcd(ll a,ll b){// a \u0026lt; b;  return a == 0?b:gcd(b%a,a); } const int MAXN = 110000; struct Edge{ int from,to; int len,nex; }edge[MAXN];int ecnt = 2; int fir[MAXN]; void addedge(int a,int b,int l){ edge[ecnt] = (Edge){a,b,l,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,l,fir[b]}; fir[b] = ecnt++; } //----  int n,m; int f[MAXN],siz[MAXN],vis[MAXN]; int rt,sz; int num[3],tmp[3]; ll ans = 0; void getroot(int nown,int fa){ siz[nown] = 1,f[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v] || v == fa) continue; getroot(v,nown); siz[nown] += siz[v]; f[nown] = max(f[nown],siz[v]); } f[nown] = max(f[nown],sz - siz[nown]); if(f[nown] \u0026lt; f[rt]) rt = nown; } void getdeep(int nown,int fa,int d){ num[d]++; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(vis[v] || v == fa) continue; getdeep(v,nown,(d+l)%3); } } void work(int nown){ tmp[0] = 1;tmp[1] = tmp[2] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(vis[v]) continue; num[0] = num[1] = num[2] = 0; getdeep(v,nown,l); ans -= num[0]*num[0] + 2*num[1]*num[2]; tmp[0] += num[0],tmp[1]+=num[1],tmp[2]+=num[2]; } ans += tmp[0] * tmp[0] + 2*tmp[1] * tmp[2]; } void solve(int nown){ vis[nown] = 1; work(nown); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v]) continue; f[rt = 0] = sz = siz[v]; getroot(v,rt); solve(rt); } } void init(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int a,b,c; for(int i = 1;i\u0026lt;=n-1;i++){ scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(a,b,c%3); } } void solve(){ f[rt = 0] = sz = n; getroot(1,rt); solve(rt); ll ans2 = n*n; printf(\u0026#34;%lld/%lld\\n\u0026#34;,ans/gcd(ans,ans2),ans2/gcd(ans,ans2)); } int main(){ init(); solve(); return 0; }   ","description":"","id":210,"section":"posts","tags":["点分治","数据结构","树形结构"],"title":"「国家集训队」聪聪可可-点分治","uri":"https://blog.chenqiqian.com/posts/luogu-2634/"},{"content":"点分治是一种主要在树上的分治，可以在解决一些树上特定条件的路径的问题。其复杂度与大部分分治类似，大概是 $O(K ; \\log{n})$（ $K$ 为除分治步骤之外的时间复杂度的多项式）。\n简介 点分治感性的来说，其实就需要考虑一件事情：如何把树上路径问题转换成过根结点的路径问题。\n定理:树上所有的路径可以分为过根结点的路径和不过根结点的路径。\n对于根结点来说，我们处理完过根结点的路径，剩下所有的路径都不会过根结点了。所以我们可以把根节点和与根结点相连的边均删掉，然后对于新产生的子树，剩下的路径应该都在其中，就可以对子树进行分治处理。\n实现 主要是三个函数：solve，work，getroot。\nsolve solve函数，也就是主要函数，是一个递归解决问题的过程。\n每一次都先把这个点标记成已经访问过，然后对于这个点去寻找\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11  void solve(int nown){ work(nown); vis[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v]) continue; f[rt = 0] = sz = siz[v];//初始化rt  getroot(v,rt);//找到该子树的重心  solve(rt);//递归解决问题  } }   work work函数就是完成对于当前的子树中所有过根的节点的处理。这个函数没有具体的样子，因题而异。\n照我目前的理解，主要的思路就是：dfs，想办法拼起来两条同时过根节点而且端点不在一个子树里面的节点。\ngetroot 首先，为了保证我们分出去的子树的规模尽量的一致，我们每次都需要把当前的树的重心作为根节点，然后完成上段所述的事情。\n在这里，寻找重心其实就是找哪个点作根的时候剩下的最大子树的大小最小\u0026hellip;代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //vis==1 代表已经处理过（不在当前子树中） //f[nown] 储存这个点作根时剩下的最大子树的大小 void getroot(int nown,int fa){ siz[nown] = 1,f[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v] || v == fa) continue; getroot(v,nown); siz[nown] += siz[v]; f[nown] = max(f[nown],siz[v]); } f[nown] = max(f[nown],sz - siz[nown]); if(f[nown] \u0026lt; f[rt]) rt = nown; }   不是很难。\n代码 以Luogu P3806 为例。\n（其实这个题\u0026hellip;比模版还是要多一些的\u0026hellip;复杂度是 $O(n \\log{n} \\log{n})$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; const int MAXN = 110000; namespace fast_io { //... }using namespace fast_io; struct Edge{ int from,to; int len,nex; }edge[MAXN]; int ecnt = 1;int fir[MAXN]; void addedge(int a,int b,int l){ edge[ecnt] = (Edge){a,b,l,fir[a]}; fir[a] = ecnt++; edge[ecnt] = (Edge){b,a,l,fir[b]}; fir[b] = ecnt++; } //----- int n,m,q[MAXN],ans[MAXN]; //----- int f[MAXN],vis[MAXN],siz[MAXN]; int rt,sz; struct node{ int d,f; bool operator \u0026lt; (node a)const{ return d \u0026lt; a.d; } }dep[MAXN]; int num; int search(int d){ int b = 1,e = num; while(e!=b){ int mid = (b+e)\u0026gt;\u0026gt;1; if(dep[mid].d \u0026gt;= d) e = mid; else b = mid + 1; } return b; } //----- void getroot(int nown,int fa){ siz[nown] = 1,f[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v] || v == fa) continue; getroot(v,nown); siz[nown] += siz[v]; f[nown] = max(f[nown],siz[v]); } f[nown] = max(f[nown],sz - siz[nown]); if(f[nown] \u0026lt; f[rt]) rt = nown; } void dfs(int nown,int fa,int wh,int d){ dep[++num] = (node){d,wh}; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(vis[v] || v == fa) continue; dfs(v,nown,wh,d+l); } } void work(int nown){ num = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to,l = edge[nowe].len; if(vis[v]) continue; dfs(v,nown,v,l); } dep[++num] = (node){0,0}; sort(dep+1,dep+num+1); //二分查找 并判断对于每个ans是否有符合的答案  for(int i = 1;i\u0026lt;=m;i++){ if(ans[i]) continue; int l = 1; while(l \u0026lt; num \u0026amp;\u0026amp; dep[l].d + dep[num].d \u0026lt; q[i]) l++; while(l \u0026lt; num \u0026amp;\u0026amp; 2*dep[l].d \u0026lt; q[i]){ if(ans[i]) break; int t = q[i]-dep[l].d,r = search(t); while(r \u0026lt;= num \u0026amp;\u0026amp; dep[r].d == t \u0026amp;\u0026amp; dep[l].f == dep[r].f) r++; ans[i] |= (dep[r].d == t); l++; } } } void solve(int nown){ vis[nown] = 1; work(nown); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(vis[v]) continue; f[rt = 0] = sz = siz[v]; getroot(v,rt); solve(rt); } } void init(){ read(n),read(m); int a,b,c; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b),read(c); addedge(a,b,c); } for(int i = 1;i\u0026lt;=m;i++) read(q[i]); } void solve(){ f[rt = 0] = sz = n; getroot(1,rt); solve(rt); for(int i = 1;i\u0026lt;=m;i++){ if(ans[i]) print(\u0026#39;A\u0026#39;),print(\u0026#39;Y\u0026#39;),print(\u0026#39;E\u0026#39;); else print(\u0026#39;N\u0026#39;),print(\u0026#39;A\u0026#39;),print(\u0026#39;Y\u0026#39;); print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   例题 「NOI2005」维护数列-非旋Treap\n[Luogu P2664]树上游戏\n","description":"","id":211,"section":"posts","tags":["笔记","点分治","树形结构","模板"],"title":"点分治学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-point-dc/"},{"content":"爆零滚粗。\n集训 在考试之前先有两个周末的集训。\n第一个周末是让我印象最为深刻的。开始没仔细看说明，结果一不小心就跑到了北师大附属实验。急忙打车，跑回到首师大附中，还好没有迟到。\n第一天上午的题非常有趣。T1比较简单，也成为了我四次考试以来唯一A掉的一道题。T2 sumsum好像是奇怪的点分治，还没有学过，所以自然也就不会做，甚至最后连暴力都懒得打。不过好像十分弱智的暴力也能过到60分？？也没有想到。T3是提答题，第一次做到，非常有趣。这个提答还是比较友善的，手玩竟然能有四十多分，可以说是很友善了。第一天就这么过去了，排了一个三四十名的名次。\n第二天就比较难了，竟然是三道数学题\u0026hellip;于是我一道都不会做\u0026hellip;做是不会做的，还把网给断了，于是就很绝望的去瞎搞。T1好像是个找规律+构造，T2不记得了\u0026hellip;T3正解貌似也是构造\u0026hellip;然而我在大佬的指点下写了个随机化，竟然搞到了三十多分，令人惊讶。\n两天的集训就这么结束了。也没有听懂什么，周末好几次险些写不完作业\u0026hellip;\nDay1 Day1不太想说什么。\nT1好像是个线段树，不过正解是三个set，不知道为什么写的暴力稀里糊涂的就爆0了。\nT2是一道找规律的题目。然而蒟蒻如我像这种东西肯定是分析不出来的\u0026hellip;随便推了个规律\u0026hellip;然而发现一大堆反例，令人发指\u0026hellip;\nT3貌似最简单。就是一个简单的LCA+前缀和查询，然而\u0026hellip;没想到竟然挂在了取模上\u0026hellip;这也一方面体现出了我的对拍人眼执行diff命令的不可靠，一方面也涨了知识：取模意义下的前缀和一定要加足够的$p$！！！要不然就WA*n了\u0026hellip;出题人瞎随机的数据出了点锅，暴力$O(n^2)$的算法居然在平衡的树上跑到了$O(n \\log{n})$，然后\u0026hellip;就过了？？？啊啊啊我要学.bat对拍！！！\n第一天期望得分140，实际得分10。\nDay2 正式考试的第二天。第一天就只有10分，所以考试之前有点慌，昨天讲的有上下界的网络流还不怎么会，而去年一道网络流都没有考过，考试前匆匆茫茫的看了看，希望能用到。\n然而，然而喜出望外的是，我最近一个多月学的东西，全部都没有考到。反而是考了一些奇奇怪怪的东西。\nT1是个提交答案题，琢磨一番样例之后发现自己连样例都推不出来，瞎玩了10分就看第二题。\nT2跟集训第一周的题很像，好像是徐明宽巨佬在考场上想出了某种特殊情况的解法\u0026hellip;然后就出成了题。貌似40分的$O(n^2)$暴力很好想，然而我只写了个$O(n^3)$的二十分暴力。最后还被出题人坑了一分都没有\u0026hellip;伤心\u0026hellip;\nT3看了一眼\u0026hellip;概率是啥？？？咋对分数取模来着\u0026hellip;期望怎么算啊\u0026hellip;不会啊\u0026hellip;于是放弃。\n于是就陷入了颓废的状态。感觉中间三个小时过的特别的快，前后一个小时就非常的漫长\u0026hellip;漫长到心态爆炸。\n第二天期望得分30，最后得分8分。\n讲完题等成绩的时候，出现了省队巨佬连连玩扫雷，大家纷纷围观，以及巨佬玩我不知道名字的Windows游戏的壮观景象。\n最后我校有了四个省队，所有去的高二 + dmy全都进了省队。\nDay2 dmy竟然AK了！第二名140分！总评dmy比第二名高了80分！害怕\u0026hellip;\n最后 今年初三有三个省队，高一三个省队，剩下的全都是高二。\n任务十分的艰巨啊。如果想要进到省队，不仅要打败高一，还要打败更为恐怖的初三。有的时候也在追问，我真的有天赋吗？真的能付得起这样的时间、精力的支出吗？如果今年的联赛和明年的省选季要停课的话，能接受失败的打击吗？\n如果其中任何一个的答案是否，我想这门竞赛或许也就没有必要去继续了吧。\n所幸，现在，我还认为这三个答案全都是True。\n如果明年的NOIP在发挥正常的情况下没有拿到450+，我想我就应该退役了。也不必再去耗它更多的半年，徒费时间，徒费神思。\n这次的考试也折射出一定的问题。虽然我比较长于代码实现，但是在思维上明显还是和巨佬有一定的差距。巨佬在现场没准可以现推结论，而我记住结论的情况下还是连暴力都没有敲出最优复杂度，令人窒息。而且思维上也很怠惰，明明10分就是2.5个积点却不想去写\u0026hellip;下次千万不能有这样的情况\u0026hellip;而且就是有的时候暴力代码写起来甚至都需要半个小时，还是有点长了。\n不管如何，这剩下的200天也要努力吧，不能让一年的努力白费啊。近一段时间打算学一下点分治、动态树、后缀数组、AC自动机啥的算法，以及刷一刷网络流二十四题和一些更多的数据结构题吧。远期目标还有就是一些基本的数学\u0026hellip;比如高斯消元，FFT，矩阵，期望啥的。\n明年再战。希望明年的明天或者后天，我能够要么坦然的面对，要么昂起头，继续前进。\n","description":"","id":212,"section":"posts","tags":null,"title":"BJOI2018游记","uri":"https://blog.chenqiqian.com/posts/trip-bjoi2018/"},{"content":"你决定设计你自己的软件包管理器。如果软件包 A 依赖软件包 B ，那么安装软件包 A 以前，必须先安装软件包 B 。同时，如果想要卸载软件包 B ，则必须卸载软件包 A 。现在你已经获得了所有的软件包之间的依赖关系。除 $0$ 号软件包以外，所有软件包都会依赖一个且仅一个软件包，而 $0$ 号软件包不依赖任何一个软件包。依赖关系不存在环。\n现在有一些安装或卸载软件包的操作，需要求出这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包）。\n链接 Luogu P2146\n题解 可以说应该还是一道比较裸的树链剖分了。\n先树链剖分，然后根据编号构建一颗线段树。线段树每个节点维护当前区间已经安装的软件包的个数。需要一个 lazy 标记，为 $1$ 意味着这个区间被全部卸载，为 $2$ 意味着这个区间被全部安装。\n对于 install 操作，明显可以看出我们的需求包是从 $0$ 号节点到 $x$ 号节点的链上的所有节点，所以我们先求出在这条路径上的安装的软件包的个数，然后再求出这个路径的节点个数，并对整个路径进行修改，最后相减得到答案。\n对于 uninstall 操作，很明显可以看出只要把以 $x$ 为根节点的子树的节点全都给卸载就可以了。\n所有我们求出在这个子树中的安装个数（注意到一颗子树的 $id$ 应当是连续的），这个就是查询的答案，然后我们将这个子树给卸载掉就可以了。\n复杂度大约是 $O(n ; log^2{n})$ 或者稍小一些吧。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; namespace fast_io { ... }using namespace fast_io; struct seg_tree{ #define lson (nown\u0026lt;\u0026lt;1)  #define rson ((nown\u0026lt;\u0026lt;1)|1)  #define mid ((l+r)\u0026gt;\u0026gt;1)  static const int MAXN = 110000; int sumn[MAXN\u0026lt;\u0026lt;2],lazy[MAXN\u0026lt;\u0026lt;2]; seg_tree(){ memset(sumn,0,sizeof(sumn)); memset(lazy,0,sizeof(lazy)); } //添加标记  inline void add_tag(int nown,int l,int r,int t){ if(t == 1) sumn[nown] = 0,lazy[nown] = 1; if(t == 2) sumn[nown] = r-l+1,lazy[nown] = 2; } //下传区间标记  inline void push_down(int nown,int l,int r){ if(l == r) return; if(lazy[nown]){ add_tag(lson,l,mid,lazy[nown]); add_tag(rson,mid+1,r,lazy[nown]); lazy[nown] = 0; } } //维护区间和  inline void maintain(int nown){ sumn[nown] = sumn[lson] + sumn[rson]; } //区间更新为安装（tag == 2）或未安装（tag == 2）  inline void update(int nown,int l,int r,int ql,int qr,int tag){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r\u0026lt;=qr) add_tag(nown,l,r,tag); else{ push_down(nown,l,r); if(ql \u0026lt;= mid) update(lson,l,mid,ql,qr,tag); if(qr \u0026gt;= mid+1) update(rson,mid+1,r,ql,qr,tag); maintain(nown); } } //区间查询安装的个数  inline int query(int nown,int l,int r,int ql,int qr){ if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return sumn[nown]; else{ push_down(nown,l,r); int ans = 0; if(ql\u0026lt;=mid) ans+=query(lson,l,mid,ql,qr); if(qr \u0026gt;= mid+1) ans+=query(rson,mid+1,r,ql,qr); return ans; } } }tree; //线段树  const int MAXN = 110000; int n,m; int cnt = 0; int dep[MAXN],id[MAXN],son[MAXN],fa[MAXN],top[MAXN],siz[MAXN]; vector\u0026lt;int\u0026gt; edge[MAXN]; //树链剖分 void dfs1(int nown,int f,int depth){ siz[nown] = 1,fa[nown] = f; dep[nown] = depth; int maxsum = -1; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == fa[nown]) continue; dfs1(to,nown,depth+1); siz[nown]+=siz[to]; if(siz[to] \u0026gt; maxsum) son[nown] = to,maxsum = siz[to]; } } void dfs2(int nown,int topf){ id[nown] = ++cnt,top[nown] = topf; if(!son[nown]) return; dfs2(son[nown],topf); for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == fa[nown] || to == son[nown]) continue; dfs2(to,to); } } //查询x到y的路径上的安装的个数 inline int query(int x,int y){ int ans = 0; while(top[x]!=top[y]){ if(dep[top[x]] \u0026lt; dep[top[y]]) swap(x,y); ans+=tree.query(1,1,n,id[top[x]],id[x]); x = fa[top[x]]; } if(dep[x] \u0026gt; dep[y]) swap(x,y); ans+=tree.query(1,1,n,id[x],id[y]); return ans; } //将x到y路径上的点标记为安装或者卸载 inline int update(int x,int y,int t){ int ans = 0; while(top[x]!=top[y]){ if(dep[top[x]] \u0026lt; dep[top[y]]) swap(x,y); ans+=id[x]-id[top[x]]+1; tree.update(1,1,n,id[top[x]],id[x],t); x = fa[top[x]]; } if(dep[x] \u0026gt; dep[y]) swap(x,y); ans+=id[y]-id[x]+1;tree.update(1,1,n,id[x],id[y],t); return ans; } //安装 inline int install(int x){ int b = query(1,x); int e = update(1,x,2); return e-b; } //卸载 inline int uninstall(int x){ int b = tree.query(1,1,n,id[x],id[x]+siz[x]-1); tree.update(1,1,n,id[x],id[x]+siz[x]-1,1); return b; } inline void init(){ read(n); int tmp; for(int i = 2;i\u0026lt;=n;i++){ read(tmp); edge[i].push_back(tmp+1); edge[tmp+1].push_back(i); } dfs1(1,0,1); dfs2(1,1); } inline void solve(){ read(m); char op[20];int x; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(x); if(op[0] == \u0026#39;u\u0026#39;) print(uninstall(x+1)),print(\u0026#39;\\n\u0026#39;); else if(op[0] == \u0026#39;i\u0026#39;) print(install(x+1)),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":213,"section":"posts","tags":["数据结构","树链剖分","线段树"],"title":"「NOI2015」软件包管理器-树链剖分","uri":"https://blog.chenqiqian.com/posts/noi2015-manager/"},{"content":"你的公司需要提供 $n$ 类产品，其中第 $i$ 类产品共需要 $C _ {i}$ 件。公司共有 $m$ 名员工。员工能够制造的产品种类有所区别，我们用一个由 $0$ 和 $1$ 组成的 $m\\times n$ 的矩阵 $\\mathbb {A}$ 来描述每名员工能够制造哪些产品。\n对于员工 $i$ ，给出 $S_i$ 。定义他的愤怒值与他制作的产品数量之间的函数是一个 $S_i+1$ 段的分段函数。设 $T _ {i,0}=0$,$T _ {i,S _ {i+1}}=+\\infty$ ，那么当他制造第 $[T _ {i,j-1}+1,T _ {i,j}]$ 件产品时，每件产品会使他的愤怒值增加 $W _ {i,j}$ ， $1\\leq j\\leq S _ {i+1}$ 。保证 $0\u0026lt;W _ {i,j} \u0026lt; W _ {i,j+1}, ; 0 \u0026lt; T _ {i,j} \u0026lt; T _ {i,j+1}$ 。\n你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。\n链接 Luogu P2488\nBZOJ 2245\n题解 一道费用流的题目。\n每个产品的数量可以用一条边来限制，主要需要满足的就是愤怒值分段函数式的结构。\n注意到每个人的愤怒值的分段函数与做了具体哪类产品无关，所以我们可以在人这边的边上动点手脚。我们可以拆边，按段来拆边，每段给一条边，通过容量来满足分段的要求。\n具体建图：\n令 $1$ 至 $m$ 为 $m$ 个员工所代表的点， $m+1$ 至 $m+n$ 为 $n$ 类产品代表的点， $s$ 为源点， $t$ 为汇点。\n对于 $A$ 矩阵，如果 $A _ {i,j}$ 是 $1$ ，那么我们就连一条起点为 $i$ ，终点为 $m+j$ ，容量为 $+\\infty$ ，费用为 $0$ 的边。\n对于第 $i$ 个商品种类，我们连一条起点为 $m+i$ ，终点为 $t$ ，容量为 $C _ {i}$ ，费用为 $0$ 的边。\n对于第 $i$ 个人，我们连 $S _ {i}+1$ 条边，起点均为 $s$ ，终点均为 $i$ ，令第 $j$ 条边的容量为 $S _ {i,j}-S _ {i,j-1}, j \\in [1,S _ {i}+1]$ ，费用为 $W _ {i,j}$ 。\n跑最小费用最大流，得到的费用即为结果。\n注意需要开 long long\u0026hellip;\n值得一提的是，由于我有一个 $j$ 写成了 $i$ ，导致我绝望的找了15分钟的bug\u0026hellip;令人窒息。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#define ll long long using namespace std; namespace fast_io { //... }using namespace fast_io; const int MAX = 1e9; const int MAXN = 1000,MAXM = 200000; struct Edge{ int from,to; int flow,cap; int cost; int nex; }edge[MAXM]; int n,m,s,t,ecnt = 2; int fir[MAXN],pree[MAXN]; ll dis[MAXN];int instack[MAXN]; queue\u0026lt;int\u0026gt; q; void addedge(int a,int b,int c,int d){ //printf(\u0026#34;%lld %lld %lld %lld\\n\u0026#34;,a,b,c,d);  edge[ecnt].from = a,edge[ecnt].to = b; edge[ecnt].cap = c,edge[ecnt].flow = 0; edge[ecnt].cost = d,edge[ecnt].nex = fir[a]; fir[a] = ecnt++; edge[ecnt].from = b,edge[ecnt].to = a; edge[ecnt].cap = 0,edge[ecnt].flow = 0; edge[ecnt].cost = -d,edge[ecnt].nex = fir[b]; fir[b] = ecnt++; } bool spfa(){ while(!q.empty()) q.pop(); memset(dis,0x3f,sizeof(dis)); dis[s] = 0;q.push(s); while(!q.empty()){ int nown = q.front();q.pop(); instack[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ Edge e = edge[nowe]; if(dis[e.to] \u0026gt; dis[nown] + e.cost \u0026amp;\u0026amp; e.cap \u0026gt; e.flow){ dis[e.to] = dis[nown] + e.cost; pree[e.to] = nowe; if(instack[e.to] == 0){ instack[e.to] = 1; q.push(e.to); } } } } return dis[t] \u0026lt; 0x3f3f3f3f3f3f3f3f; } void argument(ll \u0026amp;sumf,ll \u0026amp;sumc){ int nown = t,nowe,delta = MAX; while(nown!=s){ nowe = pree[nown]; delta = min(delta,edge[nowe].cap - edge[nowe].flow); nown = edge[nowe].from; } nown = t; while(nown!=s){ nowe = pree[nown]; edge[nowe].flow+=delta,edge[nowe^1].flow-=delta; nown = edge[nowe].from; } sumf+=delta,sumc+=delta*dis[t]; } void min_cost_flow(){ ll f = 0,c = 0; while(spfa()) argument(f,c); printf(\u0026#34;%lld\\n\u0026#34;,c); } void init(){ read(m),read(n); s = m+n+1,t = m+n+2; int tmp = 0; for(int i = 1;i\u0026lt;=n;i++){ read(tmp); addedge(m+i,t,tmp,0); } for(int i = 1;i\u0026lt;=m;i++){ for(int j = 1;j\u0026lt;=n;j++){ read(tmp); if(tmp) addedge(i,m+j,MAX,0); } } int b[10]; for(int i = 1;i\u0026lt;=m;i++){ read(tmp); for(int j = 1;j\u0026lt;=tmp;j++) read(b[j]); b[0] = 0;b[tmp+1] = MAX; for(int j = 1;j\u0026lt;=tmp+1;j++){ int w;read(w); addedge(s,i,b[j]-b[j-1],w); } } } int main(){ init(); min_cost_flow(); return 0; }   ","description":"","id":214,"section":"posts","tags":["图论","费用流"],"title":"「SDOI2011」工作安排-费用流","uri":"https://blog.chenqiqian.com/posts/sdoi2011-arrange/"},{"content":"Aho–Corasick算法，常叫做AC自动机。是一种字符串多模式串匹配算法。能在线性时间内完成多个模式串对一个查询串的匹配。\n 能自动AC哦。\n To be finished.\n思想 树型结构 建树 查询 其他 实现 基本 一些改进 代码 例题","description":"","id":215,"section":"posts","tags":["字符串","AC自动机","模板"],"title":"AC自动机学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-ac_automaton/"},{"content":"给定一个字符串 $S$ ，求出 $num$ 数组——对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $num[i]$ 。\n特别地，为了避免大量的输出，你不需要输出 $num[i]$ 分别是多少，你只需要输出所有 $(num[i]+1)$ 的乘积，对 $10^9+7$ 取模的结果即可。\n链接 Luogu P2375\n题解 终于开始怼字符串的题了。\n这一道题让我们求 $num$ 的个数，其实联系一下AC自动机，很容易就想到沿着 nex 数组往回跳。跳的次数就是相同前后缀的个数，这个可以在求 nex 的时候直接预处理出来，记为 $cnt$ 数组。\n但题目中有一个限制比较烦人：\n 该后缀与该前缀不重叠\n 一个简单的想法就是求出 nex 数组，对于每一个 $i$ ，先将 nex 降到 $\\frac{i}{2}$ 以下，然后看这个 nex 还能跳多少次。但是很遗憾，这个TLE了，只有 $50$ 分。因为每一次都跳 nex 代价太高，gg。\n一个简单的改进就可以过掉这道题。\n我们只需要像跳普通的 nex 一样去跳这个地方的 nex ，只需要每次确保其在 $\\frac{i}{2}$ 以下就可以。然后就可以找到 nex ，从而得到 $num$ 。\n说长度在 $\\frac{i}{2}$ 以下其实不太严谨，具体看代码吧。\n代码  AC代码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#define ll long long using namespace std; const int MAXN = 1110000; int n,p = 1000000007; int nex[MAXN],cnt[MAXN]; char s[MAXN]; void cal(){ memset(nex,0,sizeof(nex)); memset(cnt,0,sizeof(cnt)); nex[0] = 0; int len = strlen(s); int j = 0; for(int i = 1;i\u0026lt;len;i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i]!=s[j]) j = nex[j-1]; if(s[i] == s[j]) ++j; nex[i] = j; cnt[i] = cnt[nex[i-1]]+1; } ll ans = 1; j = 0; for(int i = 1;i\u0026lt;len;i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i]!=s[j]) j = nex[j-1]; if(s[i] == s[j]) ++j; while(j\u0026gt;0 \u0026amp;\u0026amp; 2*j \u0026gt; i+1) j = nex[j-1]; ans *= (cnt[j]+1),ans%=p; } printf(\u0026#34;%lld\\n\u0026#34;,ans); } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s); cal(); } } int main(){ solve(); return 0; }    另附50分代码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#define ll long long using namespace std; const int MAXN = 1110000; int n,p = 1000000007; int nex[MAXN],cnt[MAXN]; char s[MAXN]; void cal(){ memset(nex,0,sizeof(nex)); memset(cnt,0,sizeof(cnt)); nex[0] = 0; int j = 0,len = strlen(s); ll ans = 1; for(int i = 1;i\u0026lt;len;i++){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i]!=s[j]) j = nex[j-1]; if(s[i] == s[j]) ++j; nex[i] = j; cnt[i] = cnt[nex[i-1]]+1; } for(int i = 1;i\u0026lt;len;i++){ j = nex[i]; while(j\u0026gt;0 \u0026amp;\u0026amp; 2*j \u0026gt; i+1) j = nex[j-1]; ans *= (cnt[j]+1),ans%=p; } printf(\u0026#34;%lld\\n\u0026#34;,ans); } void solve(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%s\u0026#34;,s); cal(); } } int main(){ solve(); return 0; }   ","description":"","id":216,"section":"posts","tags":["字符串","KMP"],"title":"「NOI2014」动物园-KMP","uri":"https://blog.chenqiqian.com/posts/noi2014-zoo/"},{"content":"给定一张有向图，每条边都有一个容量 $C$ 和一个扩容费用 $W$ 。这里扩容费用是指将容量扩大 $1$ 所需的费用。\n现在请你编写一个程序求出：\n 在不扩容的情况下， $1$ 到 $N$ 的最大流； 将 $1$ 到 $N$ 的最大流增加 $K$ 所需的最小扩容费用。  链接 Luogu P2604\nBZOJ 1834\n题解 一道最大流和费用流的题。\n第一问不说了。第二问事实上我们注意到我们可以把每条边想像成， $C$ 的免费流量和费用为 $W$ 的流量。因为答案问我们在最大流为 $ans+k$ 的时候，最小费用是多少，所以我们需要引入一条边来控制流量，再跑得到的费用流就是最小费用了。\n怎么来达成边的约束呢？事实上拆边为两条就好，一条免费边，一条收费边。\n具体建图方法如下。\n先按照费用流的样子建图，所有边的费用为 $0$ ，源点为 $1$ ，终点为 $n$ ，然后跑Dinic得到 $ans1$ 。\n关于 $ans2$ ，稍微复杂一些。\n保留原图。对于图中的每条边，再建一条容量为 $ans1+k$ ，费用为 $w_i$ 的边。由 $n$ 号节点向 $n+1$ 号节点建一条容量为 $ans1+K$ ，费用为 $0$ 的边，并把汇点设置为 $n+1$ ，注意把流量初始需要设置成 $ans1$ 。直接在残量网络上跑费用流，得到费用即为 $ans2$ 。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; namespace fast_io { ... }using namespace fast_io; const int MAXN = 6000,MAXM = 110000; int fx[MAXM],tx[MAXM],cx[MAXM],wx[MAXM]; struct Edge{ int from,to; int flow,cap; int cost,nex; }edge[MAXM]; int n,m,s,t,k; int fir[MAXN],cur[MAXN],pree[MAXN],ecnt = 2; void addedge(int a,int b,int ca,int co = 0,int f = 0){ edge[ecnt].from = a,edge[ecnt].to = b; edge[ecnt].cost = co,edge[ecnt].cap = ca; edge[ecnt].flow = f; edge[ecnt].nex = fir[a],fir[a] = ecnt; ecnt++; edge[ecnt].from = b,edge[ecnt].to = a; edge[ecnt].cost = -co,edge[ecnt].cap = 0; edge[ecnt].flow = -f; edge[ecnt].nex = fir[b],fir[b] = ecnt; ecnt++; } int dis[MAXN],instack[MAXN]; queue\u0026lt;int\u0026gt; q; //Dinic bool bfs(){ memset(dis,0,sizeof(dis)); memcpy(cur,fir,sizeof(fir)); while(!q.empty()) q.pop(); q.push(s);dis[s] = 1; while(!q.empty()){ int nown = q.front();q.pop(); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dis[v] == 0 \u0026amp;\u0026amp; edge[nowe].cap \u0026gt; edge[nowe].flow){ dis[v] = dis[nown]+1; q.push(v); if(v == t) return true; } } } return false; } int dfs(int nown,int limit = 0x3f3f3f3f){ if(nown == t||limit == 0) return limit; for(int \u0026amp;nowe = cur[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dis[v] == dis[nown]+1 \u0026amp;\u0026amp; edge[nowe].cap \u0026gt; edge[nowe].flow){ int f = dfs(v,min(limit,edge[nowe].cap - edge[nowe].flow)); if(f\u0026gt;0){ edge[nowe].flow+=f; edge[nowe^1].flow-=f; return f; } } } return 0; } int dinic(){ int ans = 0,f; while(bfs()) while((f=dfs(s))\u0026gt;0) ans+=f; return ans; } //费用流 bool spfa(){ while(!q.empty()) q.pop(); memset(dis,0x3f,sizeof(dis)); memset(instack,0,sizeof(instack)); dis[s] = 0;q.push(s); while(!q.empty()){ int nown = q.front();q.pop(); instack[nown] = 0; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ Edge e = edge[nowe]; if(dis[e.to]\u0026gt;dis[nown]+e.cost\u0026amp;\u0026amp;e.cap\u0026gt;e.flow){ dis[e.to] = dis[nown]+e.cost; pree[e.to] = nowe; if(instack[e.to] == 0){ q.push(e.to); instack[e.to] = 1; } } } } return dis[t] \u0026lt; 0x3f3f3f3f; } void argument(int \u0026amp;sumc,int \u0026amp;sumf){ int nown = t,delta = 0x3f3f3f3f; while(nown!=s){ delta = min(delta,edge[pree[nown]].cap - edge[pree[nown]].flow); nown = edge[pree[nown]].from; } nown = t; while(nown!=s){ edge[pree[nown]].flow += delta; edge[pree[nown]^1].flow -= delta; nown = edge[pree[nown]].from; } sumf+=delta,sumc+=delta*dis[t]; } int min_cost_flow(int ans){ int c = 0,f = ans; while(spfa()) argument(c,f); return c; } //主程序 void init(){ read(n),read(m),read(k);s = 1,t = n; for(int i = 1;i\u0026lt;=m;i++){ read(fx[i]),read(tx[i]),read(cx[i]),read(wx[i]); addedge(fx[i],tx[i],cx[i]); } } void solve(){ int ans1 = dinic(),ans2; for(int i = 1;i\u0026lt;=m;i++) addedge(fx[i],tx[i],ans1+k,wx[i]); addedge(n,n+1,ans1+k,0,ans1);t = n+1; //注意这个地方需要改变汇点，加边的时候需要给定初始流量  ans2 = min_cost_flow(ans1); print(ans1),print(\u0026#39; \u0026#39;),print(ans2),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":217,"section":"posts","tags":["图论","费用流","网络流"],"title":"「ZJOI2010」网络扩容-网络流-费用流","uri":"https://blog.chenqiqian.com/posts/zjoi2010-network/"},{"content":"给定一个有向图 $G$ ，请求出 $G$ 的最大半连通子图拥有的节点数 $K$ ，以及不同的最大半连通子图的数目 $C$ 。\n由于 $C$ 可能比较大，仅要求输出 $C$ 对 $X$ 的余数。\n具体定义：\n一个有向图 $G=(V,E)$ 称为半连通的 $(Semi-Connected)$ ，如果满足：$\\forall u,v∈V$ ，存在 $u \\rightarrow v$ 或 $v \\rightarrow u$ 。即对于图中任意两点 $u,v$ ，存在一条 $u$ 到 $v$ 的有向路径或者从 $v$ 到 $u$ 的有向路径。\n若 $G'=(V',E')$ 满足 $V'\\subset V$ ， $E'$ 是 $E$ 中所有跟 $V'$ 有关的边，则称 $G'$ 是 $G$ 的一个导出子图。\n若 $G'$ 是 $G$ 的导出子图，且 $G'$ 半连通，则称 $G'$ 为 $G$ 的半连通子图。\n若 $G'$ 是 $G$ 所有半连通子图中包含节点数最多的，则称 $G'$ 是 $G$ 的最大半连通子图。\n链接 Luogu P2272\nBZOJ 1093\n题解 经过观察和分析发现，一个有向图是一个半连通子图当且仅当其缩点后成为一条链。\n这个很显然，画画图就发现了。那么现在问题就变成了寻找一张有向无环图里面最长链的长度及个数。\n可以用dp的方法来求。\n状态转移方程：\n$$\nlen[u] = max(len[v])+1 ,\\quad {u,v} \\in E\n$$\n$$\nnum[u] = sum(num[v]) ,\\quad {u,v} \\in E , ;len[u] = len[v] + 1\n$$\n有一点很坑的就是，不能有重边，要不然就会死的很惨，重复计算导致答案偏大。\n所以重建图要去重！！！\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; namespace fast_io { ... }using namespace fast_io; const int MAXN = 110000,MAXM = 2100000; struct stack{ int num[MAXN],topnum; stack(){topnum = 0;} void pop(){topnum--;} int top(){return num[topnum-1];} void push(int val){num[topnum++] = val;} bool empty(){return topnum != 0;} }a; int n,m,ecnt = 1,X; int fir[MAXN]; int cnt = 1,cnum = 0; int low[MAXN],dfn[MAXN],siz[MAXN]; int col[MAXN]; int instack[MAXN]; struct Edge{ int from,to,nex; bool operator \u0026lt; (Edge a)const{ if(from == a.from) return to \u0026lt; a.to; return from \u0026lt; a.from; } }edge[MAXM]; void addedge(int a,int b){ edge[ecnt].from = a,edge[ecnt].to = b; edge[ecnt].nex = fir[a];fir[a] = ecnt++; } void dfs(int nown){ low[nown] = dfn[nown] = cnt++; instack[nown] = 1;a.push(nown); for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dfn[v] == 0) dfs(v),low[nown] = min(low[v],low[nown]); else if(instack[v] == 1) low[nown] = min(dfn[v],low[nown]); } if(low[nown] == dfn[nown]){ cnum++;int j = -1; do{ j = a.top();a.pop(); instack[j] = 0; col[j] = cnum; siz[cnum]++; }while(j!=nown); } } void tarjan(){ for(int i = 1;i\u0026lt;=n;i++) if(dfn[i] == 0) dfs(i); for(int i = 1;i\u0026lt;=m;i++){ edge[i].from = col[edge[i].from]; edge[i].to = col[edge[i].to]; } memset(fir,0,sizeof(fir)); //去重！！！  sort(edge+1,edge+m+1); int lastu = 0,lastv = 0; for(int i = 1;i\u0026lt;=m;i++){ int u = edge[i].from,v = edge[i].to; if(u!=v\u0026amp;\u0026amp;(!(u==lastu\u0026amp;\u0026amp;v==lastv))) addedge(u,v); lastu = u,lastv = v; } } int dp[MAXN],num[MAXN]; void dfs2(int nown){ dp[nown] = siz[nown],num[nown] = 1; for(int nowe = fir[nown];nowe;nowe = edge[nowe].nex){ int v = edge[nowe].to; if(dp[v] == 0) dfs2(v); if(dp[nown] \u0026lt; dp[v] + siz[nown]) dp[nown] = dp[v] + siz[nown],num[nown] = num[v]; else if(dp[nown] == dp[v] + siz[nown]) num[nown] += num[v], num[nown] %= X; } } void solve(){ for(int i = 1;i\u0026lt;=cnum;i++) if(num[i] == 0) dfs2(i); int ans1 = 0,ans2 = 0; for(int i = 1;i\u0026lt;=cnum;i++){ if(dp[i] \u0026gt; ans1) ans1 = dp[i],ans2 = num[i]; else if(dp[i] == ans1) ans2 += num[i],ans2 %=X; } print(ans1),print(\u0026#39;\\n\u0026#39;),print(ans2),print(\u0026#39;\\n\u0026#39;); } void init(){ read(n),read(m),read(X); int a,b; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b); addedge(a,b); } } int main(){ init(); tarjan(); solve(); flush(); return 0; }   ","description":"","id":218,"section":"posts","tags":["图论","强连通分量","动态规划"],"title":"「ZJOI2007」最大半连通子图-强连通分量-dp","uri":"https://blog.chenqiqian.com/posts/zjoi2007-semi-connected/"},{"content":"墨墨购买了一套 $N$ 支彩色画笔（其中有些颜色可能相同）。墨墨会向你发布如下指令：\n  Q L R 代表询问你从第 $L$ 支画笔到第 $R$ 支画笔中共有几种不同颜色的画笔。\n  R P Col 把第 $P$ 支画笔替换为颜色 $Col$ 。\n  链接 Luogu P1903\n题解 带修改的莫队裸题。\n主要需要注意的就是自加自减时间。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; namespace fast_io { ... }using namespace fast_io; const int MAXN = 11000,MAX = 1100000; int n,m,Q; int col[MAXN],re_col[MAXN],re_pos[MAXN],cnum = 1; int l = 0,r = 0,x = 0; int num[MAX],ans = 0; struct Query{ int id,ql,qr,qx,ans; //运算符重载  bool operator \u0026lt; (Query b)const{ if(ql/Q != b.ql/Q) return ql/Q \u0026lt; b.ql/Q; if(qr/Q != b.qr/Q) return qr/Q \u0026lt; b.qr/Q; return qx \u0026lt; b.qx; } }; bool cmp(Query a,Query b){ return a.id \u0026lt; b.id; } vector\u0026lt;Query\u0026gt; query; void init(){ read(n),read(m);Q = sqrt(n*2); for(int i = 1;i\u0026lt;=n;i++) read(col[i]); for(int i = 1;i\u0026lt;=m;i++){ char op[10];int a,b; read(op);read(a),read(b); if(op[0] == \u0026#39;Q\u0026#39;){ Query w;w.ql = a,w.qr = b,w.qx = cnum-1; w.id = i;query.push_back(w); } else if(op[0] == \u0026#39;R\u0026#39;){ re_pos[cnum] = a,re_col[cnum] = b; cnum++; } } sort(query.begin(),query.end()); } //加入第pos个数并更新答案 void add(int pos){ if(num[col[pos]]++ == 0) ans++; } //删去第pos个数并更新答案 void del(int pos){ if(--num[col[pos]] == 0) ans--; } //进行第times次修改 void change(int times){ if(l\u0026lt;=re_pos[times]\u0026amp;\u0026amp; re_pos[times] \u0026lt;= r){ if(num[re_col[times]]++ == 0) ans++; if(--num[col[re_pos[times]]] == 0) ans--; } swap(re_col[times],col[re_pos[times]]); } void solve(){ for(int i = 0;i\u0026lt;query.size();i++){ //莫队核心转移  Query w = query[i]; while(l \u0026gt; w.ql) add(--l); while(r \u0026lt; w.qr) add(++r); while(l \u0026lt; w.ql) del(l++); while(r \u0026gt; w.qr) del(r--); while(x \u0026lt; w.qx) change(++x); while(x \u0026gt; w.qx) change(x--); query[i].ans = ans; } sort(query.begin(),query.end(),cmp); for(int i = 0;i\u0026lt;query.size();i++) print(query[i].ans),print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":219,"section":"posts","tags":["数据结构","莫队"],"title":"「国家集训队」数颜色-带修改莫队","uri":"https://blog.chenqiqian.com/posts/luogu-1903/"},{"content":"给定一个数列 ${a_n}$ ，$m$ 次询问在 $[l,r]$ 区间内的最小众数。\n强制在线。\n链接 Luogu P4168\n题解 为了在课上讲分块，特地做了一道大分块的题。\n做法一：\n预处理出 $z[i][j]$ ，表示在 $[i,j]$ 个块的区间中的众数； $cnt[i][c]$ ，表示在前i个数中颜色为c的数的个数。\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n每次查询，先将答案设成整块的众数。对于零散的数，暴力统计出在零散块中出现的次数，然后加上在整块出现的次数（前缀和相减），尝试更新答案。\n可以证明，复杂度大约是 $O(n\\ \\sqrt{n} )$ 。\n做法二：\n预处理出 $z[i][j]$ ，表示在 $[i,j]$ 个块的区间中的众数；对于每一种颜色，开一个vector把这个数每次出现的位置，按从前到后顺序加进去。这样，我们可以在 $O(\\log{n})$ 的时间内通过二分查询出一个数在 $[l,r]$ 区间出现了多少次。\n可以证明，一个区间的众数，肯定在整块的众数和零散块中出现的数中。\n每次查询，先将答案设成整块的众数，并且记录其在 $[l,r]$ 出现次数，然后对于每一个零散块中的数，查询其在 $[l,r]$ 中出现的次数，并尝试更新答案。\n可以证明，复杂度大约是 $O(n\\ \\sqrt {n}\\ \\log{n})$ 。这个复杂度存在被卡死的可能。\n由于数据范围很大，需要离散化并且记录离散化后的数对应之前的数是什么。\n代码 做法一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; //快读模版 namespace fast_io { inline char read() {...} inline void read(int \u0026amp;x) {...} inline void read(char *a){...} const int OUT_LEN = 1000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) {...} inline void print(int x) {...} inline void print(char *a){...} inline void flush() {...} }using namespace fast_io; const int MAXN = 101000,MAXQ = 1000; struct pu{ int col,id,belong; }pgy[MAXN]; int n,m,Q; int bl[MAXQ],br[MAXQ],id_to[MAXN],numc = 0; int z[MAXQ][MAXQ],cnt[MAXN][MAXQ],t[MAXN]; bool cmp1(pu a,pu b){return a.col \u0026lt; b.col;} bool cmp2(pu a,pu b){return a.id \u0026lt; b.id;} void init(){ read(n),read(m);Q = sqrt(n); for(int i = 1;i\u0026lt;=n;i++){ read(pgy[i].col); pgy[i].id = i,pgy[i].belong = (i-1)/Q+1; if(!bl[pgy[i].belong]) bl[pgy[i].belong] = i; br[pgy[i].belong] = i; } sort(pgy+1,pgy+n+1,cmp1); int lastc = 0; for(int i = 1;i\u0026lt;=n;i++){ if(pgy[i].col!=lastc) numc++,id_to[numc] = pgy[i].col; lastc = pgy[i].col; pgy[i].col = numc; } sort(pgy+1,pgy+n+1,cmp2); for(int i = 1;i\u0026lt;=n;i++) cnt[pgy[i].col][pgy[i].belong]++; for(int i = 1;i\u0026lt;=numc;i++) for(int j = 1;j\u0026lt;=n/Q;j++) cnt[i][j] += cnt[i][j-1]; } void build(){ for(int i = 1;i\u0026lt;=n;i+=Q){ memset(t,0,sizeof(t)); int maxn = 0; for(int j = i;j\u0026lt;=n;j++){ int nowc = pgy[j].col; t[nowc]++; if(t[nowc] \u0026gt; t[maxn] ||(t[nowc] == t[maxn] \u0026amp;\u0026amp; nowc \u0026lt; maxn)) maxn = nowc; if(j%Q == 0) z[(i-1)/Q+1][j/Q] = maxn; } } } int answer(int ql,int qr){ int lb = pgy[ql].belong,rb = pgy[qr].belong,maxn = 0; //printf(\u0026#34;lblock:%d rblock:%d\\n\u0026#34;,lb,rb);  if(lb == rb || lb+1 == rb){ for(int i = ql;i\u0026lt;=qr;i++) t[pgy[i].col] = 0; for(int i = ql;i\u0026lt;=qr;i++){ int nowc = pgy[i].col; t[nowc]++; if(t[nowc] \u0026gt; t[maxn] ||(t[nowc] == t[maxn] \u0026amp;\u0026amp; nowc \u0026lt; maxn)) maxn = nowc; } } else{ for(int i = ql;i\u0026lt;bl[lb+1];i++) t[pgy[i].col] = 0; for(int i = br[rb-1]+1;i\u0026lt;=qr;i++) t[pgy[i].col] = 0; maxn = z[lb+1][rb-1]; t[maxn] = 0; for(int i = ql;i\u0026lt;bl[lb+1];i++){ int nowc = pgy[i].col; t[nowc]++; int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb]; int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb]; if(tmp \u0026gt; maxnum || (tmp == maxnum \u0026amp;\u0026amp; nowc \u0026lt; maxn)) maxn = nowc; } for(int i = br[rb-1]+1;i\u0026lt;=qr;i++){ int nowc = pgy[i].col; t[nowc]++; int maxnum = t[maxn] + cnt[maxn][rb-1]-cnt[maxn][lb]; int tmp = t[nowc] + cnt[nowc][rb-1]-cnt[nowc][lb]; if(tmp \u0026gt; maxnum || (tmp == maxnum \u0026amp;\u0026amp; nowc \u0026lt; maxn)) maxn = nowc; } } return id_to[maxn]; } void solve(){ int a,b,lastans = 0; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b); a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1; if(a \u0026gt; b) swap(a,b); lastans = answer(a,b); print(lastans),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); build(); solve(); flush(); return 0; }   做法二：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; //快读模版 namespace fast_io { inline char read() {...} inline void read(int \u0026amp;x) {...} inline void read(char *a){...} const int OUT_LEN = 1000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) {...} inline void print(int x) {...} inline void print(char *a){...} inline void flush() {...} }using namespace fast_io; const int MAXN = 101000,MAXQ = 1000; vector\u0026lt;int\u0026gt; pos[MAXN]; int n,m,Q; struct pu{ int col,id; }pgy[MAXN]; //在[i,j]块中的众数 int z[MAXQ][MAXQ]; int id_to[MAXN]; bool cmp1(pu a,pu b){ return a.col \u0026lt; b.col; } bool cmp2(pu a,pu b){ return a.id \u0026lt; b.id; } void init(){ read(n),read(m);Q = sqrt(n*5); for(int i = 1;i\u0026lt;=n;i++) read(pgy[i].col),pgy[i].id = i; sort(pgy+1,pgy+n+1,cmp1); int lastc = 0,numc = 0; for(int i = 1;i\u0026lt;=n;i++){ if(pgy[i].col!=lastc) numc++,id_to[numc] = pgy[i].col; lastc = pgy[i].col; pgy[i].col = numc; } sort(pgy+1,pgy+n+1,cmp2); for(int i = 1;i\u0026lt;=n;i++){ pos[pgy[i].col].push_back(i); } } void build(){ static int t[MAXN]; for(int i = 1;i\u0026lt;=n;i+=Q){ memset(t,0,sizeof(t)); int maxn = 0; for(int j = i;j\u0026lt;=n;j++){ int nowc = pgy[j].col; t[nowc]++; if(t[nowc] \u0026gt; t[maxn] ||(t[nowc] == t[maxn] \u0026amp;\u0026amp; nowc \u0026lt; maxn)) maxn = nowc; if(j%Q == 0) z[(i-1)/Q+1][j/Q] = maxn; } } } int count_num(int lb,int rb,int num){ return lower_bound(pos[num].begin(),pos[num].end(),rb+1)-lower_bound(pos[num].begin(),pos[num].end(),lb); } int answer(int ql,int qr){ int lb = floor(double(ql-2)/Q)+2,rb = qr/Q,maxn = 0,maxnum = 0; if(lb \u0026lt;= rb) maxn = z[lb][rb],maxnum = count_num(ql,qr,maxn); //printf(\u0026#34;lblock:%d rblock:%d\\n\u0026#34;,lb,rb);  lb = (lb-1)*Q+1,rb = rb*Q; //printf(\u0026#34;lbound:%d rbound:%d maxn:%d\\n\u0026#34;,lb,rb,maxn);  while(ql \u0026lt; lb){ --lb; int c = pgy[lb].col,w = count_num(ql,qr,c); if(w \u0026gt; maxnum || (w == maxnum \u0026amp;\u0026amp; c \u0026lt; maxn)) maxn = c,maxnum = w; } while(rb \u0026lt; qr){ rb++; int c = pgy[rb].col,w = count_num(ql,qr,c); if(w \u0026gt; maxnum || (w == maxnum \u0026amp;\u0026amp; c \u0026lt; maxn)) maxn = c,maxnum = w; } return id_to[maxn]; } void solve(){ int a,b,lastans = 0; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b); a = (a+lastans-1)%n+1,b = (b+lastans-1)%n+1; if(a \u0026gt; b) swap(a,b); lastans = answer(a,b); print(lastans),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); build(); solve(); flush(); return 0; }   ","description":"","id":220,"section":"posts","tags":["分块","数据结构"],"title":"「Violet」蒲公英-分块","uri":"https://blog.chenqiqian.com/posts/luogu-4168/"},{"content":"给出一颗 $n$ 个节点的无权树， $m$ 次询问，每次给出三个点编号为 $a$ ，$b$ ， $c$ ，询问到这三个点距离最小的点的编号以及其距离和。\n链接 Luogu P4281\n题解 首先，如果每次询问都只有两个点，这个问题就很简单，只要是树上的路径上的点就可以，寻找树上的路径其实就是寻找 $LCA$ 的过程。这可以启发我们对于三个点的情况的思考。\n如果这里有三个点，我们来认真的思考一下。经过上一问的启发，我们来思考一下能不能运用 $LCA$ 来解决这道题。\n我们可以发现，树上三个点的三对 $LCA$ 一定有两个是相同的。这是一件想想的话比较显然的事情。必然能够找到某个节点，让三个点中的两个在一侧，一个在另一侧。而这个点就是两个公共的 $LCA$ 。思考的再深入些（并且结合瞎蒙），我们会发现这个相同的 $LCA$ 肯定是深度最小的一个 $LCA$ 。\n这里，我们首先可以显而易见的发现，这个点必须在三个点互相通达的路径上。\n我们再思考一下 $LCA$ 与路径和的关系。假设我们知道 $a$ 和 $b$ 的 $LCA$ 是 $x$ ，而且 $x$ 是上述的3个 $LCA$ 中深度最大的那个，那么可以发现从 $x$ 到 $a$ 的距离加上从 $x$ 到 $b$ 的距离一定是最小的。根据上面的结论，我们知道 $a$ ， $c$ 和 $b$ ， $c$ 的 $LCA$ 点 $y$ 一定在一个点上，而且这个 $y$ 一定比 $x$ 深度小。\n那么这个时候，我们会发现此时 $a$ ， $b$ ， $c$ 到 $x$ 的距离和是最小的。证明的话可以这么想：如果 $x'$ 比 $x$ 高，那么虽然 $c$ 到 $x$ 的距离减小了 $w$ ，但是 $a$ ， $b$ 到 $x'$ 的距离均增大了 $w$ ，显然距离和增大。如果 $x'$ 比 $x$ 低，有一个节点到 $x'$ 的距离减小了 $w$ ，剩下两个节点到 $x'$ 的距离均增大了 $w$ ，显然距离和也增大。\n所以我们就找到了到三个点距离和最小的点：这三个点的三对 $LCA$ 中，深度大的那两个LCA就是答案。\n我们在求 $LCA$ 之前，可以先预处理出深度$dep$，那么从节点 $u$ 到 $v$ 的路径长度就是$dis = dep[u] + dep[v] - 2*dep[lca(u,v)]$。运用这个式子分别算出 $a$ , $b$ , $c$ 到 $a1$ , $b1$ , $c1$（三个 $LCA$ ）的距离，最后发现总的 $dis$ 居然是轮换式：$ans = dep[a]+dep[b]+dep[c]-dep[a1]-dep[b1]-dep[c1]$， 所以就不用分类讨论了。\n$LCA$ 我用了树链剖分来求，顺带处理深度。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; namespace fast_io { inline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++; } inline void read(int \u0026amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == \u0026#39;-\u0026#39;) iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x+(x\u0026lt;\u0026lt;2))\u0026lt;\u0026lt;1) + (c ^ \u0026#39;0\u0026#39;); if (iosig) x = -x; } const int OUT_LEN = 1000000;char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c; } inline void print(int x) { static int buf[30], cnt; if (x == 0) print(\u0026#39;0\u0026#39;); else { if (x \u0026lt; 0) print(\u0026#39;-\u0026#39;), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); } } inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); } }using namespace fast_io; const int MAXN = 510000; vector\u0026lt;int\u0026gt; edge[MAXN]; int n,m; int dep[MAXN],siz[MAXN],fa[MAXN],son[MAXN],top[MAXN],id[MAXN],cnt = 1; //添加从a到b的无向边 void addedge(int a,int b){ edge[a].push_back(b); edge[b].push_back(a); } //树链剖分的第一个dfs void dfs1(int nown,int f,int depth){ siz[nown] = 1,fa[nown] = f,dep[nown] = depth; int maxsum = -1;son[nown] = 0; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == f) continue; dfs1(to,nown,depth+1); if(siz[to] \u0026gt; maxsum) maxsum = siz[to],son[nown] = to; siz[nown] += siz[to]; } } //树链剖分的第二个dfs void dfs2(int nown,int topf){ id[nown] = cnt++;top[nown] = topf; if(son[nown] == 0) return; dfs2(son[nown],topf); for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == fa[nown]|| to == son[nown]) continue; dfs2(to,to); } } //求a,b两点的LCA int lca(int a,int b){ while(top[a]!=top[b]){ if(dep[top[a]] \u0026lt; dep[top[b]]) swap(a,b); a = fa[top[a]]; } if(dep[a] \u0026lt; dep[b]) swap(a,b); return b; } //初始化以及dfs void init(){ read(n),read(m); int a,b; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b); addedge(a,b); } dfs1(1,0,1); dfs2(1,1); } //回应询问 void solve(){ int a,b,c,a1,b1,c1,ans,dis; for(int i = 1;i\u0026lt;=m;i++){ read(a),read(b),read(c); //a1,b1,c1的意义见下  a1 = lca(a,b),b1 = lca(b,c),c1 = lca(c,a); dis = 0; if(a1 == b1) ans = c1; else if(b1 == c1) ans = a1; else if(c1 == a1) ans = b1; //计算dis的公式  dis = dep[a] + dep[b] + dep[c] - dep[a1] - dep[b1] - dep[c1]; print(ans),print(\u0026#39; \u0026#39;),print(dis),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":221,"section":"posts","tags":["最近公共祖先","图论","树形结构"],"title":"「AHOI2008」紧急集合-LCA","uri":"https://blog.chenqiqian.com/posts/ahoi2008-emergency/"},{"content":"给定一棵有 $n$ 个节点的无根树和 $m$ 个操作，操作有两类：\n 将节点 $a$ 到节点 $b$ 路径上所有点都染成颜色 $c$ ； 询问节点 $a$ 到节点 $b$ 路径上的颜色段数量（连续相同颜色被认为是同一段），  如“112221”由3段组成：“11”、“222”和“1”。\n请你写一个程序依次完成这 $m$ 个操作。\n链接 Luogu P2486\n题解 这道题是一道不是很难的树链剖分+线段树的题目。\n很明显是一道树链剖分的题目，我们只需要搞明白：如何维护区间的颜色块的数目。\n很容易想到用线段树来维护这个东西。所以我们只要维护三个东西：左端点的颜色，右端点的颜色，总共的颜色块数目。\n在合并的时候，如果左边块的右端点的颜色等于右边块的左端点颜色，就给总颜色块数目减1，就可以达成合并区间的目的。合并后的块的左颜色等于左孩子的左颜色，右颜色等于右孩子的右颜色。总共的颜色块数目是两块颜色块的数目加起来，再判一下前文提到的相同的颜色就行了\n由于我太菜了，所以有的地方懒得去想，就多加了几个 if else... 了事，代码也就长些。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cctype\u0026gt;#define lson (nown\u0026lt;\u0026lt;1) #define rson (nown\u0026lt;\u0026lt;1|1) #define mid ((l+r)\u0026gt;\u0026gt;1) using namespace std; //快读模版 namespace fast_io { inline char read() {...} inline void read(int \u0026amp;x) {...} inline void read(char *a){...} const int OUT_LEN = 1000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) {...} inline void print(int x) {...} inline void print(char *a){...} inline void flush() {...} }using namespace fast_io; const int MAXN = 110000; int n,m; int son[MAXN],top[MAXN],fa[MAXN],siz[MAXN],dep[MAXN]; int id[MAXN],id_to[MAXN],num[MAXN],cnt = 1; vector\u0026lt;int\u0026gt; edge[MAXN]; //线段树节点定义 struct node{ int num,lcol,rcol; bool lazy; node(int n = 0,int l = 0,int r = 0):num(n),lcol(l),rcol(r){}; bool empty(){ return num == 0; } }pool[MAXN\u0026lt;\u0026lt;2]; //线段树节点的合并 inline node merge(node l,node r){ //特判！！！  if(l.empty()) return r; if(r.empty()) return l; node ans; ans.num = l.num+r.num; if(l.rcol == r.lcol) ans.num-=1; ans.lcol = l.lcol,ans.rcol = r.rcol; return ans; } //线段树的标记下传 inline void push_down(int nown,int l,int r){ if(pool[nown].lazy){ int c = pool[nown].lcol; pool[lson] = node(1,c,c),pool[lson].lazy = 1; pool[rson] = node(1,c,c),pool[rson].lazy = 1; pool[nown].lazy = 0; } } //反转区间 inline node reverse(node nown){ swap(nown.lcol,nown.rcol); return nown; } //建树 inline void build(int nown,int l,int r){ pool[nown].lazy = 0; if(l == r) pool[nown] = node(1,num[id_to[l]],num[id_to[l]]); else{ build(lson,l,mid); build(rson,mid+1,r); pool[nown] = merge(pool[lson],pool[rson]); } } //线段树区间更新 inline void update(int nown,int l,int r,int ql,int qr,int c){ if(ql\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=qr){ pool[nown] = node(1,c,c); pool[nown].lazy = 1; } else{ push_down(nown,l,r); if(ql\u0026lt;=mid) update(lson,l,mid,ql,qr,c); if(qr\u0026gt;=mid+1) update(rson,mid+1,r,ql,qr,c); pool[nown] = merge(pool[lson],pool[rson]); } } //线段树区间查询颜色块树 inline node query(int nown,int l,int r,int ql,int qr){ if(ql\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=qr) return pool[nown];//这里的返回值是整个结构体  else{ push_down(nown,l,r); if(ql\u0026lt;=mid \u0026amp;\u0026amp; mid+1\u0026lt;=qr){ node ls,rs; ls = query(lson,l,mid,ql,qr); rs = query(rson,mid+1,r,ql,qr); return merge(ls,rs); } else if(qr\u0026lt;=mid) return query(lson,l,mid,ql,qr); else if(ql\u0026gt;=mid+1) return query(rson,mid+1,r,ql,qr); } } /*--- 以下为树链剖分模版 ---*/ inline void dfs1(int nown,int f,int depth){ dep[nown] = depth,fa[nown] = f,siz[nown] = 1; son[nown] = 0;int maxsum = -1; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == f) continue; dfs1(to,nown,depth+1); siz[nown]+=siz[to]; if(siz[to]\u0026gt;maxsum) maxsum = siz[to],son[nown] = to; } } inline void dfs2(int nown,int topf){ top[nown] = topf,id[nown] = cnt,id_to[cnt] = nown;cnt++; if(!son[nown]) return; dfs2(son[nown],topf); for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == fa[nown]||to == son[nown]) continue; dfs2(to,to); } } void update_range(int x,int y,int c){ while(top[x]!=top[y]){ if(dep[top[x]]\u0026lt;dep[top[y]]) swap(x,y); update(1,1,n,id[top[x]],id[x],c); x = fa[top[x]]; } if(dep[x]\u0026gt;dep[y]) swap(x,y); update(1,1,n,id[x],id[y],c); } //这里多用了几个if else 和reverse来让颜色块接对方向 //可以同时交换lans和rans等来完成这一项(未经验证) int query_range(int x,int y){ node lans = node(0,0,0),rans = node(0,0,0); while(top[x]!=top[y]){ if(dep[top[x]] \u0026gt; dep[top[y]]){ lans = merge(lans,reverse(query(1,1,n,id[top[x]],id[x]))); x = fa[top[x]]; } else{ rans = merge(query(1,1,n,id[top[y]],id[y]),rans); y = fa[top[y]]; } } if(dep[x]\u0026lt;dep[y]) lans = merge(lans,query(1,1,n,id[x],id[y])); else rans = merge(reverse(query(1,1,n,id[y],id[x])),rans); return merge(lans,rans).num; } /*--- 以上为树链剖分模版 ---*/ //程序的初始化 inline void init(){ read(n),read(m); for(int i = 1;i\u0026lt;=n;i++) read(num[i]); int a,b; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b); edge[a].push_back(b); edge[b].push_back(a); } dfs1(1,0,1); dfs2(1,1); build(1,1,n); } //回应询问 void solve(){ char op[20];int a,b,c; for(int i = 1;i\u0026lt;=m;i++){ read(op),read(a),read(b); if(op[0] == \u0026#39;C\u0026#39;) read(c),update_range(a,b,c); else if(op[0] == \u0026#39;Q\u0026#39;) print(query_range(a,b)),print(\u0026#39;\\n\u0026#39;); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":222,"section":"posts","tags":["数据结构","树链剖分","线段树"],"title":"「SDOI2011」染色-树链剖分+线段树","uri":"https://blog.chenqiqian.com/posts/sdoi2011-colour/"},{"content":"\u0008给定一颗 $n$ 个节点的树，节点编号为 $1$ 到 $n$ ，每个节点都有一个权值 $w_i$ 。\n有以下三种操作或询问：\nI. CHANGE u t : 把结点 $u$ 的权值改为 $t$\nII. QMAX u v: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值\nIII. QSUM u v: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和\n链接 Luogu P2590\n题解 树链剖分模版题。\n进行树链剖分之后，由于注意到这里只有单点修改，所以我们用一个 zkw 线段树来维护这些信息。\n  对于 CHANGE 操作，我们直接更改叶子节点的值，然后进行 zkw 线段树的从下到上的更新操作，直到根。\n  对于 QMAX 操作，我们就用树链剖分的常规操作，每一步求一个最大值，然后更新答案即可。 QSUM 同理。\n  事实上，这个题凸显出来 zkw 线段树在单点修改上真是不一般的快，以我的垃圾 coding 水平居然能在 bzoj 上排到第一页。\n$zkw$ w大法好！\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; const int MAXN = 31000; inline int max(int a,int b){ return b\u0026gt;a?b:a; } namespace fast_io { inline char read() { //return getchar();  static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++; } inline void read(int \u0026amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == \u0026#39;-\u0026#39;) iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x + (x \u0026lt;\u0026lt; 2)) \u0026lt;\u0026lt; 1)+(c^48); if (iosig) x = -x; } inline void read(char *a){ static char c = read(); while(c!= -1\u0026amp;\u0026amp;(c == \u0026#39; \u0026#39;||c ==\u0026#39;\\n\u0026#39;)) c = read(); while(c!= -1\u0026amp;\u0026amp;c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;) *a++ = c,c = read(); *a = 0; } const int OUT_LEN = 1000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) { if(ooh == obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf; *ooh++ = c; } inline void print(int x) { static int buf[30], cnt; if(x == 0) print(\u0026#39;0\u0026#39;); else { if (x \u0026lt; 0) print(\u0026#39;-\u0026#39;), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); } } inline void print(char *a){ while(*a) print(*a++); } inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); } }using namespace fast_io; int maxn[MAXN\u0026lt;\u0026lt;2],sumn[MAXN\u0026lt;\u0026lt;2]; int n,M,q,num[MAXN]; //top数组是链子最上面的节点，fa是父节点，son是重儿子节点，siz是子树大小，dep是dfs深度 int top[MAXN],fa[MAXN],son[MAXN],siz[MAXN],dep[MAXN]; //id_to 是i号id指向的节点编号，id就是i号节点的dfs编号 int id_to[MAXN],id[MAXN]; int cnt = 1; vector\u0026lt;int\u0026gt; edge[MAXN]; //zkw线段树初始化 inline void init_seg(){ for(M = 1;M\u0026lt;n+2;M\u0026lt;\u0026lt;=1); for(int i = 1;i\u0026lt;=n;i++) maxn[M+i] = sumn[M+i] = num[id_to[i]]; for(int i = M-1;i;i--) maxn[i]=max(maxn[i\u0026lt;\u0026lt;1],maxn[i\u0026lt;\u0026lt;1|1]),sumn[i]=sumn[i\u0026lt;\u0026lt;1]+sumn[i\u0026lt;\u0026lt;1|1]; } //zkw线段树区间最值 inline int max_seg(int l,int r){ int ans = -100000; for(l=l+M-1,r=r+M+1;l^r^1;l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1){ if(~l\u0026amp;1 \u0026amp;\u0026amp; maxn[l^1]\u0026gt;ans) ans = maxn[l^1]; if(r\u0026amp;1 \u0026amp;\u0026amp; maxn[r^1]\u0026gt;ans) ans = maxn[r^1]; } return ans; } //zkw线段树区间求和 inline int sum_seg(int l,int r){ int ans = 0; for(l=l+M-1,r=r+M+1;l^r^1;l\u0026gt;\u0026gt;=1,r\u0026gt;\u0026gt;=1){ if(~l\u0026amp;1) ans += sumn[l^1]; if(r\u0026amp;1) ans += sumn[r^1]; } return ans; } //zkw线段树修改 inline void upd_seg(int pos,int x){ int nown = pos+M; maxn[nown] = sumn[nown] = x; while(nown\u0026gt;\u0026gt;=1){ maxn[nown] = max(maxn[nown\u0026lt;\u0026lt;1],maxn[nown\u0026lt;\u0026lt;1|1]); sumn[nown] = sumn[nown\u0026lt;\u0026lt;1]+sumn[nown\u0026lt;\u0026lt;1|1]; } } //树链剖分的第一个dfs inline void dfs1(int nown,int f,int depth){ son[nown] = 0,dep[nown] = depth,siz[nown] = 1,fa[nown] = f; int maxsum = 0; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == f) continue; dfs1(to,nown,depth+1); siz[nown]+=siz[to]; if(siz[to]\u0026gt;maxsum) maxsum = siz[to],son[nown] = to; } } //树链剖分的第二个dfs inline void dfs2(int nown,int topf){ id[nown] = cnt; id_to[cnt++] = nown; top[nown] = topf; if(!son[nown]) return; dfs2(son[nown],topf); for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i]; if(to == son[nown]||to == fa[nown]) continue; dfs2(to,to); } } //查询路径和 inline int query_sum(int x,int y){ int ans = 0; while(top[x]!=top[y]){ if(dep[top[x]]\u0026lt;dep[top[y]]) swap(x,y); ans+=sum_seg(id[top[x]],id[x]); x = fa[top[x]]; } if(dep[x]\u0026gt;dep[y]) swap(x,y); ans+=sum_seg(id[x],id[y]); return ans; } //查询路径最大值 inline int query_max(int x,int y){ int ans = -100000; while(top[x]!=top[y]){ if(dep[top[x]]\u0026lt;dep[top[y]]) swap(x,y); ans = max(ans,max_seg(id[top[x]],id[x])); x = fa[top[x]]; } if(dep[x]\u0026gt;dep[y]) swap(x,y); ans = max(ans,max_seg(id[x],id[y])); return ans; } //修改某个节点 inline void update(int pos,int x){ upd_seg(id[pos],x); } //初始化图和线段树还有两次dfs void init(){ read(n); int a,b; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b); edge[a].push_back(b); edge[b].push_back(a); } for(int i = 1;i\u0026lt;=n;i++) read(num[i]); dfs1(1,0,1); dfs2(1,1); init_seg(); } //进行操作以及回答询问 void solve(){ read(q); char op[20]; int a,b; for(int i = 1;i\u0026lt;=q;i++){ read(op),read(a),read(b); if(op[1] == \u0026#39;M\u0026#39;) print(query_max(a,b)),print(\u0026#39;\\n\u0026#39;); else if(op[1] == \u0026#39;S\u0026#39;) print(query_sum(a,b)),print(\u0026#39;\\n\u0026#39;); else if(op[1] == \u0026#39;H\u0026#39;) update(a,b); } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":223,"section":"posts","tags":["数据结构","树链剖分"],"title":"「ZJOI2008」树的统计-树链剖分","uri":"https://blog.chenqiqian.com/posts/zjoi2008-count/"},{"content":"给定一棵由 $n$ 个节点构成的树。\n在树上存在一个“激发器”，标号为 $s$ 。当激发器工作后，电流会延边传向每一个相邻节点。而中间节点接收到电流后，会将该电流传向与它连接并且尚未接收到电流的节点。对于每条边 $e$ ，电流通过它需要的时间为 $t_e$ ，电流的转发可以认为是在瞬间完成的。最终，激电流将到达一些“终止节点”――接收电流之后不再转发的节点。\n使用一次道具可以使得电流通过某条边的时间增加一个单位。请问最少使用多少次道具才可达到每一个“终止节点”同时收到电流？\n链接 Luogu P1131\n题解 注意到子树无论怎么搞，对上面的选择有影响的只是一个最后电流到达终点同步的时间，所以我们把这个设计进状态里面。\n注意到如果子树的同步的时间最少的话，那么它的消耗道具次数就应该是最少的，同时因为这棵子树的每一层之间，至少含有一条边，那么如果子树的同步时间变多 $x$ ，那么在子树上的道具消耗次数就一定要变多大于等于 $x$ ，而这个时候在子树与父节点的同步中，子树的根节点与父节点间的边的同步时间最多减少 $x$ ，所以可以证明父节点的最优消耗道具次数一定是在子节点的最优同步时间下取得的，也就可以证明 $dp$ 的正确性。\n状态转移方程：\n$$\ntime[u] = max(time[v]+len(u,v))\n$$\n$$\nans[u] = sum(ans[v]+time[u]-(time[v]+len(u,v))\n$$\n其中 $u$ ， $v$\u0008 有一条边，且 $v$ \u0008非\u001d $u$ 的父亲。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cctype\u0026gt;#include \u0026lt;algorithm\u0026gt;#define int long long using namespace std; namespace fast_io { ...//省略快读模版 }using namespace fast_io; namespace normal_io{ inline char read(){ return getchar(); } inline void read(int \u0026amp;x){ scanf(\u0026#34;%lld\u0026#34;,\u0026amp;x); } inline void print(int x){ printf(\u0026#34;%lld\u0026#34;,x); } inline void print(char x){ putchar(x); } inline void flush(){ return; } }using namespace normal_io; const int MAXN = 510000; int n,s; struct Edge{ int t,l; Edge(int b = 0,int c = 0):t(b),l(c){}; }; vector\u0026lt;Edge\u0026gt; edge[MAXN]; int ans[MAXN],times[MAXN]; bool vis[MAXN]; void addedge(int a,int b,int c){ edge[a].push_back(Edge(b,c)); edge[b].push_back(Edge(a,c)); } void init(){ read(n),read(s); int a,b,c; for(int i = 1;i\u0026lt;=n-1;i++){ read(a),read(b),read(c); addedge(a,b,c); } } void dp(int nown){ vis[nown] = 1; int tmpsum = 0,mintime = 0,k = 0; for(int i = 0;i\u0026lt;edge[nown].size();i++){ int to = edge[nown][i].t,len = edge[nown][i].l; if(vis[to] == 1) continue; dp(to); ans[nown] += ans[to]; mintime = max(mintime,times[to]+len); tmpsum += (times[to]+len); k++; } ans[nown] += k * mintime - tmpsum,times[nown] = mintime; } void solve(){ dp(s); print(ans[s]); } main(){ init(); solve(); flush(); return 0; }   ","description":"","id":224,"section":"posts","tags":["动态规划","树形dp"],"title":"「ZJOI2007」时态同步-树形dp","uri":"https://blog.chenqiqian.com/posts/zjoi2007-sync/"},{"content":"有一个长度为 $n$ 的整数序列，并且有以下三种操作：\n  INSERT i k ：在原数列的第 $i$ 个数后面添加一个新数 $k$ ；如果原数列的第 $i$ 个数已经添加了若干数，则添加在这些数的最后\n  MIN GAP：查询相邻两个数的之间差值（绝对值）的最小值\n  MIN SORT GAP：查询所有数中最接近的两个数的差值（绝对值）\n  链接 Luogu P1110\n题解 一道近乎于裸的 Treap ，然而由于我十分蒟蒻而且好久没敲 Treap ，调了两个小时才调完。\n这道题我们维护两棵平衡树，一颗 $b$ 记录所有相邻数的差的绝对值，一颗 $b$ 记录所有的数；一个列表，记录每个块的最前面和最后面的数。我们注意到询问三的结果随插入的数不增，所以只需要维护一个最小值 $minn$ 就可以了。\n  insert 操作：首先根据列表内容从 $b$ 里删除对应位置块间两数的差，然后把插入后多出来的相邻元素差，这个数与这一块结尾，下一块最前面的数的差分别插入平衡树 $b$ ，注意 i == n 时需要特判；并把插入的数加到 $a$ 里面，根据其与前驱后继的差更新 $minn$ ，注意需要判断一下是否这个数已经在平衡树里面存在。\n  相邻元素的差值最小值：直接在 $b$ 里求最小值并输出。\n  排序后的最小差值：直接输出 $minn$ 。\n  代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cctype\u0026gt;using namespace std; namespace fast_io { ...//隐去快读模版 }using namespace fast_io; namespace normal_io{ inline char read(){ return getchar(); } inline void read(char *c){ scanf(\u0026#34;%s\u0026#34;,c); } inline void read(int \u0026amp;x){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); } inline void print(int x){ printf(\u0026#34;%d\u0026#34;,x); } inline void print(char x){ putchar(x); } inline void flush(){ return; } }using namespace normal_io; struct treap{ struct node{ int val,p,cnt; node* son[2]; }; const static int MAXN = 1000000; int treapcnt; node pool[MAXN],*null,*root; treap(){ treapcnt = 0; newnode(null); srand(19260817); null-\u0026gt;val = -0x3f3f3f3f; null-\u0026gt;p = 2147483647; null-\u0026gt;cnt = 0; root = null; } void rotate(node *\u0026amp;r,int tmp){ node *t = r-\u0026gt;son[1-tmp]; r-\u0026gt;son[1-tmp] = t-\u0026gt;son[tmp]; t-\u0026gt;son[tmp] = r; r = t; } void newnode(node *\u0026amp;r){ r = \u0026amp;pool[treapcnt++]; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; } void __insert(node *\u0026amp;r,int v){ if(r == null){ newnode(r); r-\u0026gt;val = v;r-\u0026gt;p = rand();r-\u0026gt;cnt = 1; } else{ if(r-\u0026gt;val == v) r-\u0026gt;cnt++; else{ int tmp = v \u0026gt; r-\u0026gt;val; __insert(r-\u0026gt;son[tmp],v); if(r-\u0026gt;son[tmp]-\u0026gt;p \u0026lt; r-\u0026gt;p) rotate(r,1-tmp); } } } node *find(node *r,int t){ while(r-\u0026gt;son[t]!=null) r = r-\u0026gt;son[t]; return r; } void __erase(node *\u0026amp;r,int v){ if(r-\u0026gt;val == v){ if(r-\u0026gt;cnt \u0026gt; 1) r-\u0026gt;cnt--; else{ if(r-\u0026gt;son[0] == null\u0026amp;\u0026amp;r-\u0026gt;son[1] == null){ r = null;return; } else{ int tt = r-\u0026gt;son[0]-\u0026gt;p \u0026gt; r-\u0026gt;son[1]-\u0026gt;p; rotate(r,1-tt); __erase(r,v); } } } else{ int tmp = v \u0026gt; r-\u0026gt;val; __erase(r-\u0026gt;son[tmp],v); } } node *nei(int v,int t){ node* nown = root,*last = null; while(nown!=null\u0026amp;\u0026amp;nown-\u0026gt;val!=v){ //printf(\u0026#34;2\\n\u0026#34;);  int tmp = v \u0026gt; nown-\u0026gt;val; if(tmp!=t) last = nown; nown = nown-\u0026gt;son[tmp]; } if(nown-\u0026gt;son[t]!=null){ last = find(nown-\u0026gt;son[t],1-t); } return last; } bool find(int v){ node *r = root; while(r!=null\u0026amp;\u0026amp;r-\u0026gt;val!=v){ int tmp = v \u0026gt; r-\u0026gt;val; r = r-\u0026gt;son[tmp]; } return r != null; } inline void __print(node *r,int depth = 0){ if(r == null) return; else{ __print(r-\u0026gt;son[0],depth+1); for(int i = 0;i\u0026lt;depth;i++) putchar(\u0026#39; \u0026#39;); printf(\u0026#34;val:%d cnt:%d P:%d son?:%d %d\\n\u0026#34;,r-\u0026gt;val,r-\u0026gt;cnt,r-\u0026gt;p,r-\u0026gt;son[0]!=null,r-\u0026gt;son[1]!=null); __print(r-\u0026gt;son[1],depth+1); } } void insert(int v){ __insert(root,v); } void erase(int v){ __erase(root,v); } void print(){ __print(root); } }; //以上treap常规模版  treap a,b; const int MAXN = 1000000; int head[MAXN],tail[MAXN],minn,n,m; //a是所有数，b是所有相邻数差值 //head记录此块最前数，tail记录最后数。  void init(){ minn = 0x3f3f3f3f; read(n),read(m); static int tmp[MAXN]; for(int i = 1;i\u0026lt;=n;i++){ int t;read(t); a.insert(t); head[i] = tail[i] = tmp[i] = t; } sort(tmp+1,tmp+n+1); for(int i = 2;i\u0026lt;=n;i++){ //更新初始的两个查询答案  b.insert(abs(head[i]-head[i-1])); minn = min(minn,tmp[i]-tmp[i-1]); } } void solve(){ char op[20];int x,y; for(int i = 1;i\u0026lt;=m;i++){ read(op); if(op[4] == \u0026#39;G\u0026#39;){ print(b.find(b.root,0)-\u0026gt;val),print(\u0026#39;\\n\u0026#39;); //寻找最小相邻元素差值  } else if(op[4] == \u0026#39;S\u0026#39;){ print(minn),print(\u0026#39;\\n\u0026#39;); //寻找排序元素差值  } else if(op[4] == \u0026#39;R\u0026#39;){ read(x),read(y); if(x != n){ b.erase(abs(head[x+1]-tail[x])); b.insert(abs(head[x+1]-y)); } b.insert(abs(tail[x]-y)); tail[x] = y; //更新查询2答案  if(a.find(y)) minn = 0; else{ int low = a.nei(y,0)-\u0026gt;val,up = a.nei(y,1)-\u0026gt;val; minn = min(minn,min(abs(y-low),abs(up-y))); } a.insert(y); //更新查询3答案  } else if(op[4] ==\u0026#39;P\u0026#39;){ a.print(); printf(\u0026#34;------------------------\\n\u0026#34;); b.print(); //调试用  } //printf(\u0026#34;Finish\\n\u0026#34;);  } } int main(){ init(); solve(); flush(); return 0; }   ","description":"","id":225,"section":"posts","tags":["Treap","平衡树","数据结构"],"title":"「ZJOI2007」报表统计-平衡树","uri":"https://blog.chenqiqian.com/posts/zjoi2007-count/"},{"content":"输入输出模板替代普通读写方式，可以在一定程度上加快程序运行速度。\n依赖库stdio.h 和 ctype.h。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt; namespace fast_io { inline char read(){ //return getchar();  static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))== s)?-1:*s++) : *s++; } inline void read(int \u0026amp;x){ static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == \u0026#39;-\u0026#39;) iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = ((x+(x\u0026lt;\u0026lt;2))\u0026lt;\u0026lt;1) + (c ^ \u0026#39;0\u0026#39;); if (iosig) x = -x; } inline void read(char *a){ static char c = read(); while(c!= -1\u0026amp;\u0026amp;(c == \u0026#39; \u0026#39;||c!=\u0026#39;\\r\u0026#39;||c ==\u0026#39;\\n\u0026#39;)) c = read(); while(c!= -1\u0026amp;\u0026amp;c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\r\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;) *a++ = c,c = read(); *a = 0; } const int OUT_LEN = 1000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c){ if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c; } inline void print(int x){ static int buf[30], cnt; if (x == 0) print(\u0026#39;0\u0026#39;); else { if (x \u0026lt; 0) print(\u0026#39;-\u0026#39;), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); } } inline void print(char *a){ while(*a) print(*a++); } inline void flush(){ fwrite(obuf, 1, ooh - obuf, stdout); } }using namespace fast_io; namespace normal_io{ inline char read(){ return getchar(); } inline void read(int \u0026amp;x){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); } inline void print(int x){ printf(\u0026#34;%d\u0026#34;,x); } inline void print(char x){ putchar(x); } inline void flush(){ return; } }//using namespace normal_io;  int main(){ int x; read(x); print(x); flush(); return 0; }   short版 update at 20180405\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cctype\u0026gt; namespace fast_io { inline char read(){static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;} inline void read(int \u0026amp;x){static bool iosig;static char c;for (iosig=false,c=read();!isdigit(c);c=read()){if(c==\u0026#39;-\u0026#39;)iosig=true;if(c==-1)return;}for(x=0;isdigit(c);c=read())x=((x+(x\u0026lt;\u0026lt;2))\u0026lt;\u0026lt;1)+(c^\u0026#39;0\u0026#39;);if(iosig)x=-x;} inline void read(char *a){static char c = read();while(c!=-1\u0026amp;\u0026amp;(c==\u0026#39; \u0026#39;||c==\u0026#39;\\n\u0026#39;||c==\u0026#39;\\r\u0026#39;))c=read();while(c!=-1\u0026amp;\u0026amp;c!=\u0026#39;\\r\u0026#39;\u0026amp;\u0026amp;c!=\u0026#39; \u0026#39;\u0026amp;\u0026amp;c!=\u0026#39;\\n\u0026#39;) *a++=c,c=read();*a=0;} const int OUT_LEN=1000000;char obuf[OUT_LEN],*ooh=obuf; inline void print(char c){if(ooh==obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;*ooh++ = c;} inline void print(int x){static int buf[30],cnt;if(x==0)print(\u0026#39;0\u0026#39;);else{if(x\u0026lt;0)print(\u0026#39;-\u0026#39;),x=-x;for(cnt=0;x;x/=10)buf[++cnt]=x%10+48;while (cnt) print((char)buf[cnt--]);}} inline void print(char *a){while(*a) print(*a++);} inline void flush(){fwrite(obuf,1,ooh-obuf,stdout);} }using namespace fast_io; namespace normal_io{ inline char read(){return getchar();} inline void read(int \u0026amp;x){scanf(\u0026#34;%d\u0026#34;,\u0026amp;x);} inline void print(int x){printf(\u0026#34;%d\u0026#34;,x);} inline void print(char x){putchar(x);} inline void flush(){return;} }//using namespace normal_io;  int main(){ int x; read(x); print(x); flush(); return 0; }   ","description":"","id":226,"section":"posts","tags":["模板","输入输出"],"title":"输入输出优化模板","uri":"https://blog.chenqiqian.com/posts/notes-io-optimize/"},{"content":"最近在做红楼的总结，莫名的也就想来写上两句。\n葬花吟-双笙\n怎么说呢。红楼梦这本书，越读越令人悲伤。至六十三回以后，便已无心漫卷，至七十八回以后，也就不想再读下去。\n要依我来见，六十二回即是红楼女儿绝唱，最后一次齐聚的宴欢，最后一次惬意的愉悦。湘云醉卧石上，竟让我恍惚觉得，一切还在半年以前，还在那个春天。\n但世事不复啊。自此以后，大观园中也只剩下了潇湘之悲戚，蘅芜之孤冷。司琴、入画、四儿、芳官、晴雯也一个个离开这如梦似幻的大观园，旧时的欢宴已经不存。贾母月圆夜宴，老人的心里，也知道一切恐也再难挽回，不如「人多些」，好聚好散。\n是啊。盛筵难久，万事终有离散的一天。\n要说读到五十余回，就已经有万千心绪。不知何时，许多原本只能在贾府边缘的许多小人物，竟也如此多在书中出现。似乎从那时往后，红楼一梦已经不再是儿女的情长，不是单纯的情娱与风月，而是家族的凝着血泪的真史。\n女孩，男孩们梦中的生活，怎么可能持久呢。红楼一题早就告诉你，这不过是「真事隐」，不过是「假语存」，不过是「温柔乡里的一场梦幻处」。殊不知，时年从十八回的元宵到六十回的春日，不过是一年轮回。但一年，一年也太长了。所有的事情，都变化了许多。\n 「女孩子在没出嫁前像是一枚珍珠，而出嫁之后就变成了鱼眼珠一般」。\n 红楼梦就在小姐们出嫁时戛然而止了。君不见王夫人的爽利，君不见贾母的风华，君不见宝钗小时的淘气。但时间呵，也许不曾带走什么，但却一定带给了他们无法抗拒的改变。\n不知道是不是在这个年龄，总会有意无意的把自己往主角的位置里带入，而这样也就更能体会到那种心有悲伤而不能语。\n 「眼看他起朱楼， 眼看他宴宾客， 眼看他楼塌了。」\n 就像这样吧。\n如果让我来选，我希望时间能够永远停在那一年的春夏。\n停在并头读西厢。\n停在葬花绝世吟。\n停在海棠诗社起。\n停在那虚幻而又美好，朦胧而又恬美的梦里。\n动情真的是，令人沉迷，也令人癫狂。\n「假作真时真亦假；无为有处有还无。」「身后有余忘缩手，眼前无路想回头」\n情也许就是这样吧。\n来源：Pixiv\n","description":"","id":227,"section":"posts","tags":["红楼梦"],"title":"「红楼一梦」","uri":"https://blog.chenqiqian.com/posts/essay-a-dream-of-red-mansions/"},{"content":"维护一个数列，给定初始的 $n$ 个数字。\n现有六种命令：\n 在第 $pos$ 个数后插入 $tot$ 个数 翻转从第 $pos$ 个数开始的 $tot$ 个数 删除从第 $pos$ 个数开始的 $tot$ 个数 查询从第 $pos$ 个数开始的 $tot$ 个数的和 设定从第 $pos$ 个数开始的 $tot$ 个数设定为 $c$ 查询整个数列中和最大的连续子区间的和  链接 Luogu P2042\n题解 这是一道经典的平衡树的题，被我用来练手非旋$Treap$。\n因为我太弱了，所以写的很痛苦。\n关于合并和分裂的主要思想参见 非旋Treap学习笔记 。\n对于节点，要维护：\n树的大小，树的权值和，树从左端点开始的最大连续和，树从右端点开始的最大连续和，和树的最大连续子区间和。\n主要操作：\n pushdown  往下 $push$ ，修改两个子节点并打上标记。\n pushup  更新所有信息，维护三个 $\\max$ 信息的方式有些特殊，但仔细想想应当能想到。\n这里我被坑了。这个与线段树的区间最大查询有点不太一样，根节点也有代表的数，这个需要记住。\n 建树  构建笛卡尔树。详见 非旋Treap学习笔记 。\n 最大查询连续和  直接输出根节点维护的最大连续子区间的值即可。\n 插入  把即将插入的 $tot$ 个数按照上文的介绍方法建树。\n把原来的数按照 $size$ 裂成两棵树，分别按顺序合起来就可以了。\n接下来的操作都需要裂成三棵树，左边的有 $pos-1$ 个树，中间有 $tot$ 个数。\n 删除  直接删除中间子树，左右合并。因为内存不够（ $64MB$ ），需要垃圾回收。\n 求和  输出中间子树的和，再把三个子树顺次合并起来。\n 翻转  翻转中间子树并打标记，再把三个子树顺次合并起来。\n 设定  对中间子树完成设定并打标记，再将三个子树顺次合并起来。\n还有一点就是垃圾回收。简略来说就是把删除的节点暴力的扔到一个栈里面，然后能用就用，不能有就再新开内存池。\n其他也没有什么重要的。多 pushdown pushup几次，然后这些操作都是要注意边界，也就是 null 时候的条件的。pushup 的合并公式也需要好好斟酌。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 510000; const int MAX = 2147483647; int k,n; struct node_t{ int val,p; int lmax,rmax,maxn,sumn,tag; int size; bool rev,is_tag; node_t *son[2],**null; void pushdown(){ if(this == *null) return; if(is_tag){ son[0]-\u0026gt;cover(tag),son[1]-\u0026gt;cover(tag); is_tag = tag = 0; } if(rev) { son[0]-\u0026gt;reverse(),son[1]-\u0026gt;reverse(); rev = 0; } } void pushup(){ if(this == *null) return; if(son[0] == *null \u0026amp;\u0026amp; son[1] == *null){ size = 1;sumn = lmax = rmax = maxn = val; return; } size = son[0]-\u0026gt;size + son[1]-\u0026gt;size + 1; sumn = son[0]-\u0026gt;sumn + son[1]-\u0026gt;sumn + val; lmax = max(son[0]-\u0026gt;lmax,son[0]-\u0026gt;sumn + val + max(0,son[1]-\u0026gt;lmax)); rmax = max(son[1]-\u0026gt;rmax,son[1]-\u0026gt;sumn + val + max(0,son[0]-\u0026gt;rmax)); maxn = max(0,son[0]-\u0026gt;rmax) + val + max(0,son[1]-\u0026gt;lmax); maxn = max(maxn,max(son[0]-\u0026gt;maxn,son[1]-\u0026gt;maxn)); } void cover(int v){ if(this == *null) return; val = v;sumn = size * v; lmax = rmax = maxn = max(v,sumn); is_tag = 1;tag = v; } void reverse(){ if(this == *null) return; swap(son[0],son[1]); swap(lmax,rmax); rev^=1; } }; struct fhqtreap{ node_t pool[MAXN],*tmp[MAXN],*stack[MAXN],*garbage[MAXN]; node_t *root,*null; int cnt,tot; void newnode(node_t *\u0026amp;r,int val = 0){ if(tot == 0) r = \u0026amp;pool[cnt++]; else r = garbage[--tot];//垃圾回收  r-\u0026gt;val = val;r-\u0026gt;size = 1; r-\u0026gt;lmax = r-\u0026gt;rmax = r-\u0026gt;maxn = r-\u0026gt;sumn = val; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; r-\u0026gt;is_tag = r-\u0026gt;rev = 0; r-\u0026gt;null = \u0026amp;null; r-\u0026gt;p = rand(); } fhqtreap(){ tot = 0;cnt = 0; srand(time(NULL)); newnode(null,-MAX); null-\u0026gt;p = MAX; root = null; null -\u0026gt; sumn = null-\u0026gt;size = 0; } void cycle(node_t *r){ if(r == null) return; garbage[tot++] = r; cycle(r-\u0026gt;son[0]); cycle(r-\u0026gt;son[1]); } void read_tree(int n){ for(int i = 1;i\u0026lt;=n;i++){ int t;scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); newnode(tmp[i],t); } } node_t *build(int n){ read_tree(n); int top = 1; newnode(stack[0],-MAX); stack[0]-\u0026gt;p = -MAX; for(int i = 1;i\u0026lt;=n;i++){ int nowp = top - 1; node_t *r = tmp[i],*pre = null; while(stack[nowp]-\u0026gt;p \u0026gt; r -\u0026gt; p){ stack[nowp]-\u0026gt;pushup(); pre = stack[nowp]; stack[nowp] = null; nowp--; } stack[nowp+1] = stack[nowp]-\u0026gt;son[1] = r; stack[nowp+1]-\u0026gt;son[0] = pre; top = nowp+2; } while(top) stack[--top]-\u0026gt;pushup(); return stack[0]-\u0026gt;son[1]; } void split(node_t *r,int lsize,node_t *\u0026amp;ls,node_t *\u0026amp;rs){ if(r == null){ ls = null;rs = null;return; } r-\u0026gt;pushdown(); if(r-\u0026gt;son[0]-\u0026gt;size + 1 \u0026lt;= lsize){ ls = r; split(r-\u0026gt;son[1],lsize-r-\u0026gt;son[0]-\u0026gt;size-1,ls-\u0026gt;son[1],rs); } else{ rs = r; split(r-\u0026gt;son[0],lsize,ls,rs-\u0026gt;son[0]); } ls-\u0026gt;pushup();rs-\u0026gt;pushup(); } node_t *merge(node_t *ls,node_t *rs){ if(ls == null) return rs; if(rs == null) return ls; if(ls-\u0026gt;p \u0026lt; rs-\u0026gt;p){ ls-\u0026gt;pushdown(); ls-\u0026gt;son[1] = merge(ls-\u0026gt;son[1],rs); ls-\u0026gt;pushup(); return ls; } else{ rs-\u0026gt;pushdown(); rs-\u0026gt;son[0] = merge(ls,rs-\u0026gt;son[0]); rs-\u0026gt;pushup(); return rs; } } void insert(int rank,int n){ if(n == 0) return; node_t *ls,*rs,*newn,*ret; split(root,rank,ls,rs); newn = build(n); root = merge(merge(ls,newn),rs); } void split(int ls,int ms,node_t *\u0026amp;l,node_t *\u0026amp;m,node_t *\u0026amp;r){ node_t *m1; split(root,ls,l,m1); split(m1,ms,m,r); } void erase(int lb,int ms){ if(ms == 0) return; node_t *l,*m,*r,*ret; split(lb-1,ms,l,m,r); cycle(m); root = merge(l,r); } int get_sum(int lb,int ms){ if(ms == 0) return 0; node_t *l,*m,*r; split(lb-1,ms,l,m,r); int ans = m-\u0026gt;sumn; root = merge(l,merge(m,r)); return ans; } int max_sum(){ return root-\u0026gt;maxn; } void reverse(int lb,int ms){ if(ms == 0) return; node_t *l,*m,*r; split(lb-1,ms,l,m,r); m-\u0026gt;reverse(); root = merge(l,merge(m,r)); } void make_same(int lb,int ms,int c){ if(ms == 0) return; node_t *l,*m,*r; split(lb-1,ms,l,m,r); m-\u0026gt;cover(c); root = merge(l,merge(m,r)); } }; fhqtreap w; void init(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k); w.root = w.build(n); } void solve(){ for(int i = 1;i\u0026lt;=k;i++){ char op[50];int a,b,c; scanf(\u0026#34;%s\u0026#34;,op); if(op[0] == \u0026#39;M\u0026#39;\u0026amp;\u0026amp;op[2] == \u0026#39;X\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,w.max_sum()); else{ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); if(op[0] == \u0026#39;I\u0026#39;) w.insert(a,b); else if(op[0] == \u0026#39;D\u0026#39;) w.erase(a,b); else if(op[0] == \u0026#39;G\u0026#39;){ printf(\u0026#34;%d\\n\u0026#34;,w.get_sum(a,b)); } else if(op[0] == \u0026#39;M\u0026#39;){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;c); w.make_same(a,b,c); } else if(op[0] == \u0026#39;R\u0026#39;){ w.reverse(a,b); } } } } int main(){ init(); solve(); return 0; }   ","description":"","id":228,"section":"posts","tags":["Treap","平衡树","数据结构"],"title":"「NOI2005」维护数列-非旋Treap","uri":"https://blog.chenqiqian.com/posts/noi2005-sequence/"},{"content":"非旋 Treap ，是一种不基于旋转的平衡树。它基于 Treap 的树堆思想，并且能够高效的完成某些对区间的操作，而且灵活性比较高。它也可以进行可持久化的操作。\nTreap学习笔记，介绍了基于旋转的 Treap 的基本概念等等，在这里不再赘述。\n代码简述 这里以 这道题题作为模板。\n节点的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  struct node_t{ int val,p,size; // val 是数值，p 是优先级，size 是当前节点代表的区间的大小  bool rev; node_t *son[2],**null; //下放标记  void pushdown(){ if(this == *null) return; if(rev) { son[0]-\u0026gt;reverse(),son[1]-\u0026gt;reverse(); rev = 0; } } //更新节点  void pushup(){ if(this == *null) return; size = son[0]-\u0026gt;size + son[1]-\u0026gt;size + 1; } //反转以当前节点为父节点所代表的区间  void reverse(){ if(this == *null) return; swap(son[0],son[1]); rev^=1; } };   这里的代码很简单，不作赘述。\n不过有一点要说的。这里的双重指针**null的目的主要是让这里的节点能够快速的判断是否这个节点是下面平衡树的null节点。\nTreap结构体定义 \u0026amp; 初始化函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  struct fhqtreap{ node_t pool[MAXN],*tmp[MAXN],*stack[MAXN]; //tmp 和 stack 数组都是为了后面的$O(n)$建树做准备  node_t *root,*null; int cnt; fhqtreap(){ cnt = 0; srand(time(NULL)); newnode(null); null-\u0026gt;p = MAX; root = null; null-\u0026gt;size = 0; } void newnode(node_t *\u0026amp;r,int val = 0){ r = \u0026amp;pool[cnt++];//分配内存  r-\u0026gt;val = val;r-\u0026gt;size = 1; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; r-\u0026gt;rev = 0;//置0  r-\u0026gt;null = \u0026amp;null; r-\u0026gt;p = rand(); }   初始化也没有什么难点。主要需要注意：null的size应当为0，优先级应当是最大的。\n建树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void read_tree(int n){ //把节点全部扔到tmp里面去  for(int i = 1;i\u0026lt;=n;i++) newnode(tmp[i],i); } node_t *build(int n){ read_tree(n); int top = 1; newnode(stack[0],-MAX);stack[0]-\u0026gt;p = -MAX; //需要保证超级根能呆在最上面  for(int i = 1;i\u0026lt;=n;i++){ int nowp = top - 1; node_t *r = tmp[i],*pre = null;// r 是待添加节点  while(stack[nowp]-\u0026gt;p \u0026gt; r -\u0026gt; p){ stack[nowp]-\u0026gt;pushup();//这里需要pushup！因为应当保证下面是一个合法的treap;  pre = stack[nowp]; stack[nowp] = null; nowp--;// 出栈  } stack[nowp+1] = stack[nowp]-\u0026gt;son[1] = r;//把r链接到链上  stack[nowp+1]-\u0026gt;son[0] = pre;//把下面的链连到r的左儿子  top = nowp+2;//更新栈内元素  } while(top) stack[--top]-\u0026gt;pushup();//更新  return stack[0]-\u0026gt;son[1];//返回根节点  }   这里比较复杂。简单来说就是一个笛卡尔树的构造。\n这样做的主要好处是可以在$O(n)$之内完成建树。在这里给出一个链接：Sengxian\u0026rsquo;s Blog,我觉得这位神犇讲的比较通俗易懂。\n其实我们也可以通过一个简单的方式在 $O(n \\log {n})$ 的时间内完成建树，就是一个一个的插入进去。但这样真的，很慢。\n主要步骤如下：\n这里对于 $\\text{p}$ 而言，我们构造小根堆。\n我们将一个节点表示为：$(\\text{key}, \\text{p})$。首先将所有节点按照 $\\text{key}$ 从小到大排序。在这里，\u0008就是我们的序列顺序。\n引入一个栈，栈底存放一个元素 $(-\\infty, -\\infty)$，表示超级根，这样保证它总在最上面，他的右儿子即为我们真正的树根。这个栈，维护了笛卡尔树最右边的一条链上面的元素。（始终往右的一条链）\n从前往后遍历 $(\\text{key}, \\text{p})$：\n 对于每一个 $(\\text{key}_i, \\text{p}_i)$，从栈中找出（从栈顶往栈底遍历）第一个$p$小于等于 $\\text{p}_i$ 的元素 $j$。\n  将 $j$ 之上即 $\\text{p} \u0026gt; \\text{p}_o$ 的点全部弹出。\n  我们在这里记 $j$ 的右子节点为 $pre$ 。在树中，将 $pre$ 挂在 $j$ 的左子树上，将 $r$ 挂在原来 $j$ 的右子树的位置。\n 可以证明这个构造的时间复杂度是 $O(n)$ 。\n以上关于笛卡尔树的介绍转载自Sengxian的Blog，略有改写。\n分裂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //分裂为两颗子树，左子树的大小为lsize void split(node_t *r,int lsize,node_t *\u0026amp;ls,node_t *\u0026amp;rs){ if(r == null){//边界  ls = null;rs = null; return; } r-\u0026gt;pushdown();//很重要！  if(r-\u0026gt;son[0]-\u0026gt;size + 1 \u0026lt;= lsize){ ls = r; split(r-\u0026gt;son[1],lsize - r-\u0026gt;son[0]-\u0026gt;size - 1,ls-\u0026gt;son[1],rs); } else{ rs = r; split(r-\u0026gt;son[0],lsize,ls,rs-\u0026gt;son[0]); } ls-\u0026gt;pushup();rs-\u0026gt;pushup(); }   看起来很难，但其实很简单。\n我们面临的只有一个问题：当前节点属于左子树还是右子树？\n判定标准一般是数值大小或者排名来决定的。\n 如果我们判定当前根节点属于分裂后左子树，那么根节点的左子树就一定属于分裂后的左子树，那么我们只需要关心根节点的右子树属于分裂后那颗子树了，然后这个就可以递归下去了；判定属于分裂后的右子树是同理的。\n 代码也没有什么注意事项。可以证明，分裂的时间复杂度是 $O(\\log {n})$ 。\n合并 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  node_t *merge(node_t *ls,node_t *rs){ if(ls == null) return rs; if(rs == null) return ls; // 边界  if(ls-\u0026gt;p \u0026lt; rs-\u0026gt;p){ ls-\u0026gt;pushdown(); //需要pushdown！  ls-\u0026gt;son[1] = merge(ls-\u0026gt;son[1],rs); ls-\u0026gt;pushup();//需要pushup！  return ls; } else{ rs-\u0026gt;pushdown();//需要pushdown！  rs-\u0026gt;son[0] = merge(ls,rs-\u0026gt;son[0]); rs-\u0026gt;pushup();//需要pushup！  return rs; } }   这个和分裂也是类似的。\n我们的主要任务变成了判断：左子树右子树的根节点哪个应该放在总树的根节点？\n判断的依据十分显然。就是两个根节点的优先值。结合上面的分裂，我们也可以发现这里的递归规律：\n 如果合并后根节点是左子树的根节点，那么我们就可以把整个左子树的左子树保留下来，从而把左子树的右子树和右子树一起合并到左子树的右子树，然后左子树就可以作为返回的节点了。右子树同理。\n 可以证明，合并的时间复杂度也是 $O(\\log {n})$ 。\nsplit to three 1 2 3 4 5 6  //ls是左子树的size，rs是中间子树的size void split(int ls,int ms,node_t *\u0026amp;l,node_t *\u0026amp;m,node_t *\u0026amp;r){ node_t *m1; split(root,ls,l,m1); split(m1,ms,m,r); }   太简单了，不说这个。\n区间翻转 1 2 3 4 5 6 7  //这里使用的是左边和右边的边界 void reverse(int lb,int rb){ node_t *l,*m,*r; split(lb-1,rb-lb+1,l,m,r); m-\u0026gt;reverse(); root = merge(l,merge(m,r)); }   也不太想说。主要就是要注意一点。我们在这里，要保证打过标记以后，这个节点的信息已然正确。这个在其他的例题里会比较令人舒服，可以减少一些pushdown。\n虽然这道题只有区间翻转，但是其他的区间操作也可以同理完成。Splay能做的，非旋Treap都能做，而且他还可以进行持久化，这是Splay比不了的。（然而我并不会写\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208  #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int MAXN = 510000; const int MAX = 2147483647; /*以下为输入输出优化*/ namespace fast_IO { inline char read() { static const int IN_LEN = 1000000; static char buf[IN_LEN], *s, *t; return s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),*s++:*s++; } inline void read(int \u0026amp;x) { static bool iosig; static char c; for (iosig = false, c = read(); !isdigit(c); c = read()) { if (c == \u0026#39;-\u0026#39;) iosig = true; if (c == -1) return; } for (x = 0; isdigit(c); c = read()) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (c ^ \u0026#39;0\u0026#39;); if (iosig) x = -x; } const int OUT_LEN = 10000000; char obuf[OUT_LEN], *ooh = obuf; inline void print(char c) { if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf; *ooh++ = c; } inline void print(int x) { static int buf[30], cnt; if (x == 0) { print(\u0026#39;0\u0026#39;); } else { if (x \u0026lt; 0) print(\u0026#39;-\u0026#39;), x = -x; for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48; while (cnt) print((char)buf[cnt--]); } } inline void flush() { fwrite(obuf, 1, ooh - obuf, stdout); } }using namespace fast_IO; /*以上为输入输出优化*/ int k,n; struct node_t{ int val,p,size; bool rev; node_t *son[2],**null; void pushdown(){ if(this == *null) return; if(rev) { son[0]-\u0026gt;reverse(),son[1]-\u0026gt;reverse(); rev = 0; } } void pushup(){ if(this == *null) return; size = son[0]-\u0026gt;size + son[1]-\u0026gt;size + 1; } void reverse(){ if(this == *null) return; swap(son[0],son[1]); rev^=1; } }; struct fhqtreap{ node_t pool[MAXN],*tmp[MAXN],*stack[MAXN]; node_t *root,*null; int cnt,tot; void newnode(node_t *\u0026amp;r,int val = 0){ r = \u0026amp;pool[cnt++]; r-\u0026gt;val = val;r-\u0026gt;size = 1; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null;r-\u0026gt;rev = 0; r-\u0026gt;null = \u0026amp;null; r-\u0026gt;p = rand(); } fhqtreap(){ cnt = 0; srand(time(NULL)); newnode(null); null-\u0026gt;p = MAX; root = null; null-\u0026gt;size = 0; } void read_tree(int n){ for(int i = 1;i\u0026lt;=n;i++) newnode(tmp[i],i); } node_t *build(int n){ read_tree(n); int top = 1; newnode(stack[0],-MAX); stack[0]-\u0026gt;p = -MAX; for(int i = 1;i\u0026lt;=n;i++){ int nowp = top - 1; node_t *r = tmp[i],*pre = null; while(stack[nowp]-\u0026gt;p \u0026gt; r -\u0026gt; p){ stack[nowp]-\u0026gt;pushup(); pre = stack[nowp]; stack[nowp] = null; nowp--; } stack[nowp+1] = stack[nowp]-\u0026gt;son[1] = r; stack[nowp+1]-\u0026gt;son[0] = pre; top = nowp+2; } while(top) stack[--top]-\u0026gt;pushup(); return stack[0]-\u0026gt;son[1]; } void split(node_t *r,int lsize,node_t *\u0026amp;ls,node_t *\u0026amp;rs){ if(r == null){ ls = null;rs = null; return; } r-\u0026gt;pushdown(); if(r-\u0026gt;son[0]-\u0026gt;size + 1 \u0026lt;= lsize){ ls = r; split(r-\u0026gt;son[1],lsize - r-\u0026gt;son[0]-\u0026gt;size - 1,ls-\u0026gt;son[1],rs); } else{ rs = r; split(r-\u0026gt;son[0],lsize,ls,rs-\u0026gt;son[0]); } ls-\u0026gt;pushup();rs-\u0026gt;pushup(); } node_t *merge(node_t *ls,node_t *rs){ if(ls == null) return rs; if(rs == null) return ls; if(ls-\u0026gt;p \u0026lt; rs-\u0026gt;p){ ls-\u0026gt;pushdown(); ls-\u0026gt;son[1] = merge(ls-\u0026gt;son[1],rs); ls-\u0026gt;pushup(); return ls; } else{ rs-\u0026gt;pushdown(); rs-\u0026gt;son[0] = merge(ls,rs-\u0026gt;son[0]); rs-\u0026gt;pushup(); return rs; } } void split(int ls,int ms,node_t *\u0026amp;l,node_t *\u0026amp;m,node_t *\u0026amp;r){ node_t *m1; split(root,ls,l,m1); split(m1,ms,m,r); } void reverse(int lb,int rb){ node_t *l,*m,*r; split(lb-1,rb-lb+1,l,m,r); m-\u0026gt;reverse(); root = merge(l,merge(m,r)); } void output(node_t *r,int *a){ if(r == null) return; r-\u0026gt;pushdown(); output(r-\u0026gt;son[0],a); a[r-\u0026gt;son[0]-\u0026gt;size] = r-\u0026gt;val; output(r-\u0026gt;son[1],a + r-\u0026gt;son[0]-\u0026gt;size+1); } void print(node_t *r = NULL,int depth = 0){ if(r == NULL) r = root; if(r == null) return; print(r-\u0026gt;son[0],depth+1); for(int i = 0;i\u0026lt;depth;i++) putchar(\u0026#39; \u0026#39;); printf(\u0026#34;val:%d p:%d size:%d son:%d %d rev?:%d\\n\u0026#34;,r-\u0026gt;val,r-\u0026gt;p,r-\u0026gt;size,r-\u0026gt;son[0] != null,r-\u0026gt;son[1] != null,r-\u0026gt;rev); print(r-\u0026gt;son[1],depth+1); return; } }; fhqtreap w; int ans[MAXN]; void init(){ read(n),read(k); w.root = w.build(n); } void solve(){ int a,b; for(int i = 1;i\u0026lt;=k;i++){ read(a),read(b); w.reverse(a,b); } w.output(w.root,ans); for(int i = 0;i\u0026lt;n;i++){ print(ans[i]);print(\u0026#39; \u0026#39;); } print(\u0026#39;\\n\u0026#39;); } int main(){ init(); solve(); flush(); return 0; }   例题 「NOI2005」维护数列-非旋Treap\n一些参考 这里有一些讲非旋转$Treap$的博客：\nSengxian\u0026rsquo;s Blog\nxehoth\u0026rsquo;s Blog\nMemphis\u0026rsquo;s Blog\n","description":"","id":229,"section":"posts","tags":["Treap","平衡树","数据结构","模板"],"title":"非旋Treap学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-none-rotating-treap/"},{"content":"初始时，第 $i$ 号战舰处于第 $i$ 列 $(i = 1, 2, …, 30000)$ 。\n有两种指令：\n合并指令为 M i j ，含义为将第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。\n询问指令为 C i j 。该指令意思询问第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n链接 Luogu P1196\n题解 一道并查集的题目。\n因为快速的寻找两个战舰是否在同一列里面，我们可以使用并查集数据结构。但注意到题目还要询问两个战舰之间的距离，我们需要额外维护一些信息，所以我们需要用加权的并查集。\n说的加权，事实上就是在每一个节点上额外维护一些信息。在这里，我们在节点上额外维护到父节点的距离，在根节点处维护这个集合的大小。\n在寻找某个节点的时候，我们仍然可以进行路径压缩。只需要先对父节点递归完成后，把权值加上父节点的权值，然后就可以直接连到根上。\n合并操作也差不多。为了使合并操作简单，我们需要保证父节点一定在子节点前面。这样，我们找到的根节点就是每个队列的最前方的节点。然后可以将后面接上的节点的父亲指向前面的节点，距离设为前面的集合的大小，就可以维护了。\n查询距离的时候，只需要把两个节点到根的距离算出来，作差取绝对值，然后再减去1即可。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#define MAXN 30010 using namespace std; int f[MAXN],d[MAXN],s[MAXN],t; // f 维护父亲节点，d 维护于父亲节点的距离，s 在根节点处维护集合的元素数  int find(int x){ if(f[x] == x){ return x; } else{ int w = find(f[x]); d[x] += d[f[x]]; f[x] = w; return w; } } void un(int x,int y){ int b = find(y),e = find(x); if(b == e){ return; } else{ d[e] = s[b],d[b] = 0; s[b] = s[b] + s[e],s[e] = 0; f[e] = b; return; } } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); for(int i = 1;i\u0026lt;MAXN;i++){ f[i] = i,d[i] = 0,s[i] = 1; } for(int i = 1;i\u0026lt;=t;i++){ char op[20];int a,b; scanf(\u0026#34;%s\u0026#34;,op); scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); if(op[0] == \u0026#39;M\u0026#39;){ un(a,b); } else{ int a1 = find(a),b1 = find(b); if(a1!=b1){ printf(\u0026#34;-1\\n\u0026#34;); } else{ printf(\u0026#34;%d\\n\u0026#34;,abs(d[a]-d[b])-1); } } } return 0; }   ","description":"","id":230,"section":"posts","tags":["数据结构","并查集"],"title":"「NOI2002」银河英雄传说-并查集","uri":"https://blog.chenqiqian.com/posts/noi2002-hero/"},{"content":"Dinic算法是一种用于网络流中最大流的增广路算法，其时间复杂度为$O(n^2 \\times m)$，但大多数情况下会远远优于此时间复杂度。\n基本概念 从Menci神犇的博客复制而来。我觉得这写的是很好的一篇介绍，除了代码风格不太喜欢。\n  容量： ${capacity}(e)$ 表示一条有向边 $e(u,v)$ 的最大允许的流量。\n  流量： ${flow}(e)$ 表示一条有向边 $e(u,v)$ 总容量中已被占用的流量。\n  剩余容量（残量）：即 $capacity(e)−flow(e)$，表示当前时刻某条有向边 $e(u,v)$ 总流量中未被占用的部分。\n  反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为$0$，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n  残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n  增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为增广流量。\n  增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上增广流量的过程。\n  层次： $level(u)$ 表示节点 $u$ 在层次图中与源点的距离。\n  层次图：在原残量网络中按照每个节点的层次来分层，只保留相邻两层的节点的图，满载（即流量等于容量）的边不存在于层次图中。\n  思路 用文字叙述大概如下：\n1. 建立以出发点为源点的层次图（即源点到各店的距离） 2. 在层次图\u0026amp;残量网络中寻找增广路，并增广流量 3. 重复2直到找不到增广路 4. 重复123直到不存在层次图 实现 建立层次图使用bfs，而寻找增广路则是使用dfs递归增广。\n具体实现的时候也有一定的技巧，在代码里面有注释。\n反向边存在的意义是什么呢？形象来说其实就是给你一个后悔的机会，往一边流去之后还能再回来。注意反向边的容量在我这里初始为0。\n有一个优化就是当前弧优化。这个优化是很显而易见的。如果这条边在当前层次图下找不到路，那么这条边在当前层次图内就再也不会用到。所以我们单开一个cur数组，记录目前遍历到的边，这样就可以进行优化。\n代码 以Luogu P3376为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; struct Edge{ int from,to,flow,cap; int next; }edge[201000]; int fir[10100],dis[10100],cur[10100]; int n,m,s,t,tot = 2;//tot从2开始是最舒服的，既可以直接异或，后面的终止条件也不用想来想去。  bool bfs(){ queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis)); memcpy(cur,fir,sizeof(fir));//清空当前边  q.push(s);dis[s] = 1; while(!q.empty()){ int nown = q.front();q.pop(); for(int nowe = fir[nown];nowe!=0;nowe = edge[nowe].next){ int v = edge[nowe].to; if(dis[v] == 0 \u0026amp;\u0026amp; edge[nowe].cap \u0026gt; edge[nowe].flow){ //两个条件：未遍历而且边可以增广  dis[v] = dis[nown]+1; q.push(v); //由于我们只沿最短路增广，所以这里就可以直接break掉了。  if(v == t) return dis[t]; } } } return dis[t]; } int dfs(int nown,int limit = 0x3f3f3f3f){ //找到终点或没得可找 这个优化很重要  if(nown == t || limit == 0) return limit; for(int \u0026amp;nowe = cur[nown];nowe!=0;nowe = edge[nowe].next){ //这里有当前弧优化  int v = edge[nowe].to; if(dis[v] == dis[nown]+1 \u0026amp;\u0026amp; edge[nowe].flow \u0026lt; edge[nowe].cap){ //满足层次图条件(沿着最短路)  int f = dfs(v,min(edge[nowe].cap-edge[nowe].flow,limit)); if(f\u0026gt;0){ //更改当前边  edge[nowe].flow+=f; edge[nowe^1].flow-=f; return f; } } } return 0; } int dinic(){ int ans = 0,f; while(bfs()){//bfs是步骤1  while( (f = dfs(s)) \u0026gt; 0)//dfs是步骤2  ans+=f; } return ans; } void addedge(int a,int b,int c){ edge[tot].from = a;edge[tot].to = b; edge[tot].cap = c;edge[tot].flow = 0; edge[tot].next = fir[a];fir[a] = tot; tot++; } int main(){ scanf(\u0026#34;%d %d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s,\u0026amp;t); for(int i = 0;i\u0026lt;m;i++){ int a,b,c; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); addedge(a,b,c); addedge(b,a,0);//需要加反向边  } printf(\u0026#34;%d\\n\u0026#34;,dinic()); return 0; }   ","description":"","id":231,"section":"posts","tags":["图论","Dinic","模板"],"title":"Dinic学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-dinic/"},{"content":"有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。我们假设每个人只能睡和自己直接认识的人的床。我们已知一共有 $n$ 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n链接 Luogu P2055\n题解 这道题其实\u0008可以转化成二分图匹配的问题。如果把所有不回家的在校生和前来探访的朋友放在二分图一侧，所有\u0008本校学生床放在二分图另一侧，再将认识的人\u0026amp;床连边（包括自己和自己的床），注意上面的\u0008人不包括回家的人。\n然后就是一个模版的二分图匹配了。然而我只会写网络流，所以写了一个 Dinic 上去，使用了单路增广\u0026amp;当前弧优化。\n然而开始调了一个下午也没调对。然而回家调了一个晚上也没调对。\u0008\u0008\u0008最后还算是调对了。奇怪的是我今天又敲了另一个 Dinic ，然后竟然1次 AC 了。\u0008缘妙不可言啊。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; struct Edge{ int from,to,flow,cap; int next; }edge[20000]; int fir[300],dis[300],cur[300]; int n,T,home[300],local[300],s,t,tot; bool bfs(){ queue\u0026lt;int\u0026gt; q; memset(dis,0,sizeof(dis)); memcpy(cur,fir,sizeof(fir)); q.push(s);dis[s] = 1; while(!q.empty()){ int nown = q.front();q.pop(); for(int e = fir[nown];e!=0;e = edge[e].next){ int v = edge[e].to; if(dis[v] == 0 \u0026amp;\u0026amp; edge[e].cap \u0026gt; edge[e].flow){ dis[v] = dis[nown]+1; q.push(v); } } } return dis[t]; } int dfs(int nown,int limit = 0x3f3f3f3f){ if(nown == t || limit == 0) return limit; for(int \u0026amp;e = cur[nown];e!=0;e = edge[e].next){ int f,v = edge[e].to; if(dis[v] == dis[nown]+1\u0026amp;\u0026amp;edge[e].flow \u0026lt;edge[e].cap){ int f = dfs(v,min(edge[e].cap-edge[e].flow,limit)); if(f\u0026gt;0){ edge[e].flow+=f; edge[e^1].flow-=f; return f; } } } return 0; } int dinic(){ int ans = 0,f; while(bfs()){ while((f = dfs(s)\u0026gt;0)) ans+=f; } return ans; } void addedge(int from,int to,int c){ edge[tot].from = from;edge[tot].to = to; edge[tot].cap = c;edge[tot].flow = 0; edge[tot].next = fir[from];fir[from] = tot; tot++; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(int i = 1;i\u0026lt;=T;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //清零  memset(edge,0,sizeof(edge)); memset(home,0,sizeof(home)); memset(local,0,sizeof(local)); memset(fir,0,sizeof(fir)); tot = 2;int cnt = 0; s = 2*n+1,t = 2*n+2; //是否\u0008本校  for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;local[i]); } //是否回家  for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;home[i]); if(local[i] == 0) home[i] = 0; } //是否认识且符合条件  for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n;j++){ int tmp;scanf(\u0026#34;%d\u0026#34;,\u0026amp;tmp); if(i == j) tmp = 1; if(home[i] == 1||local[j] == 0||tmp == 0) continue; else addedge(i,j+n,1),addedge(j+n,i,0); } } //超级源点\u0026amp;\u0026amp;汇点  for(int i = 1;i\u0026lt;=n;i++){ if(home[i] == 0) addedge(s,i,1),addedge(i,s,0),cnt++; if(local[i] == 1) addedge(i+n,t,1),addedge(t,i+n,0); } if(dinic()==cnt) printf(\u0026#34;^_^\\n\u0026#34;); else printf(\u0026#34;T_T\\n\u0026#34;); } return 0; }   ","description":"","id":232,"section":"posts","tags":["图论","二分图匹配","Dinic"],"title":"「ZJOI2009」假期的宿舍-二分图匹配","uri":"https://blog.chenqiqian.com/posts/zjoi2009-vacation/"},{"content":"这篇\u0008主要介绍在序列上的无修改以及带修改的离线莫队算法。\n简介 莫队算法是一个充满着暴力美学的算法。\n莫队算法主要是用来解决一些离线无修改的区间查询问题，实现起来相比比较的简单。而莫队算法的主要用在线段树等数据结构无法在很短时间内实现区间信息合并的情况。\n莫队算法 核心思想 首先莫队算法的使用情景在上面已经提及。那么接下来让我们以一个实例来理解莫队算法。\n 有一个正整数序列$A$，$m$次询问在$[l,r]$区间内有多少个不同的数。(HH的项链)\n 一般来说，我们会想到使用线段树，但这种情况下，我们并不能很快（比如$O(1)$ ）的完成两个区间信息的合并，所以说线段树在这里是起不了作用的。\n但是，我们注意到，如果采用适当的方法，我们可以在常数时间内由$[l,r]$区间得到$[l-1,r]$和$[l,r+1]$的信息，只需要记录一下这个数出现的次数，然后增加的时候判一下是否为空即可。同理，略加思考，我们也可以发现从$[l,r]$区间得到$[l+1,r]$和$[l,r-1]$的信息的方法。\n所以如果我们直接对左端点排序，然后暴力转移的话，那么这个算法的时间复杂度在最坏情况下是$O(n^2)$的。\n这个时候就要用莫队的思想来简化这个时间复杂度。\n我们注意到，在$O(n^2)$算法中，每一次的左右端点最坏要移动$n$次。能不能想一个办法，让这个移动次数变小呢？如果通过某种方法排序后，能够使得某些相邻的查询移动变小，那么我们可以优化时间复杂度。但同时注意到，优化了一个移动的同时，会导致那些被排除出上文提到的相邻的查询之间的移动变大一些。所以事实上我们是在寻求一个平衡。\n我们可以采用分块的办法。假设我们的分块大小是$Q$,那么应该一共有$\\frac{n}{Q}$个块。分块之后，按照左端点所在的块的序号为第一关键字，右端点的位置为第二关键字排序。这句话很重要，其实就是莫队的核心实现吧。\n然后，暴力转移。\n然后可以注意到，不论是在同一个块内的移动，还是跨块的移动，左端点最多转移的次数是在$Q$的级别的，一共$m$次查询，那么总共转移$mQ$次。而右端点的移动，在一个块内的时候，由于肯定是单调递增，所以每查询过一个块，左端点转移$n$次，一共有$\\frac{n}{Q}$个块，所以右端点的移动总共就是$\\frac{n^2}{Q}$次。\n总共合起来，时间复杂度就是$O(T\\times(\\frac{n^2}{Q}+mQ))$，T为一次状态转移的时间。利用一些基础复杂的数学知识，可以发现当$Q = \\sqrt{n}$的时候，这个式子的值最小，是$O(T\\times(m+n)\\sqrt{n})$，这也就是基础莫队算法的时间复杂度。不过在具体实现中，精确的$\\sqrt{n}$\u0008未必就是最快的，有可能需要乘个常数啥的。不过大致是吧。\n具体实现 \u0008莫队的实现超级简单。\u0008不过我因为我太蒻了，开始还是没有想明白。其实就是先扩大，后缩小，一个一个暴力转移。\n代码如下。\n1 2 3 4 5 6 7 8 9 10 11  //ql,qr 为查询区间，l,r为当前区间 //add 和 del 是自定义的转移函数 //注意自增自减的时间 while(ql\u0026lt;l) add(--l); while(r\u0026lt;qr) add(++r); while(l\u0026lt;ql) del(l++); while(qr\u0026lt;r) del(r--);   超级简单吧！\n值的一提的是，在我去北京冬令营的时候，台上的神犇说：\n 莫队的卡常有个小技巧：你奇数的右端点正序排，偶数的右端点逆序排，就可以压掉一半的常数了！\n 听起来很有道理，但我没有试过。\n例题 「SDOI2009」HH的项链-莫队or树状数组\n[国家集训队]小Z的袜子 （题解待补\n带修改莫队算法 待修改的莫队就是可以支持一些简单的修改的莫队算法。\n核心思想 基本上与前面的基础算法类似。假设这里的修改有$t$次。这里的排序一般是分块之后，按照左端点所在的块的序号为第一关键字，右端点所在的块的序号为第二关键字，更改的次数为第三关键字排序。\n这里我们取分块的大小为$n^{\\frac{2}{3}}$，那么有$n^{\\frac{1}{3}}$个块，可以算出算法的时间复杂度是$O(T \\times n^{\\frac{5}{3}})$。（然而并不太懂怎么推出来这个的\u0026hellip;哪位巨佬知道请教一下 非常感谢\n具体实现 类似，不写了。\n1  //一段时间复杂度为O(n^5/3)的代码。   需要注意，如果单点修改有一个小技巧，就是每次不是更改成待更改数，而是swap当前数和待更改数，这样就可以简单的做更改了。\n例题 「国家集训队」数颜色-带修改莫队\n","description":"","id":233,"section":"posts","tags":["莫队","模板"],"title":"莫队算法学习笔记（一）","uri":"https://blog.chenqiqian.com/posts/notes-mo-algorithm-1/"},{"content":"给定一个长度为 $n$ 的正整数序列 $A$ ,有 $m$ 次询问在 $[l,r]$ 区间内有多少个不同的数。\n链接 Luogu P1972\n题解 这道题目前我只会两种离线的做法。\n做法一：莫队 其实做这道题的时候我是不会莫队了。但现在会了，又想写篇莫队的笔记，所以我把这篇题解写出来了。\n首先对序列分块，以查询的左端点所在块的序号为第一关键字，右端点的位置为第二关键字排序，然后暴力转移。\n时间复杂度： $O((m+n) \\sqrt{n})$ 或者简单点： $O(n^\\frac{3}{2})$\n代码见最后。\n做法二：离散化+树状数组 注意到，我们最重要的需要处理的就是重复的问题。如果不需要处理重复的问题，那么就可以直接用树状数组或者前缀和出解了。所以我们考虑到这样一个事情，能否使用某些玄学高端操作，使得我们不需要考虑重复的问题呢？\n可以发现，如果一个数已经出现，那么我们就不需要考虑这个数在其他位置上的出现。因此我们有如下的思路：\n把查询按照查询的右端点位置从小到大排序。为了发现某个数是否会在我们的查询的序列中出现，我们需要记录这个数最后一次在序列中出现的位置。如果查询区间的左端点在这个数的位置以左，那么查询区间内一定有这个数；而在这个数以右的话，查询区间里一定没有这个数。由于这个数出现多少次我们都只能算一次，所以这个最后出现的数就是我们判断是否含有这个数的依据。\n所以我们在树状数组中只给每个数最后出现的这一位赋值 $1$ ,其余的由于上述，不能计入个数，值也就是 $0$ 。这样操作就满足了区间可减性，然后直接树状数组前缀和相减就可以得到每次的结果。\n由于数字的范围较大，应该需要离散化。但由于这个跟时间复杂度关系不大，只与空间复杂度有关，所以我就没有这么写。\n时间复杂度：$O((m+n) \\log{n})$ 或者大体来说 $O(n \\log{n})$\n代码见下。\n代码 这里提供两种方法的代码。\n莫队代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; struct Query{ int id,l,r; }query[201000]; int times[1001000],res[201000],num[51000]; int n,m,q; bool cmp(Query a,Query b){ if(a.l/q!=b.l/q) return a.l/q\u0026lt;b.l/q; else return a.r\u0026lt;b.r; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); q = sqrt(n);//q是分块大小  for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 0;i\u0026lt;m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;query[i].l,\u0026amp;query[i].r); query[i].id = i; } sort(query,query+m,cmp);//排序  int l = 1,r = 1; int ans = 1;times[num[1]]++; for(int i = 0;i\u0026lt;m;i++){ int ql = query[i].l,qr = query[i].r; //转移时先扩大再缩小  while(ql\u0026lt;l){ l--; if(times[num[l]]++ == 0) ans++; } while(r\u0026lt;qr){ r++; if(times[num[r]]++ == 0) ans++; } while(l\u0026lt;ql){ if(--times[num[l]] == 0) ans--; l++; } while(qr\u0026lt;r){ if(--times[num[r]] == 0) ans--; r--; } res[query[i].id] = ans; } for(int i = 0;i\u0026lt;m;i++) printf(\u0026#34;%d\\n\u0026#34;,res[i]); return 0; }   离散化+树状数组代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; inline int lowbit(int x){ return x\u0026amp;(-x); } int n,m,num[51000],ans[201000],last[1001000]; int tree[201000]; struct que{ int id,l,r,res; }qq[1000000]; bool cmp(que a,que b){ if(a.r!=b.r) return a.r\u0026lt;b.r; return a.l\u0026lt;b.l; } inline void insert(int nown,int val){ for(int i = nown;i\u0026lt;=n;i+=lowbit(i)) tree[i]+=val; } inline int query(int nown){ int res = 0; for(int i = nown;i\u0026gt;0;i-=lowbit(i)) res += tree[i]; return res; } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i = 0;i\u0026lt;m;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;qq[i].l,\u0026amp;qq[i].r); qq[i].id = i; } sort(qq,qq+m,cmp); int end = 0; for(int i = 0;i\u0026lt;m;i++){ while(end\u0026lt;qq[i].r){//更新last\u0026amp;树状数组  end++; if(last[num[end]]!=0)//原来出现过就抹去last位置的数  insert(last[num[end]],-1); insert(end,1);//树状数组加入新标记  last[num[end]] = end;//更新last值  } ans[qq[i].id] = query(qq[i].r) - query(qq[i].l-1); } for(int i = 0;i\u0026lt;m;i++) printf(\u0026#34;%d\\n\u0026#34;,ans[i]); return 0; }   ","description":"","id":234,"section":"posts","tags":["莫队","树状数组"],"title":"「SDOI2009」HH的项链-莫队or树状数组","uri":"https://blog.chenqiqian.com/posts/sdoi2009-necklace/"},{"content":"维护一个序列，第 $i$ 次操作时寻找第i小的数的所在位置 $P_i$,并将 $(P _ {i-1},P _ {i}]$ 的\u0008区间翻转。\n如果有相同的数，必须保证排序后它们的相对位置关系与初始时相同。\n链接 Luogu P3165\n题解 这道题的大意是区间\u0008寻找，区间翻转，所以我们\u0008可以用\u0008Splay来做，维护一个 $size$ 值和区间翻转的 $rev$ 标记。虽然我前几天还说再也不用Splay了（逃。\n注意到每次操作都会使第 $i$ 个数排序完成，所以我们每次的 $P _ {i}$ 事实上就是数组下标的 $i-1$ 。\n对于区间的寻找，我们注意到可以在开始的时候就记录下来\u0008第 $i$ 小的数的位置，也就是把他们的指针存在一个\u0008数组\u0008里面。\n然后在查询的时候，先把第 $i-1$ 大的节点 splay 到根；找到第 $i$ 小的数对应的节点指针，寻找其在排序二叉树中的后继节点（图中红色节点），然后把\u0008后继 splay 到根的右子树。\n但注意在实际查找中，\u0008因为寻找后继会破坏根结点，所以要先找到后继节点，然后再完成上述操作。\n然后\u0008关于位置，我们可以看出，根节点左边（包括根结点），也就是图中的绿色部分应当有 $i-1$ 个数，而其他在 $i$ 左边（包括 $i$ ）的数应该就是图中的蓝色部分，所以只要将蓝色部分的 $size$ 加上一个$i-1$就是每一次操作的结果。\n翻转就是常规的区间翻转，打标记 pushdown 什么的。\n为了方便满足一些\u0008\u0008它的要求，\u0008我还事先做了\u0008离散化的处理。（其实并没有什么\u0008用\n另外还有就是我写的时候还因为少 push_down 了几次被\u0008坑了\u0008一下。不过最后一次过评测还是蛮开心的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; struct wupin{ int id,h; }w[100100]; struct splay_t{ struct node_t{ int val,size; bool rev; node_t *p,*son[2],**root,**null; inline bool get_p(){return p-\u0026gt;son[1] == this;} inline void init(node_t **root,node_t **null){this-\u0026gt;null = null,this-\u0026gt;root = root;} inline int lsize(){return son[0]-\u0026gt;size;} inline int rsize(){return son[1]-\u0026gt;size;} inline void update(){size = lsize()+rsize()+1;} inline void link(node_t *dst,int tmp){ dst-\u0026gt;son[tmp] = this; this-\u0026gt;p = dst; } inline void push_down(){ if(this == *null) return; if(rev){ swap(son[0],son[1]); son[0]-\u0026gt;rev^=1,son[1]-\u0026gt;rev^=1; rev = 0; } } inline void rotate(){ p-\u0026gt;push_down(),push_down(); node_t *rp = p;bool re = get_p(); link(rp-\u0026gt;p,rp-\u0026gt;get_p()); son[1-re]-\u0026gt;link(rp,re); rp-\u0026gt;link(this,1-re); rp-\u0026gt;update(),update(); if(p == *null) *root = this; } inline node_t* splay(node_t *tar = NULL){ if(tar == NULL) tar = *null; p-\u0026gt;push_down(),push_down(); while(p!=tar){ if(p-\u0026gt;p == tar) rotate(); else if(p-\u0026gt;get_p() == get_p()) p-\u0026gt;rotate(),rotate(); else rotate(),rotate(); } return this; } inline node_t *upper(){ splay(); node_t *r = son[1]; while(true){ r-\u0026gt;push_down(); if(r-\u0026gt;son[0] == *null) break; r = r-\u0026gt;son[0]; } return r; } }; int cnt; node_t pool[110000],*to[110000],*null,*root; splay_t(){ cnt = 0; null = newnode(); null-\u0026gt;size = 0; } node_t *newnode(int val = 0){ node_t *r = \u0026amp;pool[cnt++]; r-\u0026gt;init(\u0026amp;root,\u0026amp;null); r-\u0026gt;val = val,r-\u0026gt;size = 1,r-\u0026gt;rev = 0; r-\u0026gt;p = r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; return r; } node_t* build(wupin *a,int l,int r){ if(l\u0026gt;r) return null; int mid = (l+r)\u0026gt;\u0026gt;1; node_t *ret = newnode(a[mid].h); to[a[mid].h] = ret; build(a,l,mid-1)-\u0026gt;link(ret,0); build(a,mid+1,r)-\u0026gt;link(ret,1); ret-\u0026gt;update(); return ret; } }; splay_t s; int n; bool cmp1(wupin a,wupin b){return a.id\u0026lt;b.id;} bool cmp2(wupin a,wupin b){ if(a.h!=b.h) return a.h\u0026lt;b.h; else return a.id\u0026lt;b.id; } void find(){ for(int i = 1;i\u0026lt;=n;i++){ //找到应操作节点的后继  splay_t::node_t *rbound = s.to[i]-\u0026gt;upper(); //把前面归位好的最后一个节点旋到根节点  s.to[i-1]-\u0026gt;splay(); //把后继旋转到根节点的右儿子  rbound-\u0026gt;splay(s.to[i-1]); //打印位置  printf(\u0026#34;%d \u0026#34;,i + rbound-\u0026gt;lsize()-1); //添加lazy标记  rbound-\u0026gt;son[0]-\u0026gt;rev^=1; } } int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i].h); w[i].id = i; } //预处理  sort(w+1,w+n+1,cmp2); for(int i = 1;i\u0026lt;=n;i++) w[i].h = i; sort(w+1,w+n+1,cmp1); w[0].h = 0; w[n+1].h = n+1; //正式操作  s.root = s.build(w,0,n+1); find(); return 0; }   ","description":"","id":235,"section":"posts","tags":["数据结构","平衡树","Splay"],"title":"「CQOI2014」排序机械臂-Splay","uri":"https://blog.chenqiqian.com/posts/cqoi2014-sort/"},{"content":"维护一个数列。\n现有四种命令，新加入一个数 $k$ ，把每个数加上 $k$ ，把每个数减去 $k$ ，查询第 $k$ 大的数。如果数列中的任意数小于 $min$ ，将它立即删除。并在最后输出总共删去的数的个数 $res$ 。\n如果新加入的数 $k$ 的初值小于 $min$ ，它将不会被加入数列。\n链接 Luogu P1486\n题解 这是一道经典的平衡树的题，被我用来练手Splay。\n写完这道题之后我就觉得，我再也不会想用Splay了。debug了一天，简直浑身难受。以后尽量写旋转\u0026amp;非旋Treap吧。\n真香 ！！！\n构建一颗Splay树。需要记录目前已经全体加过或者减过的数，也就是一个相对值。换算来说就是 树外-相对值=树内，树内+相对值=树外 。后面也就不再太多特殊说明。需要添加两个虚的最大和最小节点，也会导致排名计算的一些变化。\n 插入操作  先判断是否满足插入条件，即此数是否大于 $min$ ，然后减去相对后正常插入，splay 至根节点。\n 加上一个数  直接更改全局相对值，由于不会出现删数，不会有其他操作。\n 减去一个数  首先更改全局相对值，再把小于 $min$ 的数删除，简单的来说就是吧第一个大于等于 $min$ 的数 splay 到根上，然后删除左子树，补上左边的最小节点。\n如果正好存在值为 $min$ 的节点，就将它直接 splay 到根，完成上述操作；如果不存在，就插入一个值为 $min-1$ 的节点，寻找它的后继，并 splay 到根，完成上述操作。这时统计 $res$ 需要减去我们刚刚加上的节点。\n 查询第 k 大  直接查，然后 splay 到根。只需要注意我们的数列是从小到大排列的。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  #include \u0026lt;cstdio\u0026gt;#define MAX 0x3f3f3f3f using namespace std; inline int qr(){ int f = 1,s = 0;char ch = getchar(); while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){ if(ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){ s = (s\u0026lt;\u0026lt;3)+(s\u0026lt;\u0026lt;1)+ch-48; ch = getchar(); } return f*s; } struct splay_t{ struct node_t{ int val,size,cnt; node_t *son[2],*p;node_t **null,**root; //与父亲关系  inline bool get_p(){return p-\u0026gt;son[1] == this;} //双向连接  inline void link(node_t *dst,bool re){p = dst;dst-\u0026gt;son[re] = this;} //更新size值  inline void update(){size = son[0]-\u0026gt;size + son[1]-\u0026gt;size + cnt;} //初始化**root和**null  inline void init(node_t **null,node_t **root){this-\u0026gt;null = null,this-\u0026gt;root = root;} //获取左右节点的大小  inline int lsize(){return son[0]-\u0026gt;size;}int rsize(){return son[1]-\u0026gt;size;} //寻找节点前驱或者后继  node_t *uporlow(int tmp){//0前驱，1后继  splay(); node_t *t = son[tmp]; while(t-\u0026gt;son[1-tmp] != *null) t = t-\u0026gt;son[1-tmp]; return t; } //旋转  void rotate(){ bool re = get_p();node_t *rp = p; link(rp-\u0026gt;p,rp-\u0026gt;get_p()); son[1-re]-\u0026gt;link(rp,re); rp-\u0026gt;link(this,1-re); rp-\u0026gt;update();update(); if(p == *null) *root = this; } //splay操作  node_t* splay(node_t *tar = NULL){ if(this == *null) return this; if(tar == NULL) tar = *null; while(p!=tar){ if(p-\u0026gt;p == tar) rotate(); else{ if(p-\u0026gt;get_p()==get_p()) p-\u0026gt;rotate(),rotate(); else rotate(),rotate(); } } return this; } }; int treecnt; node_t pool[300000]; node_t *null,*root,*lb,*rb;//lb是左边的虚拟节点，rb同理  //初始化  splay_t(){ treecnt = 0; newnode(null);root = null; null-\u0026gt;size = 0,null-\u0026gt;val = 0; lb = insert(-MAX);rb = insert(MAX); } //新建节点  void newnode(node_t *\u0026amp;r,int val = 0){ r = \u0026amp;pool[treecnt++]; r-\u0026gt;val = val; r-\u0026gt;son[0] = r-\u0026gt;son[1] = r-\u0026gt;p = null; r-\u0026gt;cnt = r-\u0026gt;size = 1; r-\u0026gt;init(\u0026amp;null,\u0026amp;root); } //寻找给定rank的数字  node_t* find_Kth(int rank){ node_t *t = root; while(t!=null){ if(rank\u0026lt;t-\u0026gt;lsize()) t = t-\u0026gt;son[0]; else if((rank-=t-\u0026gt;lsize())\u0026lt;t-\u0026gt;cnt) return t-\u0026gt;splay(); else rank-=t-\u0026gt;cnt,t = t-\u0026gt;son[1]; } return null; } //按值寻找  node_t *find_by_val(int val){ node_t *t = root; while(t!=null){ if(val\u0026lt;t-\u0026gt;val) t = t-\u0026gt;son[0]; else if(val==t-\u0026gt;val) return t-\u0026gt;splay(); else t = t-\u0026gt;son[1]; } return null; } //插入给定值的节点  node_t* insert(int val){ node_t **tar = \u0026amp;root,*parent = null; while(*tar!=null){ (*tar)-\u0026gt;size++; if((*tar)-\u0026gt;val == val){ (*tar)-\u0026gt;cnt++;return *tar; } else{ parent = *tar;tar = \u0026amp;(*tar)-\u0026gt;son[(*tar)-\u0026gt;val\u0026lt;val]; } } newnode(*tar,val); (*tar)-\u0026gt;link(parent,parent-\u0026gt;val \u0026lt; val); return (*tar)-\u0026gt;splay(); } //调试用 打印树  void print(node_t *r = NULL,int depth = 0){ if(r == NULL) r = root; if(r == null) return; else{ print(r-\u0026gt;son[0],depth+1); for(int i = 0;i\u0026lt;depth;i++) putchar(\u0026#39; \u0026#39;); printf(\u0026#34;v:%d,size:%d,cnt:%d,son:%d %d,depth:%03d\\n\u0026#34;,r-\u0026gt;val,r-\u0026gt;size,r-\u0026gt;cnt,r-\u0026gt;son[0]!=null,r-\u0026gt;son[1]!=null,depth); print(r-\u0026gt;son[1],depth+1); } } }; splay_t x;int n,minn,res = 0,nowadd = 0; //插入一个数 inline void insert(int val){if(val\u0026gt;=minn) x.insert(val-nowadd);}//注意要减去nowadd //统一加工资 inline void add(int val){nowadd+=val;} //统一减公司顺便裁人 inline void decrease(int val){ nowadd-=val; splay_t::node_t *r = x.find_by_val(minn-nowadd);//注意要减去nowadd  if(r!=x.null) r-\u0026gt;splay(),res+=(x.root-\u0026gt;lsize()-1); else x.insert(minn-nowadd-1)-\u0026gt;uporlow(1)-\u0026gt;splay(),res+=(x.root-\u0026gt;lsize()-2); x.lb-\u0026gt;link(x.root,0);x.lb-\u0026gt;son[1] = x.null; x.root-\u0026gt;update(); } //查找工资排名K位的员工的工资 inline int ask(int rank){ if(rank \u0026gt; x.root-\u0026gt;size - 2) return -1; return x.find_Kth(x.root-\u0026gt;size-rank-1)-\u0026gt;val + nowadd;//注意要加上nowadd } int main(){ n = qr();minn = qr(); for(int i = 0;i\u0026lt;n;i++){ char op[20];int k; scanf(\u0026#34;%s\u0026#34;,op);k = qr(); if(op[0] == \u0026#39;A\u0026#39;) add(k); else if(op[0] == \u0026#39;S\u0026#39;) decrease(k); else if(op[0] == \u0026#39;I\u0026#39;) insert(k); else if(op[0] == \u0026#39;F\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,ask(k)); else if(op[0] == \u0026#39;P\u0026#39;) x.print(); } printf(\u0026#34;%d\\n\u0026#34;,res); return 0; }   ","description":"","id":236,"section":"posts","tags":["数据结构","平衡树","Splay"],"title":"「NOI2004」郁闷的出纳员-Splay","uri":"https://blog.chenqiqian.com/posts/noi2004-cashier/"},{"content":"OI考试前最好来看一看\u0026hellip;\n会不断的补充。\n考前  带好需要的东西  笔 纸 水 吃的 适量的衣服   复习以下膜版  线段树 平衡树 dp  \u0026hellip;   数学 网络流\u0026amp;费用流 缩点 字符串相关 \u0026hellip;\u0026hellip;（来日补充   早点睡 吃点好的  考中  思路放开 不要鄙视暴力 不要给自己太大压力 多喝水 多上厕所（学习d姓大神 遇到不会做的题目时的checklist：  看下数据范围和题目要求 尝试对算法入座 先敲个30分左右的暴力 仔细回顾一遍学过的所有数据结构如上面所列 没准可以打个表？？ 评估一下思考的代价和不做的代价 后面的题如果有思路可以先做 不要慌 再做不出来去玩局初级扫雷平静一下   写暴力对拍  update: 对拍\u0026hellip;要写程序拍\u0026hellip;   最后检查两遍文件输入输出  update: 还是三遍吧   除非一点都不会 不能不写  考后  吃顿好的。 拉个人出去玩。 再吃顿好的。 忘掉比赛。 ","description":"","id":237,"section":"posts","tags":null,"title":"考试前要看的东西","uri":"https://blog.chenqiqian.com/posts/notes-test/"},{"content":"今年冬天，去了趟北京冬令营旅游。\n其实本就没有抱着什么信心。NOIP只考了二等奖，好多提高组的基础知识都没有学完。但还是义无反顾的去了。也许早就知道会是这个样子。\nDay1 冬令营在北师大附中。虽然是去过的地方，然而还是十分迷茫的找啊找。第一天主要是颁奖仪式等等。第一次体会到如坐针毡的感觉。深刻的觉得，旁边的人哪个都好像那么巨，而自己，却是那么蒟蒻。生怕做错哪怕一点事情，而同班的OIer却还没有来冬令营。万幸，找到了几个看着还比较眼熟的，果然是同学。\n下午是胡伟栋老师的课，讲的是深搜。\n“这也许是某些人冬令营唯一能听懂的一节课。”或许就是我吧。讲的的确不难，而且还是蛮有趣的。果然很厉害呢。\nDay2 第一次考试。\n看到题瞬间懵逼。一道题都不会做呢。只好随便写了几个暴力骗分，发了条pyq之后就开始玩跳一跳。坐在我旁边的貌似是小学六年级。不得不感叹，年轻真好。如果能来五年冬令营还进不了省队，说什么我都不相信。祝他有光明的前途吧。\n下午开始讲题。\n首先看了看程序，40／400。被std十倍杀。不过也很正常。\n这天下午的讲课似乎还比较友善，好像主要讲了贪心和归纳的思想。我个人认为讲的还是不错的，我也忍住了，没有睡着。讲的例题我竟然也能听懂。不容易。\nDay3 第二天考试。\n还是一道题都不会。依旧是，暴力骗分然后就玩跳一跳。我现在也依然认为，如果冬令营再多几天，没准我的跳一跳水平还能有长足的进步。\n考完试才知道，第一道题原来只是有技巧的打表。果然还是too naive呢。不过同来的两位同学也没能做出后面的题，还是有了一点心理安慰的呢。不过最后只考了20分。扎心。\n下午讲的是国家集训队自选题。其实我都不记得讲的是什么了。只记得也是好难。无奈只好打起了世征。居然打过了一个征服。噫\u0026hellip;\u0026hellip;\n回家居然水过了Treap，值得庆贺。\nDay4 第三天考试。今天竟然恍惚的以为自己做出来了一道贪心。然而我还是太天真。std竟是什么我都没有听说过的费用流。不过勉强骗到了30分还是50分。后面几道题接着无穷骗分，跳一跳。最后居然骗上了100分。不错不错。\n下午好像讲的是国家集训队的自选题。实在实在好难。听着听着实在听不懂，于是开始学上午考到的KMP。然而写了好久还没有写对。最后到家再写还是没有写对。最后发现把一个int数组不小心开成了char。我大概是个傻子吧。\n回家不知道为什么脑子抽风了，稀里糊涂的总共坐了四趟公交才到家。坐了好久都没坐过的无轨电车。终于体会到在冷风中瑟瑟发抖的等公交车的感觉。诶。回到家都一个半小时了。\nDay5 最后一天考试。\n一看到题，就觉得可以暴力打表。然并卵。调一个暴力程序调了一个小时才终于调对。然后打表两分钟。啧啧啧。后面第二道题最后半个小时才开始写，写了个暴力打表。然而最后只打到30分都不到。据说还有人查OEIS的？？？我怎么没想到？？？非常有趣。学习了一个新技能。最后一道题好像颇为吐槽。反正我也不会做。\n下午讲高精度，我也没听，也只是记得巨佬1300多行的高精度膜版。终于把第三道线段树的题给出完了。下午回家去坐了特4，一路坐着回家很excited。啧啧啧。\n啧啧 总结一下吧。去了趟冬令营，考了四天试，得分250/1400。啧啧。某d姓人大概考了1000分吧。差距固然存在，也就告诉了我前进该向何方，到了什么程度才能算强者吧。\n和某人晚上谈论了一下。某人这一段时间好像经常听我的感慨吧，谢谢你。还吐槽了我的“强弱”标准。但的确是，每进入一个阶段，总会觉得自己很弱，而强者遥不可及。但尤其在我认真对待的OI里，目标的无望却真的有些让人绝望。OI在高考里不会考到，选择了这项，那是真的真的喜欢。但似乎真的有点晚了。\n省一看起来不像是难事，可省队，实在是遥不可及。\n如果不进队，那么竞赛好像用处也不是很大。可我毕竟选择它，除了竞赛，更多的也是喜欢吧。\n我永远都不会认输的。\n明年，再来。\n","description":"","id":238,"section":"posts","tags":["冬令营"],"title":"冬令营旅游记","uri":"https://blog.chenqiqian.com/posts/trip-bjwc2018/"},{"content":"或许，我一直认为我早就长大了吧。\n那应该是在五年级的时候。我又一次去找老师，又一次没有说成我心中最为完美的想法，又一次的陷入沉思。那个时候，我真正的意识到，或许并不是所有事情，都能按照我心中最好的方式去进行吧。或许从那以后，我以为我就再也不会为了我心中的梦想的世界——或者说更美好的事情，去与人争辩了吧。而初中，也确实是，和人争辩大多也都是做错了题或者做对了题去跟同学和老师的争辩了吧。\n一度，我竟真的以为我长大了。\n那些记忆已经很模糊了，而近几天发生的事情却还历历在目。\n看到某位同学的随笔，某位同学的批语，又想到了好多。\n最近写了不少随笔，也阅了不少随笔。而我写的随笔有不少却像是“抱怨”，“抱怨”班歌比赛的劳民伤财，抱怨体育运动的不切实际，抱怨《论语》的无理考法。\n最近和几位同学互相批判了一番。价值观的不同其实是必然的。或许你有一身嫉世热血，或许我有一颗如冰寒心。脚踏实地还是仰望星空？向理想前行还是于现实混沌？谁又会知道呢。想了很久要不要提笔写下自己的想法，最后还是放弃了。早就应该知道，这些事情，笑笑就好，何必去劳心费神呢？但又不知道为何，最近总是想写，想去表达所有一切一切的想法，或许应该收收了吧。\n“这不是能随心所欲的年纪。”\n说的真的是好啊。或许，从小学就应该想到的吧。但为什么现在又忘记了呢？谁会知道呢。也许是一颗心不再凉的彻骨，也许是一不小心就忘记了以前吧。\n这句话可以说是，“一语点破梦中人”。小学的无数经历让我曾以为我已经从这梦中醒来，再也不会去做那荒诞的梦；但如今发现，到底是梦还是现实却也分不太清。或许我仍然还在梦中？或许是我一直都错了？谁又知道呢。\n曾经以为长大，但恍然之间被人点醒，却才知道梦仍然在。有梦是不是一件好事呢？\n或许几年之后仍会有相同的感慨吧。但现在，真的没有时间去思考那么多。但也许julao们不一定吧。\n不如先滚去把作业写完。\n另祝各位2018吉祥快乐，万事如意。\n","description":"","id":239,"section":"posts","tags":null,"title":"「随笔」“长大”","uri":"https://blog.chenqiqian.com/posts/essay-growing/"},{"content":"在你面前有一圈整数（一共 $n$ 个），你要按顺序将其分为 $m$ 个部分，各部分内的数字相加，相加所得的 $m$ 个结果对 10 取模后再相乘，最终得到一个数 $k$ 。游戏的要求是使你所得的 $k$ 最大或者最小。\n例如，对于下面这圈数字（ $n=4$， $m=2$）：\n要求最小值时，$((2-1) mod 10)×((4+3) mod 10)=1×7=7$，要求最大值时，为$((2+4+3) mod 10)×(-1 mod 10)=9×9=81$。特别值得注意的是，无论是负数还是正数，对$10$取模的结果均为非负值。\n丁丁请你编写程序帮他赢得这个游戏。\n链接 Luogu P1043\n题解 很水的一道 $dp$ 题目。只要知道断环为链剩下的也都不难。题解洛谷没给通过，现在也找不到了，只有代码还剩了下来。代码里面也有注释，凑活看看也可以。\nupdate: 这是我写的第一篇题解啦！\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;using namespace std; long long num[150],dp_1[150],dp_2[150];//_1放最大值,_2放最小值  int n,m; inline int mod(long long nnn){//mod函数  int w = int(floor(double(nnn)/10)); return nnn - w*10; } int main(){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i = 1;i\u0026lt;=n;i++){//断环为链的准备  scanf(\u0026#34;%lld\u0026#34;,\u0026amp;(num[i])); num[i+n] = num[i]; } for(int i = 1;i\u0026lt;=2*n;i++)//前缀和的处理  num[i] = num[i-1]+num[i]; //正经dp  long long maxn = -1,minn = 0x3f3f3f3f; for(int s = 1;s\u0026lt;=n;s++){//枚举起点  memset(dp_1,0,sizeof(dp_1));//清零dp数组  memset(dp_2,0,sizeof(dp_2)); for(int j = 0;j\u0026lt;m;j++){//板子由少到多  for(int i = s;i\u0026lt;=s+n;i++){//上一个插板子的地方  if(j == 0){//j==0的时候的处理，其实也可以叫初始化  dp_1[i] = dp_2[i] = mod(num[s+n]-num[i]); continue; } long long maxtmp = -1,mintmp = 0x3f3f3f3f;//对所有可能下一状态的遍历，并取最大或最小值  for(int x = i+1;x\u0026lt;=s+n-j-1;x++){ maxtmp = max(maxtmp,dp_1[x]*mod(num[x]-num[i])); mintmp = min(mintmp,dp_2[x]*mod(num[x]-num[i])); } dp_1[i] = maxtmp;//取最大最小值  dp_2[i] = mintmp; } } maxn = max(dp_1[s],maxn);//对于起点不同的最大最小值进行更新  minn = min(dp_2[s],minn); } printf(\u0026#34;%lld\\n%lld\\n\u0026#34;,minn,maxn); return 0; }   ","description":"","id":240,"section":"posts","tags":["动态规划"],"title":"「Luogu1043」数字游戏-dp","uri":"https://blog.chenqiqian.com/posts/luogu-1043/"},{"content":"原文地址：点此查看 很久很久以前 算法突然出现\n带来导论 带走了智商又消失不见\n编程十分危险 世间谁最勇敢\n一位懵逼儿赶来 大声喊\n我要写出最高的树 打出最大的表\n搜进最深的递归 把AC带回到面前\n老师非常高兴 忙问他的技能\n年轻人想了想 他说\n老师我会 非确定性有穷状态决策自动机\n再来一次 非确定性有穷状态决策自动机\n是不是 非确定性有穷状态决策自动机\n对对是 非确定性有穷状态决策自动机\n懵逼无名少年 捧着算法导论\n带着大家的希望 从学校里出发\n战胜BUG来袭 获得调试神技\n无数代码见证 他慢慢升级\n偏远论坛角落 参与所有话题\n一路排序 伴随指引前路的单链表\n进入决赛考场 比赛和可怕难题\n少年打开IDE 难题道\n我是 Floyd区间DP均衡红黑树\n再来一次 Floyd区间DP均衡红黑树\n是不是 Kruskal一维DP二叉排序树\n不对是 Floyd区间DP均衡红黑树\n于是 非确定性有限状态决策自动机\n打出 深度搜索模拟枚举单源最短路\n应用 拓扑排序Trie结构Polya定律\n套入 Dijkasta联通分量BellmanFord\n最后 非确定性有限状态决策自动机\n他使用了 IO优化树链剖分输出random\n调用了 矩阵速幂虚二叉树行列式消元\n完成了 凸包扫描后缀数组网络最大流\n老师听说 非确定性有限状态决策自动机\n他忘了写 #include\u0026lt;stdio\u0026gt; freopen\n就让 非确定性有限状态决策自动机\n全手写 map/set稳定婚姻KMP实现\n啦啦 懵逼少年 敲着键盘 Ctrl+V来几遍\n他发明了一个算法 也在天天渐渐复杂\n为了避免以后麻烦 算法叫做暴力法\n它的全名十分难念 我不想说一遍\n","description":"","id":241,"section":"posts","tags":["歌曲"],"title":"[转载]达拉崩吧-OI版","uri":"https://blog.chenqiqian.com/posts/dalabengba-oi/"},{"content":"闲下来了，开始写一点学习笔记，也希望能给后人造福吧。\n第一篇来说一说 Treap 。\nTreap是什么 Tree + Heap 树堆（英语： Treap ），是有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为 $O(\\log {n})$ 。相对于其他的平衡二叉搜索树， Treap 的特点是实现简单，且能基本实现随机平衡的结构。\n基本思想及操作 一般在 Treap 里面维护一个最小堆。\n旋转 旋转是一种不破坏二叉搜索树性质的操作，有左旋及右旋两种。具体操作在代码部分解释。\n旋转的时间复杂度是 $O(1)$ ，因为只需要修改常数个指针。\n按关键字寻找 可以发现，在要寻找的关键字小于当前节点关键字时，其节点只可能在当前节点的左子树中；等于时即为当前节点；大于时候在右子树中。于是可以根据关键字寻找到节点。\n插入 在 Treap 中，插入需要根据二叉搜索树的性质，找到能放置这个节点的空位置，给新节点随机分配一个优先值，然后调整 Treap 的堆性质。\n删除 如果需要删除一个节点，首先应当寻找到这个节点，并将这个节点旋转至最底层，即左右儿子皆为空的时候，删除该节点。并注意需要在旋转过程中维护最小堆性质。\n查询排名 在这里排名是指小于某数的数的个数+1。注意到在某二叉搜索树中，小于根节点的节点数目即为根节点左子树的节点数目。所以只需要按关键字查找到此节点，并如果向右搜索，就加上此节点左子树的大小和根节点的大小，进行递归搜索。\n按排名查找 需要对每一个节点维护一个 size 值，意为以其为根节点的树的大小（包括本身）。搜索的时候，如果排名小于当前节点左子树的 size 值直接递归进入左子树；如果排名落在当前节点，则返回当前节点；否则更新排名向右子树递归。\n前驱\u0026amp;后继 在这里，前驱定义为小于 $x$ ，且最大的数。后继同理。这个的寻找稍微复杂。\n以前驱为例。\n如果寻找到的节点有左子树，那么其前驱就是左子树里面的最大值；如果没有左子树，那么其前驱就是寻找的路径上最靠近的一个向右寻找的节点。\n第一种很容易想明白，第二种稍难一些。\n以此图为例。比如我们寻找12的前驱，它没有左子树，所以它属于情况二。按照刚才提到的规则，可以发现12的前驱是11，因为11是最后一个向右寻找，即下一次寻找是其右儿子（16）的节点。\n可以注意到，11的左子树上的点全都比6小，不符合要求；12的左子树不存在，12的右子树上的点都比12大，而11-12的路径上的点，其应当是全都是向左寻找的，也都比12要大，而在11以上的点，应当都比12要大（11是左儿子的时候），或者比11要小（11是右儿子的时候），所以，6就是7的前驱。\n后继同理。\n插入、删除等以上操作的期望时间复杂度都是 $O(\\log {n})$ ，因为树的期望高度是 $\\log {n}$ 。\n代码解析 以洛谷P3369 普通平衡树为例。代码是指针版，不记录父节点，递归操作。\n（其实我还是觉得数组好写\n结构体的定义 1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T,size_t siz\u0026gt; struct treap{ struct node_t{ T val; int p,size,cnt; node_t *son[2]; }; int treapcnt; node_t pool[siz\u0026lt;\u0026lt;1],*root,*null; //... }   在这里采用了模板的定义方法。T为一个模版类。需要注意这里的T模板要有小于运算符。\n对于每一个节点，我们维护以下几个信息：关键字，随机优先值，以其为根的二叉搜索树的大小，和这个关键字的数量，左儿子和右儿子的指针。默认0为左，1为右。\n在结构体的变量中，我们维护了一个静态内存池，内存池已经使用的数量，根节点的指针，以及一个虚的空节点。\n在这里自己定义一个空节点的好处主要是可以避免 NULL 导致的 segmentation fault ，以及让函数编写变得更加简单。\n需要注意的是，视题目不同， cnt 变量可能可以省去。\n一些简单函数 1 2 3 4 5 6 7 8 9 10 11 12  void newnode(node_t *\u0026amp;r){ r = \u0026amp;pool[Treapcnt++]; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; } void update(node_t *r){ r-\u0026gt;size = r-\u0026gt;son[0]-\u0026gt;size + r-\u0026gt;son[1]-\u0026gt;size + r-\u0026gt;cnt; } node_t* find_minormax(node_t *r,int tmp){//0最小 1最大  while(r-\u0026gt;son[tmp]!=null) r = r-\u0026gt;son[tmp]; return r; }   newnode 函数在这里完成对节点初始化的任务，并对子节点赋值。需要注意以下，这里需要使用引用的方法，否则如果使用了返回值的办法，就不能使用 newnode 函数对 null 赋值了，因为会产生 NULL 这种可怕的东西。其实在这里也可以把赋关键字、随机值、 size 值等事情一并完成，但是我比较懒，所以就在后面手动赋值了。\nupdate 函数在这里完成对节点 size 值的更新，很好理解。\nfind_minormax 函数在这里完成对以 r 为根节点的树上最大或最小节点的寻找。也很简单，就不解释了。\n后两个函数可以放到 node 结构体里面，但是我不太喜欢那么做，因为那样会使箭头的数目大大增多，从而导致头疼（雾。\n结构体的初始化 1 2 3 4 5 6 7 8  treap(){ treapcnt = 0; newnode(null); null-\u0026gt;size = null-\u0026gt;val = 0; null-\u0026gt;p = MAXINT; root = null; srand(time(NULL)); }   结构体的初始化不难，有几点需要注意：\n 空指针的 size 需要为 0 空指针的随机值需要足够大（最大堆中足够小，最好是 maxint ，否则有可能在之后的删除操作中被转上去，然后树就断了 最好 srand 一下  旋转 1 2 3 4 5 6 7  void rotate(node_t *\u0026amp;r,int tmp){//0左旋，1右旋  node_t *t = r-\u0026gt;son[1-tmp]; r-\u0026gt;son[1-tmp] = t-\u0026gt;son[tmp]; t-\u0026gt;son[tmp] = r; update(r),update(t); r = t; }   旋转操作的文字叙述：\n（括号里文字以左旋为例）\n 选定当前节点 r （图中的 x ） 找到并记录需要旋上来的节点 t（左旋旋右儿子，右旋左儿子）（图中的 y ） 把 t 将要被覆盖的儿子（与旋转方向相同的儿子）接到 t 在 r 原来的位置上 （把 b 接在 x 的右子位置上） 把 r 接到 t 空出来的位置上 （把 x 接到 y 的 x 的左子树上） 更新 size 值 （更新 x ，y 的 size ）  由于我们没有记录父节点，所以这个旋转的写法跟 Splay 的旋转写法不太像。但其实 Splay 也可以这么写，只不过没有必要。\n其实这个记不下来不要紧。大概有个印象，要写的时候根据二叉搜索树的性质现推也可以其实。（误\n但需要注意的是，旋转很有可能（就是）会破坏一个合法 Treap 的堆性质，所以旋转在 Treap 中只用来维护堆的性质，而不用在其他的地方。而且这里的指针是引用传递，才能修改对应父节点的儿子指针。\n有一点很重要的就是要维护 size 的值，而且是从下到上。\n插入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void __insert(node_t *\u0026amp;r,T v){ if(r == null){ newnode(r); r-\u0026gt;val = v,r-\u0026gt;cnt = 1,r-\u0026gt;p = rand(); } else{ if(r-\u0026gt;val == v) r-\u0026gt;cnt++; else{ int tmp = r-\u0026gt;val \u0026lt; v; __insert(r-\u0026gt;son[tmp],v); if(r-\u0026gt;son[tmp]-\u0026gt;p \u0026lt; r-\u0026gt;p) rotate(r,1-tmp); } } update(r); }   用文字说明 Treap 的插入策略：\n 递归边界：寻找到节点， cnt++ 或者已经到达空节点，赋值一个新节点 递归添加节点，比当前节点小向左，比当前节点大向右 维护最小堆的性质 更新 size 值  在维护最小堆的性质的时候，如果子节点的权值较小，那我们就需要把它转上来。\n需要注意，这里的节点是引用方式传入，这样才能对父节点的儿子指针进行修改，从而完成树的连接。\n再次重复，不要忘记更新 size 值。\n删除 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  void __erase(node_t *\u0026amp;r,T v){ if(r-\u0026gt;val == v){ if(r-\u0026gt;cnt \u0026gt; 1) r-\u0026gt;cnt--; else{ if(r-\u0026gt;son[0]==null \u0026amp;\u0026amp; r-\u0026gt;son[1]==null){ r = null;return; } else{//还有子节点，  int tmp = r-\u0026gt;son[1]-\u0026gt;p \u0026lt; r-\u0026gt;son[0]-\u0026gt;p; rotate(r,1-tmp); __erase(r,v); } } } else{ int tmp = r-\u0026gt;val \u0026lt; v; __erase(r-\u0026gt;son[tmp],v); } update(r); }   用文字说明 Treap 的删除策略：\n 递归边界：要删除的节点没有儿子节点 寻找到当前节点，减少数量或者向下旋转 维护最小堆的性质，即把两个儿子中权值较小的旋转上来 递归删除节点注意此处的节点指针仍是r，因为r在旋转中已经发生了变化 更新 size 值  删除的时候最需要注意的已经在上面指出。\n还有在旋转比较的时候一定比较的是优先级！！！\nTreap 的删除和插入其实很像，只不过递归的位置相反。插入是先递归再维护，而删除是先维护再递归。\n查询排名\u0026amp;排名查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int __getrank(node_t *r,T v){//查找数v的排名  if(r-\u0026gt;val == v||r == null)//记得判空！  return r-\u0026gt;son[0]-\u0026gt;size + 1; else if(v \u0026lt; r-\u0026gt;val) return __getrank(r-\u0026gt;son[0],v); else return __getrank(r-\u0026gt;son[1],v) + r-\u0026gt;son[0]-\u0026gt;size + r-\u0026gt;cnt; } node_t* __qrank(node_t *r,int rank){//查找以rank排名的数  rank -= r-\u0026gt;son[0]-\u0026gt;size; if(rank\u0026lt;=0) return __qrank(r-\u0026gt;son[0],rank + r-\u0026gt;son[0]-\u0026gt;size); else if(rank \u0026lt;= r-\u0026gt;cnt) return r; else return __qrank(r-\u0026gt;son[1],rank - r-\u0026gt;cnt); }   这两个比较简单，而且在上面也讲的很详细了，所以就一块说。\n查询排名和排名查询其实是相反的操作，只需要注意将+1，-1和空节点等问题处理好了就可以了。\n前驱和后继 1 2 3 4 5 6 7 8 9 10 11  node_t *loworup(T v,int t){//0代表前驱，1代表后继  node_t *last = null,*nown = root; while(nown-\u0026gt;val!=v \u0026amp;\u0026amp; nown!=null){ int tmp = nown-\u0026gt;val \u0026lt; v; if(tmp!=t) last = nown; nown = nown-\u0026gt;son[tmp]; } if(nown-\u0026gt;son[t]!=null) last = find_minormax(nown-\u0026gt;son[t],1-t); return last; }   这两个操作其实是完全相反的，所以合到了一个函数里面，在后面的进一步的封装中再分开。\n思路在上面已经提到，在这里只需要注意对不存在的值的前驱／后继进行处理。我们查不到不存在的值的节点，但我们可以假装那里有一个节点。因为 null 的孩子也是 null ，所以这段代码也可以直接使用在值的前驱和后继里面。\n多说一句，在 Splay 里面，我们可以直接把待查节点 splay 到根然后瞎搞一通\n输出树 1 2 3 4 5 6 7 8 9  void __print(node_t *r,int depth = 0){ if(r == null) return; else{ __print(r-\u0026gt;son[0],depth+1); for(int i = 0;i\u0026lt;depth;i++) putchar(\u0026#39; \u0026#39;);//打印深度  printf(\u0026#34;val:%d cnt:%d size:%d P:%d son?:%d %d\\n\u0026#34;,r-\u0026gt;val,r-\u0026gt;cnt,r-\u0026gt;size,r-\u0026gt;p,r-\u0026gt;son[0]!=null,r-\u0026gt;son[1]!=null); __print(r-\u0026gt;son[1],depth+1); } }   按照中序遍历打印一棵树。主要在调试的时候用的多。有一个小技巧就是记录一个深度，然后把深度长度的空格打印出来，这样就可以更直观的看到各个节点的深度什么的。\n封装 1 2 3 4 5 6 7  void insert(T v){__insert(root,v);} void erase(T v){__erase(root,v);} int getrank(T v){return __getrank(root,v);} int qrank(int rank){return __qrank(root,rank)-\u0026gt;val;} int lower(T v){return loworup(v,0)-\u0026gt;val;} int upper(T v){return loworup(v,1)-\u0026gt;val;} void print(){__print(root);}   封装其实没有必要，可以用一些判断来代替。但是我们为了让代码更像工程的代码，而且让前面的代码更美观，更令人赏心悦目，所以我们封装一下吧。\n完整代码及注释 题目：洛谷P3369 普通平衡树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147  #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;ctime\u0026gt;#define maxint 2147483647 using namespace std; template\u0026lt;typename T,size_t siz\u0026gt;//模版T,需要有等于不等于和小于运算符 struct treap{ private: struct node_t{ T val; int p,size,cnt; node_t *son[2]; }; int treapcnt; node_t pool[siz\u0026lt;\u0026lt;1],*root,*null; void newnode(node_t *\u0026amp;r){ r = \u0026amp;pool[treapcnt++]; r-\u0026gt;son[0] = r-\u0026gt;son[1] = null; } void update(node_t *r){ r-\u0026gt;size = r-\u0026gt;son[0]-\u0026gt;size+r-\u0026gt;son[1]-\u0026gt;size+r-\u0026gt;cnt; } void rotate(node_t *\u0026amp;r,int tmp){//0左旋，1右旋  node_t *t = r-\u0026gt;son[1-tmp];//找到需要旋上来的节点  r-\u0026gt;son[1-tmp] = t-\u0026gt;son[tmp];//将被选节点的被遮蔽的儿子交给上面的节点  t-\u0026gt;son[tmp] = r;//将r作为t的儿子  update(r),update(t);//注意更新顺序！先儿子后父亲  r = t;//通过引用更改上方节点的儿子  } void __insert(node_t *\u0026amp;r,T v){//r代表当前节点，v代表关键字  if(r == null){//如果r的地方已经没有节点  newnode(r);//新建节点，并通过引用添加至上面节点的儿子  r-\u0026gt;val = v,r-\u0026gt;cnt = 1,r-\u0026gt;p = rand();//对相关信息的设置  } else{ if(r-\u0026gt;val == v) //如果已经添加过，直接给数量++  r-\u0026gt;cnt++; else{ int tmp = r-\u0026gt;val \u0026lt; v; __insert(r-\u0026gt;son[tmp],v);//递归更改  if(r-\u0026gt;son[tmp]-\u0026gt;p \u0026lt; r-\u0026gt;p)//维护treap性质  rotate(r,1-tmp); } } update(r);//不要忘了更新！  } void __erase(node_t *\u0026amp;r,T v){ if(r-\u0026gt;val == v){//已经找到  if(r-\u0026gt;cnt \u0026gt; 1) r-\u0026gt;cnt--; else{ if(r-\u0026gt;son[0]==null \u0026amp;\u0026amp; r-\u0026gt;son[1]==null){//已经没有子节点，直接删除  r = null;return; } else{//还有子节点，  int tmp = r-\u0026gt;son[1]-\u0026gt;p \u0026lt; r-\u0026gt;son[0]-\u0026gt;p; rotate(r,1-tmp); //找到其中随机权值较小的一个旋转替换当前节点  __erase(r,v);//递归删除 注意此处r已经发生了变化  } } } else{//还没找到  int tmp = r-\u0026gt;val \u0026lt; v; __erase(r-\u0026gt;son[tmp],v);//递归寻找  } update(r);//不要忘了更新！  } void __print(node_t *r,int depth = 0){//调试用  if(r == null) return; else{ __print(r-\u0026gt;son[0],depth+1); for(int i = 0;i\u0026lt;depth;i++) putchar(\u0026#39; \u0026#39;);//打印深度  printf(\u0026#34;val:%d cnt:%d size:%d P:%d son?:%d %d\\n\u0026#34;,r-\u0026gt;val,r-\u0026gt;cnt,r-\u0026gt;size,r-\u0026gt;p,r-\u0026gt;son[0]!=null,r-\u0026gt;son[1]!=null); __print(r-\u0026gt;son[1],depth+1); } } int __getrank(node_t *r,T v){//查找数v的排名  if(r-\u0026gt;val == v||r == null)//记得判空！  return r-\u0026gt;son[0]-\u0026gt;size +1; else if(v \u0026lt; r-\u0026gt;val) return __getrank(r-\u0026gt;son[0],v); else return __getrank(r-\u0026gt;son[1],v) + r-\u0026gt;son[0]-\u0026gt;size + r-\u0026gt;cnt; } node_t* __qrank(node_t *r,int rank){//查找以rank排名的数  rank -= r-\u0026gt;son[0]-\u0026gt;size; if(rank\u0026lt;=0) return __qrank(r-\u0026gt;son[0],rank + r-\u0026gt;son[0]-\u0026gt;size); else if(rank \u0026lt;= r-\u0026gt;cnt) return r; else return __qrank(r-\u0026gt;son[1],rank - r-\u0026gt;cnt); } node_t *find_minormax(node_t *r,int tmp){ //寻找以r为根节点的树上最大或最小节点  while(r-\u0026gt;son[tmp]!=null) r = r-\u0026gt;son[tmp]; return r; } node_t *loworup(T v,int t){//0代表前驱，1代表后继  node_t *last = null,*nown = root;//last表示上一个没有当前寻找方向的节点  while(nown-\u0026gt;val!=v \u0026amp;\u0026amp; nown!=null){//记得判空!  int tmp = nown-\u0026gt;val \u0026lt; v; if(tmp!=t) last = nown; nown = nown-\u0026gt;son[tmp]; } if(nown-\u0026gt;son[t]!=null)//有子节点  last = find_minormax(nown-\u0026gt;son[t],1-t);//寻找对应方向子节点的最小or最大值  return last; } public: treap(){ treapcnt = 0; newnode(null); null-\u0026gt;size = null-\u0026gt;val=0; null-\u0026gt;p = maxint; root = null; srand(time(NULL)); } void insert(T v){__insert(root,v);} void erase(T v){__erase(root,v);} int getrank(T v){return __getrank(root,v);} int qrank(int rank){return __qrank(root,rank)-\u0026gt;val;} int lower(T v){return loworup(v,0)-\u0026gt;val;} int upper(T v){return loworup(v,1)-\u0026gt;val;} void print(){__print(root);} }; treap\u0026lt;int,200000\u0026gt; w; int n; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 0;i\u0026lt;n;i++){ int op, x; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;op,\u0026amp;x); if(op == 1) w.insert(x); else if(op == 2) w.erase(x); else if(op == 3) printf(\u0026#34;%d\\n\u0026#34;,w.getrank(x)); else if(op == 4) printf(\u0026#34;%d\\n\u0026#34;,w.qrank(x)); else if(op == 5) printf(\u0026#34;%d\\n\u0026#34;,w.lower(x)); else if(op == 6) printf(\u0026#34;%d\\n\u0026#34;,w.upper(x)); else if(op == 0) w.print(); } return 0; }   update:数组版代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126  #include \u0026lt;bits/stdc++.h\u0026gt;#define maxint 2147483647 using namespace std; const int MAXN = 200000; struct treap{ int val[MAXN],p[MAXN],son[MAXN][2]; int siz[MAXN],cnt[MAXN]; int root,treapcnt; int newnode(int v){ int x = ++treapcnt; son[x][0] = son[x][1] = 0; val[x] = v;cnt[x] = 1;p[x] = rand(); return x; } void update(int x){ siz[x] = cnt[x]+siz[son[x][1]]+siz[son[x][0]]; } void rotate(int \u0026amp;x,int t){ int y = son[x][t]; son[x][t] = son[y][1-t]; son[y][1-t] = x; update(x),update(y); x = y; } treap(){ srand(19260817); treapcnt = root = 0; p[0] = maxint; } void __insert(int \u0026amp;x,int v){ if(x){ if(val[x] == v) cnt[x]++; else{ int t = v \u0026gt; val[x]; __insert(son[x][t],v); if(p[son[x][t]] \u0026lt; p[x]) rotate(x,t); } } else x = newnode(v); update(x); } void __erase(int \u0026amp;x,int v){ if(val[x] == v){ if(cnt[x]) cnt[x]--; else{ if(son[x][0] == 0 \u0026amp;\u0026amp; son[x][1] == 0){ x = 0;return; } int t = p[son[x][0]] \u0026gt; p[son[x][1]]; rotate(x,t); __erase(x,v); } } else{ int t = val[x] \u0026lt; v; __erase(son[x][t],v); } update(x); } int get_kth(int k){ int x = root; while(true){ if(k\u0026lt;=siz[son[x][0]]) x = son[x][0]; else{ k -= siz[son[x][0]] + cnt[x]; if(k\u0026lt;=0) return val[x]; else x = son[x][1]; } } } int get_rank(int v){ int x = root,ans = 0; while(x){ if(v \u0026lt; val[x]) x = son[x][0]; else if(v \u0026gt; val[x]) ans+=siz[son[x][0]]+cnt[x],x = son[x][1]; else ans+=siz[son[x][0]],x = 0; } return ans; } void __print(int x,int dep){ if(dep == 0) printf(\u0026#34;-------------------\\n\u0026#34;); if(x == 0) return; __print(son[x][0],dep+1); for(int i = 0;i\u0026lt;dep;i++) putchar(\u0026#39; \u0026#39;); printf(\u0026#34;v:%d p:%d siz:%d cnt:%d son:%d %d\\n\u0026#34;,val[x],p[x],siz[x],cnt[x],son[x][0],son[x][1]); __print(son[x][1],dep+1); if(dep == 0) printf(\u0026#34;---------------------\\n\u0026#34;); } void insert(int v){__insert(root,v);} void erase(int v){__erase(root,v);} int upper(int v){return get_kth(get_rank(v+1)+1);} int lower(int v){return get_kth(get_rank(v));} void print(){__print(root,0);} }; treap a; int n,op,v; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;op,\u0026amp;v); if(op == 1) a.insert(v); else if(op == 2) a.erase(v); else if(op == 3) printf(\u0026#34;%d\\n\u0026#34;,a.get_rank(v)+1); else if(op == 4) printf(\u0026#34;%d\\n\u0026#34;,a.get_kth(v)); else if(op == 5) printf(\u0026#34;%d\\n\u0026#34;,a.lower(v)); else if(op == 6) printf(\u0026#34;%d\\n\u0026#34;,a.upper(v)); else if(op == 0) a.print(),--i; } return 0; }   例题 「ZJOI2007」报表维护\n","description":"闲下来了，开始写一点学习笔记，也希望能给后人造福吧。第一篇来说一说Treap。","id":247,"section":"posts","tags":["数据结构","平衡树","Treap","笔记","模板"],"title":"Treap学习笔记","uri":"https://blog.chenqiqian.com/posts/notes-treap/"}]